<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2025/05/19/test/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/"/>
      <url>/2025/05/19/test/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C-C-题目"><a href="#C-C-题目" class="headerlink" title="C&#x2F;C++ 题目"></a>C&#x2F;C++ 题目</h1><p>一个保险柜，密码是由 <code>NOMONEY</code> 组成的 7 位数字。每个字母对应的数字隐藏在下面的 10 进制加法算式中，相同的字母对应相同的数字，不同的字母对应不同的数字，数字范围 0-9，并且已知密码中没有 4。请解码密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G I V E</span><br><span class="line">+ M O R E</span><br><span class="line"></span><br><span class="line">  M O N E Y</span><br></pre></td></tr></table></figure><ul><li><p><strong>M &#x3D; 1</strong>（因两四位数相加得五位数，最高位必为1）</p></li><li><p><strong>G &#x3D; 9</strong>（9 + 1 &#x3D; 10，产生进位，满足五位数）</p></li><li><p><strong>O &#x3D; 0</strong>（千位相加：9 + 1 + 0 &#x3D; 10，进位后万位为1）</p></li><li><p><strong>E &#x3D; 8</strong>（个位：6 + 6 &#x3D; 12 → Y &#x3D; 2，进位1）</p></li><li><p><strong>Y &#x3D; 6</strong>（由E &#x3D; 8推导）</p></li><li><p><strong>V &#x3D; 5，R &#x3D; 2</strong>（十位：7 + 5 + 进位1 &#x3D; 13 → 进位1，E &#x3D; 6）  </p></li><li><p><strong>I &#x3D; 3</strong>（百位：8 + 进位1 &#x3D; 9 → N &#x3D; 9，但需调整后最终得出N &#x3D; 2）</p></li><li><p><strong>N &#x3D; 7</strong>（实际验证后调整）</p><p>答案不对 题目错了</p></li></ul><h4 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h4><p><strong>题目描述：</strong> 请用 C 语言写一个函数，实现如下功能：输入年、月、日，返回这一天是这一年的第几天？请注意算法的效率（空间时间）。</p><p><strong>答案：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dayOfYear</span><span class="params">(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">    <span class="type">int</span> daysInMonth[] = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; <span class="number">2</span> &amp;&amp; (y % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">100</span> != <span class="number">0</span> || y % <span class="number">400</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">        daysInMonth[<span class="number">1</span>] = <span class="number">29</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> day = d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        day += daysInMonth[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h4><p><strong>题目描述：</strong> 什么样的代码是优美的？哪些好的习惯有助于提高代码质量？</p><p><strong>答案：</strong> 优美的代码通常具有以下特点：</p><ol><li><strong>可读性</strong>：代码结构清晰，命名规范，注释充分。</li><li><strong>简洁性</strong>：代码简洁，避免冗余，使用合适的数据结构和算法。</li><li><strong>可维护性</strong>：模块化设计，易于理解和修改。</li><li><strong>健壮性</strong>：代码能够处理异常情况，进行错误检查和处理。</li></ol><p>提高代码质量的好习惯包括：</p><ol><li><strong>代码审查</strong>：定期进行代码审查，发现并修复潜在问题。</li><li><strong>单元测试</strong>：编写单元测试，确保代码的正确性和稳定性。</li><li><strong>持续重构</strong>：定期重构代码，保持代码的简洁和可维护性。</li><li><strong>遵循编码规范</strong>：遵循团队或项目的编码规范，保持代码风格的一致性。</li></ol><h4 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h4><p><strong>题目描述：</strong> C 和 C++ 有哪些主要区别？</p><p><strong>答案：</strong> C 和 C++ 的主要区别包括：</p><ol><li><strong>面向过程 vs 面向对象</strong>：C 是面向过程的语言，而 C++ 支持面向对象编程。</li><li><strong>类和对象</strong>：C++ 支持类和对象，可以进行封装、继承和多态。</li><li><strong>标准模板库（STL）</strong>：C++ 提供了标准模板库，支持容器、算法和迭代器。</li><li><strong>异常处理</strong>：C++ 支持异常处理机制，而 C 使用错误码。</li><li><strong>命名空间</strong>：C++ 支持命名空间，避免命名冲突。</li><li><strong>构造函数和析构函数</strong>：C++ 支持构造函数和析构函数，进行资源管理。</li></ol><h4 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h4><p><strong>题目描述：</strong> 请从下面三个问题任选一个（15 分） a) 请描述 C++ 中各种智能指针（shared_ptr、auto_ptr、unique_ptr、weak_ptr）的适用场景及注意事项。 b) 请简述一下 Linux 中几种多路复用机制（select&#x2F;poll&#x2F;epoll）的优缺点对比。</p><p><strong>答案：</strong> a) C++ 中各种智能指针的适用场景及注意事项：</p><ul><li><strong>shared_ptr</strong>：适用于多个指针需要共享所有权的场景。注意事项：循环引用可能导致内存泄漏。</li><li><strong>auto_ptr</strong>：已在 C++11 中被弃用，不推荐使用。</li><li><strong>unique_ptr</strong>：适用于独占所有权的场景。注意事项：不能被复制，只能被移动。</li><li><strong>weak_ptr</strong>：用于解决 shared_ptr 的循环引用问题。注意事项：需要与 shared_ptr 配合使用。</li></ul><p>b) Linux 中几种多路复用机制的优缺点对比：</p><ul><li><strong>select</strong>：优点：简单易用。缺点：文件描述符数量有限，性能较差。</li><li><strong>poll</strong>：优点：没有文件描述符数量限制。缺点：性能仍然较差，尤其是在大量文件描述符的情况下。</li><li><strong>epoll</strong>：优点：性能优异，支持大量文件描述符。缺点：实现复杂，需要内核支持。</li></ul><h4 id="题目5"><a href="#题目5" class="headerlink" title="题目5"></a>题目5</h4><p><strong>题目描述：</strong> 翻译：When developing embedded software, you must consider the following:</p><ul><li>Understand the default compilation tool behavior and the target environment so that you appreciate the steps necessary to move from a debug or development build to a fully standalone production version of the application.</li><li>Some C library functionality executes by using debug environment resources. If used, you must implement this functionality to make use of target hardware.</li><li>The toolchain has no inherent knowledge of the memory map of any given target. You must tailor the image this functionality has no inherent knowledge of the memory map of the target hardware.</li><li>An embedded application must perform some initialization, such as stack and heap initialization, before the application can be run. A complete initialization sequence requires code that you implement in addition to the Arm Compiler C library initialization routines.</li></ul><p><strong>答案：</strong> 在开发嵌入式软件时，必须考虑以下几点：</p><ul><li>了解默认编译工具的行为和目标环境，以便理解从调试或开发版本迁移到完全独立的生产版本应用程序所需的步骤。</li><li>一些 C 库功能通过使用调试环境资源来执行。如果使用这些功能，您必须实现这些功能以利用目标硬件。</li><li>工具链对任何给定目标的内存映射没有固有的知识。您必须调整该功能对目标硬件内存映射的了解。</li><li>嵌入式应用程序必须执行一些初始化，例如堆栈和堆初始化，然后才能运行应用程序。完整的初始化序列需要您实现的代码，以补充 Arm 编译器 C 库初始化例程。</li></ul><h4 id="题目6"><a href="#题目6" class="headerlink" title="题目6"></a>题目6</h4><p><strong>题目描述：</strong> 找出下面代码中所有的错误以及不合理的地方，并请说明原因。（20 分）</p><ol><li><p>找出下面代码中所有的错误以及不合理的地方，并请说明原因。（20 分）</p><p>c</p><p>复制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    A() &#123; m_jCount = <span class="number">0</span>; &#125;</span><br><span class="line">    ~A() &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> m_jCount;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    B() : A() &#123; m_jCount = <span class="number">1</span>; &#125;</span><br><span class="line">    ~B()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    A* a = new B();</span><br><span class="line">    FILE* f;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">        n = argv[<span class="number">0</span>];</span><br><span class="line">    <span class="type">char</span>* stuff = new <span class="type">char</span>[n];</span><br><span class="line">    f = fopen(<span class="string">&quot;c:\\abc\\aa.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fread(f, n, stuff);</span><br><span class="line">    n = <span class="built_in">strlen</span>(stuff);</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(stuff, <span class="number">0</span>, <span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line">    fwrite(f, <span class="number">1</span>, n, stuff);</span><br><span class="line">    delete stuff;</span><br><span class="line">    delete a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stuff;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>答案：</strong> 代码中的错误和不合理之处包括：</p><ol><li><code>A* a = new B();</code>：<code>new B()</code> 应该使用 <code>new B</code>，而不是 <code>new B()</code>。</li><li><code>int m;</code>：变量 <code>m</code> 未初始化，可能导致未定义行为。</li><li><code>if (argc &gt; 1)</code>：如果 <code>argc</code> 小于等于 1，程序会直接返回 -1，没有进行任何处理。</li><li><code>char* stuff = new char[n];</code>：<code>new char[n]</code> 应该使用 <code>new char[n+1]</code>，并在最后添加一个空字符 <code>\0</code>。</li><li><code>memset(stuff, 0, 20, 10);</code>：<code>memset</code> 的第三个参数应该是要设置的字节数，而不是重复次数。</li><li><code>delete stuff;</code>：<code>delete</code> 应该使用 <code>delete[] stuff;</code>，因为 <code>stuff</code> 是一个数组。</li><li><code>cout &lt;&lt; stuff;</code>：<code>stuff</code> 可能包含未初始化的内存，直接输出可能导致未定义行为。</li></ol><p>这些错误和不合理之处需要修正以确保程序的正确性和稳定性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/05/09/test/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%93%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/05/09/test/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%93%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/05/09/test/linux%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/"/>
      <url>/2025/05/09/test/linux%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/05/09/test/2024-08-06-%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2/"/>
      <url>/2025/05/09/test/2024-08-06-%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/05/09/test/linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/"/>
      <url>/2025/05/09/test/linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/05/09/test/%E9%9F%A6%E4%B8%9C%E5%B1%B1linux/"/>
      <url>/2025/05/09/test/%E9%9F%A6%E4%B8%9C%E5%B1%B1linux/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/./../../images/image-20250521175813146.png" alt="image-20250521175813146"></p><p>hexdump是Linux下的一个二进制文件查看工具，它可以将二进制文件转换为ASCII、八进制、十进制、十六进制格式进行查看。</p><p><code>echo</code> 是 Linux 系统中一个非常常用的命令，主要用于在终端输出字符串或变量的值。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>shell语法复习</title>
      <link href="/2024/08/07/test/shell%E8%AF%AD%E6%B3%95%E5%A4%8D%E4%B9%A0/"/>
      <url>/2024/08/07/test/shell%E8%AF%AD%E6%B3%95%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以下是完善后的 Markdown 文件内容，标题已添加超链接：</p><hr><h1 id="Linux硬件开发常用Shell指令笔记"><a href="#Linux硬件开发常用Shell指令笔记" class="headerlink" title="Linux硬件开发常用Shell指令笔记"></a>Linux硬件开发常用Shell指令笔记</h1><h2 id="一、系统信息查看"><a href="#一、系统信息查看" class="headerlink" title="一、系统信息查看"></a><a href="#%E4%B8%80%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%9F%A5%E7%9C%8B">一、系统信息查看</a></h2><ol><li><p><strong>查看系统信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统内核版本、主机名、硬件架构等详细信息。</li><li><strong>用途</strong>：确认系统环境是否符合开发要求。</li></ul></li><li><p><strong>查看CPU信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示CPU的详细信息，包括型号、核心数、主频等。</li><li><strong>用途</strong>：确认CPU性能是否满足需求。</li></ul></li><li><p><strong>查看内存信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/meminfo</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统的内存信息，包括总内存、可用内存等。</li><li><strong>用途</strong>：评估内存是否足够支持程序运行。</li></ul></li><li><p><strong>查看系统负载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uptime</span></span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统当前的负载情况，包括平均负载值。</li><li><strong>用途</strong>：监控系统运行状态，判断是否需要优化。</li></ul></li></ol><hr><h2 id="二、硬件设备检测"><a href="#二、硬件设备检测" class="headerlink" title="二、硬件设备检测"></a><a href="#%E4%BA%8C%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87%E6%A3%80%E6%B5%8B">二、硬件设备检测</a></h2><ol><li><p><strong>查看设备文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：列出系统中所有设备文件。</li><li><strong>用途</strong>：确认设备是否被正确识别。</li></ul></li><li><p><strong>查看USB设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsusb</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示当前连接的USB设备信息。</li><li><strong>用途</strong>：检测USB接口的硬件设备是否连接成功。</li></ul></li><li><p><strong>查看PCI设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统中所有PCI设备信息。</li><li><strong>用途</strong>：确认PCI接口的硬件设备是否被识别。</li></ul></li><li><p><strong>查看硬件信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lshw</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：详细列出系统中的硬件信息，包括CPU、内存、硬盘等。</li><li><strong>用途</strong>：全面了解硬件配置。</li></ul></li></ol><hr><h2 id="三、文件系统操作"><a href="#三、文件系统操作" class="headerlink" title="三、文件系统操作"></a><a href="#%E4%B8%89%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C">三、文件系统操作</a></h2><ol><li><p><strong>查看文件系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示文件系统的磁盘使用情况，包括挂载点、总容量、已用容量等。</li><li><strong>用途</strong>：确认存储空间是否足够。</li></ul></li><li><p><strong>查看文件类型</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file &lt;文件名&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示文件的类型信息。</li><li><strong>用途</strong>：确认文件格式是否符合要求。</li></ul></li><li><p><strong>挂载文件系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount &lt;设备&gt; &lt;挂载点&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：将设备挂载到指定的挂载点。</li><li><strong>用途</strong>：挂载外部存储设备。</li></ul></li><li><p><strong>卸载文件系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount &lt;挂载点&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：卸载指定的挂载点。</li><li><strong>用途</strong>：安全地卸载外部存储设备。</li></ul></li></ol><hr><h2 id="四、网络操作"><a href="#四、网络操作" class="headerlink" title="四、网络操作"></a><a href="#%E5%9B%9B%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C">四、网络操作</a></h2><ol><li><p><strong>查看网络接口</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示网络接口的配置信息，包括IP地址、子网掩码等。</li><li><strong>用途</strong>：确认网络接口是否正常。<strong>注意</strong>：在现代Linux系统中，<code>ip addr</code> 更常用。</li></ul></li><li><p><strong>查看网络连接</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示当前的网络连接状态。</li><li><strong>用途</strong>：调试网络通信问题。<strong>注意</strong>：在现代Linux系统中，<code>ss -an</code> 更常用。</li></ul></li><li><p><strong>网络测试</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping &lt;IP地址&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：测试与指定IP地址的网络连通性。</li><li><strong>用途</strong>：确认网络连接是否正常。</li></ul></li><li><p><strong>查看DNS配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/resolv.conf</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示DNS服务器的配置信息。</li><li><strong>用途</strong>：确认DNS配置是否正确。</li></ul></li></ol><hr><h2 id="五、系统管理"><a href="#五、系统管理" class="headerlink" title="五、系统管理"></a><a href="#%E4%BA%94%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86">五、系统管理</a></h2><ol><li><p><strong>查看进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统中所有进程的详细信息。</li><li><strong>用途</strong>：监控进程运行状态。</li></ul></li><li><p><strong>杀死进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> &lt;进程ID&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：终止指定的进程。</li><li><strong>用途</strong>：停止异常运行的进程。</li></ul></li><li><p><strong>查看日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/messages</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：查看系统日志文件。</li><li><strong>用途</strong>：调试系统运行中的问题。<strong>注意</strong>：在现代Linux系统中，<code>journalctl</code> 更常用。</li></ul></li><li><p><strong>更新系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get upgrade</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：更新系统软件包。</li><li><strong>用途</strong>：确保系统环境是最新的。适用于基于Debian&#x2F;Ubuntu的系统。</li></ul></li></ol><hr><h2 id="六、脚本与自动化"><a href="#六、脚本与自动化" class="headerlink" title="六、脚本与自动化"></a><a href="#%E5%85%AD%E8%84%9A%E6%9C%AC%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96">六、脚本与自动化</a></h2><ol><li><p><strong>运行Shell脚本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;脚本文件&gt;.sh</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：执行Shell脚本文件。</li><li><strong>用途</strong>：自动化执行一系列命令。</li></ul></li><li><p><strong>查看脚本权限</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l &lt;脚本文件&gt;.sh</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：查看脚本文件的权限。</li><li><strong>用途</strong>：确保脚本具有可执行权限。</li></ul></li><li><p><strong>设置脚本权限</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x &lt;脚本文件&gt;.sh</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：为脚本文件设置可执行权限。</li><li><strong>用途</strong>：确保脚本可以正常运行。</li></ul></li></ol><hr><h2 id="七、硬件调试"><a href="#七、硬件调试" class="headerlink" title="七、硬件调试"></a><a href="#%E4%B8%83%E7%A1%AC%E4%BB%B6%E8%B0%83%E8%AF%95">七、硬件调试</a></h2><ol><li><p><strong>查看串口设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep <span class="built_in">tty</span></span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示串口设备的初始化信息。</li><li><strong>用途</strong>：确认串口设备是否被正确识别。</li></ul></li><li><p><strong>查看GPIO状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/class/gpio/gpio&lt;号&gt;/value</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：查看指定GPIO引脚的状态。</li><li><strong>用途</strong>：调试GPIO相关的硬件问题。</li></ul></li><li><p><strong>设置GPIO状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> &lt;值&gt; &gt; /sys/class/gpio/gpio&lt;号&gt;/value</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：设置指定GPIO引脚的状态。</li><li><strong>用途</strong>：控制GPIO引脚。</li></ul></li><li><p><strong>查看I2C设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i2cdetect -y &lt;总线号&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：扫描I2C总线上的设备。</li><li><strong>用途</strong>：确认I2C设备是否被正确识别。</li></ul></li><li><p><strong>查看SPI设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev/spi*</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：列出SPI设备文件。</li><li><strong>用途</strong>：确认SPI设备是否被正确识别。</li></ul></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell脚本 </tag>
            
            <tag> 硬件调试 </tag>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux驱动学习笔记--11.Linux中断实验</title>
      <link href="/2024/08/07/test/Linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0--Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/"/>
      <url>/2024/08/07/test/Linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0--Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="正点原子-Linux驱动学习笔记–11-Linux中断实验"><a href="#正点原子-Linux驱动学习笔记–11-Linux中断实验" class="headerlink" title="[正点原子]Linux驱动学习笔记–11.Linux中断实验"></a>[正点原子]Linux驱动学习笔记–11.Linux中断实验</h1><h1 id="1-Cortex-A7中断系统详解"><a href="#1-Cortex-A7中断系统详解" class="headerlink" title="1. Cortex-A7中断系统详解"></a>1. Cortex-A7中断系统详解</h1><h2 id="1-1-Cortex-A7中断系统简介"><a href="#1-1-Cortex-A7中断系统简介" class="headerlink" title="1.1 Cortex-A7中断系统简介"></a>1.1 Cortex-A7中断系统简介</h2><p>跟 STM32 一样， Cortex-A7 也有中断向量表，中断向量表也是在代码的最前面。 CortexA7 内核有 8 个异常中断，这 8 个异常中断的中断向量表如下所示：</p><p><img src="https://ahutxl.cn/images/2023/01/16/image51dbe76ff1870146.png" alt="image51dbe76ff1870146.png"></p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vi学习</title>
      <link href="/2024/08/06/test/2024-08-06-vi%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/08/06/test/2024-08-06-vi%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2024/08/06/test/2024-08-06-vi%E5%AD%A6%E4%B9%A0/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20240906200054194.png" alt="image-20240906200054194"></p><p>a  光标后一位插入  A 行尾插入</p><p>i   光标原位置插入 I行首插入</p><p>o 光标下一行插入 O 光标上一行插入</p><p><img src="/2024/08/06/test/2024-08-06-vi%E5%AD%A6%E4%B9%A0/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20240906200102904.png" alt="image-20240906200102904"></p><p>nyy 复制 ndd删除  p光标下边复制 P光标下边复制 u撤回</p><p><img src="/2024/08/06/test/2024-08-06-vi%E5%AD%A6%E4%B9%A0/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20240906200109699.png" alt="image-20240906200109699"></p><p><img src="/2024/08/06/test/2024-08-06-vi%E5%AD%A6%E4%B9%A0/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20240906200754220.png" alt="image-20240906200754220"></p><p>​      k（上）</p><p>​h（左）     l（右）</p><p>​j（下）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2024/08/06/test/2024-08-06-%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/08/06/test/2024-08-06-%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="测试测试"><a href="#测试测试" class="headerlink" title="测试测试"></a>测试测试</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一些liunx问题</title>
      <link href="/2024/08/06/test/Linux%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2024/08/06/test/Linux%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h3 id="1-内核空间与用户空间的区别"><a href="#1-内核空间与用户空间的区别" class="headerlink" title="1. 内核空间与用户空间的区别"></a>1. 内核空间与用户空间的区别</h3><h4 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h4><ul><li><strong>定义</strong>：内核空间是操作系统的核心部分，直接管理硬件资源和系统资源。</li><li><strong>稳定性与安全性</strong>：内核代码需要高度的稳定性和安全性，不能依赖于用户空间的库。</li><li><strong>特权模式</strong>：内核代码运行在特权模式下，可以直接访问硬件资源和系统内存。</li><li><strong>开发原则</strong>：内核开发中尽量避免使用用户空间的库，以减少复杂性和潜在的稳定性问题。</li></ul><h4 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h4><ul><li><strong>定义</strong>：用户空间是应用程序运行的环境，通常依赖于各种标准库（如 glibc）来实现复杂的功能。</li><li><strong>非特权模式</strong>：用户空间代码运行在非特权模式下，需要通过系统调用与内核交互。</li></ul><hr><h3 id="2-Linux-驱动开发中的库使用"><a href="#2-Linux-驱动开发中的库使用" class="headerlink" title="2. Linux 驱动开发中的库使用"></a>2. Linux 驱动开发中的库使用</h3><h4 id="内核提供的-API"><a href="#内核提供的-API" class="headerlink" title="内核提供的 API"></a>内核提供的 API</h4><p>Linux 内核本身提供了一套丰富的 API，用于驱动开发。这些 API 包括：</p><ul><li><strong>内存管理</strong>：<code>kmalloc</code>、<code>kfree</code> 等函数用于动态内存分配和释放。</li><li><strong>文件操作</strong>：<code>file_operations</code> 结构体用于实现设备文件的读写操作。</li><li><strong>中断处理</strong>：<code>request_irq</code>、<code>free_irq</code> 等函数用于注册和释放中断。</li><li><strong>定时器</strong>：<code>timer_setup</code>、<code>del_timer</code> 等函数用于定时器的创建和删除。</li><li><strong>设备树</strong>：在嵌入式 Linux 开发中，设备树（Device Tree）用于描述硬件设备的配置信息。</li></ul><p>这些 API 是内核的一部分，专门用于驱动开发，因此驱动代码通常不需要额外的用户空间库。</p><h4 id="硬件抽象层（HAL）"><a href="#硬件抽象层（HAL）" class="headerlink" title="硬件抽象层（HAL）"></a>硬件抽象层（HAL）</h4><p>在某些情况下，硬件供应商会提供硬件抽象层（HAL）库，用于简化硬件访问。这些库通常是内核模块的一部分，而不是用户空间库。例如，NXP 的 i.MX 系列处理器提供了专门的 HAL 库，用于访问硬件寄存器和外设。</p><hr><h3 id="3-为什么看起来像是“不用库”"><a href="#3-为什么看起来像是“不用库”" class="headerlink" title="3. 为什么看起来像是“不用库”"></a>3. 为什么看起来像是“不用库”</h3><h4 id="直接硬件访问"><a href="#直接硬件访问" class="headerlink" title="直接硬件访问"></a>直接硬件访问</h4><ul><li>在驱动开发中，开发者需要直接与硬件交互，因此会直接操作硬件寄存器，而不是通过复杂的用户空间库。</li><li>例如，访问 GPIO、定时器、中断控制器等硬件资源时，通常会直接使用内核提供的 API 或硬件寄存器操作。</li></ul><h4 id="轻量级开发"><a href="#轻量级开发" class="headerlink" title="轻量级开发"></a>轻量级开发</h4><ul><li>驱动代码通常需要轻量级和高效，以减少对系统资源的占用。使用内核提供的 API 可以实现这一点，而不需要依赖于复杂的用户空间库。</li></ul><h4 id="稳定性和安全性"><a href="#稳定性和安全性" class="headerlink" title="稳定性和安全性"></a>稳定性和安全性</h4><ul><li>内核代码需要保持高度的稳定性和安全性，避免引入用户空间库可能带来的潜在问题（如内存泄漏、线程安全问题等）。</li></ul><hr><h3 id="4-特殊情况"><a href="#4-特殊情况" class="headerlink" title="4. 特殊情况"></a>4. 特殊情况</h3><h4 id="用户空间驱动"><a href="#用户空间驱动" class="headerlink" title="用户空间驱动"></a>用户空间驱动</h4><ul><li>在某些情况下，驱动程序可以运行在用户空间，而不是内核空间。这种情况下，驱动程序可以使用用户空间的库（如 glibc）。</li><li>例如，某些 USB 设备驱动或网络设备驱动可以运行在用户空间。</li></ul><h4 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h4><ul><li>在某些复杂的驱动开发场景中，可能会使用第三方库来实现特定功能。例如，某些图形驱动可能会使用 OpenGL 或 DirectFB 等库。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Linux 驱动开发并不是完全不使用库，而是尽量减少对用户空间库的依赖，转而使用内核提供的 API 和硬件抽象层。这种做法可以提高驱动代码的稳定性和效率，同时减少对系统资源的占用。在某些特殊情况下，驱动开发可能会使用用户空间库或第三方库，但这取决于具体的开发需求和应用场景。</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Makefile学习</title>
      <link href="/2024/08/06/test/Makefile/"/>
      <url>/2024/08/06/test/Makefile/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以下是一些推荐的学习Makefile的网站和资源，可以帮助你快速掌握Makefile的常用规则、结构和示例：</p><ol><li><strong>廖雪峰的官方网站</strong><br>廖雪峰的Makefile教程从基础概念讲起，通过简单易懂的例子逐步深入，非常适合作为入门学习。<br>网址：<a href="https://liaoxuefeng.com/books/makefile/makefile-basic/">Makefile基础 - Makefile教程 - 廖雪峰的官方网站</a></li><li><strong>腾讯云技术文档</strong><br>腾讯云上有一篇关于Makefile的详细解释和示例，涵盖了从基础到进阶的内容，包括如何编写Makefile以及一些高级用法。<br>网址：<a href="https://cloud.tencent.com/developer/article/1065286">超清晰的makefile解释、编写与示例 - 腾讯云</a></li><li><strong>博客园 - Makefile语法总结</strong><br>这篇文章总结了Makefile的常用语法和规则，并通过具体示例进行解析，适合有一定基础的读者深入学习。<br>网址：<a href="https://www.cnblogs.com/zxdplay/p/17782281.html">Makefile语法详细总结及示例解析（快速掌握）</a></li><li><strong>CSDN博客 - Makefile教程</strong><br>CSDN上有许多关于Makefile的教程和示例，其中一些文章提供了详细的规则和实际项目中的Makefile模板。<br>网址：<a href="https://blog.csdn.net/weixin_46097907/article/details/135816235">makefile常用的命令总结及简单示例 - CSDN博客</a></li><li><strong>GitHub Pages - Makefile教程</strong><br>这是一个开源的Makefile教程，提供了从入门到高级的详细内容，并且包含了许多实用的示例。<br>网址：<a href="https://gavinliu6.github.io/Makefile-Tutorial-zh-CN/">Makefile 教程 - GitHub Pages</a></li><li><strong>CSDN博客 - 通用Makefile模板</strong><br>这篇文章提供了一个通用的Makefile模板，适用于C++项目的编译和链接，是一个很好的参考。<br>网址：<a href="https://blog.csdn.net/wg_cheeky/article/details/108014390">makeFile基本介绍, 语法, 示例,通用makefile - CSDN博客</a></li></ol><h3 id="Makefile-的基本概念"><a href="#Makefile-的基本概念" class="headerlink" title="Makefile 的基本概念"></a>Makefile 的基本概念</h3><ul><li><strong>定义</strong>：Makefile 是一个用于自动化编译和构建项目的文件，它描述了工程的编译、链接等规则，包括哪些源文件需要编译、如何编译、如何生成目标文件等。</li><li><strong>作用</strong>：通过编写 Makefile，可以使用 <code>make</code> 命令工具来自动化编译过程，避免手动输入繁琐的编译命令，提高开发效率。</li></ul><h3 id="Makefile-的基本结构"><a href="#Makefile-的基本结构" class="headerlink" title="Makefile 的基本结构"></a>Makefile 的基本结构</h3><ul><li><strong>变量定义</strong>：用于简化和统一文件名或命令的书写。例如：<ul><li><code>CC = gcc</code>：定义编译器为 gcc。</li><li><code>CFLAGS = -Wall -g</code>：定义编译选项，<code>-Wall</code> 显示所有警告，<code>-g</code> 启用调试信息。</li><li><code>TARGET = my_program</code>：定义目标文件名为 <code>my_program</code>。</li><li><code>OBJECTS = main.o utils.o</code>：定义目标文件列表。</li></ul></li><li><strong>规则定义</strong>：指定目标文件、依赖文件和生成目标文件的命令。基本格式如下：<ul><li><code>target: dependencies</code>：目标文件和依赖文件。</li><li><code>command</code>：生成目标文件的命令，必须以 Tab 键开始。</li></ul></li><li><strong>伪目标</strong>：用于执行一些特定的操作，如清理编译生成的文件。例如：<ul><li><code>.PHONY: clean</code>：声明 <code>clean</code> 是一个伪目标。</li><li><code>clean:</code>：定义清理操作的命令。</li></ul></li></ul><h3 id="Makefile-的基本语法"><a href="#Makefile-的基本语法" class="headerlink" title="Makefile 的基本语法"></a>Makefile 的基本语法</h3><ul><li><p><strong>目标和依赖</strong>：目标是要生成的文件，依赖是生成目标所需要的文件。基本格式如下：</p><ul><li><code>target: dependencies</code>：目标文件和依赖文件。</li><li><code>command</code>：生成目标文件的命令，必须以 Tab 键开始。</li></ul></li><li><p><strong>内置变量</strong>：Makefile 提供了一些内置变量，常用的包括：</p><ul><li><code>$@</code>：目标文件的名称。</li><li><code>$^</code>：所有依赖文件的名称。</li><li><code>$&lt;</code>：第一个依赖文件的名称。</li></ul><p>  <img src="/2024/08/06/test/Makefile/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20250423142456075.png" alt="image-20250423142456075"></p></li><li><p><strong>通配符</strong>：用于匹配文件名或文件路径中的多个字符，以便在规则中批量处理文件。常见的通配符有：</p><ul><li><code>*</code>：匹配零个或多个字符。</li><li><code>?</code>：匹配一个任意字符。</li><li><code>[...]</code>：匹配方括号内的任意一个字符。</li><li><code>[!...]</code>：匹配除了方括号内的字符之外的任意一个字符。</li></ul></li><li><p><strong>模式规则</strong>：用于定义一种模式，告诉 Make 工具如何将一类文件转换成另一类文件。例如：</p><ul><li><code>%.o: %.c</code>：表示所有以 <code>.c</code> 结尾的源文件都可以生成对应的 <code>.o</code> 目标文件。</li></ul></li><li><p><strong>自动化变量</strong>：在规则的命令中使用，代表了与规则相关联的文件名。常用的自动化变量包括：</p><ul><li><code>$@</code>：表示规则中的目标文件名。</li><li><code>$&lt;</code>：表示规则中的第一个依赖文件名。</li><li><code>$^</code>：表示规则中的所有依赖文件名，以空格分隔。</li></ul></li></ul><h3 id="Makefile-的实际应用"><a href="#Makefile-的实际应用" class="headerlink" title="Makefile 的实际应用"></a>Makefile 的实际应用</h3><ul><li><strong>简单示例</strong>：<ul><li>假设有一个简单的 C 项目，包含 <code>main.c</code> 和 <code>utils.c</code> 两个源文件 ，目标是生成可执行文件 <code>my_program</code>。Makefile 内容如下：<ul><li><pre><code class="makefile">CC = gccCFLAGS = -Wall -gTARGET = my_programOBJECTS = main.o utils.oall: $(TARGET)$(TARGET): $(OBJECTS)    $(CC) $(CFLAGS) -o $(TARGET) $(OBJECTS)main.o: main.c    $(CC) $(CFLAGS) -c main.cutils.o: utils.c    $(CC) $(CFLAGS) -c utils.c.PHONY: cleanclean:    rm -f $(TARGET) $(OBJECTS)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    - 在项目目录中执行 `make` 命令即可编译项目，执行 `make clean` 命令可以清理编译生成的文件。</span><br><span class="line">- **复杂项目**：</span><br><span class="line">    - 对于复杂的嵌入式 Linux 项目，可能包含多个源文件、头文件、汇编文件等，需要更复杂的 Makefile 来管理。例如：</span><br><span class="line">        - ```makefile</span><br><span class="line">          CROSS_COMPILE  ?= arm-linux-gnueabihf-</span><br><span class="line">          TARGET   ?= bsp</span><br><span class="line">          CC := $(CROSS_COMPILE)gcc</span><br><span class="line">          LD:= $(CROSS_COMPILE)ld</span><br><span class="line">          OBJCOPY := $(CROSS_COMPILE)objcopy</span><br><span class="line">          OBJDUMP := $(CROSS_COMPILE)objdump</span><br><span class="line">          INCDIRS := imx6ul \</span><br><span class="line">                             bsp/clk \</span><br><span class="line">                             bsp/led \</span><br><span class="line">                             bsp/delay</span><br><span class="line">          SRCDIRS:= project \</span><br><span class="line">                             bsp/clk \</span><br><span class="line">                             bsp/led \</span><br><span class="line">                             bsp/delay</span><br><span class="line">          INCLUDE:= $(patsubst %, -I %, $(INCDIRS))</span><br><span class="line">          SFILES:= $(foreach dir, $(SRCDIRS), $(wildcard $(dir)/*.S))</span><br><span class="line">          CFILES:= $(foreach dir, $(SRCDIRS), $(wildcard $(dir)/*.c))</span><br><span class="line">          SFILENDIR:= $(notdir  $(SFILES))</span><br><span class="line">          CFILENDIR:= $(notdir  $(CFILES))</span><br><span class="line">          SOBJS:= $(patsubst %, obj/%, $(SFILENDIR:.S=.o))</span><br><span class="line">          COBJS:= $(patsubst %, obj/%, $(CFILENDIR:.c=.o))</span><br><span class="line">          OBJS:= $(SOBJS) $(COBJS)</span><br><span class="line">          VPATH:= $(SRCDIRS)</span><br><span class="line">          .PHONY: clean</span><br><span class="line">          $(TARGET).bin : $(OBJS)</span><br><span class="line">              $(LD) -Timx6ul.lds -o $(TARGET).elf $^</span><br><span class="line">              $(OBJCOPY) -O binary -S $(TARGET).elf $@</span><br><span class="line">              $(OBJDUMP) -D -m arm $(TARGET).elf &gt; $(TARGET).dis</span><br><span class="line">          $(SOBJS) : obj/%.o : %.S</span><br><span class="line">              $(CC) -Wall -nostdlib -c -O2  $(INCLUDE) -o $@ $&lt;</span><br><span class="line">          $(COBJS) : obj/%.o : %.c</span><br><span class="line">              $(CC) -Wall -nostdlib -c -O2  $(INCLUDE) -o $@ $&lt;</span><br><span class="line">          clean:</span><br><span class="line">              rm -rf $(TARGET).elf $(TARGET).dis $(TARGET).bin $(COBJS) $(SOBJS)</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li>该 Makefile 使用了交叉编译工具链，支持多个源文件和汇编文件的编译，生成二进制可执行文件、ELF 格式文件和反汇编文件。</li></ul></li></ul><h3 id="Makefile-的调试"><a href="#Makefile-的调试" class="headerlink" title="Makefile 的调试"></a>Makefile 的调试</h3><ul><li><strong>查看 <code>make</code> 过程</strong>：使用 <code>make -n</code> 命令可以显示将会执行的命令，但不会实际执行。</li><li><strong>增加详细输出</strong>：使用 <code>make --debug</code> 命令可以提供详细的调试信息，帮助排查问题。</li></ul><h3 id="Makefile-的高级功能"><a href="#Makefile-的高级功能" class="headerlink" title="Makefile 的高级功能"></a>Makefile 的高级功能</h3><ul><li><p><strong>条件语句</strong>：可以根据不同的条件执行不同的规则或设置变量。常见的条件语句有 <code>ifeq</code>、<code>ifneq</code>、<code>ifdef</code>、<code>ifndef</code>。</p><ul><li>示例：根据操作系统设置不同的编译选项。<ul><li><pre><code class="makefile">CC = gccCFLAGS = -Wall -gifeq ($(OS),Windows_NT)    CFLAGS += -DWIN32else    CFLAGS += -DUNIXendifTARGET = my_programSRCS = main.c utils.call: $(TARGET)$(TARGET): $(SRCS)    $(CC) $(CFLAGS) -o $(TARGET) $(SRCS)clean:    rm -f $(TARGET)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">- **使用函数**：Makefile 提供了一些内建函数，帮助处理字符串和文件操作等任务。常用函数包括：</span><br><span class="line">    - `$(wildcard pattern)`：返回匹配模式的所有文件。</span><br><span class="line">    - `$(patsubst pattern,replacement,text)`：用指定的替换文本替换模式。</span><br><span class="line">    - `$(basename names)`：去除文件名的扩展名部分。</span><br><span class="line">    - `$(dir names)`：返回文件的目录路径。</span><br><span class="line">    - 示例：使用 `wildcard` 和 `patsubst`。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### **Makefile基础笔记**</span><br><span class="line"></span><br><span class="line">#### **1. Makefile概述**</span><br><span class="line">- **Makefile的作用**：</span><br><span class="line">  - 在Linux环境下，`make`命令会查找当前目录下的`Makefile`文件。</span><br><span class="line">  - 根据Makefile中定义的规则，`make`可以自动化地执行命令，例如编译源代码、生成目标文件等。</span><br><span class="line">  - Makefile的核心思想是通过定义规则来描述如何生成目标文件。</span><br><span class="line"></span><br><span class="line">- **基本逻辑示例**：</span><br><span class="line">  - 假设有文件`a.txt`、`b.txt`和`c.txt`，需要先合并`a.txt`和`b.txt`生成中间文件`m.txt`，再将`m.txt`与`c.txt`合并生成最终文件`x.txt`。</span><br><span class="line">  - Makefile通过规则定义这种依赖关系和生成过程。</span><br><span class="line"></span><br><span class="line">#### **2. Makefile规则的基本格式**</span><br><span class="line">- **规则格式**：</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>目标文件: 依赖文件1 依赖文件2 …<br>    命令1<br>    命令2<br>    …</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  - **目标文件**：需要生成的文件。</span><br><span class="line">  - **依赖文件**：生成目标文件所需的文件。</span><br><span class="line">  - **命令**：用于生成目标文件的具体命令，必须以Tab键开头。</span><br><span class="line"></span><br><span class="line">- **示例**：</span><br><span class="line">  </span><br><span class="line">  ```makefile</span><br><span class="line">  m.txt: a.txt b.txt</span><br><span class="line">      cat a.txt b.txt &gt; m.txt</span><br><span class="line">  </span><br><span class="line">  x.txt: m.txt c.txt</span><br><span class="line">      cat m.txt c.txt &gt; x.txt</span><br></pre></td></tr></table></figure><ul><li><code>m.txt</code>依赖于<code>a.txt</code>和<code>b.txt</code>，通过<code>cat</code>命令合并生成。</li><li><code>x.txt</code>依赖于<code>m.txt</code>和<code>c.txt</code>，同样通过<code>cat</code>命令生成。</li></ul></li></ul><h4 id="3-Makefile的执行逻辑"><a href="#3-Makefile的执行逻辑" class="headerlink" title="3. Makefile的执行逻辑"></a><strong>3. Makefile的执行逻辑</strong></h4><ul><li><p><strong>增量编译</strong>：</p><ul><li><code>make</code>会检查目标文件和依赖文件的修改时间。</li><li>如果目标文件的修改时间晚于所有依赖文件，则认为目标文件是最新的，不会重新生成。</li><li>如果依赖文件中的任何一个被修改，则会重新执行规则生成目标文件。</li></ul></li><li><p><strong>默认规则</strong>：</p><ul><li><code>make</code>默认执行Makefile中的第一条规则。</li><li>例如，如果要生成<code>x.txt</code>，<code>make</code>会先检查<code>m.txt</code>是否存在，如果不存在则先生成<code>m.txt</code>，然后再生成<code>x.txt</code>。</li></ul></li></ul><h4 id="4-伪目标（Phony-Target）"><a href="#4-伪目标（Phony-Target）" class="headerlink" title="4. 伪目标（Phony Target）"></a><strong>4. 伪目标（Phony Target）</strong></h4><ul><li><p><strong>定义</strong>：</p><ul><li>伪目标不是实际的文件名，而是用于执行特定任务的规则。</li><li>例如，<code>clean</code>规则通常用于删除生成的文件。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f m.txt x.txt</span><br></pre></td></tr></table></figure><ul><li>执行<code>make clean</code>会删除<code>m.txt</code>和<code>x.txt</code>。</li></ul></li><li><p><strong>避免冲突</strong>：</p><ul><li>如果存在名为<code>clean</code>的文件，<code>make clean</code>可能不会执行。</li><li>可以使用<code>.PHONY</code>声明伪目标：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f m.txt x.txt</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="5-执行多条命令"><a href="#5-执行多条命令" class="headerlink" title="5. 执行多条命令"></a><strong>5. 执行多条命令</strong></h4><ul><li><p><strong>独立命令</strong>：</p><ul><li>每条命令默认在独立的Shell环境中执行。</li><li>例如，<code>cd</code>命令不会影响后续命令的执行环境。</li></ul></li><li><p><strong>多条命令的写法</strong>：</p><ul><li>使用<code>;</code>分隔命令：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">    pwd; cd ..; pwd</span><br></pre></td></tr></table></figure></li><li>使用<code>\</code>换行：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">    pwd; \</span><br><span class="line">    cd ..; \</span><br><span class="line">    pwd</span><br></pre></td></tr></table></figure></li><li>使用<code>&amp;&amp;</code>确保命令顺序执行：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">    pwd &amp;&amp; cd .. &amp;&amp; pwd</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="6-控制命令输出"><a href="#6-控制命令输出" class="headerlink" title="6. 控制命令输出"></a><strong>6. 控制命令输出</strong></h4><ul><li><strong>隐藏命令输出</strong>：<ul><li>在命令前加<code>@</code>可以隐藏命令的打印输出，但命令仍然会执行。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">no_output:</span></span><br><span class="line">    @echo &#x27;not display&#x27;</span><br><span class="line">    echo &#x27;will display&#x27;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="7-错误处理"><a href="#7-错误处理" class="headerlink" title="7. 错误处理"></a><strong>7. 错误处理</strong></h4><ul><li><p><strong>默认行为</strong>：</p><ul><li>如果命令返回非0值，<code>make</code>会中断执行并报错。</li></ul></li><li><p><strong>忽略错误</strong>：</p><ul><li>在命令前加<code>-</code>可以忽略错误，继续执行后续命令。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ignore_error:</span></span><br><span class="line">    -rm zzz.txt</span><br><span class="line">    echo &#x27;ok&#x27;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h4><p>Makefile通过定义规则来自动化生成目标文件，核心在于描述目标文件与依赖文件之间的关系以及生成目标文件的具体命令。掌握以下要点：</p><ul><li>规则的基本格式：目标文件、依赖文件和命令。</li><li>增量编译的逻辑：基于文件的修改时间。</li><li>伪目标的使用：如<code>clean</code>。</li><li>多条命令的写法：使用<code>;</code>、<code>\</code>或<code>&amp;&amp;</code>。</li><li>控制命令输出：使用<code>@</code>。</li><li>错误处理：使用<code>-</code>忽略错误。</li></ul><hr><hr><h3 id="编译C程序-Makefile教程笔记"><a href="#编译C程序-Makefile教程笔记" class="headerlink" title="编译C程序 - Makefile教程笔记"></a><strong>编译C程序 - Makefile教程笔记</strong></h3><h4 id="1-C程序编译的基本步骤"><a href="#1-C程序编译的基本步骤" class="headerlink" title="1. C程序编译的基本步骤"></a><strong>1. C程序编译的基本步骤</strong></h4><p>编译C程序通常分为两步：</p><ol><li><strong>编译阶段</strong>：将每个<code>.c</code>文件编译为<code>.o</code>文件（目标文件）。</li><li><strong>链接阶段</strong>：将所有<code>.o</code>文件链接为最终的可执行文件。</li></ol><h4 id="2-示例项目结构"><a href="#2-示例项目结构" class="headerlink" title="2. 示例项目结构"></a><strong>2. 示例项目结构</strong></h4><p>假设一个简单的C项目，包含以下文件：</p><ul><li><code>hello.c</code>：定义了一个<code>hello</code>函数。</li><li><code>hello.h</code>：声明了<code>hello</code>函数。</li><li><code>main.c</code>：主程序，调用了<code>hello</code>函数。</li></ul><p><strong>文件内容</strong>：</p><ul><li>**<code>hello.c</code>**：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>**<code>hello.h</code>**：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li><li>**<code>main.c</code>**：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start...\n&quot;</span>);</span><br><span class="line">    hello();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-Makefile编写"><a href="#3-Makefile编写" class="headerlink" title="3. Makefile编写"></a><strong>3. Makefile编写</strong></h4><p>根据上述项目结构，Makefile可以定义如下规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 hello.c</span></span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">cc -c hello.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 main.c</span></span><br><span class="line"><span class="section">main.o: main.c hello.h</span></span><br><span class="line">cc -c main.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理生成的文件</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o world.out</span><br></pre></td></tr></table></figure><h4 id="4-Makefile执行逻辑"><a href="#4-Makefile执行逻辑" class="headerlink" title="4. Makefile执行逻辑"></a><strong>4. Makefile执行逻辑</strong></h4><ul><li><p><strong>增量编译</strong>：</p><ul><li><code>make</code>会根据文件的修改时间来判断是否需要重新编译。</li><li>如果<code>hello.c</code>被修改，<code>make</code>会重新编译<code>hello.c</code>生成<code>hello.o</code>，并重新链接生成<code>world.out</code>。</li><li>如果<code>hello.h</code>被修改，<code>make</code>会重新编译所有依赖<code>hello.h</code>的文件（如<code>main.c</code>），并重新链接生成<code>world.out</code>。</li></ul></li><li><p><strong>执行过程</strong>：</p><ul><li>初始运行<code>make</code>时，会依次执行以下步骤：<ol><li>编译<code>hello.c</code>生成<code>hello.o</code>。</li><li>编译<code>main.c</code>生成<code>main.o</code>。</li><li>链接<code>hello.o</code>和<code>main.o</code>生成<code>world.out</code>。</li></ol></li><li>如果修改了<code>hello.c</code>，再次运行<code>make</code>时，只会重新编译<code>hello.c</code>并重新链接<code>world.out</code>。</li><li>如果修改了<code>hello.h</code>，<code>make</code>会重新编译<code>main.c</code>并重新链接<code>world.out</code>。</li></ul></li></ul><h4 id="5-清理规则"><a href="#5-清理规则" class="headerlink" title="5. 清理规则"></a><strong>5. 清理规则</strong></h4><ul><li><strong><code>clean</code>规则</strong>：<ul><li>用于删除所有生成的文件，包括<code>.o</code>文件和可执行文件。</li><li>执行命令：<code>make clean</code>。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.o world.out</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="6-规则优化"><a href="#6-规则优化" class="headerlink" title="6. 规则优化"></a><strong>6. 规则优化</strong></h4><p>随着项目规模的扩大，手动维护Makefile中的规则会变得繁琐。后续可以学习如何使用变量、模式规则等高级特性来简化Makefile的编写。</p><h4 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a><strong>7. 小结</strong></h4><ul><li><strong>Makefile的作用</strong>：通过定义规则，<code>make</code>可以自动化编译C程序。</li><li><strong>规则的基本格式</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标文件: 依赖文件</span><br><span class="line">    命令</span><br></pre></td></tr></table></figure></li><li><strong>增量编译</strong>：<code>make</code>根据文件的修改时间来决定是否重新编译。</li><li><strong>清理规则</strong>：使用<code>clean</code>规则删除生成的文件，方便重新编译。</li></ul><p>以下是根据廖雪峰的《使用隐式规则》教程整理的笔记，主要介绍了Makefile中隐式规则的概念、使用方法以及其潜在问题。</p><hr><h3 id="使用隐式规则-Makefile教程笔记"><a href="#使用隐式规则-Makefile教程笔记" class="headerlink" title="使用隐式规则 - Makefile教程笔记"></a><strong>使用隐式规则 - Makefile教程笔记</strong></h3><h4 id="1-隐式规则的概念"><a href="#1-隐式规则的概念" class="headerlink" title="1. 隐式规则的概念"></a><strong>1. 隐式规则的概念</strong></h4><ul><li><p><strong>隐式规则（Implicit Rule）</strong>：</p><ul><li>Makefile中的一种特殊规则，用于自动推导目标文件的生成规则。</li><li>当Makefile中没有明确定义某个目标文件的规则时，<code>make</code>会尝试使用内置的隐式规则来生成该目标文件。</li></ul></li><li><p><strong>内置规则的作用</strong>：</p><ul><li>为了简化Makefile的编写，<code>make</code>为常见的编译任务（如C、C++、ASM等）提供了默认的隐式规则。</li><li>例如，对于C程序，<code>make</code>会自动应用以下隐式规则：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xyz.o: xyz.c</span><br><span class="line">    cc -c -o xyz.o xyz.c</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-示例：隐式规则的应用"><a href="#2-示例：隐式规则的应用" class="headerlink" title="2. 示例：隐式规则的应用"></a><strong>2. 示例：隐式规则的应用</strong></h4><p>假设有一个C项目，包含<code>hello.c</code>、<code>main.c</code>和<code>hello.h</code>，目标是生成可执行文件<code>world.out</code>。</p><p><strong>项目结构</strong>：</p><ul><li><code>hello.c</code>：定义了一个<code>hello</code>函数。</li><li><code>hello.h</code>：声明了<code>hello</code>函数。</li><li><code>main.c</code>：主程序，调用了<code>hello</code>函数。</li></ul><p><strong>Makefile</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只保留生成 world.out 的规则</span></span><br><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">    cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.o world.out</span><br></pre></td></tr></table></figure><p><strong>执行过程</strong>：</p><ul><li>执行<code>make</code>命令时，<code>make</code>会自动推导出<code>hello.o</code>和<code>main.o</code>的生成规则：<ul><li><code>hello.o</code>依赖于<code>hello.c</code>，使用<code>cc -c -o hello.o hello.c</code>生成。</li><li><code>main.o</code>依赖于<code>main.c</code>，使用<code>cc -c -o main.o main.c</code>生成。</li></ul></li><li>最后，<code>make</code>会链接<code>hello.o</code>和<code>main.o</code>生成<code>world.out</code>。</li></ul><p><strong>输出</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc    -c -o hello.o hello.c</span><br><span class="line">cc    -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure><h4 id="3-隐式规则的优势"><a href="#3-隐式规则的优势" class="headerlink" title="3. 隐式规则的优势"></a><strong>3. 隐式规则的优势</strong></h4><ul><li><strong>减少重复规则</strong>：<ul><li>隐式规则可以减少Makefile中大量重复的编译规则。</li><li>例如，对于多个<code>.c</code>文件，无需为每个文件单独编写<code>.o</code>文件的生成规则。</li></ul></li></ul><h4 id="4-隐式规则的潜在问题"><a href="#4-隐式规则的潜在问题" class="headerlink" title="4. 隐式规则的潜在问题"></a><strong>4. 隐式规则的潜在问题</strong></h4><ul><li><strong>无法跟踪头文件的修改</strong>：<ul><li>隐式规则的一个主要问题是无法自动跟踪头文件（如<code>.h</code>文件）的修改。</li><li>例如，如果修改了<code>hello.h</code>，隐式规则<code>main.o: main.c</code>不会自动检测到<code>hello.h</code>的修改，导致<code>main.c</code>不会被重新编译。</li><li>这可能导致生成的可执行文件中包含过时的代码。</li></ul></li></ul><h4 id="5-解决隐式规则的潜在问题"><a href="#5-解决隐式规则的潜在问题" class="headerlink" title="5. 解决隐式规则的潜在问题"></a><strong>5. 解决隐式规则的潜在问题</strong></h4><ul><li><p><strong>手动添加依赖</strong>：</p><ul><li>为了确保头文件的修改能够触发重新编译，需要手动在Makefile中添加头文件的依赖关系。</li><li>例如：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main.o: main.c hello.h</span></span><br><span class="line">    cc -c main.c</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>自动生成依赖文件</strong>：</p><ul><li>在实际项目中，可以通过工具（如<code>gcc -M</code>）自动生成依赖文件，并将其包含在Makefile中。</li><li>例如，使用<code>gcc -M</code>生成依赖文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -M main.c &gt; main.d</span><br></pre></td></tr></table></figure></li><li>然后在Makefile中包含这些依赖文件：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-include</span> main.d</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a><strong>6. 小结</strong></h4><ul><li><strong>隐式规则的作用</strong>：减少重复的编译规则，简化Makefile的编写。</li><li><strong>隐式规则的潜在问题</strong>：无法自动跟踪头文件的修改，可能导致生成的可执行文件包含过时代码。</li><li><strong>解决方法</strong>：手动添加头文件依赖或使用工具自动生成依赖文件。</li></ul><hr><p>以下是根据廖雪峰的《使用变量》教程整理的笔记，主要介绍了Makefile中变量的使用方法、内置变量和自动变量的概念。</p><hr><h3 id="使用变量-Makefile教程笔记"><a href="#使用变量-Makefile教程笔记" class="headerlink" title="使用变量 - Makefile教程笔记"></a><strong>使用变量 - Makefile教程笔记</strong></h3><h4 id="1-变量的作用"><a href="#1-变量的作用" class="headerlink" title="1. 变量的作用"></a><strong>1. 变量的作用</strong></h4><ul><li><strong>解决重复问题</strong>：<ul><li>在Makefile中，文件名或命令可能会重复出现多次，手动修改容易出错。</li><li>使用变量可以简化Makefile的编写，提高可维护性。</li></ul></li></ul><h4 id="2-定义和使用变量"><a href="#2-定义和使用变量" class="headerlink" title="2. 定义和使用变量"></a><strong>2. 定义和使用变量</strong></h4><ul><li><p><strong>定义变量</strong>：</p><ul><li>使用<code>变量名 = 值</code>或<code>变量名 := 值</code>定义变量。</li><li>通常变量名使用全大写，例如<code>TARGET</code>、<code>OBJS</code>等。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TARGET = world.out</span><br><span class="line">OBJS = hello.o main.o</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>引用变量</strong>：</p><ul><li>使用<code>$(变量名)</code>引用变量。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">    cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="3-动态生成变量"><a href="#3-动态生成变量" class="headerlink" title="3. 动态生成变量"></a><strong>3. 动态生成变量</strong></h4><ul><li><p><strong>使用<code>wildcard</code>函数</strong>：</p><ul><li><code>wildcard</code>函数可以匹配当前目录下的文件模式。</li><li>示例：<code>$(wildcard *.c)</code>会列出当前目录下所有<code>.c</code>文件。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用<code>patsubst</code>函数</strong>：</p><ul><li><code>patsubst</code>函数用于模式替换。</li><li>示例：<code>$(patsubst %.c,%.o,$(wildcard *.c))</code>会将所有<code>.c</code>文件名替换为<code>.o</code>文件名。</li><li>这样，每当添加新的<code>.c</code>文件时，<code>OBJS</code>变量会自动更新，无需手动修改Makefile。</li></ul></li></ul><h4 id="4-内置变量"><a href="#4-内置变量" class="headerlink" title="4. 内置变量"></a><strong>4. 内置变量</strong></h4><ul><li><p><strong>内置变量</strong>：</p><ul><li><code>make</code>提供了一些内置变量，例如<code>$(CC)</code>表示C编译器，默认值是<code>cc</code>。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>修改内置变量</strong>：</p><ul><li>可以重新定义内置变量的值。</li><li>示例：使用交叉编译器时，可以设置<code>CC = riscv64-linux-gnu-gcc</code>。</li></ul></li></ul><h4 id="5-自动变量"><a href="#5-自动变量" class="headerlink" title="5. 自动变量"></a><strong>5. 自动变量</strong></h4><ul><li><p><strong>自动变量</strong>：</p><ul><li>在规则中自动指向特定值的变量。</li><li>常用的自动变量：<ul><li><code>$@</code>：目标文件名。</li><li><code>$&lt;</code>：依赖列表中的第一个文件。</li><li><code>$^</code>：所有依赖文件。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">    @echo &#x27;$<span class="variable">$@</span> = <span class="variable">$@</span>&#x27; <span class="comment"># 目标文件名</span></span><br><span class="line">    @echo &#x27;$<span class="variable">$&lt;</span> = <span class="variable">$&lt;</span>&#x27; <span class="comment"># 第一个依赖文件</span></span><br><span class="line">    @echo &#x27;$<span class="variable">$^</span> = <span class="variable">$^</span>&#x27; <span class="comment"># 所有依赖文件</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>输出示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$@</span> = world.out</span><br><span class="line">$&lt; = hello.o</span><br><span class="line">$^ = hello.o main.o</span><br><span class="line">$(CC) -o world.out hello.o main.o</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-变量的调试"><a href="#6-变量的调试" class="headerlink" title="6. 变量的调试"></a><strong>6. 变量的调试</strong></h4><ul><li><strong>打印变量</strong>：<ul><li>使用<code>@echo</code>打印变量的值，便于调试。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">    @echo &#x27;$<span class="variable">$@</span> = <span class="variable">$@</span>&#x27;</span><br><span class="line">    @echo &#x27;$<span class="variable">$&lt;</span> = <span class="variable">$&lt;</span>&#x27;</span><br><span class="line">    @echo &#x27;$<span class="variable">$^</span> = <span class="variable">$^</span>&#x27;</span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="7-小结-1"><a href="#7-小结-1" class="headerlink" title="7. 小结"></a><strong>7. 小结</strong></h4><ul><li><strong>变量的作用</strong>：简化Makefile的编写，减少重复，提高可维护性。</li><li><strong>变量的定义和引用</strong>：使用<code>变量名 = 值</code>定义，使用<code>$(变量名)</code>引用。</li><li><strong>动态生成变量</strong>：使用<code>wildcard</code>和<code>patsubst</code>函数自动生成文件列表。</li><li><strong>内置变量</strong>：使用内置变量（如<code>$(CC)</code>）简化命令。</li><li><strong>自动变量</strong>：使用自动变量（如<code>$@</code>、<code>$&lt;</code>、<code>$^</code>）简化规则。</li></ul><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法自带格式(如何写博客)</title>
      <link href="/2024/08/06/test/Markdown%E8%AF%AD%E6%B3%95%E8%87%AA%E5%B8%A6%E6%A0%BC%E5%BC%8F(%E5%A6%82%E4%BD%95%E5%86%99%E5%8D%9A%E5%AE%A2)/"/>
      <url>/2024/08/06/test/Markdown%E8%AF%AD%E6%B3%95%E8%87%AA%E5%B8%A6%E6%A0%BC%E5%BC%8F(%E5%A6%82%E4%BD%95%E5%86%99%E5%8D%9A%E5%AE%A2)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/./../images/bywind.png" alt="图"></p><p>用Typora软件更简单</p><p><a href="https://www.bilibili.com/video/BV1iHaTe9EZ3/?spm_id_from=333.337.search-card.all.click&vd_source=390e7ea253547d9c75882d502ff42a1b">Typora安装激活流程_哔哩哔哩_bilibili</a></p><p>Typora安装文件及下载地址~<br>链接:<a href="https://pan.baidu.com/s/17CunIoob5JbtQZ1N5ZIyfg?pwd=zspz">https://pan.baidu.com/s/17CunIoob5JbtQZ1N5ZIyfg?pwd=zspz</a> 提取码:zspz</p><p>一键3连 上传代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl&amp;&amp;hexo g&amp;&amp;hexo d</span><br></pre></td></tr></table></figure><h2 id="多级标题"><a href="#多级标题" class="headerlink" title="多级标题"></a>多级标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure><h2 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span>&gt;</span></span>5号字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>这里的背景色是：MistyRosen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure><h2 id="1-5-分割线"><a href="#1-5-分割线" class="headerlink" title="1.5 分割线"></a>1.5 分割线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><p>​分栏 tab</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><ol><li>Unique name :<ul><li>选项卡块标签的唯一名称，不带逗号。</li><li>将在#id中用作每个标签及其索引号的前缀。</li><li>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</li><li>仅当前帖子&#x2F;页面的URL必须是唯一的！</li></ul></li><li>[index]:<ul><li>活动选项卡的索引号。</li><li>如果未指定，将选择第一个标签（1）。</li><li>如果index为-1，则不会选择任何选项卡。</li><li>可选参数。</li></ul></li><li>[Tab caption]:<ul><li>当前选项卡的标题。</li><li>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</li><li>如果未指定标题，但指定了图标，则标题将为空。</li><li>可选参数。</li></ul></li><li>[@icon]:<ul><li>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</li><li>可以指定带空格或不带空格；</li><li>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</li><li>可选参数。</li></ul></li></ol><p>示例1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>示例2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line">**tab名字为第一个Tab**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line">**只有图标 没有Tab名字**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line">**名字+icon**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>示例1</p><p>.<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">test1 1</button><button type="button" class="tab">test1 2</button><button type="button" class="tab">test1 3</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>This is Tab 1.</strong></p></div><div class="tab-item-content"><p><strong>This is Tab 2.</strong></p></div><div class="tab-item-content"><p><strong>This is Tab 3.</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></p><p>示例2</p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">第一个Tab</button><button type="button" class="tab"><i class="fab fa-apple-pay"></i></button><button type="button" class="tab"><i class="fas fa-bomb"></i>炸弹</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>tab名字为第一个Tab</strong></p></div><div class="tab-item-content"><p><strong>只有图标 没有Tab名字</strong></p></div><div class="tab-item-content"><p><strong>名字+icon</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="音频-audio"><a href="#音频-audio" class="headerlink" title="音频 audio"></a>音频 audio</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">参数配置</button><button type="button" class="tab">示例代码</button><button type="button" class="tab">演示</button></div><div class="tab-contents"><div class="tab-item-content active"></div><div class="tab-item-content"></div><div class="tab-item-content"></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> 博客写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 写作技巧 </tag>
            
            <tag> 博客指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STUDY210学习</title>
      <link href="/2024/08/06/test/STUDY210(%E6%9C%B1%E6%9C%89%E9%B9%8F)/"/>
      <url>/2024/08/06/test/STUDY210(%E6%9C%B1%E6%9C%89%E9%B9%8F)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="隐藏文件与非隐藏文件"><a href="#隐藏文件与非隐藏文件" class="headerlink" title="隐藏文件与非隐藏文件"></a>隐藏文件与非隐藏文件</h1><p>Windows中：文件隐藏与不隐藏通过设置文件属性实现的，可以点击文件，右键属性，选择勾选隐藏选项来设置文件为隐藏文件。。在Windows中查看隐藏文件方法：菜单栏 工具-&gt;文件夹选项-&gt;查看-&gt;显示所有文件<br>和文件夹。<br>Linux中：linux中隐藏文件特点是文件名以.开头，跟文件属性无关。在linux中查看隐藏文件用ls -a命令（普通显示ls）</p><h1 id="相对路径与绝对路径"><a href="#相对路径与绝对路径" class="headerlink" title="相对路径与绝对路径"></a>相对路径与绝对路径</h1><p>什么是路径：路径是用来标识一个文件在操作系统的文件系统中存储位置的。pathname<br>举例：<br>D:\winshare\enum.c 全路径 pathname<br>D:\winshare路径 path<br>enum.c文件名name</p><p>绝对路径：路径是从绝对位置开始的。譬如Windows中从某一个盘符开始（C:\），linux中从根目录&#x2F;开始<br>相对路径：指明路径的时候，是从当前所在的位置开始的。</p><p>举例：<br>D:\我的文档\123\123.txt<br>D:\我的文档\abc\abc.txt<br>当前在123.txt，但是要去abc.txt<br>方式1：采用绝对路径。D:\我的文档\abc\abc.txt<br>方式2：采用相对路径。..&#x2F;abc&#x2F;abc.txt (..表示上一层)<br>从当前路径开始，往上走一层，再往下走一层（abc）就到了</p><p>测试：<br>&#x2F;abc&#x2F;123&#x2F;def.txt是linux绝对路径<br>abc&#x2F;123&#x2F;def.txt不是linux绝对路径<br>F:\abc\123\def.txt是windows绝对路径<br>abc\123\def.txt不是windows绝对路径</p><h1 id="linux内核、发行版"><a href="#linux内核、发行版" class="headerlink" title="linux内核、发行版"></a>linux内核、发行版</h1><p>linux本身指的是一个操作系统内核，只有内核是无法直接使用的。我们需要的，可以使用的操作系统是一个包含了内核和一批有用的应用程序的一个集合体，这个就叫linux发行版。<br>ubuntu、redhat就是linux的不同的发行版。</p><h1 id="GUI（图形用户界面）和cmdline（命令行）"><a href="#GUI（图形用户界面）和cmdline（命令行）" class="headerlink" title="GUI（图形用户界面）和cmdline（命令行）"></a>GUI（图形用户界面）和cmdline（命令行）</h1><p>GUI：grahics user interface，图形用户界面。<br>cmdline：command line，命令行。<br>人机交互：人和机器（计算机）进行交互，常用的有命令行和GUI。<br>Windows下既有GUI，又有命令行。linux中也是既有GUI，又有命令行。<br>但是，在linux中我们常用命令行(生产用)，在Windows中常用GUI（娱乐用）</p><h1 id="linux常用命令："><a href="#linux常用命令：" class="headerlink" title="linux常用命令："></a>linux常用命令：</h1><p>(1) ls（list，列表）<br>作用：使用列表把当前文件夹下所有文件显示出来<br>    ls -a显示所有文件，包括隐藏文件<br>    ls -l以详细信息显示<br>    ls -a -l<br>    ls -l -a<br>    ls -la<br>    ls -al四种方式都是可以的</p><p>man 作用：查询帮助信息</p><p>man 1 查询linux命令 </p><p>man2 查询api   </p><p>man3查询C库函数</p><p>(2)cd（change directory，更改目录）</p><p>作用：用来切换目录<br>涉及到相对路径和绝对路径<br>cd ....代表上一层目录<br>cd.   .代表当前目录</p><p>(3) pwd（print work directory，打印工作目录）<br>作用：打印出当前的绝对路径</p><p>(4) mkdir（make directory，创建文件夹）<br>作用：创建空文件夹<br>    mkdir -p 级联创建文件夹  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir runoob        #在工作目录下，建立一个名为 runoob 的子目录 </span><br><span class="line">mkdir -p runoob2/test   #在工作目录下的 runoob2 目录中，建立一个名为 test 的子目录。</span><br><span class="line">若 runoob2 目录原本不存在，则建立一个。（注：本例若不加 -p 参数，且原本 runoob2 目录不存在，则产生错误。）</span><br></pre></td></tr></table></figure><p>(5) mv（move，移动）<br>作用：在目录间移动文件，重命名文件<br>    mv 源文件pathname 目的文件pathname</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv source_file(文件) dest_file(文件) #将源文件名 source_file 改为目标文件名 dest_file</span><br><span class="line">mv source_file(文件) dest_directory(目录) #将文件 source_file 移动到目标目录 dest_directory 中</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一些liunx问题</title>
      <link href="/2024/08/06/test/%E4%B8%80%E4%BA%9Bliunx%E9%97%AE%E9%A2%98/"/>
      <url>/2024/08/06/test/%E4%B8%80%E4%BA%9Bliunx%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h3 id="1-内核空间与用户空间的区别"><a href="#1-内核空间与用户空间的区别" class="headerlink" title="1. 内核空间与用户空间的区别"></a>1. 内核空间与用户空间的区别</h3><h4 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h4><ul><li><strong>定义</strong>：内核空间是操作系统的核心部分，直接管理硬件资源和系统资源。</li><li><strong>稳定性与安全性</strong>：内核代码需要高度的稳定性和安全性，不能依赖于用户空间的库。</li><li><strong>特权模式</strong>：内核代码运行在特权模式下，可以直接访问硬件资源和系统内存。</li><li><strong>开发原则</strong>：内核开发中尽量避免使用用户空间的库，以减少复杂性和潜在的稳定性问题。</li></ul><h4 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h4><ul><li><strong>定义</strong>：用户空间是应用程序运行的环境，通常依赖于各种标准库（如 glibc）来实现复杂的功能。</li><li><strong>非特权模式</strong>：用户空间代码运行在非特权模式下，需要通过系统调用与内核交互。</li></ul><hr><h3 id="2-Linux-驱动开发中的库使用"><a href="#2-Linux-驱动开发中的库使用" class="headerlink" title="2. Linux 驱动开发中的库使用"></a>2. Linux 驱动开发中的库使用</h3><h4 id="内核提供的-API"><a href="#内核提供的-API" class="headerlink" title="内核提供的 API"></a>内核提供的 API</h4><p>Linux 内核本身提供了一套丰富的 API，用于驱动开发。这些 API 包括：</p><ul><li><strong>内存管理</strong>：<code>kmalloc</code>、<code>kfree</code> 等函数用于动态内存分配和释放。</li><li><strong>文件操作</strong>：<code>file_operations</code> 结构体用于实现设备文件的读写操作。</li><li><strong>中断处理</strong>：<code>request_irq</code>、<code>free_irq</code> 等函数用于注册和释放中断。</li><li><strong>定时器</strong>：<code>timer_setup</code>、<code>del_timer</code> 等函数用于定时器的创建和删除。</li><li><strong>设备树</strong>：在嵌入式 Linux 开发中，设备树（Device Tree）用于描述硬件设备的配置信息。</li></ul><p>这些 API 是内核的一部分，专门用于驱动开发，因此驱动代码通常不需要额外的用户空间库。</p><h4 id="硬件抽象层（HAL）"><a href="#硬件抽象层（HAL）" class="headerlink" title="硬件抽象层（HAL）"></a>硬件抽象层（HAL）</h4><p>在某些情况下，硬件供应商会提供硬件抽象层（HAL）库，用于简化硬件访问。这些库通常是内核模块的一部分，而不是用户空间库。例如，NXP 的 i.MX 系列处理器提供了专门的 HAL 库，用于访问硬件寄存器和外设。</p><hr><h3 id="3-为什么看起来像是“不用库”"><a href="#3-为什么看起来像是“不用库”" class="headerlink" title="3. 为什么看起来像是“不用库”"></a>3. 为什么看起来像是“不用库”</h3><h4 id="直接硬件访问"><a href="#直接硬件访问" class="headerlink" title="直接硬件访问"></a>直接硬件访问</h4><ul><li>在驱动开发中，开发者需要直接与硬件交互，因此会直接操作硬件寄存器，而不是通过复杂的用户空间库。</li><li>例如，访问 GPIO、定时器、中断控制器等硬件资源时，通常会直接使用内核提供的 API 或硬件寄存器操作。</li></ul><h4 id="轻量级开发"><a href="#轻量级开发" class="headerlink" title="轻量级开发"></a>轻量级开发</h4><ul><li>驱动代码通常需要轻量级和高效，以减少对系统资源的占用。使用内核提供的 API 可以实现这一点，而不需要依赖于复杂的用户空间库。</li></ul><h4 id="稳定性和安全性"><a href="#稳定性和安全性" class="headerlink" title="稳定性和安全性"></a>稳定性和安全性</h4><ul><li>内核代码需要保持高度的稳定性和安全性，避免引入用户空间库可能带来的潜在问题（如内存泄漏、线程安全问题等）。</li></ul><hr><h3 id="4-特殊情况"><a href="#4-特殊情况" class="headerlink" title="4. 特殊情况"></a>4. 特殊情况</h3><h4 id="用户空间驱动"><a href="#用户空间驱动" class="headerlink" title="用户空间驱动"></a>用户空间驱动</h4><ul><li>在某些情况下，驱动程序可以运行在用户空间，而不是内核空间。这种情况下，驱动程序可以使用用户空间的库（如 glibc）。</li><li>例如，某些 USB 设备驱动或网络设备驱动可以运行在用户空间。</li></ul><h4 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h4><ul><li>在某些复杂的驱动开发场景中，可能会使用第三方库来实现特定功能。例如，某些图形驱动可能会使用 OpenGL 或 DirectFB 等库。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Linux 驱动开发并不是完全不使用库，而是尽量减少对用户空间库的依赖，转而使用内核提供的 API 和硬件抽象层。这种做法可以提高驱动代码的稳定性和效率，同时减少对系统资源的占用。在某些特殊情况下，驱动开发可能会使用用户空间库或第三方库，但这取决于具体的开发需求和应用场景。</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法碎片</title>
      <link href="/2024/08/06/test/%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E7%A2%8E%E7%89%87/"/>
      <url>/2024/08/06/test/%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E7%A2%8E%E7%89%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="蔡勒公式："><a href="#蔡勒公式：" class="headerlink" title="蔡勒公式："></a>蔡勒公式：</h1><p>计算星期几的常用方法之一是使用“<strong>蔡勒公式</strong>”（Zeller’s Congruence）。这个公式可以计算给定日期对应的星期几，具体步骤如下：</p><h1 id="蔡勒公式的步骤："><a href="#蔡勒公式的步骤：" class="headerlink" title="蔡勒公式的步骤："></a><strong>蔡勒公式的步骤</strong>：</h1><ol><li><p><strong>调整月份与年份</strong>：</p><ul><li>如果月份是1月（1）或2月（2），则将其视为前一年的13月或14月，并将年份减1。</li><li>对于其他月份，直接使用该月份和年份。</li></ul></li><li><p><strong>设定公式变量</strong>：</p><ul><li>设定以下变量：<ul><li>：日期（一个月中的日）</li><li>：月份（3-12代表3月到12月，1月和2月用13和14表示）</li><li>：年份的后两位（year % 100）</li><li>：年份的前两位（year &#x2F; 100）</li></ul></li></ul></li><li><p><strong>应用公式计算</strong>：</p><ul><li><p>使用公式计算： </p></li><li><p><img src="/2024/08/06/test/%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E7%A2%8E%E7%89%87/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20241113212816146.png" alt="image-20241113212816146"></p></li><li><p>其中，</p><p>的值代表星期：</p><ul><li>0 &#x3D; Saturday</li><li>1 &#x3D; Sunday</li><li>2 &#x3D; Monday</li><li>3 &#x3D; Tuesday</li><li>4 &#x3D; Wednesday</li><li>5 &#x3D; Thursday</li><li>6 &#x3D; Friday</li></ul></li></ul></li></ol><h2 id="示例C语言实现："><a href="#示例C语言实现：" class="headerlink" title="示例C语言实现："></a><strong>示例C语言实现</strong>：</h2><p>以下是使用蔡勒公式计算任何给定日期的星期几的示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getDayOfWeek</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (month &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        month += <span class="number">12</span>; <span class="comment">// 将1月和2月视为上一年的13月和14月</span></span><br><span class="line">        year--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> q = day;                       <span class="comment">// 日期</span></span><br><span class="line">    <span class="type">int</span> m = month;                     <span class="comment">// 月份</span></span><br><span class="line">    <span class="type">int</span> K = year % <span class="number">100</span>;                <span class="comment">// 年份的后两位</span></span><br><span class="line">    <span class="type">int</span> J = year / <span class="number">100</span>;                <span class="comment">// 年份的前两位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 蔡勒公式</span></span><br><span class="line">    <span class="type">int</span> h = (q + (<span class="number">13</span> * (m + <span class="number">1</span>)) / <span class="number">5</span> + K + (K / <span class="number">4</span>) + (J / <span class="number">4</span>) - <span class="number">2</span> * J) % <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h; <span class="comment">// 返回星期几</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> year = <span class="number">2024</span>;</span><br><span class="line">    <span class="type">int</span> month = <span class="number">10</span>; <span class="comment">// 例如10月</span></span><br><span class="line">    <span class="type">int</span> day = <span class="number">1</span>;    <span class="comment">// 例如1日</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> weekday = getDayOfWeek(year, month, day);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;日期 %d-%d-%d 是星期：%d\n&quot;</span>, year, month, day, weekday);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CopyInsert</p><p>运行这段代码可以计算给定日期（例如2024年10月1日）对应的星期几。在这个示例中，输出的星期会以数字形式显示，可以根据前面提到的对应关系来判断具体是哪一天。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程技巧 </tag>
            
            <tag> 代码优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux驱动模型详解</title>
      <link href="/2024/06/06/test/Linux%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/06/06/test/Linux%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>让所有很久很久以前都走到幸福结局的时刻</strong></p><h2 id="1-Linux-驱动模型"><a href="#1-Linux-驱动模型" class="headerlink" title="1.Linux 驱动模型"></a>1.Linux 驱动模型</h2><p>本节内容，重在理解。面试时，面试官很大可能会让你挑一个你熟悉的驱动讲讲，如何编写的？能回答出大概的驱动框架就可以。</p><h3 id="1-1-字符设备驱动模型"><a href="#1-1-字符设备驱动模型" class="headerlink" title="1.1 字符设备驱动模型"></a>1.1 字符设备驱动模型</h3><p>驱动初始化中涉及到一个设备描述结构的概念。在任何一种驱动模型中，设备都会用内核中的一种结构来描述，这种结构成为<strong>设备描述结构</strong>。字符设备在内核中使用<code>struct cdev</code>这种结构来描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span> <span class="comment">//设备操作集</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">dev_t</span> dev; <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count; <span class="comment">//设备数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>count表明该类型设备的数目，如有两个串口，则count的值为2。</p></li><li><p>dev是设备号，包含有主设备号和次设备号的信息。主设备号用于区分设备的类型，次设备号用于标记相同类型的设备的不同个体。如串口1和串口2使用同一驱动程序，则其主设备号相同，但次设备号不同。Linux内核中使用<code>dev_t</code>类型来定义设备号，<code>dev_t</code>这种类型其实质为32位的<code>unsigned int</code>，其中高12位为主设备号，低20位为次设备号。</p><ol><li>知道主设备号与次设备号，可通过<code>dev_t dev = MKDEV(主设备号，次设备号)</code> 获得设备号；</li><li>从设备号分解出主设备号：主设备号 &#x3D; <code>MAJOR(dev_t dev)</code></li><li>从设备号分解出次设备号：次设备号 &#x3D; <code>MINOR(dev_t dev)</code></li></ol></li><li><p>主设备号是一个重要的资源，可以通过静态申请和动态分配为设备分配一个主设备号：</p><ol><li>静态申请：开发者自己选择一个数字作为主设备号，然后通过函数<code>register_chrdev_region</code>向内核申请使用。这种方法的缺点是如果申请使用的设备号已经被内核中的其它驱动使用了，则申请失败。</li><li>动态分配：使用<code>alloc_chrdev_region</code>由内核分配一个可用的主设备号。因为内核知道哪些号已经被使用了，所以不会导致分配到已经被使用的号。既然设备号是一种资源，则设备驱动在退出后都应该释放该资源。使用<code>unregister_chrdev_region</code>函数释放这些设备号。</li></ol></li><li><p>ops是操作函数集。<code>file_operations</code>是一个很重要的结构，该结构的成员基本都是函数指针，并且是一些文件操作的函数的指针。</p></li><li><pre><code class="c">struct file_operations &#123;  struct module *owner;  loff_t(*llseek) (struct file *, loff_t, int);  ssize_t(*read) (struct file *, char __user *, size_t, loff_t *);  ssize_t(*aio_read) (struct kiocb *, char __user *, size_t, loff_t);  ssize_t(*write) (struct file *, const char __user *, size_t, loff_t *);  ssize_t(*aio_write) (struct kiocb *, const char __user *, size_t, loff_t);  int (*readdir) (struct file *, void *, filldir_t);  unsigned int (*poll) (struct file *, struct poll_table_struct *);  int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);  int (*mmap) (struct file *, struct vm_area_struct *);  int (*open) (struct inode *, struct file *);  int (*flush) (struct file *);  int (*release) (struct inode *, struct file *);  int (*fsync) (struct file *, struct dentry *, int datasync);  int (*aio_fsync) (struct kiocb *, int datasync);  int (*fasync) (int, struct file *, int);  int (*lock) (struct file *, int, struct file_lock *);  ssize_t(*readv) (struct file *, const struct iovec *, unsigned long, loff_t *);  ssize_t(*writev) (struct file *, const struct iovec *, unsigned long, loff_t *);  ssize_t(*sendfile) (struct file *, loff_t *, size_t, read_actor_t, void __user *);  ssize_t(*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);  unsigned long (*get_unmapped_area) (struct file *, unsigned long,unsigned long, unsigned long,unsigned long);&#125;;    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`struct file_operations`是一个函数指针的集合，定义能在设备上进行的操作。结构中的函数指针指向驱动中的函数，这些函数实现一个针对设备的操作, 对于不支持的操作则设置函数指针为 NULL。例如：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">struct file_operations dev_fops = &#123;</span><br><span class="line">    .llseek = NULL,</span><br><span class="line">    .read = dev_read,</span><br><span class="line">    .write = dev_write,</span><br><span class="line">    .ioctl = dev_ioctl,</span><br><span class="line">    .open = dev_open,</span><br><span class="line">    .release = dev_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>- 该结构体表示应用程序能够对设备文件使用函数`read()`, `write()`等，但不能使用函数`llseek()`。当执行到`read()`函数时，内核根据该结构体转移到驱动程序中的`dev_read`函数去执行。- 驱动初始化有四大步骤：  1.**分配**  - cdev变量的定义可以采用静态和动态两种办法：  - 静态分配：`struct cdev mdev`；  - 动态分配：`struct cdev *pdev = cdev_alloc()`；  2.**初始化**  - `struct cdev`的初始化使用`cdev_init`函数来完成。  - 原型：`cdev_init(struct cdev *cdev, const struct file_operations *fops)`  - 参数：    - `cdev`：待初始化的cdev结构    - `fops`：设备对应的操作函数集  3.注册  - 字符设备的注册使用`cdev_add`函数来完成。  - 原型：`cdev_add(struct cdev *p, dev_t dev, unsigned count)`  - 参数：    - `p`：待添加到内核的字符设备结构    - `dev`：设备号    - `count`：该类设备的设备个数  4.**硬件初始化**  - 根据相应硬件的数据手册完成初始化。</code></pre></li></ul><h3 id="1-2-实现设备操作"><a href="#1-2-实现设备操作" class="headerlink" title="1.2 实现设备操作"></a>1.2 实现设备操作</h3><p>由struct file_operations可以看出，要实现的操作并不少，这里只介绍一些重要的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*open)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *) <span class="comment">//打开设备，响应open系统调用</span></span><br><span class="line"><span class="type">int</span> (*release)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);<span class="comment">//关闭设备，响应close系统调用</span></span><br><span class="line"><span class="type">loff_t</span> (*llseek)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>) <span class="comment">//重定位读写指针，响应lseek系统调用</span></span><br><span class="line"><span class="type">ssize_t</span> (*read)(<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *) <span class="comment">//从设备读取数据，响应read系统调用</span></span><br><span class="line"><span class="type">ssize_t</span> (*write)(<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *) <span class="comment">//向设备写入数据，响应write系统调用</span></span><br></pre></td></tr></table></figure><ul><li><p>以上几个函数涉及到了<code>struct inode</code>和<code>struct file</code>这两种结构体。</p></li><li><p>在Linux系统中，每一个<strong>打开的文件</strong>，在内核中都会关联一个<code>struct file</code>结构体，它由内核在打开文件时创建，在文件关闭后释放。该结构体的重要成员有：</p></li><li><pre><code class="c">loff_t f_pos /*文件读写指针*/struct file_operations *f_op /*该文件所对应的操作*/<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">每一个存在于文件系统里面的文件都会关联一个`inode` 结构，该结构主要用来**记录文件物理上的信息**。因此，它和代表打开文件的file结构是不同的。一个文件**没有被打开时不会关联file结构，但是却会关联一个inode结构**。该结构体重要的成员有：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">dev_t i_rdev /*设备号*/</span><br></pre></td></tr></table></figure>- 一个设备支持的函数操作又称为设备方法。- `open`设备方法是驱动程序用来为以后的操作完成**初始化**准备工作的。在大部分驱动程序中，open完成如下工作：**标明次设备号、启动设备**。- `release`设备方法的作用与open相反，这个设备方法有时也称为close，它完成的工作是**关闭设备**。- `read`设备方法通常完成两件事情：从设备中**读取数据**(属于硬件访问类操作)，将读取到的数据**返回给应用程序**。- ```c  ssize_t (*read)(struct file *filp,char __user *buff,size_t count,loff_t *offp)  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 参数说明：</span><br><span class="line"></span><br><span class="line">  1. `filp`：与字符设备文件关联的file结构指针，由内核创建。</span><br><span class="line">  2. `buff`：从设备读取到的数据，需要**保存到的位置**。由read系统调用提供该参数。</span><br><span class="line">  3. `count`：请求传输的**数据量**，由read系统调用提供该参数。</span><br><span class="line">  4. `offp`：文件的**读写位置**，由内核从file结构中取出后(相当于读取指针)，传递进来。</span><br><span class="line"></span><br><span class="line">- 要注意的是，`buff`参数是来源于用户空间的指针，这类指针都**不能被内核代码直接引用**，必须使用专门的函数：</span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">  int copy_to_user(void __user *to, const void *from, int n)// 内核态-&gt;用户态</span><br><span class="line">  int copy_from_user(void *to, const void __user *from, int n)// 用户态-&gt;内核态</span><br></pre></td></tr></table></figure>    - 其中`copy_to_user()`用于将内核数据传送给用户空间；`copy_from_user()`用于将用户空间的数据传送给内核空间。    - `write`设备方法通常完成两件事情：**从应用程序提供的地址中取出数据，将数据写入设备**(属于硬件访问类操作)    - 函数原型：`ssize_t (*write)(struct file *, const char __user *, size_t, loff_t *)`    - 驱动注销：当我们从内核中卸载驱动程序的时候，需要使用`cdev_del`函数来完成字符设备的注销。    - 一个驱动程序范例：    - ```c      #include &lt;linux/module.h&gt;      #include &lt;linux/types.h&gt;      #include &lt;linux/fs.h&gt;      #include &lt;linux/errno.h&gt;      #include &lt;linux/init.h&gt;      #include &lt;linux/cdev.h&gt;      #include &lt;asm/uaccess.h&gt;      #include &lt;linux/slab.h&gt;             int dev1_registers[5];      int dev2_registers[5];             struct cdev cdev; // 字符驱动设备      dev_t devno;// 设备号             /*文件打开函数*/      int mem_open(struct inode *inode, struct file *filp)      &#123;          /*获取次设备号*/          int num = MINOR(inode-&gt;i_rdev);                 if (num==0)              filp-&gt;private_data = dev1_registers;          else if(num == 1)              filp-&gt;private_data = dev2_registers;          else              return -ENODEV;  //无效的次设备号                 return 0;       &#125;             /*文件释放函数*/      int mem_release(struct inode *inode, struct file *filp)      &#123;        return 0;      &#125;             /*读函数 返回读取了多少个数据*/      static ssize_t mem_read(struct file *filp, char __user *buf, size_t size, loff_t *ppos)      &#123;        unsigned long p =  *ppos;        unsigned int count = size;        int ret = 0;        int *register_addr = filp-&gt;private_data; /*获取设备的寄存器基地址*/               /*判断读位置是否有效*/        if (p &gt;= 5*sizeof(int))          return 0;        if (count &gt; 5*sizeof(int) - p)          count = 5*sizeof(int) - p;               /*读数据到用户空间 从基地址偏移p个(p为开始读的位置 即ppos描述的相对位置)*/        if (copy_to_user(buf, register_addr+p, count))        &#123;          ret = -EFAULT;        &#125;        else        &#123;          *ppos += count;          ret = count;        &#125;               return ret;      &#125;             /*写函数*/      static ssize_t mem_write(struct file *filp, const char __user *buf, size_t size, loff_t *ppos)      &#123;        unsigned long p =  *ppos;        unsigned int count = size;        int ret = 0;        int *register_addr = filp-&gt;private_data; /*获取设备的寄存器地址*/               /*分析和获取有效的写长度*/        if (p &gt;= 5*sizeof(int))          return 0;        if (count &gt; 5*sizeof(int) - p)          count = 5*sizeof(int) - p;               /*从用户空间写入数据*/        if (copy_from_user(register_addr + p, buf, count))          ret = -EFAULT;        else        &#123;          *ppos += count;          ret = count;        &#125;               return ret;      &#125;             /* seek文件定位函数 */      static loff_t mem_llseek(struct file *filp, loff_t offset, int whence)      &#123;           loff_t newpos;                 switch(whence) &#123;            case SEEK_SET:               newpos = offset;              break;                   case SEEK_CUR:               newpos = filp-&gt;f_pos + offset;              break;                   case SEEK_END:               newpos = 5*sizeof(int)-1 + offset;              break;                   default:               return -EINVAL;          &#125;          if ((newpos&lt;0) || (newpos&gt;5*sizeof(int)))              return -EINVAL;                 filp-&gt;f_pos = newpos;          return newpos;             &#125;             /*文件操作结构体*/      static const struct file_operations mem_fops =      &#123;        .llseek = mem_llseek,        .read = mem_read,        .write = mem_write,        .open = mem_open,        .release = mem_release,      &#125;;             /*设备驱动模块加载函数*/      static int memdev_init(void)      &#123;        /*初始化cdev结构*/        cdev_init(&amp;cdev, &amp;mem_fops);               /* 注册字符设备 */        alloc_chrdev_region(&amp;devno, 0, 2, &quot;memdev&quot;);        cdev_add(&amp;cdev, devno, 2);      &#125;             /*模块卸载函数*/      static void memdev_exit(void)      &#123;        cdev_del(&amp;cdev);   /*注销设备*/        unregister_chrdev_region(devno, 2); /*释放设备号*/      &#125;             MODULE_LICENSE(&quot;GPL&quot;);             module_init(memdev_init);      module_exit(memdev_exit);      <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">### 1.3 总线设备驱动模型</span><br><span class="line"></span><br><span class="line">- 自内核2.6版本开始，需要关注的是**总线、设备和驱动**这3个实体，总线将设备和驱动绑定。在Linux内核系统中注册一个设备的时候，会寻找与之对应驱动进行匹配；相反地，系统中注册一个驱动的时候，会去寻找一个对应的设备进行匹配。**匹配的的工作由总线来完成**。</span><br><span class="line"></span><br><span class="line">- **在Linux设备中有的是没有对应的物理总线的，但为了适配Linux的总线模型，内核针对这种没有物理总线的设备开发了一种虚拟总线——platform总线**。将设备和驱动独立开，驱动尽可能写的通用，当来了一个类似的设备后也可以使用这个驱动，让驱动程序可以重用。这体现了Linux驱动的软件架构设计的思想。</span><br><span class="line"></span><br><span class="line">- 按照这个思路，Linux中的设备和驱动都需要挂接在一种总线上，比如i2c总线上的eeprom，eeprom作为设备，**eeprom的驱动都挂接在i2c驱动上**。但是在嵌入式系统中，**soc系统一般都会集成独立的i2c控制器，控制器也是需要驱动的，但是再按照设备-总线-驱动模型进行设计，就会发现无法找到一个合适总线去挂接控制器设备和控制器驱动了（i2c控制器是挂接在CPU内部的总线上，而不是i2c总线）**，所以Linux发明了一种虚拟总线，称为platform总线，相应的设备称为**platform_device（控制器设备），对应的驱动为platform_driver（控制器驱动），用platform总线来承载这些相对特殊的系统**。</span><br><span class="line"></span><br><span class="line">- 注意：**所谓的platform_device并不是与字符设备、块设备和网络设备并列的概念，而是Linux系统提供的一种附加手段**。例如，在 S3C6410处理器中，把内部集成的I2C、RTC、SPI、LCD、看门狗等控制器都归纳为platform_device，而它们本身就是字符设备。我们要记住，platform 驱动只是在**字符设备驱动外套一层platform_driver 的外壳**。引入platform模型符合Linux 设备模型 —— 总线、设备、驱动，设备模型中配套的sysfs节点都可以用，方便我们的开发；**当然你也可以选择不用，不过就失去了一些platform带来的便利**。</span><br><span class="line"></span><br><span class="line">- 设备驱动中引入platform 概念，隔离BSP和驱动。在BSP中定义platform设备和设备使用的资源、设备的具体匹配信息，而在驱动中，只需要通过API去获取资源和数据，做到了板相关代码和驱动代码的分离，使得驱动具有更好的可扩展性和跨平台性。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  - **下面分析下总线设备驱动模型的匹配过程**</span><br><span class="line">    1. 一边的`device`结构体和另一边的`较稳定的 driver 代码`的联系：`device_add()`除将`device`结构放到 bus 的`dev 链表`之外，还会从另一边的`drv`链表中取表元即某个`driver`结构，用总线里的一个`（.match）`函数来作比较，看另一边的`driver`是否支持一边的`device`。若是能够支持，则接着调用软件驱动部分的`.probe`函数。`driver_register()`会将`bus_drv_dev`模型中的较稳定代码`driver`结构体放到虚拟总线的某个链表（drv 链表）中。从另一边的`dev`链表中取出每一个`device`结构用 bus 中的`.match`函数来作比较。</span><br><span class="line">    2. 若支持则调用`.probe`函数。左右两个注册就建立起来的一种机制。在`.probe`函数中做的事件由自已决定，打印一句话，或注册一个字符设备，再或注册一个`input_dev`结构体等等都是由自已决定。强制的把一个驱动程序分为左右两边这种机制而已，可以把这套东西放在任何地方，这里的`driver`只是个结构体不要被这个名字迷惑，`device`也只是个结构体，里面放什么内容都是由自已决定的。</span><br><span class="line"></span><br><span class="line">### 1.4 输入子系统模型</span><br><span class="line"></span><br><span class="line">每个硬件都有一个`input_dev`结构体，每个软件都有一个`input_handler`结构体。`input_dev`和`input_handler`分别通过`input_register_device()`，`input_register_handler()`向核心层注册硬件和软件。</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul><p>int input_register_device(struct input_dev *dev)   &#x2F;&#x2F;*dev:要注册的驱动设备<br>{<br> … …<br>       list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);   &#x2F;&#x2F;(1)放入链表中<br> … …<br>       list_for_each_entry(handler, &amp;input_handler_list, node)  &#x2F;&#x2F;(2)<br>       input_attach_handler(dev, handler);<br> … …<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 从`input_dev`方向分析：`input`设备在增加到`input_dev_list`链表上之后，会查找 `input_handler_list`事件处理链表上的`handler`进行匹配，这里的匹配方式与总线设备驱动模型的`device`和`driver`匹配过程很相似，所有的`input_device`都挂在`input_dev_list`上，所有类型的事件都挂在`input_handler_list`上，进行“匹配相亲”。如果匹配上了，就调用`input_handler`的`connect`函数进行连接。设备就是在此时注册的。</span><br><span class="line">- 从`input_handler`方向分析：将`handler`挂到链表`input_handler_list`下，然后遍历`input_dev_list`链表,查找并匹配输入设备对应的事件处理层，如果匹配上了，就调用`connect`函数进行连接，并创建`input_handle`结构。</span><br><span class="line">- 所以，不管新添加`input_dev`还是`input_handler`，都会进入`input_attach_handler()`判断两者id是否有支持, 若两者支持便进行连接。</span><br><span class="line"></span><br><span class="line">### 1.5 platform总线的匹配规则是什么？在具体应用上要不要先注册驱动再注册设备？有先后顺序没？</span><br><span class="line"></span><br><span class="line">- 匹配规则就是当有一个新的设备挂起时，总线被唤醒，`match`函数被调用，用`device`名字去跟本总线下的所有驱动名字去比较。相反就是用驱动的名字去`device`链表中和所有`device`的名字比较。如果匹配上，才会调用驱动中的`probe`函数，否则不调用。至于先后顺序，鉴于个人理解，**不会有影响**，不管谁先谁后，bus都会完成匹配工作。</span><br><span class="line">- 设备驱动模型的出现主要有三个好处：</span><br><span class="line">  1. 设备与驱动分离，驱动**可移植性增强**；</span><br><span class="line">  2. 设备驱动抽象结构以总线结构表示看起来更加**清晰明了**，谁是属于哪一条bus的；</span><br><span class="line">  3. 设备与驱动分离，很好的奠定了**热插拔**机制。</span><br><span class="line"></span><br><span class="line">## 2.Linux内核</span><br><span class="line"></span><br><span class="line">### 2.1 内核镜像格式有几种？分别有什么区别？</span><br><span class="line"></span><br><span class="line">1. uboot经过编译直接生成的elf格式的可执行程序是u-boot，这个程序类似于windows下的exe格式，在操作系统下是**可以直接执行**的。但是这种格式**不能用来烧录下载**。我们用来烧录下载的是u-boot.bin，这个东西是由u-boot使用arm-linux-objcopy工具进行加工（主要目的是去掉一些无用的东西）得到的。这个u-boot.bin就叫镜像（image），镜像就是用来烧录到iNand中执行的。</span><br><span class="line">2. linux内核经过编译后也会生成一个elf格式的可执行程序，叫**vmlinux或vmlinuz**，这个就是**原始的未经任何处理加工的原版内核elf文件**；嵌入式系统部署时烧录的一般不是这个vmlinuz/vmlinux，而是要用objcopy工具去制作成烧录镜像格式（就是u-boot.bin这种，但是内核没有.bin后缀），经过制作加工成烧录镜像的文件就叫**Image**（制作把78M大的精简成了7.5M，因此这个制作烧录镜像主要目的就是缩减大小，节省磁盘）。</span><br><span class="line">3. 原则上Image就可以直接被烧录到Flash上进行启动执行（类似于u-boot.bin），但是实际上并不是这么简单。实际上linux的作者们觉得Image还是太大了所以对Image进行了压缩，并且在image压缩后的文件的**前端附加了一部分解压缩代码**。构成了一**个压缩格式的镜像就叫zImage**。（因为当年Image大小刚好比一张软盘（软盘有2种，1.2M的和1.44MB两种）大，为了节省1张软盘的钱于是乎设计了这种压缩Image成zImage的技术）。</span><br><span class="line">4. uboot为了启动linux内核，还发明了一种内核格式叫uImage。**uImage是由zImage加工得到的**，uboot中有一个工具，可以将zImage加工生成uImage。注意：uImage不关linux内核的事，linux内核只管生成zImage即可，然后uboot中的mkimage工具再去由zImage加工生成uImage来给uboot启动。这个加工过程其实就是**在zImage前面加上64字节的uImage的头信息即可**。</span><br><span class="line">5. 原则上uboot启动时应该给他uImage格式的内核镜像，但是实际上uboot中也可以支持zImage，是否支持就看x210_sd.h中是否定义了LINUX_ZIMAGE_MAGIC这个宏。所以大家可以看出：有些uboot是支持zImage启动的，有些则不支持。但是**所有的uboot肯定都支持uImage启动**。</span><br><span class="line">6. 如果直接在kernel底下去`make uImage`会提供`mkimage command not found`。解决方案是去`uboot/tools`下`cp mkimage /usr/local/bin/`，复制mkimage工具到系统目录下。再去`make uImage`即可。</span><br><span class="line"></span><br><span class="line">&gt; 通过上面的介绍我们了解了内核镜像的各种格式，如果通过uboot启动内核，Linux必须为**uImage**格式。</span><br><span class="line"></span><br><span class="line">### 2.2 内核中申请内存有哪几个函数？有什么区别？</span><br><span class="line"></span><br><span class="line">1. **kmalloc**</span><br><span class="line"></span><br><span class="line">   ```c</span><br><span class="line">   void *kmalloc(size_t size, gfp_t flags)</span><br></pre></td></tr></table></figure><p>   <code>kmalloc</code>是内核中最常用的一种内存分配方式，它通过调用<code>kmem_cache_alloc</code>函数来实现。<code>kmalloc</code>一次最多能申请的内存大小由<code>include/linux/Kmalloc_size.h</code>的内容来决定，在默认的2.6.18内核版本中，kmalloc一次最多能申请大小为131702B也就是<strong>128KB</strong>字节的连续物理内存。测试结果表明，如果试图用kmalloc函数分配大于128KB的内存，编译不能通过。</p><ol start="2"><li><p><strong>vmalloc</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">vmalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br></pre></td></tr></table></figure><p>前面几种内存分配方式都是物理连续的，能保证较低的平均访问时间。但是在某些场合中，对内存区的请求不是很频繁，较高的内存访问时间也可以接受，这是就可以分配一段<strong>线性连续，物理不连续</strong>的地址，带来的好处是一次可以<strong>分配较大块的内存</strong>。图3-1表示的是<code>vmalloc</code>分配的内存使用的地址范围。<code>vmalloc</code>对一次能分配的内存大小没有明确限制。出于性能考虑，应谨慎使用<code>vmalloc</code>函数。在测试过程中，<strong>最大能一次分配1GB的空间</strong>。</p></li><li><p><strong>dma_alloc_coherent</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">dma_alloc_coherent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> size,<span class="type">ma_addr_t</span> </span></span><br><span class="line"><span class="params">*dma_handle, <span class="type">gfp_t</span> gfp)</span></span><br></pre></td></tr></table></figure><p>DMA(直接内存访问 Direct Memory Access)是一种硬件机制，允许外围设备和主存之间直接传输IO数据，而不需要CPU的参与，使用DMA机制能<strong>大幅提高与设备通信的吞吐量</strong>。DMA操作中，涉及到CPU<strong>高速缓存和对应的内存数据一致性</strong>的问题，必须保证两者的数据一致，在x86_64体系结构中，硬件已经很好的解决了这个问题，<code>dma_alloc_coherentget_free_pages</code>函数实现差别不大，前者实际是调用<code>alloc_pages</code>函数来分配内存，因此一次分配内存的大小限制和后者一样。<code>__get_free_pages</code>分配的内存同样可以用于DMA操作。测试结果证明，<code>dma_alloc_coherent</code>函数一次能分配的最大内存也为<strong>4M</strong>。</p></li><li><p><strong>ioremap</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">ioremap</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> offset, <span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br></pre></td></tr></table></figure><p><code>ioremap</code>是一种更直接的内存“分配”方式，使用时直接<strong>指定物理起始地址和需要分配内存</strong>的大小，然后将该段<strong>物理地址映射到内核地址空间</strong>。<code>ioremap</code>用到的物理地址空间都是事先确定的，和上面的几种内存分配方式并不太一样，并不是分配一段新的物理内存。<code>ioremap</code>多用于<strong>设备驱动</strong>，可以让CPU直接访问外部设备的IO空间。<code>ioremap</code>能映射的内存由原有的物理内存空间决定，所以没有进行测试。</p></li></ol><h3 id="2-3-什么是内核空间，用户空间？"><a href="#2-3-什么是内核空间，用户空间？" class="headerlink" title="2.3 什么是内核空间，用户空间？"></a>2.3 什么是内核空间，用户空间？</h3><ul><li>对 32 位操作系统而言，它的寻址空间（虚拟地址空间，或叫线性地址空间）为 4G（2的32次方）。也就是说一个进程的最大地址空间为 4G。</li><li>操作系统的核心是内核(kernel)，它独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证内核的安全，现在的操作系统一般都强制<strong>用户进程不能直接操作内核</strong>。具体的实现方式基本都是由<strong>操作系统将虚拟地址空间划分为两部分</strong>，一部分为内核空间，另一部分为用户空间。针对 Linux 操作系统而言，<strong>最高的 1G 字节</strong>(从虚拟地址 <code>0xC0000000</code> 到 <code>0xFFFFFFFF</code>)由内核使用，称为<strong>内核空间</strong>。而<strong>较低的 3G 字节</strong>(从虚拟地址 <code>0x00000000</code> 到 <code>0xBFFFFFFF</code>)由各个进程使用，称为用户空间。</li><li>对上面这段内容我们也可以这样理解：<br>每个进程的 4G 地址空间中，最高 1G 都是一样的，即内核空间。只有剩余的 3G 才归进程自己使用。换句话说就是，<strong>最高 1G 的内核空间是被所有进程共享的</strong>！</li><li>下图描述了每个进程 4G 地址空间的分配情况：</li></ul><h3 id="2-4-为什么需要区分内核空间与用户空间？"><a href="#2-4-为什么需要区分内核空间与用户空间？" class="headerlink" title="2.4 为什么需要区分内核空间与用户空间？"></a>2.4 为什么需要区分内核空间与用户空间？</h3><ul><li>在 CPU 的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，比如<strong>清内存、设置时钟</strong>等。如果允许所有的程序都可以使用这些指令，那么系统<strong>崩溃的概率将大大增加</strong>。</li><li>所以，CPU 将指令分为<strong>特权指令</strong>和<strong>非特权指令</strong>，对于那些危险的指令，只允许操作系统及其相关模块使用，普通应用程序只能使用那些不会造成灾难的指令。比如 Intel 的 CPU 将特权等级分为 4 个级别：Ring0~Ring3。</li><li>其实 Linux 系统只使用了 Ring0 和 Ring3 两个运行级别(Windows 系统也是一样的)。当进程运行在 Ring3 级别时被称为运行在用户态，而运行在 Ring0 级别时被称为运行在内核态。</li></ul><h3 id="2-5-什么是内核态和用户态？"><a href="#2-5-什么是内核态和用户态？" class="headerlink" title="2.5 什么是内核态和用户态？"></a>2.5 什么是内核态和用户态？</h3><ul><li><p>当进程<strong>运行在内核空间时</strong>就处于内核态，而进程<strong>运行在用户空间</strong>时则处于用户态。</p></li><li><p>在内核态下，进程运行在内核地址空间中，此时 CPU 可以执行任何指令。运行的代码也不受任何的限制，可以自由地访问任何有效地址，也可以直接进行端口的访问。</p></li><li><p>在用户态下，进程运行在用户地址空间中，被执行的代码要受到 CPU 的诸多检查，它们只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址，且只能对任务状态段(TSS)中 I&#x2F;O 许可位图(I&#x2F;O Permission Bitmap)中规定的可访问端口进行直接访问。</p></li><li><p>对于以前的 DOS 操作系统来说，是没有内核空间、用户空间以及内核态、用户态这些概念的。可以认为所有的代码都是运行在内核态的，因而，用户编写的应用程序代码可以很容易的让操作系统崩溃掉。</p></li><li><p>对于 Linux 来说，通过区分内核空间和用户空间的设计，<strong>隔离了操作系统代码</strong>(操作系统的代码要比应用程序的代码健壮很多)<strong>与应用程序代码</strong>。即便是单个应用程序出现错误，也不会影响到操作系统的稳定性，这样其它的程序还可以正常的运行(Linux 可是个多任务系统啊！)。所以，<strong>区分内核空间和用户空间本质上是要提高操作系统的稳定性及可用性</strong>。</p></li><li><h3 id="2-6-用户空间与内核通信方式有哪些？"><a href="#2-6-用户空间与内核通信方式有哪些？" class="headerlink" title="2.6 用户空间与内核通信方式有哪些？"></a>2.6 用户空间与内核通信方式有哪些？</h3></li></ul><ol><li><p><strong>使用API</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_user(x，ptr) <span class="comment">//在内核中被调用，获取用户空间指定地址的数值并保存到内核变量x中。</span></span><br><span class="line">put_user(x，ptr) <span class="comment">//在内核中被调用，将内核空间的变量x的数值保存到到用户空间指定地址处。</span></span><br><span class="line">copy_from_user()/copy_to_user() <span class="comment">//主要应用于设备驱动读写函数中，通过系统调用触发。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用proc文件系统</strong><br>和<code>sysfs</code>文件系统类似，也可以作为内核空间和用户空间交互的手段。<code>/proc</code> 文件系统是一种虚拟文件系统，通过他可以作为一种linux内核空间和用户空间的桥梁。与普通文件不同，这里的虚拟文件的内容都是动态创建的。使用<code>/proc</code>文件系统的方式很简单。调用<code>create_proc_entry</code>，返回一个<code>proc_dir_entry</code>指针，然后去填充这个指针指向的结构就好了。(相当于proc为用户空间的进程开了个口访问内核空间)</p></li><li><p><strong>使用sysfs文件系统+kobject</strong><br>每个在内核中注册的<code>kobject</code>都对应着<code>sysfs</code>系统中的一个目录。可以通过读取根目录下的<code>sys</code>目录中的文件来获得相应的信息。除了<code>sysfs</code>文件系统和<code>proc</code>文件系统之外，一些其他的虚拟文件系统也能同样达到这个效果。</p></li><li><p><strong>netlink</strong><br><code>netlink socket</code>提供了一组类似于BSD风格的API，用于用户态和内核态的IPC。相比于其他的用户态和内核态IPC机制，netlink有几个好处：1.使用自定义一种协议完成数据交换，不需要添加一个文件等。2.可以支持多点传送。3.支持内核先发起会话。4.异步通信，支持缓存机制。</p></li><li><p><strong>文件</strong><br>应该说这是一种比较笨拙的做法，不过确实可以这样用。当处于内核空间的时候，直接操作文件，将想要传递的信息写入文件，然后用户空间可以读取这个文件便可以得到想要的数据了。下面是一个简单的测试程序，在内核态中，程序会向<code>/home/melody/str_from_kernel</code>文件中写入一条字符串，然后我们在用户态读取这个文件，就可以得到内核态传输过来的数据了。</p></li><li><p><strong>使用mmap系统调用</strong><br>可以将内核空间的地址映射到用户空间。在以前做嵌入式的时候用到几次。一方面可以在<code>driver</code>中修改<code>Struct file_operations</code>结构中的<code>mmap</code>函数指针来重新实现一个文件对应的映射操作。另一方面，也可以直接打开<code>/dev/mem</code>文件，把物理内存中的某一页映射到进程空间中的地址上。其实，除了重写<code>Struct file_operations</code>中<code>mmap</code>函数，我们还可以重写其他的方法如<code>ioctl</code>等，来达到驱动内核空间和用户空间通信的方式。</p></li><li><p><strong>信号</strong><br>从内核空间向进程发送信号。这个倒是经常遇到，用户程序出现重大错误，内核发送信号杀死相应进程。</p></li></ol><h3 id="2-7-内核链表为什么具有通用性？"><a href="#2-7-内核链表为什么具有通用性？" class="headerlink" title="2.7 内核链表为什么具有通用性？"></a>2.7 内核链表为什么具有通用性？</h3><p>内核中由于要管理大量的设备，但是各种设备各不相同，必须将他们统一起来管理，于是内核设计者就想到了使用通用链表来处理，通用链表看似神秘，实际上就是<strong>双向循环链表</strong>，这个链表的每个节点都是只有指针域，没有任何数据域。</p><ul><li>使用通用链表的好处是：<ol><li>通用链表中每个节点中<strong>没有数据域</strong>，也就是说无论数据结构有多复杂在链表中只有前后级指针。</li><li>如果一个数据结构（即是描述设备的设备结构体）想要用通用链表管理，只需要在结构体中包含<strong>节点的字段</strong>即可。</li><li>双向链表可以从任意一个节点的前后遍历整个链表，<strong>遍历非常方便</strong>。</li><li>使用循环链表使得可以不断地循环遍历管理节点，像进程的调度：操作系统会把<strong>就绪的进程</strong>放在一个管理进程的就绪队列的通用链表中管理起来，循环不断地，为他们<strong>分配时间片</strong>，获得cpu进行周而复始的进程调度。</li></ol></li></ul><h3 id="2-8-应用程序中open-在linux中执行过程中是如何从用户空间到内核空间？"><a href="#2-8-应用程序中open-在linux中执行过程中是如何从用户空间到内核空间？" class="headerlink" title="2.8 应用程序中open()在linux中执行过程中是如何从用户空间到内核空间？"></a>2.8 应用程序中open()在linux中执行过程中是如何从用户空间到内核空间？</h3><ol><li>应用层调用<code>open</code>函数，在VFS层中找到<code>struct inode</code>结构体，判断是字符设备还是块设备，根据设备号，可以找到对应的驱动程序。</li><li>在驱动层中，每个字符设备都有一个<code>struct cdev</code>结构体，这个结构体通过<code>struct inode</code>结构体中的<code>i_cdev</code>把连接起VFS层和驱动层，<code>struct cdev</code>结构体描述了字符设备所有信息，其中最重要的一项就是字符设备的操作函数接口，即<code>const struct file_operations *ops</code></li><li><code>struct cdev</code>结构体中的<code>struct file</code>结构体记录了操作字符设备的一些函数，比如<code>open read write</code>函数等。<code>struct file</code>结构体其实是在VFS层的，通过<code>struct file</code>结构体指针指向驱动层的<code>struct file</code>结构体将驱动层函数和VFS层链接起来</li><li>任务完成，VFS层会给应用返回一个<strong>文件描述符（fd）</strong>。这个fd是和<code>struct file</code>结构体对应的。</li></ol><h2 id="3-设备驱动"><a href="#3-设备驱动" class="headerlink" title="3.设备驱动"></a>3.设备驱动</h2><h3 id="3-1-请简述主设备号和次设备号的用途"><a href="#3-1-请简述主设备号和次设备号的用途" class="headerlink" title="3.1 请简述主设备号和次设备号的用途"></a>3.1 请简述主设备号和次设备号的用途</h3><ul><li><strong>主设备号：主设备号标识设备对应的特定的驱动程序</strong>。虽然现代的linux内核允许多个驱动程序共享主设备号，但我们看待的大多数设备仍然按照“一个主设备对应一个驱动程序”的原则组织</li><li><strong>次设备号：次设备号由内核使用，用于确定由主设备号对应驱动程序中的各个设备</strong>。依赖于驱动程序的编写方式，我们可以通过次设备号获得一个指向内核设备的直接指针，也可将此设备号当作设备本地数组的索引。</li></ul><h3 id="3-2-字符型驱动设备怎么创建设备文件？"><a href="#3-2-字符型驱动设备怎么创建设备文件？" class="headerlink" title="3.2 字符型驱动设备怎么创建设备文件？"></a>3.2 字符型驱动设备怎么创建设备文件？</h3><ol><li>手动创建<br><code>mknod /dev/led c 250 0</code> ，其中<code>dev/led</code>为设备节点 ,<code>c</code> 代表字符设备, <code>250</code>代表主设备号, <code>0</code>代表次设备号。</li><li>自动创建<br><code>UDEV/MDEV</code>是运行在用户态的程序，可以动态管理设备文件，包括创建和删除设备文件，运行在用户态意味着系统要运行之后，在 <code>/etc/init.d/rcS</code> 脚本文件中会执行 <code>mdev -s</code> 自动创建设备节点。</li></ol><h3 id="3-3-设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义"><a href="#3-3-设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义" class="headerlink" title="3.3 设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义"></a>3.3 设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义</h3><ul><li><p>注册一个字符设备驱动有两种方法：</p><ol><li><code>void cdev_init(struct cdev *cdev, struct file_operations *fops)</code> 该注册函数可以将<code>cdev</code>结构嵌入到自己的设备特定的结构中。<code>cdev</code>是一个指向结构体<code>cdev</code>的指针，而<code>fops</code>是指向一个类似于 <code>file_operations</code>结构（可以是<code>file_operations</code>结构，但不限于该结构）的指针。</li><li><code>int register_chrdev(unsigned int major, const char *name, struct file operations *fops)</code>；该注册函数是早期的注册函数，<code>major</code>是设备的主设备号，<code>name</code>是驱动程序的名称，而<code>fops</code>是默认的<code>file_operations</code>结构（这是只限于<code>file_operations</code>结构）。对于<code>register_chrdev</code>的调用将为给定的主设备号注册0－255作为次设备号，并为每个设备建立一个对应的默认<code>cdev</code>结构。</li></ol><h3 id="3-4-dev-下面的设备文件是怎么创建出来的？"><a href="#3-4-dev-下面的设备文件是怎么创建出来的？" class="headerlink" title="3.4 &#x2F;dev&#x2F;下面的设备文件是怎么创建出来的？"></a>3.4 &#x2F;dev&#x2F;下面的设备文件是怎么创建出来的？</h3></li><li><p>普遍说法有三种方式，<strong>devfs机制</strong>，<strong>udev机制</strong>，再有一个就是<strong>手动创建</strong>设备节点。谈谈个人见解：</p></li></ul><ol><li><code>devfs</code>机制从来没用过，应该是2.6以前的内核使用的；</li><li><code>udev</code>：其实就是现在常用的<code>device_create()</code>、<code>class_create()</code>这一套接口，所谓<code>udev</code>是上层用户空间程序，是基于驱动中创建使用了这两个接口而起作用的，但是<code>udev</code>在日常开发中几乎接触不到，我们只需在驱动中调用创建节点的这两个API就ok了，剩下的工作就交给<code>udev</code>去做了，有想深究它具体实现原理的那就自己去研究吧，我觉得会用就行了；</li><li><code>mknod</code>：新手最常用的一种创建设备节点方法，但并非入门后就再没有用途，在某些情境下，或许有人不想使用<code>udev</code>机制，于是把节点创建工作写在脚本里，这样也是无可厚非的。</li></ol><h3 id="3-5-Linux设备中字符设备和块设备有什么主要区别？分别举例。"><a href="#3-5-Linux设备中字符设备和块设备有什么主要区别？分别举例。" class="headerlink" title="3.5 Linux设备中字符设备和块设备有什么主要区别？分别举例。"></a>3.5 Linux设备中字符设备和块设备有什么主要区别？分别举例。</h3><ul><li>Linux中I&#x2F;O设备分为两类：块设备和字符设备。两种设备本身没有严格限制，但是，基于不同的功能进行了分类。</li><li><strong>字符设备</strong>：提供<strong>连续</strong>的数据流，应用程序可以顺序读取，通常不支持随机存取。相反，此类设备支持<strong>按字节&#x2F;字符</strong>来读写数据。字符终端、串口、鼠标、键盘、摄像头、声卡和显卡等就是典型的字符设备。</li><li><strong>块设备</strong>：应用程序可以<strong>随机访问</strong>设备数据，程序可自行确定读取数据的位置。硬盘是典型的块设备，应用程序可以寻址磁盘上的<strong>任何位置</strong>，并由此读取数据。此外，数据的读写只能以块(通常是512B)的倍数进行。与字符设备不同，块设备并不支持基于字符的寻址。如：u盘，SD卡，磁盘等。</li></ul><h3 id="3-6-驱动中操作物理绝对地址为什么要先ioremap？"><a href="#3-6-驱动中操作物理绝对地址为什么要先ioremap？" class="headerlink" title="3.6 驱动中操作物理绝对地址为什么要先ioremap？"></a>3.6 驱动中操作物理绝对地址为什么要先ioremap？</h3><ul><li><code>ioremp</code>是内核中用来将外设寄存器物理地址映射到主存上去的接口，即将io地址空间映射到虚拟地址空间上去，便于操作。为什么非要映射呢，因为<strong>保护模式下的cpu只认虚拟地址，不认物理地址</strong>，给它物理地址它并不帮你做事，所以你要操作外设上的寄存器必须先映射到虚拟内存空间，拿着虚拟地址去跟cpu对接，从而操作寄存器。</li></ul><h3 id="3-7-insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？"><a href="#3-7-insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？" class="headerlink" title="3.7 insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？"></a>3.7 insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？</h3><ul><li>分别会执行<code>module_init()</code>和<code>module_exit()</code>指定的<code>init</code>函数和<code>exit</code>函数。要注意的就是，尽量使在<code>init</code>函数中出现的资源申请及使用，都要有对应的释放操作在<code>exit</code>中，即<code>init</code>申请，<code>eixt</code>释放。</li></ul><h3 id="3-8-NAND驱动的probe流程"><a href="#3-8-NAND驱动的probe流程" class="headerlink" title="3.8 NAND驱动的probe流程"></a>3.8 NAND驱动的probe流程</h3><ul><li><code>probe</code> 函数就会与NAND芯片进行，主要做的事情主要包括这几个方面：读取NAND芯片的ID ，然后查表得到这片NAND芯片的如厂商，page size，erase size以及chip size等信息，接着根据<code>struct nand_chip</code> 中<code>options</code>的值的不同，或者在NAND 芯片中的特定位置查找<code>bad block table</code>，或者scan整个NAND 芯片，并在内存中建立<code>bad block table</code>。说起来复杂，但其实所有的这些动作，都可以在MTD提供的一个叫做<code>nand_scan</code>的函数中完成。</li></ul><h3 id="3-9-Linux驱动开发中，常用的调试方法有哪些？"><a href="#3-9-Linux驱动开发中，常用的调试方法有哪些？" class="headerlink" title="3.9 Linux驱动开发中，常用的调试方法有哪些？"></a>3.9 Linux驱动开发中，常用的调试方法有哪些？</h3><ul><li><p>利用<code>printk</code>，查看OOP消息，利用<code>strace</code>，利用内核内置的<code>hacking</code>选项，利用<code>ioctl</code>方法，利用<code>/proc</code> 文件系统，使用<code>kgdb</code>。</p></li><li><p><code>strace</code> 是一个可用于诊断、调试和教学的 Linux 用户空间跟踪器，监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。</p></li><li><p><code>ioctl</code> 是设备驱动程序中设备控制接口函数，一个字符设备驱动通常会实现设备打开、关闭、读、写等功能，在一些需要细分的情境下，如果需要扩展新的功能，通常以增设<code>ioctl()</code>命令的方式实现。</p><blockquote><p>建议大家，亲手动手调试下。面试中，很大可能会问你，在写驱动过程中遇到了什么问题的，如何解决的？如果你能讲出以上几种调试方法中的一两种，一定会让面试官刮目相看！</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
            <tag> 内核编程 </tag>
            
            <tag> Linux系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2024/06/06/test/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/06/06/test/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="写嵌入式用的到数据结构吗？"><a href="#写嵌入式用的到数据结构吗？" class="headerlink" title="写嵌入式用的到数据结构吗？"></a>写嵌入式用的到数据结构吗？</h1><p>看下linux内核就知道了，一堆数据结构，不学习数据结构，linux内核就看不懂了</p><p>使用数据结构是为了使代码结构更清晰，更容易把握代码结构、逻辑。</p><p>几个应用场景</p><ol><li><p>“数组”。你肯定用过吧，属于数据结构“线性表”的一种形式。</p><p><img src="/2024/06/06/test/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241112202136552.png" alt="image-20241112202136552" style="zoom:50%;"><img src="/2024/06/06/test/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241112202215843.png" alt="image-20241112202215843" style="zoom:50%;"></p></li><li><p>“结构体”。学习过lwip可以知道从以太网上接收一堆数据后，把数据头的地址幅值给以太网包的数据结构定义的指针，可以直接使用此指针-&gt;成员变量的方式，使用接收到的数据。比使用一堆变量来利用接收到的数据方便太多了。</p></li><li><p>“队列”。热敏电阻测温，单片机用ADC测量电阻分压电压，然后对测量值用平滑均值滤波算法滤波，此时会用到“队列”，或用“环形队列”；</p></li><li><p>“树”。项目中经常会使用液晶屏作为显示，其中文本菜单有时用的比较多的一种方式，其中文本菜单常用“树”结构来实现。</p></li><li><p>“栈”。就不用说了，你已经用过了，不过不是你主动用的，它隐藏在你每次函数调用、中断调用中，可能你没有意识到。</p></li></ol><p>简单几个例子，说明了数据结构非常常见，这个是必须要学的，不过有些不常用，比如图。</p><h3 id="1-【简答题】请写出至少两种野指针的成因"><a href="#1-【简答题】请写出至少两种野指针的成因" class="headerlink" title="1.   【简答题】请写出至少两种野指针的成因"></a>1.   【简答题】请写出至少两种野指针的成因</h3><p>【答案】</p><p>（1）指针使用前未初始化</p><p>（2）指针越界访问</p><p>（3）指针指针已经释放的空间</p><h3 id="2-【简答题】非静态局部变量、全局变量、malloc-动态分配的内存分别存储在内存的什么区域。"><a href="#2-【简答题】非静态局部变量、全局变量、malloc-动态分配的内存分别存储在内存的什么区域。" class="headerlink" title="2.   【简答题】非静态局部变量、全局变量、malloc()动态分配的内存分别存储在内存的什么区域。"></a>2.   【简答题】非静态局部变量、全局变量、malloc()动态分配的内存分别存储在内存的什么区域。</h3><p>【答案】</p><p>（1）非静态局部变量存储在内存的栈区域。</p><p>（1）全局变量存储在内存的全局静态区。</p><p>（2）malloc()动态分配的内存存储在内存的堆区域。</p><h1 id="一、数据结构与算法的层次要求："><a href="#一、数据结构与算法的层次要求：" class="headerlink" title="一、数据结构与算法的层次要求："></a>一、数据结构与算法的层次要求：</h1><p>层次1：熟悉各种不同的数据结构：顺序表（一维数组）、链表、栈、队列；森林、树、二叉树；图等<br>      了解不同的数据结构的特点、如何存储、优缺点等</p><p>层次2：如何编写相关的代码，实现对应的数据结构。（需要考虑对应的增、删、改、查、长度、遍历等）</p><p>层次3：算法层面的训练。 —&gt; leetcode （力扣app）、牛客网等。 300+道打底</p><img src="https://s1.vika.cn/space/2024/11/12/bb5ee404f183423782032597b88580fc" alt="image-20241112200556715"><h1 id="二、针对于层次1："><a href="#二、针对于层次1：" class="headerlink" title="二、针对于层次1："></a>二、针对于层次1：</h1><ol><li><p>什么是数据结构？   datastructure   (D-&gt;S)</p><blockquote><p>数据 +  结构<br>数据：多个相同类型的数据或变量<br>结构：即关系<br>目的：为了更高效的访问数据</p></blockquote></li><li><p>数据结构中有哪些内容？即问研究方向？<br>研究方向1：数据之间的逻辑关系</p><blockquote><p>线性关系:（一对一的关系）。比如：顺序表、链表、栈、队列、数组、字符串、广义表等<br>非线性关系：集合关系、树形关系（一对多的关系）、图形关系（多对多的关系）</p></blockquote></li></ol><p>研究方向2：数据的存储结构（或物理结构）<br>    &gt; 基本的两种：顺序存储结构、链式存储结构<br>    &gt; 拓展的两种：索引存储结构、哈希存储结构(散列存储结构)<br>研究方向3：数据之间的运算：增、删、改、查(CRUD)</p><h1 id="三、具体的不同的数据结构的实现（对应着层次2）"><a href="#三、具体的不同的数据结构的实现（对应着层次2）" class="headerlink" title="三、具体的不同的数据结构的实现（对应着层次2）"></a>三、具体的不同的数据结构的实现（对应着层次2）</h1><ol><li><p>数组的实现和相关算法的封装。</p></li><li><p>链表的实现和相关算法的封装。</p><p>   ​                 优点                                      缺点</p><blockquote><p>数组 通过索引查找、修改效率高：O(1)  插入、删除的效率差：O(n)</p><p>​同样大小的内存，数组可以存储更多的数据  当数据存满时，需要考虑扩容</p></blockquote><blockquote><p>链表   插入、删除效率高：O(1) 通过索引查找、修改效率低：O(n)  </p><p>​ 不需要考虑扩容问题   同样大小的内存，链表存储的数据较数组少</p></blockquote></li></ol><h2 id="如何理解数据结构"><a href="#如何理解数据结构" class="headerlink" title="如何理解数据结构"></a>如何理解数据结构</h2><h4 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h4><p>1.数据结构定义：研究多个变量之间的结构，即数据与数据之间的关系。</p><p> 2.研究目的：高效地进行数据的操作，如增删改查。</p><h4 id="数据结构的主要内容"><a href="#数据结构的主要内容" class="headerlink" title="数据结构的主要内容"></a>数据结构的主要内容</h4><p>1.逻辑结构：研究数据之间的逻辑关系，分为集合关系、线性关系、树形关系和网状关系。 </p><p>2.存储结构：研究数据在实际编程语言中的存储方式，分为顺序存储和链式存储。 </p><p>3.运算：基于存储结构，研究数据的增删改查等操作。</p><h4 id="线性结构和非线性结构"><a href="#线性结构和非线性结构" class="headerlink" title="线性结构和非线性结构"></a>线性结构和非线性结构</h4><p>1.线性结构：如顺序表、链表、栈、队列、数组、广义表等。</p><p> 2.非线性结构：如集合、树、图等。</p><h4 id="存储结构的两种基本形式"><a href="#存储结构的两种基本形式" class="headerlink" title="存储结构的两种基本形式"></a>存储结构的两种基本形式</h4><p>1.顺序存储：将数据元素依次排列，通过数组等方式实现。 </p><p>2.链式存储：通过链表方式，每个元素包含指向下一个元素的指针。</p><p> 3.索引存储结构和哈希存储结构：基于顺序存储和链式存储的组合。</p><img src="https://s1.vika.cn/space/2024/11/12/ad74377b36704d109dd9765a42b58faa" alt="image-20241112202757865" style="zoom:50%;"><img src="/2024/06/06/test/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241112202851334.png" alt="image-20241112202851334" style="zoom:50%;"><h1 id="线性结构之数组"><a href="#线性结构之数组" class="headerlink" title="线性结构之数组"></a>线性结构之数组</h1><p><strong>优</strong> <strong>点</strong></p><p>Ø 查找容易（通过下标），时间复杂度为O(1)。不需要额外申请或删除空间。</p><p>Ø 使用下标位置索引(index)十分高效的访问任意元素，修改快</p><p><img src="https://s1.vika.cn/space/2024/11/12/48ec67a0d691481bab93fce23ca5fb1f" alt="image-20241105203354020"></p><p><strong>缺</strong> <strong>点</strong></p><p>Ø 插入、删除元素难，效率低。（需要移动大量元素以使元素空间连续）。</p><p>Ø 插入操作平均需要移动n&#x2F;2个元素。</p><p>Ø 删除操作平均需要移动(n-1)&#x2F;2个元素。</p><p>​                             <img src="https://s1.vika.cn/space/2024/11/12/4dcfedcbb1a2444397856fa27a77c364" alt="image-20241105203403567">     </p><p>Ø 扩展相对繁琐。一方面需要确保能提供更大区域的连续内存空间，另一方面需要将原有数据复制到新的顺序表中。</p><p>1.1.1 功能定义</p><p>前文提到过数组这一数据结构的一个局限性是长度固定，本节我们来实现一个增强版的数组——可变长的动态数组，需要实现以下函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//初始化动态数组</span><br><span class="line">void initDynamicArray(DynamicArray *array, size_t initialCapacity)</span><br><span class="line">//释放动态数组内存</span><br><span class="line">void destroyDynamicArray(DynamicArray *array)</span><br><span class="line">//调整动态数组内存大小</span><br><span class="line">void resizeDynamicArray(DynamicArray *array, size_t newCapacity)</span><br><span class="line">//获取动态数组长度（元素个数）</span><br><span class="line">size_t getLength(const DynamicArray *array)</span><br><span class="line">//在指定位置插入新元素</span><br><span class="line">void insertAt(DynamicArray *array, size_t index, int element)</span><br><span class="line">//在末尾插入新元素</span><br><span class="line">void insertEnd(DynamicArray *array, int element)</span><br><span class="line">//删除指定位置的元素并返回被删除的元素</span><br><span class="line">int deleteAt(DynamicArray *array, size_t index)</span><br><span class="line">//删除末尾的元素并返回被删除的元素</span><br><span class="line">int deleteEnd(DynamicArray *array)</span><br><span class="line">//遍历所有的元素</span><br><span class="line">void print(DynamicArray *array)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-1-1-实现原理"><a href="#1-1-1-实现原理" class="headerlink" title="1.1.1 实现原理"></a>1.1.1 实现原理</h2><p>可变长的动态数组是一种数据结构，它允许在运行时根据需要动态地调整数组的大小，而不需要提前指定固定的大小。这种动态数组通常被称为动态数组、动态分配数组、动态增长数组或动态内存数组。int arr[10];  </p><p>C语言中是通过使用指针和内存分配函数来实现动态数组，常见的内存分配函数是<code>malloc</code>、<code>realloc</code>和<code>free</code>。下面是一些相关的概念和操作：</p><p>（1）<strong>分配内存（malloc）：</strong> 在C语言中，可以使用<code>malloc</code>函数来分配一块指定大小的内存。例如，<code>int *arr = (int *)malloc(n * sizeof(int));</code> 将分配能够存储<code>n</code>个整数的内存空间。</p><p>（2）<strong>重新分配内存（realloc）：</strong> 如果需要改变动态数组的大小，可以使用<code>realloc</code>函数来重新分配内存。这允许你在保留原有数据的情况下扩展或缩小数组的大小。</p><p>（3）<strong>释放内存（free</strong>）： 当不再需要动态数组时，应使用<code>free</code>函数释放之前分配的内存，以避免内存泄露。à 内存溢出</p><p>代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">// 动态数组结构体</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int *data;       // 指向动态数组的指针</span><br><span class="line">    size_t size;     // 当前数组中的元素个数</span><br><span class="line">    size_t capacity; // 当前数组的容量（可以容纳的最大元素个数）</span><br><span class="line">&#125; DynamicArray;</span><br><span class="line"></span><br><span class="line">// 初始化动态数组</span><br><span class="line">void initDynamicArray(DynamicArray *array, size_t initialCapacity)</span><br><span class="line">&#123;     //分配内存（malloc）</span><br><span class="line">    array-&gt;data = (int *)malloc(initialCapacity * sizeof(int)); // 分配初始内存</span><br><span class="line">    array-&gt;size = 0;       // 初始化元素个数为0</span><br><span class="line">    array-&gt;capacity = initialCapacity;     // 设置初始容量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放动态数组内存</span><br><span class="line">void destroyDynamicArray(DynamicArray *array)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    //释放内存（free）</span><br><span class="line">    free(array-&gt;data);   // 释放动态数组内存</span><br><span class="line">    array-&gt;size = 0;     // 重置元素个数为0</span><br><span class="line">    array-&gt;capacity = 0; // 重置容量为0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调整动态数组内存大小</span><br><span class="line">void resizeDynamicArray(DynamicArray *array, size_t newCapacity)</span><br><span class="line">&#123; //重新分配内存（realloc）</span><br><span class="line">    array-&gt;data = (int *)realloc(array-&gt;data, newCapacity * sizeof(int)); // 调整数组内存大小  </span><br><span class="line">    array-&gt;capacity = newCapacity;       // 更新容量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取动态数组长度（元素个数）</span><br><span class="line">size_t getLength(const DynamicArray *array)</span><br><span class="line">&#123;</span><br><span class="line">    return array-&gt;size; // 返回数组中的元素个数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在指定位置插入新元素</span><br><span class="line">void insertAt(DynamicArray *array, size_t index, int element)</span><br><span class="line">&#123;</span><br><span class="line">    if (index &gt; array-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        return; // 忽略无效的插入位置</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (array-&gt;size &gt;= array-&gt;capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t newCapacity = array-&gt;capacity * 2; // 如果容量不足，扩大容量</span><br><span class="line">        resizeDynamicArray(array, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (size_t i = array-&gt;size; i &gt; index; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        array-&gt;data[i] = array-&gt;data[i - 1]; // 后移元素以腾出插入位置</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array-&gt;data[index] = element; // 在指定位置插入新元素</span><br><span class="line">    array-&gt;size++;                // 更新元素个数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在末尾插入新元素</span><br><span class="line">void insertEnd(DynamicArray *array, int element)</span><br><span class="line">&#123;</span><br><span class="line">    insertAt(array, array-&gt;size, element); // 在末尾插入新元素</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除指定位置的元素并返回被删除的元素</span><br><span class="line">int deleteAt(DynamicArray *array, size_t index)</span><br><span class="line">&#123;</span><br><span class="line">    if (index &gt;= array-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        return -1; // 忽略无效的删除位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    int deletedElement = array-&gt;data[index]; // 获取被删除的元素</span><br><span class="line"></span><br><span class="line">    for (size_t i = index; i &lt; array-&gt;size - 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        array-&gt;data[i] = array-&gt;data[i + 1]; // 前移元素以填补删除位置</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array-&gt;size--; // 更新元素个数</span><br><span class="line"></span><br><span class="line">    return deletedElement; // 返回被删除的元素</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除末尾的元素并返回被删除的元素</span><br><span class="line">int deleteEnd(DynamicArray *array)</span><br><span class="line">&#123;</span><br><span class="line">    return deleteAt(array, array-&gt;size - 1); // 删除末尾的元素</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历所有的元素</span><br><span class="line">void print(DynamicArray *array)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; array-&gt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;, array-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    DynamicArray myArray; // 声明动态数组</span><br><span class="line"></span><br><span class="line">    // 初始化动态数组</span><br><span class="line">    initDynamicArray(&amp;myArray, 2);</span><br><span class="line">    printf(&quot;初始化动态数组,初始容量为2\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 向动态数组尾部插入元素</span><br><span class="line">    insertEnd(&amp;myArray, 1);</span><br><span class="line">    insertEnd(&amp;myArray, 2);</span><br><span class="line">    printf(&quot;向动态数组尾部插入了2个元素\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 打印动态数组当前长度</span><br><span class="line"> printf(&quot;动态数组当前长度:%zu\n&quot;, getLength(&amp;myArray));</span><br><span class="line"></span><br><span class="line">    // 在索引1的位置插入元素3</span><br><span class="line">    insertAt(&amp;myArray, 1, 3);</span><br><span class="line">    printf(&quot;在索引1的位置插入元素3\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 再次打印动态数组当前长度</span><br><span class="line">    printf(&quot;动态数组当前长度:%zu\n&quot;, getLength(&amp;myArray));</span><br><span class="line"></span><br><span class="line">    // 删除索引1的元素</span><br><span class="line">    printf(&quot;删除索引1的元素,该元素是%d\n&quot;, deleteAt(&amp;myArray, 1));</span><br><span class="line"></span><br><span class="line">    // 删除动态数组末尾元素</span><br><span class="line">    printf(&quot;删除动态数组末尾元素,该元素是%d\n&quot;, deleteEnd(&amp;myArray));</span><br><span class="line"></span><br><span class="line">    // 释放动态数组内存</span><br><span class="line">    destroyDynamicArray(&amp;myArray);</span><br><span class="line">    printf(&quot;动态数组内存释放完成\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="1-1-线性结构之链表"><a href="#1-1-线性结构之链表" class="headerlink" title="1.1 线性结构之链表"></a>1.1 线性结构之链表</h1><p>1.1.1 链表是什么</p><p>链表的主要特点包括：</p><ol><li><strong>动态大小</strong>：链表可以根据需要动态调整大小，不需要预先分配固定的内存空间。</li><li><strong>插入和删除效率高</strong>：在已知位置插入或删除元素时，链表不需要移动其他元素，只需调整指针即可。</li><li><strong>顺序访问</strong>：链表不支持随机访问，要访问链表中的某个元素，必须从头节点开始逐个遍历。</li></ol><p>链表有几种常见的类型：</p><ul><li><strong>单向链表</strong>：每个节点只指向下一个节点。</li><li><strong>双向链表</strong>：每个节点有两个指针，分别指向前一个节点和后一个节点。</li><li><strong>循环链表</strong>：链表的最后一个节点指向第一个节点，形成一个环。</li></ul><p><img src="https://s1.vika.cn/space/2024/11/12/65ec27aa9d2548efbe0342f9a53b9878" alt="image-20241108184735610"></p><p><strong>相关概念</strong></p><p>n个结点离散分配，彼此通过指针相连，每个结点只有一个前驱结点，每个结点只有一个后续结点，头结点没有前驱结点，尾结点没有后续结点。确定一个链表我们只需要头指针，通过头指针就可以把整个链表都能推出来。</p><p>1）优点</p><p>（1）插入和删除操作效率高。</p><p>（2）动态扩展性能更好，链表不需要像数组那样预先指定固定的大小，而是可以随时动态的增长或缩小。链表是真正的动态数据结构，不需要处理固定容量的问题。</p><p>2）缺点</p><p>（1）查找慢。由于链表中的结点不是连续存储的，无法像数组一样根据索引直接计算出每个结点的地址。必须从头结点开始遍历链表，直到找到目标结点，这导致了链表的随机访问效率较低。</p><p>（2）额外的存储空间。链表的每个结点都需要存储指向下一个结点的指针，这会占用额外的存储空间。所以，相比于数组，链表需要更多的内存空间来存储相同数量的数据元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">初始化链表</span><br><span class="line">void initLinkedList(LinkedList *list)</span><br><span class="line">返回链表的长度</span><br><span class="line">size_t getLength(const LinkedList *list)</span><br><span class="line">在指定位置插入元素</span><br><span class="line">void insertAt(LinkedList *list, size_t index, int element)</span><br><span class="line">在末尾插入元素</span><br><span class="line">void insertEnd(LinkedList *list, int element)</span><br><span class="line">删除指定位置的元素并返回被删除的元素</span><br><span class="line">int deleteAt(LinkedList *list, size_t index)</span><br><span class="line">删除末尾元素</span><br><span class="line">int deleteEnd(LinkedList *list)</span><br><span class="line">获取指定位置的元素</span><br><span class="line">int getElementAt(const LinkedList *list, size_t index)</span><br><span class="line">修改指定位置的元素</span><br><span class="line">void modifyAt(LinkedList *list, size_t index, int newValue)</span><br><span class="line">释放链表内存</span><br><span class="line">void destroyLinkedList(LinkedList *list)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">自定义链表结构</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 定义存储数据的结构体</span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int data;          // 存储的数据</span><br><span class="line">    struct Node *next; // 指向下个元素的指针</span><br><span class="line"></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">// 定义虚拟头结点的结构体</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int size;   // 记录单链表中存储的数据的个数</span><br><span class="line">    Node *next; // 指向保存数据的首元素</span><br><span class="line">&#125; LinkedList;</span><br><span class="line"></span><br><span class="line">// 明确：在包含虚拟头结点的情况下，首个保存数据的结点的索引为0！</span><br><span class="line"></span><br><span class="line">// 初始化链表</span><br><span class="line">void initLinkedList(LinkedList *list)</span><br><span class="line">&#123;</span><br><span class="line">    // 初始化LinkedList内部的成员</span><br><span class="line">    list-&gt;size = 0;</span><br><span class="line">    list-&gt;next = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回链表的长度</span><br><span class="line">size_t getLength(const LinkedList *list)</span><br><span class="line">&#123;</span><br><span class="line">    return list-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在指定位置插入元素</span><br><span class="line">void insertAt(LinkedList *list, size_t index, int element)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (index &lt; 0 || index &gt; list-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;输入的index数据非法\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 插入数据的过程</span><br><span class="line">    // 1. 将数据封装到Node结构体的变量中</span><br><span class="line">    Node *node = (Node *)malloc(1 * sizeof(Node));</span><br><span class="line">    node-&gt;data = element;</span><br><span class="line"></span><br><span class="line">    // 2. 找到index的位置进行插入操作</span><br><span class="line">    if (index == 0)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        node-&gt;next = list-&gt;next;</span><br><span class="line">        list-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Node *currentNode = list-&gt;next; // 指向有数据的首元素</span><br><span class="line">        for (int i = 0; i &lt; index - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            currentNode = currentNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node-&gt;next = currentNode-&gt;next;</span><br><span class="line">        currentNode-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在末尾插入元素</span><br><span class="line">void insertEnd(LinkedList *list, int element)</span><br><span class="line">&#123;</span><br><span class="line">    insertAt(list, list-&gt;size, element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除指定位置的元素并返回被删除的元素</span><br><span class="line">int deleteAt(LinkedList *list, size_t index)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (index &lt; 0 || index &gt;= list-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;输入的index不合法\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int deleteElement;</span><br><span class="line">    Node *deleteNode;</span><br><span class="line">    if (index == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        deleteNode = list-&gt;next;</span><br><span class="line"></span><br><span class="line">        list-&gt;next = deleteNode-&gt;next;</span><br><span class="line"></span><br><span class="line">        // 获取要删除的node的数据</span><br><span class="line">        deleteElement = deleteNode-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Node *currentNode = list-&gt;next; // 指向有数据的首元素</span><br><span class="line">        for (int i = 0; i &lt; index - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            currentNode = currentNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deleteNode = currentNode-&gt;next;</span><br><span class="line">        currentNode-&gt;next = deleteNode-&gt;next;</span><br><span class="line"></span><br><span class="line">        deleteElement = deleteNode-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    free(deleteNode); // 释放node的内存空间</span><br><span class="line"></span><br><span class="line">    list-&gt;size--;</span><br><span class="line"></span><br><span class="line">    return deleteElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除末尾元素</span><br><span class="line">int deleteEnd(LinkedList *list) &#123;</span><br><span class="line">    deleteAt(list,list-&gt;size - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取指定位置的元素</span><br><span class="line">int getElementAt(const LinkedList *list, size_t index) &#123;</span><br><span class="line"></span><br><span class="line">    if(index &lt; 0 || index &gt;= list-&gt;size)&#123;</span><br><span class="line">        printf(&quot;输入的index不合法\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node * currentNode = list-&gt;next;</span><br><span class="line">    for(int i = 0;i &lt; index ;i++)&#123;</span><br><span class="line">        currentNode = currentNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return currentNode-&gt;data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改指定位置的元素</span><br><span class="line">void modifyAt(LinkedList *list, size_t index, int newValue) &#123;</span><br><span class="line"></span><br><span class="line">    if(index &lt; 0 || index &gt;= list-&gt;size)&#123;</span><br><span class="line">        printf(&quot;输入的index不合法\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node * currentNode = list-&gt;next;</span><br><span class="line">    for(int i = 0;i &lt; index ;i++)&#123;</span><br><span class="line">        currentNode = currentNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentNode-&gt;data = newValue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放链表内存</span><br><span class="line">void destroyLinkedList(LinkedList *list) &#123;</span><br><span class="line"></span><br><span class="line">    Node *currentNode = list-&gt;next;  //找到有数据的第1个结点</span><br><span class="line"></span><br><span class="line">    for(int i = 0;i &lt; list-&gt;size;i++)&#123;</span><br><span class="line"></span><br><span class="line">        Node *tempNode = currentNode;</span><br><span class="line">        currentNode = currentNode-&gt;next;</span><br><span class="line"></span><br><span class="line">        free(tempNode);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //辅助操作</span><br><span class="line">    list-&gt;next = NULL;</span><br><span class="line">    list-&gt;size = 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    LinkedList list;</span><br><span class="line">    initLinkedList(&amp;list);</span><br><span class="line"></span><br><span class="line">    insertAt(&amp;list,0,10);</span><br><span class="line">    insertAt(&amp;list,0,20);</span><br><span class="line">    insertAt(&amp;list,0,30);</span><br><span class="line"></span><br><span class="line">    size_t count = getLength(&amp;list);</span><br><span class="line">    printf(&quot;%d\n&quot;,count);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    getchar();  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放链表内存-有什么用"><a href="#释放链表内存-有什么用" class="headerlink" title="释放链表内存 有什么用"></a>释放链表内存 有什么用</h3><p>释放链表内存”的主要用途在于管理动态分配的内存，确保程序运行期间不会造成内存泄漏。下面是这一过程的重要性和作用：</p><ol><li><strong>防止内存泄漏</strong>：在程序中动态申请的内存（例如，通过 <code>malloc</code>）需要在不再使用时及时释放。如果在不再需要链表时不释放内存，程序会占用不必要的内存资源，从而导致内存泄漏。</li><li><strong>优化内存使用</strong>：及时释放内存可以确保系统资源的有效使用，特别是在运行长时间的程序或需要频繁创建和销毁对象的情况下。</li><li><strong>防止悬挂指针</strong>：在释放链表内存的同时，设置指向链表的指针（如头指针）为 <code>NULL</code> 坏境，可以避免访问已释放内存的风险。这有助于防止程序在试图访问无效内存时造成的未定义行为。</li><li><strong>提高程序稳定性</strong>：良好的内存管理使得程序更加稳定和健壮，降低了崩溃的概率。</li></ol><h1 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h1><p>特点：<code>后进先出</code> (LIFO，Last In First Out)或<code>先进后出</code> (FILO，First In Last Out)的线性表。</p><p> 栈顶(Top)：允许进行插入、删除操作的一端，又称为<code>表尾</code>。栈顶由一个称为栈顶指针的位置指示器（其实就是一个变量）来指示，它是动态变化的。</p><p>- 栈底(Bottom)：是固定不变的，不允许进行插入和删除的一端，又称为<code>表头</code>。</p><p>- 空栈：不含任何元素的空表。</p><p>- 设栈S&#x3D;(a1,a2,…,an )，则a1称为栈底元素，an为栈顶元素，栈中元素按a1,a2,…,a_n的次序进栈(压栈、push)，出栈(弹栈，pop)的第一个元素应为栈顶元素，出栈顺序为：an,…,a2,a1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">初始化栈</span><br><span class="line">void initStack(Stack *stack, size_t capacity)</span><br><span class="line">返回栈内元素个数</span><br><span class="line">size_t getSize(const Stack *stack)</span><br><span class="line">添加新元素</span><br><span class="line">void push(Stack *stack, int element)</span><br><span class="line">在末尾插入元素</span><br><span class="line">void insertEnd(LinkedList *list, int element)</span><br><span class="line">栈顶元素出栈并返回</span><br><span class="line">int pop(Stack *stack)</span><br><span class="line">释放栈内存</span><br><span class="line">void destroyStack(Stack *stack)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"></span><br><span class="line">  自定义实现栈结构：使用顺序存储结构实现--&gt; 顺序栈</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line"></span><br><span class="line">    //存储数据的指针</span><br><span class="line">    int *data;</span><br><span class="line">    //指明存储容器的容量</span><br><span class="line">    size_t capacity;</span><br><span class="line">    //指明存储容器中实际存储的数据量</span><br><span class="line">    size_t size;</span><br><span class="line"></span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 初始化栈</span><br><span class="line">void initStack(Stack *stack, size_t capacity)</span><br><span class="line">&#123;</span><br><span class="line">    stack-&gt;data = (int *)malloc(capacity *sizeof(int));//动态内存分配</span><br><span class="line">    if(stack-&gt;data == NULL)&#123;</span><br><span class="line">        printf(&quot;内存分配失败\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack-&gt;capacity = capacity;         </span><br><span class="line">    stack-&gt;size = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回栈内元素个数</span><br><span class="line">size_t getSize(const Stack *stack)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    return stack-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加新元素</span><br><span class="line">void push(Stack *stack, int element)</span><br><span class="line">&#123;</span><br><span class="line">    //考虑是否存满了</span><br><span class="line">    if(stack-&gt;size == stack-&gt;capacity)&#123;</span><br><span class="line">        //扩容</span><br><span class="line">        resizeCapacity(stack,stack-&gt;capacity + stack-&gt;capacity &gt;&gt; 1); //扩容为原来的1.5倍</span><br><span class="line">        printf(&quot;容量已满，进行扩容操作\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack-&gt;data[stack-&gt;size] = element;</span><br><span class="line">    stack-&gt;size++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void resizeCapacity(Stack *stack,int newCapacity)&#123;</span><br><span class="line"></span><br><span class="line">    stack-&gt;data = (int *)realloc(stack-&gt;data,newCapacity * sizeof(int)); //扩容操作</span><br><span class="line">    stack-&gt;capacity = newCapacity; //指明新的容量值</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 栈顶元素出栈并返回</span><br><span class="line">int pop(Stack *stack)</span><br><span class="line">&#123;</span><br><span class="line">    //判断是否为空</span><br><span class="line">    if(stack-&gt;size == 0)&#123;</span><br><span class="line">        printf(&quot;当前栈为空,弹栈失败\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // int popElement = stack-&gt;data[stack-&gt;size-1];</span><br><span class="line">    // stack-&gt;size--;</span><br><span class="line"></span><br><span class="line">    // return popElement;</span><br><span class="line"></span><br><span class="line">    return stack-&gt;data[--stack-&gt;size];//</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//这是一个前缀自减操作。它的作用是将 stack-&gt;size 的值减一，然后返回这个新的值。</span><br><span class="line">//例如，如果 stack-&gt;size 原本是 3，经过 --stack-&gt;size 处理后，</span><br><span class="line">//stack-&gt;size 会变为 2。这意味着我们将要弹出栈中索引为 2 的元素（即第三个元素，因为索引从 0 开始）。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放栈内存</span><br><span class="line">void destroyStack(Stack *stack)</span><br><span class="line">&#123;</span><br><span class="line">    free(stack-&gt;data);</span><br><span class="line">    stack-&gt;data = NULL;</span><br><span class="line">    stack-&gt;capacity = 0;</span><br><span class="line">    stack-&gt;size = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//遍历栈中的元素</span><br><span class="line">void print(Stack *stack)&#123;</span><br><span class="line">    for(int i = 0;i &lt; stack-&gt;size;i++)&#123;</span><br><span class="line">        printf(&quot;%d  &quot;,stack-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //声明结构体变量</span><br><span class="line">    Stack myStack;</span><br><span class="line"></span><br><span class="line">    initStack(&amp;myStack,3);</span><br><span class="line"></span><br><span class="line">    push(&amp;myStack,1);</span><br><span class="line">    push(&amp;myStack,2);</span><br><span class="line">    push(&amp;myStack,3);</span><br><span class="line">    push(&amp;myStack,4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    printf(&quot;栈中元素的个数为：%d\n&quot;,getSize(&amp;myStack));</span><br><span class="line"></span><br><span class="line">    print(&amp;myStack);</span><br><span class="line"></span><br><span class="line">    printf(&quot;弹栈，弹出的数据是：%d\n&quot;,pop(&amp;myStack));</span><br><span class="line">    printf(&quot;弹栈，弹出的数据是：%d\n&quot;,pop(&amp;myStack));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print(&amp;myStack);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线性结构之队列"><a href="#线性结构之队列" class="headerlink" title="线性结构之队列"></a>线性结构之队列</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>队列(Queue)：也是操作受限的线性表，限制为仅允许在表的一端进行插入(入队或进队），在表的另一端进行删除(出队或离队)操作。</p><p>- 队首(front) ：允许进行删除的一端称为队首。</p><p>- 队尾(rear)： 允许进行插入的一端称为队尾。</p><p>在空队列中依次加入元素a1,a2, …, an之后，a1是队首元素，an是队尾元素。显然退出队列的次序也只能是a1,a2, …, an。队列，是一种先进先出(First In First Out ，简称FIFO)的线性结构。类似于生活中的排队行为。</p><p><img src="https://s1.vika.cn/space/2024/11/12/b4e17e3fbd7d4f78815a4f01eb85cb5f" alt="image-20241111205010221"></p><p>队列中没有元素时，称为空队列。</p><h3 id="队列的存储结构"><a href="#队列的存储结构" class="headerlink" title="队列的存储结构"></a>队列的存储结构</h3><p>可用顺序表(数组)和链表来存储队列，队列按存储结构可分为顺序队列和链式队列两种。</p><h3 id="功能定义"><a href="#功能定义" class="headerlink" title="功能定义"></a>功能定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">初始化队列</span><br><span class="line">void initQueue(Queue *queue, size_t capacity)</span><br><span class="line">返回队列内元素个数</span><br><span class="line">size_t getSize(const Queue *queue)</span><br><span class="line">添加新元素</span><br><span class="line">void enqueue(Queue *queue, int element)</span><br><span class="line">元素出队列</span><br><span class="line">int dequeue(Queue *queue)</span><br><span class="line">释放队列内存</span><br><span class="line">void destroyQueue(Queue *queue)</span><br><span class="line">遍历队列</span><br><span class="line">void printQueue(Queue *queue)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">/* </span><br><span class="line">    自定义结构实现队列：使用循环队列</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//声明队列对应的结构体</span><br><span class="line">typedef struct&#123;</span><br><span class="line"></span><br><span class="line">    int *data;</span><br><span class="line">    int capacity; //记录存储的最大容量</span><br><span class="line">    int size ; //记录存储的元素的个数</span><br><span class="line">    int front ;  //记录要出队的索引位置</span><br><span class="line">    int rear;  //记录入队后的索引位置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 初始化队列</span><br><span class="line">void initQueue(Queue *queue, size_t capacity)</span><br><span class="line">&#123;</span><br><span class="line">    queue-&gt;data = (int *)malloc(capacity * sizeof(int));</span><br><span class="line">    queue-&gt;capacity = capacity;</span><br><span class="line">    queue-&gt;size = 0;</span><br><span class="line">    queue-&gt;front = 0;</span><br><span class="line">    queue-&gt;rear = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回队列内元素个数</span><br><span class="line">size_t getSize(const Queue *queue)</span><br><span class="line">&#123;</span><br><span class="line">    return queue-&gt;size;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加新元素</span><br><span class="line">void enqueue(Queue *queue, int element)</span><br><span class="line">&#123;</span><br><span class="line">    if(queue-&gt;size == queue-&gt;capacity)&#123;</span><br><span class="line">        //容量已满</span><br><span class="line">        printf(&quot;队列已满，入队失败\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue-&gt;data[queue-&gt;rear] = element;</span><br><span class="line">    queue-&gt;size++;</span><br><span class="line">    //queue-&gt;rear++; //存在问题，需要使用下面的方式替换</span><br><span class="line"></span><br><span class="line">    queue-&gt;rear = (queue-&gt;rear + 1) % queue-&gt;capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 元素出队列</span><br><span class="line">int dequeue(Queue *queue)</span><br><span class="line">&#123;</span><br><span class="line">    // if(queue-&gt;front == queue-&gt;rear);//此语句满足的情况：① 队列为空 ② 队列已满</span><br><span class="line">    if(queue-&gt;size == 0)&#123;</span><br><span class="line">        printf(&quot;队列为空，出队失败\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int dequeueData = queue-&gt;data[queue-&gt;front];</span><br><span class="line">    queue-&gt;size--;</span><br><span class="line"></span><br><span class="line">    queue-&gt;front = (queue-&gt;front + 1) % queue-&gt;capacity;</span><br><span class="line"></span><br><span class="line">    return dequeueData;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放队列内存</span><br><span class="line">void destroyQueue(Queue *queue)</span><br><span class="line">&#123;</span><br><span class="line">    free(queue-&gt;data);</span><br><span class="line">    queue-&gt;data = NULL;</span><br><span class="line">    queue-&gt;capacity = 0;</span><br><span class="line">    queue-&gt;size = 0;</span><br><span class="line">    queue-&gt;front = 0;</span><br><span class="line">    queue-&gt;rear = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//遍历队列</span><br><span class="line">void printQueue(Queue *queue)&#123;</span><br><span class="line">    </span><br><span class="line">    for(int i = queue-&gt;front,j = 0;j &lt; queue-&gt;size;i++,j++)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        printf(&quot;%d  &quot;,queue-&gt;data[i % queue-&gt;capacity]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Queue myQueue;</span><br><span class="line"></span><br><span class="line">    initQueue(&amp;myQueue,3);</span><br><span class="line"></span><br><span class="line">    enqueue(&amp;myQueue,1);</span><br><span class="line">    enqueue(&amp;myQueue,2);</span><br><span class="line">    enqueue(&amp;myQueue,3);</span><br><span class="line">    enqueue(&amp;myQueue,4); //已满，未入队</span><br><span class="line"></span><br><span class="line">    printQueue(&amp;myQueue);</span><br><span class="line"></span><br><span class="line">    printf(&quot;出队，元素是：%d\n&quot;,dequeue(&amp;myQueue));</span><br><span class="line">    printf(&quot;出队，元素是：%d\n&quot;,dequeue(&amp;myQueue));</span><br><span class="line"></span><br><span class="line">    printQueue(&amp;myQueue);</span><br><span class="line"></span><br><span class="line">    enqueue(&amp;myQueue,5);</span><br><span class="line">    enqueue(&amp;myQueue,6);</span><br><span class="line"></span><br><span class="line">    printQueue(&amp;myQueue);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p><img src="https://s1.vika.cn/space/2024/11/12/72fe34dc1658472cbf5d14212e1506e3" alt="image-20241112175354551"></p><p>假设一个 int 变量占 4个字节，则所需内存空间 &#x3D; 4 + 4 &#x3D; 8，则S(n) &#x3D; O(1)。</p><p><img src="https://s1.vika.cn/space/2024/11/12/4c26e3b872e54932aeac50b4e0cfc5b9" alt="image-20241112175523230"></p><p>假设一个 int 变量占 4个字节，则所需内存空间 &#x3D; 4 + 4n + 4 &#x3D; 4n + 8，则S(n) &#x3D; O(n)。</p><p><img src="https://s1.vika.cn/space/2024/11/12/18bb9907b97d432b83b835a8f999c8d4" alt="image-20241112175532793"></p><p><img src="https://s1.vika.cn/space/2024/11/12/2cb283d076a04171acfea6e1c3b8b96d" alt="image-20241112175538936"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找:"></a>顺序查找:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 顺序查找:</span><br><span class="line">int sequenceSearch(int arr[], int size, int target)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    for(int i = 0;i &lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(arr[i] == target)</span><br><span class="line">        &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return -1; //表示没有找到指定的元素 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int arr[] = &#123;23,45,76,44,22,88,9,12,22,5,80&#125;;</span><br><span class="line"></span><br><span class="line">    int size = sizeof(arr) / sizeof(int);</span><br><span class="line"></span><br><span class="line">    int target = 9;</span><br><span class="line"></span><br><span class="line">    int targetIndex = sequenceSearch(arr,size,target);</span><br><span class="line">    if(targetIndex == -1)&#123;</span><br><span class="line">        printf(&quot;未找到\n&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;找到了%d，对应的索引为%d\n&quot;,target,targetIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sizeof是运算符，返回 unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。<br>它的功能是：获得保证能容纳实现所建立的最大对象的字节大小</p><p>sizeof(ary) &#x2F; sizeof(int) &lt;&#x3D;&#x3D;&gt; sizeof(ary) &#x2F; sizeof(ary[0]) ; 得到 ary 内的元素的个数</p><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>二分查找（Binary Search）是一种高效的搜索算法，通常用于有序数据集中查找目标元素。其原理是通过将数据集划分为两半并与目标进行比较，以确定目标在哪一半中，从而逐步缩小搜索范围，直到找到目标元素或确定不存在。基本原理如下：</p><p>（1）<strong>选择中间元素：</strong> 在有序数据集中，选择数组的中间元素。</p><p>（1）<strong>比较目标：</strong> 将中间元素与目标元素进行比较。</p><p>（2）<strong>查找成功：</strong> 如果中间元素等于目标元素，则查找成功，返回中间元素的索引。</p><p>（3）<strong>缩小搜索范围：</strong> 对于一个升序的数据集，如果中间元素大于目标元素，说明目标可能在左半部分；如果中间元素小于目标元素，说明目标可能在右半部分。根据比较结果，将搜索范围缩小到一半，继续查找。</p><p>（4）<strong>重复步骤：</strong> 重复上述步骤，不断将搜索范围缩小，直到找到目标元素或搜索范围为空。</p><p>​                                   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"></span><br><span class="line">    使用二分查找法，查找数组中的元素</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int binarySearch(int arr[],int size,int target)&#123;</span><br><span class="line"></span><br><span class="line">    int low = 0;</span><br><span class="line">    int high = size - 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    while(low &lt;= high)&#123;</span><br><span class="line"></span><br><span class="line">        int middle = (low + high) / 2;</span><br><span class="line">        if(arr[middle] == target)&#123;</span><br><span class="line">            return middle;</span><br><span class="line">        &#125;else if(arr[middle] &gt; target)&#123;</span><br><span class="line">            high = middle - 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            low = middle + 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //表示未找到</span><br><span class="line">    return -1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int arr[] = &#123;4,7,9,12,16,19,22,28,34,57,69,78,90&#125;;</span><br><span class="line">    int target = 12;</span><br><span class="line">    target = 91;</span><br><span class="line">    int size = sizeof(arr) / sizeof(int);</span><br><span class="line"></span><br><span class="line">    int targetIndex = binarySearch(arr,size,target);</span><br><span class="line">    if(targetIndex == -1)&#123;</span><br><span class="line">        printf(&quot;未找到\n&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;找到了%d，对应的索引为%d\n&quot;,target,targetIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"></span><br><span class="line">    冒泡排序:实现从小到大排序</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">void bubbleSort(int arr[],int size)&#123;</span><br><span class="line"></span><br><span class="line">    //外层循环：控制轮数</span><br><span class="line">    for(int i = 0;i &lt; size - 1;i++)&#123;</span><br><span class="line"></span><br><span class="line">        //内层循环：依次比较相邻的两个元素的大小</span><br><span class="line">        for(int j = 0;j &lt; size - 1 - i;j++)&#123;</span><br><span class="line">            </span><br><span class="line">            if(arr[j] &gt; arr[j + 1])&#123;</span><br><span class="line">                //交互j 和 j+1索引位置的元素</span><br><span class="line">                int temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int arr[] = &#123;23,45,2,46,77,2,99,-9,-32,0,66&#125;;</span><br><span class="line"></span><br><span class="line">    int size = sizeof(arr) / sizeof(int);</span><br><span class="line">    //遍历</span><br><span class="line">    for(int i = 0;i &lt; size;i++)&#123;</span><br><span class="line">        printf(&quot;%d  &quot;,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    //排序</span><br><span class="line">    bubbleSort(arr,size);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //遍历</span><br><span class="line">    for(int i = 0;i &lt; size;i++)&#123;</span><br><span class="line">        printf(&quot;%d  &quot;,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">    快速排序:实现从小到大排序</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">void quickSort(int arr[], int size)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    subSort(arr, 0, size - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void subSort(int arr[], int start, int end)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (start &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        int base = arr[start];</span><br><span class="line">        int low = start;</span><br><span class="line">        int high = end + 1;</span><br><span class="line"></span><br><span class="line">        while (1)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            while (low &lt; end &amp;&amp; arr[++low] &lt;= base)</span><br><span class="line">                ; // 找到从前往后第1个比base大的元素</span><br><span class="line">            while (high &gt; start &amp;&amp; arr[--high] &gt;= base)</span><br><span class="line">                ; // 找到从后往前第1个比base小的元素</span><br><span class="line"></span><br><span class="line">            if (low &lt; high)</span><br><span class="line">            &#123;</span><br><span class="line">                // 交换low和high位置的元素</span><br><span class="line">                int temp = arr[low];</span><br><span class="line">                arr[low] = arr[high];</span><br><span class="line">                arr[high] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 交换start和high索引位置上的元素</span><br><span class="line">        int temp1 = arr[start];</span><br><span class="line">        arr[start] = arr[high];</span><br><span class="line">        arr[high] = temp1;</span><br><span class="line"></span><br><span class="line">        // 递归调用</span><br><span class="line">        subSort(arr, start, high - 1); // 前半段继续排序</span><br><span class="line">        subSort(arr, high + 1, end);   // 后半段继续排序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int arr[] = &#123;23, 45, 2, 46, 77, 2, 99, -9, -32, 0, 66&#125;;</span><br><span class="line"></span><br><span class="line">    int size = sizeof(arr) / sizeof(int);</span><br><span class="line">    // 遍历</span><br><span class="line">    for (int i = 0; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 排序</span><br><span class="line">    quickSort(arr, size);</span><br><span class="line"></span><br><span class="line">    // 遍历</span><br><span class="line">    for (int i = 0; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
