<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2025/11/28/test/%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/"/>
      <url>/2025/11/28/test/%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="系统移植"><a href="#系统移植" class="headerlink" title="系统移植"></a><strong>系统移植</strong></h1><h4 id="（一）应用层开发和嵌入式底层开发的区别"><a href="#（一）应用层开发和嵌入式底层开发的区别" class="headerlink" title="（一）应用层开发和嵌入式底层开发的区别"></a>（一）应用层开发和嵌入式底层开发的区别</h4><h5 id="1》嵌入式是什么？"><a href="#1》嵌入式是什么？" class="headerlink" title="1》嵌入式是什么？"></a>1》嵌入式是什么？</h5><p>官方：嵌入式是以应用为中心，以计算机技术为基础，软硬件可剪裁的计算机系统。</p><p>嵌入式系统的特点：成本，体积，可靠性，功耗都有严格要求。</p><p>解读：</p><p>1，计算机系统</p><p>2，针对某个应用的，也就是通常所说的“专用的”</p><p>说白了，就是针对某个应用的计算机系统</p><h5 id="2》应用层开发和嵌入式底层开发的区别"><a href="#2》应用层开发和嵌入式底层开发的区别" class="headerlink" title="2》应用层开发和嵌入式底层开发的区别"></a>2》应用层开发和嵌入式底层开发的区别</h5><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">编程思路：</span><br><span class="line">编译:gcc运行</span><br><span class="line">hello.c  ----------------&gt;  hello(可执行文件) -----------&gt; ./hello </span><br><span class="line">  || x86</span><br><span class="line"> C库:比如：printf   链接C库</span><br></pre></td></tr></table></figure><p>inux内核开发——驱动</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">编程思路： </span><br><span class="line">         (交叉编译器---可以把程序编程成指定平台的程序  ------&gt; ./hello ARM)</span><br><span class="line">编译：交叉编译器  加载</span><br><span class="line">hello_drv.c ------------------------&gt;hello_drv.ko  --------------&gt; insmod  hello_drv.ko </span><br><span class="line">|| |</span><br><span class="line">linux内核源码和内核源码一起编译内核模块将驱动加载到系统(开发板)中</span><br></pre></td></tr></table></figure><h4 id="（二）开发板介绍"><a href="#（二）开发板介绍" class="headerlink" title="（二）开发板介绍"></a>（二）开发板介绍</h4><p>​STM32MP157A 是基于 Cortex-A7 32bit RISC核心加 Cortex-M4 32bit RISC 核心的高性能双核心处理器，最高工作频率为 800MHz。Cortex-A7 处理器为每个 CPU 内置一个 32 kbyte L1 指令缓存，一个 32 kbyte L1 数据缓存为每个 CPU 内置一个 256 kbyte 2 级缓存。同时 Cortex-A7 处理器是一个低功耗的应用处理器，旨在为高端可穿戴设备以及其他低功耗嵌入式和消费应用提供丰富的性能。它提供了比 Cortex-A5 多20%的单线程性能。</p><h4 id="（三）linux系统的芯片的启动模式"><a href="#（三）linux系统的芯片的启动模式" class="headerlink" title="（三）linux系统的芯片的启动模式"></a>（三）linux系统的芯片的启动模式</h4><h5 id="1》单片机是怎么启动的？"><a href="#1》单片机是怎么启动的？" class="headerlink" title="1》单片机是怎么启动的？"></a>1》单片机是怎么启动的？</h5><p>STM32单片机，通常在MDK，IAR，集成IDE上编写程序，可以直接烧写到硬件单片机上内部flash中，使用起来是非常方便且简单的。因为一般单片机的程序不会超过2MB，单片机的内部flash也不会超过8MB。</p><h5 id="2》linux系统的芯片的启动模式"><a href="#2》linux系统的芯片的启动模式" class="headerlink" title="2》linux系统的芯片的启动模式"></a>2》linux系统的芯片的启动模式</h5><p>​1）Linux系统很大，Linux系统镜像一般情况下都能达到几十，上百M。如果功能很强大，很可能就上GB了。因此Linux芯片，需要借助外部flash存放它是的镜像。</p><p>​2）能够存放镜像的外部flash：SD卡，EMMC，Nand flash，NOR flash ，SPI flash 等。所以当我们将Linux系统做好以后，要将它烧写到这些外部flash中去。</p><p>​3）不同的半导体厂商会提供相应的烧写工具</p><p>​4）一款芯片有可能会同时支持多种flash启动</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/11/28/test/liunx%E9%A9%B1%E5%8A%A8/Linux%E9%A9%B1%E5%8A%A8/"/>
      <url>/2025/11/28/test/liunx%E9%A9%B1%E5%8A%A8/Linux%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux驱动"><a href="#Linux驱动" class="headerlink" title="Linux驱动"></a><strong>Linux驱动</strong></h1><p>内容</p><p>​1、内核模块框架</p><p>​2、一个完完整驱动的组成</p><p>​3、led设备驱动</p><p>准备工作：</p><p>1、将linux源码拷贝一份到Windows下</p><p>2、在Windows下的linux源码目录下新建一个 source insight 文件夹</p><p>3、打开source insight 软件，新建一个工程，工程保存到刚新建的source insight 文件夹下</p><p>4、将Linux源码导入到source insight的工程中，并同步<br>    同步方法如下：<br>    在右边project文件栏下按鼠标右键-》点击Synchronize files-》勾选force all files to be re-parsed-》点击start</p><h1 id="一）内核模块框架"><a href="#一）内核模块框架" class="headerlink" title="一）内核模块框架"></a>一）内核模块框架</h1><h3 id="1》内核模块组成"><a href="#1》内核模块组成" class="headerlink" title="1》内核模块组成"></a>1》内核模块组成</h3><p>​1、在fs_mp157a&#x2F;driver&#x2F;2308&#x2F;1day&#x2F;新建一个drv_hello.c 文件<br>​2、头文件<br>​#include &lt;linux&#x2F;init.h&gt;<br>​#include &lt;linux&#x2F;module.h&gt;<br>​3、加载函数——模块加载后运行的第一个函数<br>​static int __init drv_hello_init(void)&#x2F;&#x2F;加载函数<br>​{<br>​int ret&#x3D;0;<br>​printk(“—%s—\r\n”,<strong>FUNCTION</strong>);<br>​return ret;<br>​}<br>​4、卸载函数——模块卸载时，会调用这个函数<br>​static void __exit drv_hello_exit(void)&#x2F;&#x2F;卸载函数<br>​{<br>​printk(“—%s—\r\n”,<strong>FUNCTION</strong>);<br>​}<br>​5、函数声明和认证<br>​module_init(drv_hello_init);<br>​module_exit(drv_hello_exit);<br>​MODULE_LICENSE(“GPL”);</p><h3 id="2》编写Makefile文件"><a href="#2》编写Makefile文件" class="headerlink" title="2》编写Makefile文件"></a>2》编写Makefile文件</h3><p>​&#x2F;&#x2F;指定内核源码路径</p><p>​KERNEL_DIR &#x3D; &#x2F;home&#x2F;linux&#x2F;fs_mp157a&#x2F;kernel&#x2F;stm32mp1-openstlinux-5.4-dunfell-mp1-20-06-24&#x2F;sources&#x2F;arm-ostl-linux-gnueabi&#x2F;linux-stm32mp-5.4.31-r0&#x2F;linux-5.4.31</p><p>​CUR_DIR &#x3D; ${shell pwd}</p><p>​all:</p><p>​&#x2F;&#x2F;将当前目录下的源码和内核源码一起编译，编译成.ko文件</p><p>​make -C $(KERNEL_DIR) M&#x3D;$(CUR_DIR) modules</p><p>​clean:</p><p>​&#x2F;&#x2F;清除将上面编译生成的文件</p><p>​make -C $(KERNEL_DIR) M&#x3D;$(CUR_DIR) clean</p><p>​install:</p><p>​&#x2F;&#x2F;将当前目录下的所有.ko文件拷贝到根文件系统中</p><p>​sudo cp *.ko &#x2F;opt&#x2F;rootfs&#x2F;drivers</p><p>​&#x2F;&#x2F;指定要编译的源文件</p><p>​obj-m &#x3D; drv_hello.o</p><h3 id="3》编译make"><a href="#3》编译make" class="headerlink" title="3》编译make"></a>3》编译make</h3><p>​make -C &#x2F;home&#x2F;linux&#x2F;fs_mp157a&#x2F;kernel&#x2F;stm32mp1-openstlinux-5.4-dunfell-mp1-20-06-24&#x2F;sources&#x2F;arm-ostl-linux-gnueabi&#x2F;linux-stm32mp-5.4.31-r0&#x2F;linux-5.4.31 M&#x3D;&#x2F;home&#x2F;linux&#x2F;fs_mp157a&#x2F;drivers&#x2F;2308&#x2F;1day modules</p><p>​make[1]: Entering directory ‘&#x2F;home&#x2F;linux&#x2F;fs_mp157a&#x2F;kernel&#x2F;stm32mp1-openstlinux-5.4-dunfell-mp1-20-06-24&#x2F;sources&#x2F;arm-ostl-linux-gnueabi&#x2F;linux-stm32mp-5.4.31-r0&#x2F;linux-5.4.31’</p><p>​  CC [M]  &#x2F;home&#x2F;linux&#x2F;fs_mp157a&#x2F;drivers&#x2F;2308&#x2F;1day&#x2F;drv_hello.o</p><p>​  Building modules, stage 2.</p><p>​  MODPOST 1 modules</p><p>​  CC [M]  &#x2F;home&#x2F;linux&#x2F;fs_mp157a&#x2F;drivers&#x2F;2308&#x2F;1day&#x2F;drv_hello.mod.o</p><p>​  LD [M]  &#x2F;home&#x2F;linux&#x2F;fs_mp157a&#x2F;drivers&#x2F;2308&#x2F;1day&#x2F;drv_hello.ko</p><p>​make[1]: Leaving directory ‘&#x2F;home&#x2F;linux&#x2F;fs_mp157a&#x2F;kernel&#x2F;stm32mp1-openstlinux-5.4-dunfell-mp1-20-06-24&#x2F;sources&#x2F;arm-ostl-linux-gnueabi&#x2F;linux-stm32mp-5.4.31-r0&#x2F;linux-5.4.31’</p><h3 id="4》加载内核模块"><a href="#4》加载内核模块" class="headerlink" title="4》加载内核模块"></a>4》加载内核模块</h3><p>​1、在&#x2F;opt&#x2F;rootfs&#x2F;下新建一个drivers文件夹</p><p>​2、执行 make install 将.ko文件拷贝到根文件系统中</p><p>​3、打开开发板，加载内核模块  (insmod 加载函数，rmmod 卸载函数，lsmod 查看)</p><p>​[root@fsmp1a ]# cd drivers&#x2F; &#x2F;&#x2F;进入模块文件夹</p><p>​[root@fsmp1a drivers]# ls&#x2F;&#x2F;查看文件夹内容</p><p>​drv_hello.ko</p><p>​[root@fsmp1a drivers]# insmod drv_hello.ko&#x2F;&#x2F;加载内核模块</p><p>​[ 8213.458054] —drv_hello_init—</p><p>​[root@fsmp1a drivers]# lsmod&#x2F;&#x2F;查看系统中加载的模块</p><p>​drv_hello 16384 0 - Live 0xbf000000 (OE)</p><p>​[root@fsmp1a drivers]# rmmod drv_hello.ko&#x2F;&#x2F;卸载已经加载的模块</p><p>​[ 8338.518719] —drv_hello_exit—</p><h1 id="二-一个完整驱动的组成"><a href="#二-一个完整驱动的组成" class="headerlink" title="(二)一个完整驱动的组成"></a>(二)一个完整驱动的组成</h1><h3 id="1》设备号"><a href="#1》设备号" class="headerlink" title="1》设备号"></a>1》设备号</h3><h4 id="1、设备号的概念"><a href="#1、设备号的概念" class="headerlink" title="1、设备号的概念"></a>1、设备号的概念</h4><p>​是用一个32位的正数表示，分成两部分： 主设备号和次设备号</p><p>​主设备号：用32位正数的高12位表示，表示一类设备(一类设备)</p><p>​次设备号：用32位正数的低20位表示，表示具体的设备编号（具体的某一个）</p><h4 id="2、申请设备号："><a href="#2、申请设备号：" class="headerlink" title="2、申请设备号："></a>2、申请设备号：</h4><p>​static inline int register_chrdev(unsigned int major, const char *name,const struct file_operations *fops)</p><p>​&#x2F;&#x2F;参数1申请设备号的方式：major&#x3D;0，表示动态申请主设备号</p><p>​      major&gt;0,表示静态指定一个主设备号</p><p>​&#x2F;&#x2F;参数2字符串，表示描述信息，自定义</p><p>​&#x2F;&#x2F;参数3struct file_operations结构体指针</p><p>​&#x2F;&#x2F;返回指如果参数1为0，成功返回主设备号，失败返回错误码</p><p>​如果参数1不为0，成功返回0，失败返回错误码</p><p>static inline void unregister_chrdev(unsigned int major, const char *name) &#x2F;&#x2F; 释放设备号.</p><h4 id="3、编译，在开发板中加载驱动，并查看主设备号"><a href="#3、编译，在开发板中加载驱动，并查看主设备号" class="headerlink" title="3、编译，在开发板中加载驱动，并查看主设备号"></a>3、编译，在开发板中加载驱动，并查看主设备号</h4><p>​[root@fsmp1a drivers]# insmod drv_hello.ko</p><p>​[ 1985.156434] —drv_hello_init—</p><p>​[root@fsmp1a drivers]# cat &#x2F;proc&#x2F;devices</p><p>​Character devices:</p><p>​  1 mem</p><p>​  2 pty</p><p>​  3 ttyp</p><p>​  4 &#x2F;dev&#x2F;vc&#x2F;0</p><p>​  4 tty</p><p>​  5 &#x2F;dev&#x2F;tty</p><p>​  5 &#x2F;dev&#x2F;console</p><p>​  5 &#x2F;dev&#x2F;ptmx</p><p>​  5 ttyRPMSG</p><p>​  7 vcs</p><p>​ 10 misc</p><p>​ 13 input</p><p>​ 21 sg</p><p>​ 29 fb</p><p>​ 89 i2c</p><p>​ 90 mtd</p><p>​100 drv_hello  &#x2F;&#x2F;加载驱动申请的主设号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span><span class="comment">//头文件固定的两个</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">drv_hello_open</span>  <span class="params">(<span class="keyword">struct</span> inode * node, <span class="keyword">struct</span> file * fp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">printk(<span class="string">&quot;---%s---&quot;</span>,__FUNCTION__);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">drv_hello_release</span> <span class="params">(<span class="keyword">struct</span> inode * node, <span class="keyword">struct</span> file * fp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;L</span><br><span class="line"><span class="title function_">printk</span><span class="params">(<span class="string">&quot;---%s---&quot;</span>,__FUNCTION__)</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fopt</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">.open = drv_hello_open,</span><br><span class="line">.release = drv_hello_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//加载函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">drv_hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">printk(<span class="string">&quot;---%s---&quot;</span>, __FUNCTION__);</span><br><span class="line"><span class="comment">//申请设备号</span></span><br><span class="line">ret = register_chrdev(<span class="number">111</span>, <span class="string">&quot;hello&quot;</span>, &amp;fopt);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果没有</span></span><br><span class="line">printk(<span class="string">&quot;register_chrdev erro&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">drv_hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;---%s---&quot;</span>, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明和认证</span></span><br><span class="line">module_init(drv_hello_init);</span><br><span class="line">module_exit(drv_hello_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);<span class="comment">//必须要加，表示开源的意思s</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/11/28/test/c%E5%92%8Cc++/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/2025/11/28/test/c%E5%92%8Cc++/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>编码规范</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/11/28/test/c%E5%92%8Cc++/%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B%20%E7%BA%BF%E6%80%A7%E8%A1%A8%20%E5%87%BD%E6%95%B0%20%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E6%8C%87%E9%92%88%E4%B8%93%E9%A2%98/"/>
      <url>/2025/11/28/test/c%E5%92%8Cc++/%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B%20%E7%BA%BF%E6%80%A7%E8%A1%A8%20%E5%87%BD%E6%95%B0%20%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E6%8C%87%E9%92%88%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a><strong>存储类型</strong></h1><p>在C语言中，存储类型（或存储类别）定义了变量的<strong>作用域</strong>（即它可以在哪里被访问）和生命周期（即它存在多久）。以下是C语言中的几种存储类型：</p><ol><li><strong>自动存储类型（Auto）</strong>自动存储类型是所有局部变量的默认存储类型。这些变量在函数开始时被创建，并在函数结束时被销毁。它们通常存储在栈内存中。可以使用 auto 关键字显式声明，但这很少见。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">int</span> x = <span class="number">1</span>;  <span class="comment">// 自动存储类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>静态存储类型（Static）</strong>静态变量仅在程序的执行期间被初始化一次，之后它们保持其值，直到程序终止。可以使用 static 关键字来声明静态变量。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x = <span class="number">0</span>;  <span class="comment">// 静态存储类型</span></span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>寄存器存储类型（Register）</strong>寄存器变量被存储在CPU的寄存器中，而不是RAM中，以便更快地访问。可以使用 register 关键字来声明寄存器变量。但是，这只是一个建议，编译器可以选择忽略它。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> x = <span class="number">0</span>;  <span class="comment">// 寄存器存储类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>外部存储类型（Extern）</strong>外部变量是在所有文件中共享的变量。它们是在一个文件中定义的，可以在其他文件中使用。可以使用 extern 关键字来声明外部变量。 extern int x; &#x2F;&#x2F; 外部存储类型，x是在另一个文件中定义的</li></ol><p>除了这些，还有 typedef 关键字，它不是存储类别，但它允许你创建类型的别名，这可以使代码更易于阅读和维护。<br>注意，存储类型关键字只能应用于变量和函数，而不能应用于类型定义或其他语言元素。</p><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a><strong>线性表</strong></h1><p>顺序表<br>编写一个顺序表通常包括定义一个结构来存储元素及其有关的属性，如数组和当前大小，以及一系列操作顺序表的函数，如插入、删除和搜索。下面是一个简单的C语言实现示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义最大容量为100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义顺序表结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE]; <span class="comment">// 存储元素的数组</span></span><br><span class="line">    <span class="type">int</span> length;         <span class="comment">// 当前顺序表的长度</span></span><br><span class="line">&#125; SeqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化顺序表</span></span><br><span class="line">SeqList* <span class="title function_">initSeqList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 分配内存空间，并将长度初始化为0</span></span><br><span class="line">    SeqList* <span class="built_in">list</span> = (SeqList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqList));</span><br><span class="line">    <span class="built_in">list</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertSeqList</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="type">int</span> pos, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查位置是否合法和顺序表是否已满</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;length &gt;= MAX_SIZE || pos &lt; <span class="number">0</span> || pos &gt; <span class="built_in">list</span>-&gt;length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从后往前，将元素向后移动，以创建空位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;length; i &gt; pos; i--) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;data[i] = <span class="built_in">list</span>-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在指定位置插入新元素</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;data[pos] = value;</span><br><span class="line">    <span class="comment">// 增加顺序表的长度</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteSeqList</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="type">int</span> pos)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查位置是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt;= <span class="built_in">list</span>-&gt;length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从前往后，将元素向前移动，覆盖待删除的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt; <span class="built_in">list</span>-&gt;length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;data[i] = <span class="built_in">list</span>-&gt;data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 减少顺序表的长度</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findSeqList</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历顺序表，查找给定值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;data[i] == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">// 如果找到，返回索引</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 如果未找到，返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">displaySeqList</span><span class="params">(SeqList* <span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历并打印所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">list</span>-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">// 在打印完所有元素后换行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化顺序表</span></span><br><span class="line">    SeqList* <span class="built_in">list</span> = initSeqList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    insertSeqList(<span class="built_in">list</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    insertSeqList(<span class="built_in">list</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    insertSeqList(<span class="built_in">list</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示当前顺序表的内容</span></span><br><span class="line">    displaySeqList(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除索引为1的元素</span></span><br><span class="line">    deleteSeqList(<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示当前顺序表的内容</span></span><br><span class="line">    displaySeqList(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找值为3的元素</span></span><br><span class="line">    <span class="type">int</span> index = findSeqList(<span class="built_in">list</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (index != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Element found at index: %d\n&quot;</span>, index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Element not found\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放顺序表所占用的内存空间</span></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中：<br>我们首先定义了一个SeqList结构体，它有一个数组来存储元素和一个整数来存储列表的当前长度。<br>initSeqList函数初始化一个新的顺序表。<br>insertSeqList函数在指定位置插入一个新元素。<br>deleteSeqList函数删除指定位置的元素。<br>findSeqList函数查找给定值的元素。<br>displaySeqList函数显示列表的所有元素。<br>注意，这个示例没有包含错误检查和恢复代码来处理如内存分配失败这样的错误条件。在真实的代码中，你应该添加适当的错误检查和处理代码。</p><h1 id="函数-、数组、指针专题"><a href="#函数-、数组、指针专题" class="headerlink" title="函数 、数组、指针专题"></a><strong>函数 、数组、指针专题</strong></h1><h2 id="一、数组指针和指针数组"><a href="#一、数组指针和指针数组" class="headerlink" title="一、数组指针和指针数组"></a>一、数组指针和指针数组</h2><p>在C语言中，”数组指针”和”指针数组”是两种不同的概念。下面我将解释这两者的区别：<br><strong>数组指针 ： 本质是指针，是一个指向数组的指针 用于指针指向多维数组的时候</strong><br><strong>指针数组：本质是数组， 是一个存放指针数组</strong></p><h3 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h3><p>数组指针是一个指针，它指向一个数组。通常它是指向数组中的第一个元素的指针，或者指向一个多维数组。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> (*ptr_to_arr)[<span class="number">3</span>] = &amp;arr;</span><br></pre></td></tr></table></figure><p>在这个示例中，<strong>ptr_to_arr</strong>是一个指针，它指向一个具有3个整数的数组。</p><h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><p>指针数组则是一个数组，它的每个元素都是指针。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr_arr[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>在这个示例中，<strong>ptr_arr</strong>是一个数组，它包含3个整数指针。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li><strong>数据类型</strong>：</li></ol><ul><li>数组指针：是一个指针，它指向一个数组。</li><li>指针数组：是一个数组，它包含多个指针。</li></ul><ol><li><strong>内存分布</strong>：</li></ol><ul><li>数组指针：它本质上是一个指针，占用的内存大小是指针的大小（通常是4或8字节，取决于系统的架构）。</li><li>指针数组：它是一个数组，占用的内存大小是数组中所有指针的大小之和。</li></ul><ol><li><strong>声明方式</strong>：</li></ol><ul><li>数组指针：使用圆括号来改变优先级，例如：**int (*ptr_to_arr)[3]*。</li><li>指针数组：使用方括号来定义数组的大小，例如：**int *ptr_arr[3]*。</li></ul><h2 id="1-数组指针"><a href="#1-数组指针" class="headerlink" title="1. 数组指针"></a>1. 数组指针</h2><p>数组指针是一个指针，它指向一个数组。它常用于指向多维数组的情况。数组指针的定义和使用如下：</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>数组指针的定义需要指明数组的类型和大小。例如，如果我们有一个含有3个整数的数组，我们可以定义一个指向该数组的数组指针如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*array_ptr)[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>在这里：</p><ul><li><strong>int</strong>：表示数组中元素的类型是整数。</li><li>**(*array_ptr)*：是一个指向数组的指针。</li><li>**[3]**：表示数组的大小是3。</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>我们可以通过获取数组的地址来初始化数组指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> (*array_ptr)[<span class="number">3</span>] = &amp;<span class="built_in">array</span>;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用数组指针访问数组中的元素时，我们可以使用下标语法，就像我们在数组中做的那样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (*array_ptr)[<span class="number">0</span>]); <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure><p>在这里：</p><ul><li>**(*array_ptr)*：解引用数组指针以获取数组。</li><li>**[0]**：访问数组的第一个元素。</li></ul><p>注意，在定义数组指针时，我们使用了括号来确保*是数组指针名的一部分，而不是类型的一部分。这是因为数组和指针在C语言中有不同的优先级，所以我们需要使用括号来表明我们是在定义一个数组指针，而不是一个指针数组。</p><h2 id="2-指针数组"><a href="#2-指针数组" class="headerlink" title="2. 指针数组"></a>2. 指针数组</h2><p>“指针数组”是一个数组，它的每一个元素都是指针。这种结构可以用来存储多个指针，每个指针可以指向不同的数据或结构。以下是一个关于如何定义和使用指针数组的说明：</p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>你可以如下定义一个指针数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr_array[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><strong>int</strong> * 表示数组中的元素是指向整数的指针。</li><li><strong>ptr_array[3]</strong> 表示这是一个可以存储3个指针的数组。</li></ul><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>你可以通过将指针分配给数组中的各个元素来初始化指针数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> *ptr_array[<span class="number">3</span>] = &#123;&amp;a, &amp;b, &amp;c&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>你可以通过索引来访问指针数组中的各个指针，并通过解引用来访问它们所指向的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *ptr_array[<span class="number">0</span>]); <span class="comment">// 输出 1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *ptr_array[<span class="number">1</span>]); <span class="comment">// 输出 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *ptr_array[<span class="number">2</span>]); <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure><p>在上面的代码中：</p><ul><li><strong>ptr_array[0]<strong>、</strong>ptr_array[1]</strong> 和 <strong>ptr_array[2]</strong> 分别是数组中的三个指针。</li><li>使用 * 运算符（解引用运算符）来访问这些指针所指向的值。</li></ul><h2 id="二、指针访问二维数组"><a href="#二、指针访问二维数组" class="headerlink" title="二、指针访问二维数组"></a>二、指针访问二维数组</h2><p>访问二维数组有几种方法，你可以通过数组名称直接访问，也可以通过指针进行访问。下面我将介绍如何通过指针访问二维数组：</p><h3 id="方法1-指向数组的指针"><a href="#方法1-指向数组的指针" class="headerlink" title="方法1: 指向数组的指针"></a>方法1: 指向数组的指针</h3><p>当你有一个二维数组时，你可以创建一个指向数组的指针来指向这个二维数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*ptr)[<span class="number">3</span>] = arr; <span class="comment">// ptr是一个指向含有3个整数的数组的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过指针访问二维数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ptr[i][j]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="方法2-双重指针"><a href="#方法2-双重指针" class="headerlink" title="方法2: 双重指针."></a>方法2: 双重指针.</h3><p>你还可以使用双重指针来访问二维数组。但是这需要数组是动态分配的，或者是指针数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">     arr[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">         arr[i][j] = i * <span class="number">3</span> + j + <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> **ptr = arr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过双重指针访问二维数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ptr[i][j]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="方法3-一级指针与算术运算"><a href="#方法3-一级指针与算术运算" class="headerlink" title="方法3: 一级指针与算术运算"></a>方法3: 一级指针与算术运算</h3><p>你可以使用一个一级指针和指针算术来访问二维数组的元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *ptr = &amp;arr[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过指针和算术运算访问二维数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(ptr + i * <span class="number">3</span> + j));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注意，你需要确切地知道二维数组的行和列大小，以便正确地计算索引。</p><h2 id="三、函数指针和指针函数"><a href="#三、函数指针和指针函数" class="headerlink" title="三、函数指针和指针函数"></a>三、函数指针和指针函数</h2><p>“指针函数”和“函数指针”也是两个常见的容易混淆的概念。让我们来详细解释它们的定义和区别：</p><h3 id="1-函数指针"><a href="#1-函数指针" class="headerlink" title="1. 函数指针"></a>1. 函数指针</h3><p>函数指针是一个指针变量，它指向一个函数。函数指针可以被用来调用指向的函数，也可以被用来作为参数传递给其他函数。函数指针的定义和使用如下：</p><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>return_type (*pointer_name)(parameter_list);</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">greeting</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">void</span> (*func_ptr)() = greeting; <span class="comment">// 定义一个函数指针并将其初始化为greeting函数的地址</span></span><br><span class="line">     func_ptr(); <span class="comment">// 调用通过函数指针指向的函数</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，func_ptr 是一个指向 greeting 函数的函数指针。</p><h3 id="2-指针函数（Pointer-Function）"><a href="#2-指针函数（Pointer-Function）" class="headerlink" title="2. 指针函数（Pointer Function）"></a>2. 指针函数（Pointer Function）</h3><p>“指针函数”是一个通常造成混淆的术语，实际上是指返回指针的函数。指针函数的定义和使用如下：</p><h4 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h4><p>return_type* function_name(parameter_list);</p><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">get_value</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">static</span> <span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line">     <span class="keyword">return</span> &amp;value;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> *val_ptr = get_value(); <span class="comment">// 调用返回指针的函数</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Value: %d\n&quot;</span>, *val_ptr); <span class="comment">// 解引用指针来获取值</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，get_value 是一个返回整数指针的函数，也就是所谓的“指针函数”。</p><h3 id="区别与联系："><a href="#区别与联系：" class="headerlink" title="区别与联系："></a>区别与联系：</h3><ol><li><strong>函数指针</strong>是一个变量，它存储了一个函数的地址，可以被用来间接调用这个函数。</li><li><strong>指针函数</strong>是一个函数，它返回一个指针。</li><li>两者的主要区别在于，一个是变量（指向函数的指针），而另一个是函数（返回指针）。</li><li>它们都涉及到指针的概念，但在实践中用于不同的目的和场景。</li></ol><p>希望这能帮到你！</p><h1 id="指针常量和常量指针"><a href="#指针常量和常量指针" class="headerlink" title="指针常量和常量指针"></a><strong>指针常量和常量指针</strong></h1><h2 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h2><h3 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h3><p> 又叫常指针，可以理解为常量的指针，也即这个是指针，但指向的是个常量，这个常量是指针的值（地址），而不是地址指向的值。</p><h3 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h3><p>1.常量指针指向的对象不能通过这个指针来修改，可是仍然可以通过原来的声明修改；</p><p>2.常量指针可以被赋值为变量的地址，之所以叫常量指针，是限制了通过这个指针修改变量的值；</p><p>3.指针还可以指向别处，因为指针本身只是个变量，可以指向任意地址；</p><h3 id="代码形式："><a href="#代码形式：" class="headerlink" title="代码形式："></a>代码形式：</h3><p>int const* p;  const int* p;</p><h2 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h2><h3 id="定义：-3"><a href="#定义：-3" class="headerlink" title="定义："></a>定义：</h3><p>本质是一个常量，而用指针修饰它。指针常量的值是指针，这个值因为是常量，所以不能被赋值。</p><h3 id="关键点：-1"><a href="#关键点：-1" class="headerlink" title="关键点："></a>关键点：</h3><p>1.它是个常量！</p><p>2.指针本身是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化；</p><h3 id="代码形式：-1"><a href="#代码形式：-1" class="headerlink" title="代码形式："></a>代码形式：</h3><p>int* const p;</p><p>指向常量的常指针</p><p>定义：指向常量的指针常量就是一个常量，且它指向的对象也是一个常量。</p><p>代码形式：</p><p>const int* const p;</p><p>那如何区分这几类呢? 带两个const的肯定是指向常量的常指针，很容易理解，主要是如何区分常量指针和指针常量:</p><p>一种方式是看 * 和 const 的排列顺序，比如</p><p>int const* p;    &#x2F;&#x2F;const * 即常量指针</p><p>const int* p;    &#x2F;&#x2F;const * 即常量指针</p><p>int* const p;    &#x2F;&#x2F;* const 即指针常量</p><p>还一种方式是看const离谁近，即从右往左看，比如</p><p>int const* p;    &#x2F;&#x2F;const修饰的是<em>p，即</em>p的内容不可通过p改变，但p不是const，p可以修改，*p不可修改；</p><p>const int* p;    &#x2F;&#x2F;同上</p><p>const int* const p;  &#x2F;&#x2F;*P 和p都不可修改</p><p>int* const p;    &#x2F;&#x2F;const修饰的是p，p是指针，p指向的地址不能修改，p不能修改，但*p可以修改；</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>&#x2F;&#x2F;——-常量指针——-</p><p>const int *p1 &#x3D; &a;</p><p>a &#x3D; 300;     &#x2F;&#x2F;OK,仍然可以通过原来的声明修改值，</p><p>&#x2F;&#x2F;*p1 &#x3D; 56;  &#x2F;&#x2F;Error,*p1是const int的，不可修改，即常量指针不可修改其指向地址</p><p>p1 &#x3D; &b;     &#x2F;&#x2F;OK,指针还可以指向别处，因为指针只是个变量，可以随意指向；</p><p>&#x2F;&#x2F;——-指针常量——-&#x2F;&#x2F;</p><p>int*  const p2 &#x3D; &a;</p><p>a &#x3D; 500;     &#x2F;&#x2F;OK,仍然可以通过原来的声明修改值，</p><p>*p2 &#x3D; 400;   &#x2F;&#x2F;OK,指针是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化</p><p>&#x2F;&#x2F;p2 &#x3D; &b;     &#x2F;&#x2F;Error,因为p2是const 指针，因此不能改变p2指向的内容</p><p>&#x2F;&#x2F;——-指向常量的常量指针——-&#x2F;&#x2F;</p><p>const int* const p3 &#x3D; &a;</p><p>&#x2F;&#x2F;*p3 &#x3D; 1;    &#x2F;&#x2F;Error</p><p>&#x2F;&#x2F;p3 &#x3D; &b;    &#x2F;&#x2F;Error</p><p>a &#x3D; 5000;    &#x2F;&#x2F;OK,仍然可以通过原来的声明修改值</p><p>在实际应用中，常量指针要比指针常量用的多，比如常量指针经常用在函数传参中，以避免函数内部修改内容。</p><p>size_t strlen(const char* src); &#x2F;&#x2F;常量指针，src的值不可改变；</p><p>char a[] &#x3D; “hello”;</p><p>char b[] &#x3D; “world”;</p><p>size_t a1 &#x3D; strlen(a);</p><p>size_t b1 &#x3D; strlen(b);</p><p>虽然a、b是可以修改的，但是可以保证在strlen函数内部不会修改a、b的内容。</p><p>1.一个指针常量，指向的是一个指针对象；</p><p>2.它指向的指针对象且是一个常量，即它指向的对象不能变化；</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/06/25/test/RS485%E5%92%8Cmodbus/"/>
      <url>/2025/06/25/test/RS485%E5%92%8Cmodbus/</url>
      
        <content type="html"><![CDATA[<p>RS485鏄竴绉嶇‖浠舵帴鍙ｆ爣鍑嗭紝鎻愪緵宸垎淇″彿浼犺緭鏂瑰紡锛屽叿鏈夐暱璺濈锛堝彲杈?200绫筹級銆佹姉骞叉壈鑳藉姏寮哄拰澶氱偣閫氫俊锛堟渶澶?2涓妭鐐癸級鐨勭壒鐐广€傚畠瀹氫箟浜嗚澶囦箣闂寸殑鐗╃悊杩炴帴鏂瑰紡锛屼絾涓嶆秹鍙婂叿浣撶殑鏁版嵁鍗忚銆?</p><p>Modbus鏄竴绉嶅簲鐢ㄥ眰鍗忚锛岃瀹氫簡璁惧闂寸殑鏁版嵁浼犺緭鏍煎紡鍜屾搷浣滆鍒欙紝鏀寔澶氱鐗堟湰锛堝RTU銆乀CP锛夛紝涓昏瀹炵幇涓讳粠閫氫俊妯″紡銆傚畠渚濊禆浜嶳S485绛夌墿鐞嗘帴鍙ｈ繘琛屾暟鎹紶杈擄紝浣嗕篃鍙互鍦ㄥ叾浠栨帴鍙ｄ笂瀹炵幇銆?</p><p>涓よ€呯殑鍏崇郴鏄細RS485浣滀负鐗╃悊鍩虹锛屼负Modbus鎻愪緵浜嗙‖浠惰繛鎺ュ獟浠嬶紱鑰孧odbus鍒欏湪RS485涔嬩笂锛屽疄鐜版爣鍑嗗寲鐨勬暟鎹€氫俊鍜岃澶囦簰鎿嶄綔銆?</p><p>鍦ㄥ疄闄呭簲鐢ㄤ腑锛屽父瑙佺殑缁勫悎鏄細璁惧閫氳繃RS485鎺ュ彛杩炴帴锛屽啀鍒╃敤Modbus鍗忚杩涜鏁版嵁浜ゆ崲銆傝繖绉嶅崗鍚屽伐浣滄瀬澶х畝鍖栦簡宸ヤ笟鑷姩鍖栫郴缁熺殑闆嗘垚涓庣淮鎶わ紝鎻愬崌浜嗙郴缁熺殑鍙潬鎬у拰鎵╁睍鎬с€?</p><p>绠€鑰岃█涔嬶紝RS485鏄‖浠跺熀纭€锛孧odbus鏄€氫俊鍗忚锛屼簩鑰呴厤鍚堝疄鐜板伐涓氳澶囩殑楂樻晥銆佸彲闈犻€氫俊銆傜悊瑙ｅ畠浠殑鍖哄埆鍜屽崗浣滄柟寮忥紝鏈夊姪浜庝紭鍖栧伐涓氳嚜鍔ㄥ寲鎺у埗鏂规銆?</p><h1 id="娓╂箍搴︿紶鎰熷櫒鎬庝箞璋冭瘯"><a href="#娓╂箍搴︿紶鎰熷櫒鎬庝箞璋冭瘯" class="headerlink" title="娓╂箍搴︿紶鎰熷櫒鎬庝箞璋冭瘯"></a>娓╂箍搴︿紶鎰熷櫒鎬庝箞璋冭瘯</h1><p>娓╂箍搴︿紶鎰熷櫒浣滀负鐜颁唬鐜鐩戞祴绯荤粺涓笉鍙垨缂虹殑涓€閮ㄥ垎锛屽叾鍑嗙‘鎬у拰绋冲畾鎬х洿鎺ュ奖鍝嶅埌鏁版嵁鐨勫彲闈犳€т笌鍚庣画鍒嗘瀽鐨勭簿鍑嗗害銆傚洜姝わ紝姝ｇ‘鐨勮皟璇曡繃绋嬪浜庣‘淇濅紶鎰熷櫒鎬ц兘鑷冲叧閲嶈銆備互涓嬪皢璇︾粏浠嬬粛娓╂箍搴︿紶鎰熷櫒璋冭瘯鐨勬楠ゃ€佹敞鎰忎簨椤瑰強甯歌闂瑙ｅ喅鏂规锛屽府鍔╃敤鎴烽珮鏁堝畬鎴愯皟璇曞伐浣溿€?</p><p>娓╂箍搴︿紶鎰熷櫒鎬庝箞璋冭瘯</p><p>銆€銆€涓€銆佽皟璇曞墠鍑嗗</p><p>銆€銆€1. 妫€鏌ヨ澶囧畬鏁存€?</p><p>銆€銆€- 纭繚娓╂箍搴︿紶鎰熷櫒鍙婂叾閰嶄欢(濡傝繛鎺ョ嚎銆佸浐瀹氭敮鏋剁瓑)瀹屽ソ鏃犳崯锛屾棤鏄庢樉鐨勭墿鐞嗘崯浼ゆ垨鑵愯殌銆?</p><p>銆€銆€- 妫€鏌ヤ紶鎰熷櫒鍨嬪彿涓庢墍闇€搴旂敤鍦烘櫙鏄惁鍖归厤锛岀‘淇濈簿搴︺€佹祴閲忚寖鍥寸瓑鍙傛暟绗﹀悎闇€姹傘€?</p><p>銆€銆€2. 闃呰骞剁悊瑙ｈ鏄庝功</p><p>銆€銆€- 浠旂粏闃呰浼犳劅鍣ㄩ檮甯︾殑浣跨敤璇存槑涔︼紝浜嗚В浼犳劅鍣ㄧ殑鍩烘湰鍙傛暟銆佹€ц兘鎸囨爣銆佹帴绾挎柟寮忓強璋冭瘯姝ラ銆?</p><p>銆€銆€- 娉ㄦ剰璇存槑涔︿腑鐨勫畨鍏ㄨ绀猴紝纭繚璋冭瘯杩囩▼涓殑浜鸿韩瀹夊叏鍙婅澶囧畨鍏ㄣ€?</p><p>銆€銆€3. 鍑嗗璋冭瘯宸ュ叿</p><p>銆€銆€- 鍑嗗蹇呰鐨勮皟璇曞伐鍏凤紝濡備竾鐢ㄨ〃銆佺ず娉㈠櫒(瀵逛簬楂樼骇璋冭瘯)銆佹爣鍑嗘俯婀垮害婧?鏍″噯鐢?绛夈€?</p><p>銆€銆€- 纭繚鎵€鏈夊伐鍏峰潎鍦ㄦ湁鏁堟湡鍐咃紝骞舵牎鍑嗚嚦鍑嗙‘鐘舵€併€?</p><p>浜屻€佺‖浠惰繛鎺ヤ笌妫€鏌?</p><p>銆€銆€1. 鎺ョ嚎</p><p>銆€銆€- 鎸夌収璇存槑涔︿腑鐨勬帴绾垮浘姝ｇ‘杩炴帴浼犳劅鍣ㄤ笌鏁版嵁閲囬泦绯荤粺鎴栨樉绀鸿澶囥€傛敞鎰忓尯鍒嗙數婧愮嚎銆佷俊鍙风嚎鍙婂彲鑳界殑鎺ュ湴绾匡紝閬垮厤鎺ラ敊銆?</p><p>銆€銆€- 浣跨敤缁濈紭鑳跺甫鎴栫嚎鏉熷浐瀹氬ソ鎺ョ嚎锛岄槻姝㈡澗鍔ㄦ垨鐭矾銆?</p><p>銆€銆€2. 渚涚數妫€鏌?</p><p>銆€銆€- 纭浼犳劅鍣ㄤ緵鐢电數鍘嬬鍚堣鏍艰姹傦紝浣跨敤涓囩敤琛ㄦ祴閲忕數婧愮數鍘嬶紝纭繚绋冲畾涓旀棤娉㈠姩銆?</p><p>銆€銆€- 瑙傚療浼犳劅鍣ㄦ寚绀虹伅(濡傛灉鏈夌殑璇?锛岀‘璁ゅ叾姝ｅ父宸ヤ綔鐘舵€併€?</p><p>涓夈€佽蒋浠堕厤缃笌璋冭瘯</p><p>銆€銆€1. 鍒濆鍖栬缃?</p><p>銆€銆€- 閫氳繃鏁版嵁閲囬泦杞欢鎴栨帶鍒剁郴缁燂紝瀵逛紶鎰熷櫒杩涜鍒濆鍖栬缃紝鍖呮嫭鍦板潃閰嶇疆(瀵逛簬鏀寔澶氫紶鎰熷櫒缃戠粶鐨勭郴缁?銆侀噰鏍烽鐜囥€佹祴閲忚寖鍥寸瓑銆?</p><p>銆€銆€- 璁惧畾鎶ヨ闃堝€硷紝浠ヤ究鍦ㄦ俯婀垮害瓒呭嚭姝ｅ父鑼冨洿鏃跺強鏃跺彂鍑鸿鎶ャ€?</p><p>銆€銆€2. 闈欐€佹牎鍑?</p><p>銆€銆€- 浣跨敤鏍囧噯娓╂箍搴︽簮(濡傛亽娓╂亽婀跨)浣滀负鍙傝€冿紝灏嗕紶鎰熷櫒缃簬鍏朵腑锛岃缃爣鍑嗘俯婀垮害鍊笺€?</p><p>銆€銆€- 绛夊緟浼犳劅鍣ㄧǔ瀹氬悗锛岃鍙栧苟璁板綍鍏惰緭鍑哄€硷紝涓庢爣鍑嗗€艰繘琛屾瘮杈冿紝璋冩暣浼犳劅鍣ㄥ唴閮ㄧ殑鏍″噯鍙傛暟锛岀洿鑷宠緭鍑哄€兼帴杩戞垨绛変簬鏍囧噯鍊笺€?</p><p>銆€銆€3. 鍔ㄦ€佹祴璇?</p><p>銆€銆€- 鍦ㄤ笉鍚屾俯婀垮害鏉′欢涓嬪浼犳劅鍣ㄨ繘琛屽姩鎬佹祴璇曪紝瑙傚療鍏跺搷搴旈€熷害銆佺ǔ瀹氭€у強绮惧害銆?</p><p>鍦ㄦ垜鐨勯」鐩腑锛屾垜鍩轰簬**STM32F103C8T6鍗曠墖鏈?*锛岄泦鎴?*TJA1050-CAN閫氫俊妯″潡**涓?*DS18B20娓╁害浼犳劅鍣?*锛屾惌寤轰簡瀹屾暣鐨凜AN鎬荤嚎娓╁害閲囬泦鎶ヨ绯荤粺銆?</p><p>*<em>鍏蜂綋鍋氭硶濡備笅锛?</em><br>棣栧厛锛屾垜鍒╃敤STM32F103C8T6鐨勫己澶у鐞嗚兘鍔涳紝瀹炵幇DS18B20澶氱偣娓╁害鏁版嵁閲囬泦銆傞€氳繃TJA1050妯″潡锛屽皢閲囬泦鍒扮殑娓╁害鏁版嵁瀹炴椂鎵撳寘鎴怌AN鎶ユ枃锛屾寜鐓ц瀹氱殑鑺傜偣ID鏈夊簭鍙戦€佸埌鎬荤嚎銆傜郴缁熻蒋浠跺眰闈紝鎴戣璁′簡娓╁害闃堝€煎垽鏂拰澶氱骇鎶ヨ閫昏緫锛岀‘淇濅竴鏃︽煇璺俯搴﹁秴闄愶紝鑳界珛鍗宠Е鍙戝０鍏夋姤璀︼紝鍚屾椂灏嗘姤璀︿俊鎭€氳繃CAN鎬荤嚎骞挎挱銆?<br>涓烘柟渚胯皟璇曚笌鏁版嵁鍒嗘瀽锛屾垜杩橀€氳繃USB-TTL锛圕H340锛夋ā鍧楀皢STM32涓插彛鏁版嵁瀹炴椂涓婁紶鑷崇數鑴戯紝閰嶅悎涓插彛璋冭瘯鍔╂墜杩涜鏁版嵁鐩戞帶鍜岀郴缁熷弬鏁拌皟鏁淬€?</p><p>*<em>椤圭洰鎴愭灉锛?</em><br>璇ョ郴缁熸姇鍏ョ幇鍦哄悗锛屾俯搴﹀紓甯告娴嬪噯纭巼鎻愬崌鑷?9%锛屾姤璀﹀搷搴旀椂闂寸缉鐭?0%锛屾湁鏁堥槻姝簡璁惧杩囩儹瀵艰嚧鐨勫仠鏈哄拰鎹熷潖锛屾樉钁楁彁鍗囦簡璁惧杩愯鐨勫畨鍏ㄦ€т笌绋冲畾鎬с€</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/06/16/test/BSP%E5%A4%A7%E4%BD%9C%E4%B8%9A/"/>
      <url>/2025/06/16/test/BSP%E5%A4%A7%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<p>BSP澶т綔涓?</p><p> [BSP鍓嶇疆鍩瑰吇澶т綔涓?pdf](H:\123\鏂板缓鏂囦欢澶筡WeChat Files\wxid_m7uts4kc8omo22\FileStorage\TempFromPhone\BSP鍓嶇疆鍩瑰吇澶т綔涓?pdf) </p><h1 id="铏氭嫙鏈洪厤缃甎buntu20-04"><a href="#铏氭嫙鏈洪厤缃甎buntu20-04" class="headerlink" title="铏氭嫙鏈洪厤缃甎buntu20.04"></a>铏氭嫙鏈洪厤缃甎buntu20.04</h1><p><a href="https://www.bilibili.com/video/BV1DcoFYaEVq/?spm_id_from=333.337.top_right_bar_window_custom_collection.content.click&vd_source=390e7ea253547d9c75882d502ff42a1b">铏氭嫙鏈洪厤缃甎buntu20.04鏂版墜鍏ㄦ祦绋嬨€愬叾浠栫郴缁熺増鏈畨瑁呭悓鐞嗐€慱鍝斿摡鍝斿摡_bilibili</a></p><p>鎼缓qemu</p><p><a href="https://www.bilibili.com/video/BV1ZKwCe1EyY/?spm_id_from=333.337.search-card.all.click&vd_source=390e7ea253547d9c75882d502ff42a1b">鏃犻渶寮€鍙戞澘锛?鍒嗛挓閫氳繃qemu鎼缓宓屽叆寮弆inux鑷鐜_鍝斿摡鍝斿摡_bilibili</a></p><p>閰嶇疆瀹屽悗 </p><p>瀹夎qemu </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.qemu.org/qemu-9.2.4.tar.xz</span><br></pre></td></tr></table></figure><p> 瑙ｅ帇</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xJf qemu-9.2.4.tar.xz.tar.xz</span><br></pre></td></tr></table></figure><p> 鎶ラ敊   瀹夎gcc  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_38393271/article/details/141347415">ubuntu20.04婧愮爜缂栬瘧瀹夎qemu锛坬emu8.2锛塤either install ensurepip, or alleviate the need fo-CSDN鍗氬</a></p><p>瀹夎涓€浜涘熀纭€閰嶇疆</p><p><a href="https://zhuanlan.zhihu.com/p/642830339">(35 灏佺淇?&#x2F; 14 鏉℃秷鎭? qemu婧愮爜缂栬瘧锛堝畬鏁村浘鏂囨暀绋嬶級 - 鐭ヤ箮</a></p><p><img src="H:/Hexo-Blog/blog-demo/source/images/image-20250612135929025.png" alt="image-20250612135929025"></p><p><img src="H:/Hexo-Blog/blog-demo/source/images/image-20250612135943560.png" alt="image-20250612135943560"></p><h1 id="vscode-bear-clangd瀹炵幇闃呰浠g爜绮惧噯璺宠浆"><a href="#vscode-bear-clangd瀹炵幇闃呰浠g爜绮惧噯璺宠浆" class="headerlink" title="vscode+bear+clangd瀹炵幇闃呰浠ｇ爜绮惧噯璺宠浆"></a>vscode+bear+clangd瀹炵幇闃呰浠ｇ爜绮惧噯璺宠浆</h1><p>鏈夊叾浠栫増鏈悧 杩欎釜鏂囦欢澶?</p><p>1鎴戝凡缁忓噯澶囧ソ浜? 澶ф闇€瑕佸涔?宸茬粡鍦ㄧ紪璇戜簡</p><p>2涔熷噯澶囧ソ浜?</p><p>3.缂栬瘧瀹屾垚浜? qumu宸茬粡鍚姩浜?</p><p>  鍋氫竴涓惎鍔ㄦ枃浠舵妸  鍦ㄨ繖</p><p>qumu鍦?home&#x2F;linqiutian&#x2F;workspace&#x2F;</p><p>鍚姩鑴氭湰 鏂瑰紡</p><p>qemu-system-aarch64 <br>    -machine virt <br>    -cpu cortex-a57 <br>    -m 2G <br>    -kernel &#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;linux&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;Image <br>    -initrd &#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;initramfs_arm64.img <br>    -append “console&#x3D;ttyAMA0 root&#x3D;&#x2F;dev&#x2F;ram rdinit&#x3D;&#x2F;sbin&#x2F;init” <br>    -fsdev local,id&#x3D;fsdev0,path&#x3D;&#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;hello,security_model&#x3D;none <br>    -device virtio-9p-pci,fsdev&#x3D;fsdev0,mount_tag&#x3D;hostshare <br>    -nographic</p><p>鎸傝浇鍏变韩绌洪棿</p><p>mkdir -p &#x2F;mnt&#x2F;share<br>mount -t 9p -o trans&#x3D;virtio,version&#x3D;9p2000.L hostshare &#x2F;mnt&#x2F;share</p><p>涓轰簡姝ｇ‘缂栬瘧椹卞姩妯″潡锛屾垜闇€瑕佺煡閬換EMU铏氭嫙鏈轰腑v5.10鍐呮牳鐨勬簮浠ｇ爜璺緞銆傝鎻愪緵浠ヤ笅淇℃伅锛?</p><ol><li>QEMU铏氭嫙鏈轰腑v5.10鍐呮牳婧愪唬鐮佺殑瀹屾暣璺緞  &#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;linux</li></ol><p>鏄鍦╭emu make 杩樻槸鍦ㄨ繖閲宮ake</p><p>鍦ㄤ富鏈虹幆澧冧负浠€涔堣缂栬瘧鍐呮牳鐜锛?</p><h1 id="QEMU鍏变韩鏂囦欢澶硅缃畬鏁存祦绋"><a href="#QEMU鍏变韩鏂囦欢澶硅缃畬鏁存祦绋" class="headerlink" title="QEMU鍏变韩鏂囦欢澶硅缃畬鏁存祦绋?"></a>QEMU鍏变韩鏂囦欢澶硅缃畬鏁存祦绋?</h1><ol><li><p>涓绘満绔噯澶?</p></li><li><p>鍒涘缓鍏变韩鐩綍锛?</p></li></ol><p>mkdir -p &#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;qemu_shared<br>cp -r &#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;helloDev&#x2F;*&#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;qemu_shared&#x2F;</p><ol start="2"><li>鍑嗗QEMU鍚姩鍛戒护锛?</li></ol><p>qemu-system-x86_64 <br>    -kernel &#x2F;path&#x2F;to&#x2F;vmlinuz-5.10 <br>    -initrd &#x2F;path&#x2F;to&#x2F;initrd.img <br>    -append “root&#x3D;&#x2F;dev&#x2F;sda1 console&#x3D;ttyS0” <br>    -hda &#x2F;path&#x2F;to&#x2F;qemu-image.qcow2 <br>    -fsdev local,id&#x3D;share_dev,path&#x3D;&#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;qemu_shared,security_model&#x3D;none <br>    -device virtio-9p-pci,fsdev&#x3D;share_dev,mount_tag&#x3D;hostshare <br>    -nographic<br>娉ㄦ剰锛氳鏇挎崲&#x2F;path&#x2F;to&#x2F;涓哄疄闄呯殑璺緞銆?</p><ol start="2"><li><p>QEMU铏氭嫙鏈哄唴閮ㄦ搷浣?</p></li><li><p>鐧诲綍QEMU鍚庡垱寤烘寕杞界偣锛?</p></li></ol><p>mkdir -p &#x2F;mnt&#x2F;hostshare<br>2. 鎸傝浇鍏变韩鏂囦欢澶癸細</p><p>mount -t 9p -o trans&#x3D;virtio,version&#x3D;9p2000.L hostshare &#x2F;mnt&#x2F;hostshare<br>3. 楠岃瘉鎸傝浇锛?</p><p>ls &#x2F;mnt&#x2F;hostshare<br>3. 缂栬瘧鍐呮牳妯″潡</p><ol><li>杩涘叆鍏变韩鐩綍锛?</li></ol><p>cd &#x2F;mnt&#x2F;hostshare<br>2. 娓呯悊涔嬪墠鐨勭紪璇戯紙濡傛湁闇€瑕侊級锛?</p><p>make clean<br>3. 缂栬瘧妯″潡锛?</p><p>make<br>4. 浣跨敤璇存槑</p><ol><li><p>涓绘満绔慨鏀规枃浠朵細鑷姩鍚屾鍒癚EMU涓?</p></li><li><p>缂栬瘧鐢熸垚鐨?ko鏂囦欢涔熶細鍑虹幇鍦ㄤ富鏈虹殑鍏变韩鐩綍涓?</p></li><li><p>鍗歌浇鍏变韩鏂囦欢澶癸紙閫€鍑篞EMU鍓嶏級锛?</p></li></ol><p>umount &#x2F;mnt&#x2F;hostshare3</p><p>&#x2F;mnt&#x2F;hostshare # mknod &#x2F;dev&#x2F;hello_dev c 511 0<br>&#x2F;mnt&#x2F;hostshare # chmod 666 &#x2F;dev&#x2F;hello_dev<br>&#x2F;mnt&#x2F;hostshare # echo “Test message” &gt; &#x2F;dev&#x2F;hello_dev<br>[  624.427209] Hello device opened<br>sh: write error: Invalid argument<br>[  624.437116] Hello device closed<br>&#x2F;mnt&#x2F;hostshare # dmesg | tail<br>[    0.969666]   with arguments:<br>[    0.969690]     &#x2F;sbin&#x2F;init<br>[    0.969712]   with environment:<br>[    0.969730]     HOME&#x3D;&#x2F;<br>[    0.969740]     TERM&#x3D;linux<br>[  485.529205] random: fast init done<br>[  489.339214] hello_dev: loading out-of-tree module taints kernel.<br>[  489.346637] Hello device registered with major number 511<br>[  624.427209] Hello device opened<br>[  624.437116] Hello device closed</p><p>浠庢祴璇曠粨鏋滄潵鐪嬶紝鍐呮牳妯″潡鍩烘湰宸ヤ綔姝ｅ父锛屼絾瀛樺湪涓€涓棶棰橈細</p><ol><li>鎴愬姛閮ㄥ垎锛?</li></ol><p>璁惧鑺傜偣鍒涘缓鎴愬姛 (&#x2F;dev&#x2F;hello_dev)<br>妯″潡姝ｇ‘鍝嶅簲浜唎pen&#x2F;close鎿嶄綔<br>涓昏澶囧彿511姝ｇ‘娉ㄥ唽<br>2. 闂閮ㄥ垎锛?</p><p>鍐欏叆鏃跺嚭鐜癐nvalid argument閿欒<br>杩欒〃鏄庨┍鍔ㄧ▼搴忕殑write鎿嶄綔娌℃湁姝ｇ‘澶勭悊杈撳叆<br>3. 鍘熷洜鍒嗘瀽锛?</p><p>鍙兘鏄┍鍔ㄤ腑娌℃湁瀹炵幇write鎿嶄綔<br>鎴栬€厀rite鎿嶄綔杩斿洖浜嗛敊璇€?<br>涔熷彲鑳芥槸缂撳啿鍖哄鐞嗘湁闂<br>4. 瑙ｅ喅鏂规锛?</p><p>闇€瑕佹鏌ラ┍鍔ㄤ唬鐮佷腑鐨剋rite鍑芥暟瀹炵幇<br>纭繚姝ｇ‘澶勭悊鐢ㄦ埛绌洪棿鏁版嵁</p><h1 id="闇€瑕佷娇qemu鏈塺oot鏉冮檺锛屾墍浠ュ湪鍚姩鏃堕渶瑕-浣库饯sudo鍚姩-arm64-root鍚姩"><a href="#闇€瑕佷娇qemu鏈塺oot鏉冮檺锛屾墍浠ュ湪鍚姩鏃堕渶瑕-浣库饯sudo鍚姩-arm64-root鍚姩" class="headerlink" title="闇€瑕佷娇qemu鏈塺oot鏉冮檺锛屾墍浠ュ湪鍚姩鏃堕渶瑕?                       浣库饯sudo鍚姩  arm64   root鍚姩"></a>闇€瑕佷娇qemu鏈塺oot鏉冮檺锛屾墍浠ュ湪鍚姩鏃堕渶瑕?                       浣库饯sudo鍚姩  arm64   root鍚姩</h1><p>sudo qemu-system-aarch64 <br>    -M virt <br>    -cpu cortex-a53 <br>    -kernel &#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;linux&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;Image.gz <br>    -initrd &#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;initramfs_arm64.img <br>    -nographic <br>    -serial mon:stdio <br>    -append “console&#x3D;ttyAMA0” <br>    -fsdev local,security_model&#x3D;passthrough,id&#x3D;fsdev0,path&#x3D;&#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;qemu_shared <br>    -device virtio-9p-pci,id&#x3D;fs0,fsdev&#x3D;fsdev0,mount_tag&#x3D;hostshare</p><p>2.0</p><p>sudo qemu-system-aarch64 <br>    -M virt <br>    -cpu cortex-a53 <br>    -kernel &#x2F;home&#x2F;wangbeiy&#x2F;workspace&#x2F;linux&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;Image.gz <br>    -initrd &#x2F;home&#x2F;wangbeiy&#x2F;workspace&#x2F;initramfs_arm64.img <br>    -nographic <br>    -serial mon:stdio <br>    -append “console&#x3D;ttyAMA0” <br>    -fsdev local,security_model&#x3D;passthrough,id&#x3D;fsdev0,path&#x3D;&#x2F;home&#x2F;wangbeiy&#x2F;workspace&#x2F;qemu_shared <br>    -device virtio-9p-pci,id&#x3D;fs0,fsdev&#x3D;fsdev0,mount_tag&#x3D;hostshare</p><h1 id="guest鍚姩鍚庨渶瑕佲伎鍔╩ount璇ュ叡浜浆褰"><a href="#guest鍚姩鍚庨渶瑕佲伎鍔╩ount璇ュ叡浜浆褰" class="headerlink" title="guest鍚姩鍚庨渶瑕佲伎鍔╩ount璇ュ叡浜浆褰?"></a>guest鍚姩鍚庨渶瑕佲伎鍔╩ount璇ュ叡浜浆褰?</h1><p>鍒涘缓涓撶敤鎸傝浇鐐圭洰褰曪細</p><p>mkdir &#x2F;hostshare<br>2. 鎸傝浇瀹夸富鏈哄叡浜洰褰曪細</p><p>mount -t 9p -o trans&#x3D;virtio,version&#x3D;9p2000.L hostshare &#x2F;hostshare<br>3. 楠岃瘉鎸傝浇鏄惁鎴愬姛锛?</p><p>ls &#x2F;hostshare</p><p>瑕佽В鍐冲唴鏍搁厤缃棶棰橈紝璇锋寜鐓т互涓嬫楠ゆ搷浣滐細</p><ol><li>棣栧厛杩涘叆鍐呮牳婧愪唬鐮佺洰褰曪細</li></ol><p>cd &#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;linux<br>2. 鐢熸垚鍐呮牳閰嶇疆鏂囦欢锛堜娇鐢ㄥ綋鍓嶈繍琛屽唴鏍哥殑閰嶇疆锛夛細</p><p>make ARCH&#x3D;arm64 CROSS_COMPILE&#x3D;aarch64-linux-gnu- oldconfig<br>3. 鍑嗗鍐呮牳缂栬瘧鐜锛?</p><p>make ARCH&#x3D;arm64 CROSS_COMPILE&#x3D;aarch64-linux-gnu- prepare<br>4. 鐜板湪鍙互杩斿洖妯″潡鐩綍閲嶆柊缂栬瘧锛?</p><p>cd &#x2F;path&#x2F;to&#x2F;module<br>make ARCH&#x3D;arm64 CROSS_COMPILE&#x3D;aarch64-linux-gnu- -C &#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;linux M&#x3D;$PWD modules</p><ol start="5"><li>濡傛灉浠嶇劧閬囧埌閰嶇疆闂锛屽彲鑳介渶瑕侊細</li></ol><p>浠庤繍琛屼腑鐨勫唴鏍歌幏鍙栭厤缃細<br>zcat &#x2F;proc&#x2F;config.gz &gt; &#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;linux&#x2F;.config<br>鎴栦娇鐢ㄩ粯璁ら厤缃細<br>make ARCH&#x3D;arm64 CROSS_COMPILE&#x3D;aarch64-linux-gnu- defconfig<br>娉ㄦ剰锛氳繖浜涙搷浣滈渶瑕佸湪鍐呮牳婧愪唬鐮佺洰褰曟湁鍐欐潈闄愩€?</p><p>insmod helloDev.ko<br>[ 1108.216925] helloDev: loading out-of-tree module taints kernel.<br>[ 1108.225087] Hello: Module loaded successfully! Major number: 511<br>[ 1108.225324] Hello: Create device file with: mknod &#x2F;dev&#x2F;hello_dev c 511 0</p><p>. 妯″潡宸叉垚鍔熷姞杞斤紝鏄剧ず”Module loaded successfully”鍜屼富璁惧鍙?11</p><ol start="2"><li><p>鍐呮牳鏃ュ織鎻愮ず闇€瑕佸垱寤鸿澶囨枃浠?</p></li><li><p>娴嬭瘯姝ラ闇€瑕侊細</p></li></ol><p>鍒涘缓璁惧鑺傜偣<br>娴嬭瘯璁惧璁块棶<br>楠岃瘉妯″潡鍔熻兘<br>4. 瑙ｅ喅鏂规锛?</p><p>鎻愪緵瀹屾暣鐨勮澶囨祴璇曟祦绋?<br>鍖呮嫭璇诲啓娴嬭瘯鏂规硶<br>鎭枩妯″潡鍔犺浇鎴愬姛锛佷互涓嬫槸瀹屾暣鐨勬祴璇曟楠わ細</p><ol><li>棣栧厛鍒涘缓璁惧鑺傜偣锛?</li></ol><p>sudo mknod &#x2F;dev&#x2F;hello_dev c 511 0<br>sudo chmod 666 &#x2F;dev&#x2F;hello_dev</p><ol start="2"><li>鍩烘湰璁惧鏂囦欢娴嬭瘯锛?</li></ol><p>ls -l &#x2F;dev&#x2F;hello_dev  # 搴旀樉绀篶rw-rw-rw-鏉冮檺<br>file &#x2F;dev&#x2F;hello_dev   # 搴旀樉绀哄瓧绗﹁澶囨枃浠?</p><ol start="3"><li>娴嬭瘯璁惧璇诲啓锛堟牴鎹偍鐨勯┍鍔ㄥ疄鐜帮級锛?</li></ol><h1 id="鍐欏叆娴嬭瘯"><a href="#鍐欏叆娴嬭瘯" class="headerlink" title="鍐欏叆娴嬭瘯"></a>鍐欏叆娴嬭瘯</h1><p>echo “test message” &gt; &#x2F;dev&#x2F;hello_dev</p><h1 id="璇诲彇娴嬭瘯"><a href="#璇诲彇娴嬭瘯" class="headerlink" title="璇诲彇娴嬭瘯"></a>璇诲彇娴嬭瘯</h1><p>cat &#x2F;dev&#x2F;hello_dev<br>4. 妫€鏌ュ唴鏍告棩蹇楋細</p><p>dmesg | tail -n 10</p><h1 id="搴旇鑳界湅鍒伴┍鍔ㄥ鐞嗚鍐欐搷浣滅殑鏃ュ織"><a href="#搴旇鑳界湅鍒伴┍鍔ㄥ鐞嗚鍐欐搷浣滅殑鏃ュ織" class="headerlink" title="搴旇鑳界湅鍒伴┍鍔ㄥ鐞嗚鍐欐搷浣滅殑鏃ュ織"></a>搴旇鑳界湅鍒伴┍鍔ㄥ鐞嗚鍐欐搷浣滅殑鏃ュ織</h1><ol start="5"><li>鍘嬪姏娴嬭瘯锛堝彲閫夛級锛?</li></ol><h1 id="杩炵画鍐欏叆娴嬭瘯"><a href="#杩炵画鍐欏叆娴嬭瘯" class="headerlink" title="杩炵画鍐欏叆娴嬭瘯"></a>杩炵画鍐欏叆娴嬭瘯</h1><p>for i in {1..10}; do echo “test $i” &gt; &#x2F;dev&#x2F;hello_dev; done</p><h1 id="杩炵画璇诲彇娴嬭瘯"><a href="#杩炵画璇诲彇娴嬭瘯" class="headerlink" title="杩炵画璇诲彇娴嬭瘯"></a>杩炵画璇诲彇娴嬭瘯</h1><p>for i in {1..10}; do cat &#x2F;dev&#x2F;hello_dev; done<br>6. 娴嬭瘯瀹屾垚鍚庢竻鐞嗭細</p><p>sudo rm &#x2F;dev&#x2F;hello_dev<br>sudo rmmod helloDev</p><h1 id="浜ゅ弶缂栬瘧"><a href="#浜ゅ弶缂栬瘧" class="headerlink" title="浜ゅ弶缂栬瘧"></a>浜ゅ弶缂栬瘧</h1><p>褰撳墠宸茬煡淇℃伅锛?</p><p>鐩爣锛氱紪璇戝苟鍔犺浇helloDev.ko鍐呮牳妯″潡<br>绯荤粺鏋舵瀯锛欰RM64 (aarch64)<br>鍐呮牳鐗堟湰锛?.10.0<br>妯″潡婧愪唬鐮佷綅缃細~&#x2F;workspace&#x2F;helloDev&#x2F;<br>4. 闇€瑕侀噰鍙栫殑姝ラ锛?</p><p>娓呯悊涔嬪墠鐨勭紪璇戝皾璇?<br>浠庡熀纭€姝ラ寮€濮嬫寚瀵?<br>纭繚姣忎竴姝ラ兘娓呮櫚鍙墽琛?<br>5. 瑙ｅ喅鏂规锛?</p><p>鎻愪緵浠庡ご寮€濮嬬殑瀹屾暣鎸囧<br>鍒嗘楠ら獙璇佹瘡涓幆鑺傚綋鍓嶅凡鐭ヤ俊鎭細</p><p>鐩爣锛氱紪璇戝苟鍔犺浇helloDev.ko鍐呮牳妯″潡<br>绯荤粺鏋舵瀯锛欰RM64 (aarch64)<br>鍐呮牳鐗堟湰锛?.10.0<br>妯″潡婧愪唬鐮佷綅缃細~&#x2F;workspace&#x2F;helloDev&#x2F;<br>4. 闇€瑕侀噰鍙栫殑姝ラ锛?</p><p>娓呯悊涔嬪墠鐨勭紪璇戝皾璇?<br>浠庡熀纭€姝ラ寮€濮嬫寚瀵?<br>纭繚姣忎竴姝ラ兘娓呮櫚鍙墽琛?<br>5. 瑙ｅ喅鏂规锛?</p><p>鎻愪緵浠庡ご寮€濮嬬殑瀹屾暣鎸囧<br>鍒嗘楠ら獙璇佹瘡涓幆鑺?</p><ol><li>鍑嗗宸ヤ綔锛?</li></ol><h1 id="瀹夎浜ゅ弶缂栬瘧宸ュ叿閾"><a href="#瀹夎浜ゅ弶缂栬瘧宸ュ叿閾" class="headerlink" title="瀹夎浜ゅ弶缂栬瘧宸ュ叿閾?"></a>瀹夎浜ゅ弶缂栬瘧宸ュ叿閾?</h1><p>sudo apt-get install gcc-aarch64-linux-gnu</p><h1 id="杩涘叆妯″潡鐩綍"><a href="#杩涘叆妯″潡鐩綍" class="headerlink" title="杩涘叆妯″潡鐩綍"></a>杩涘叆妯″潡鐩綍</h1><p>cd ~&#x2F;workspace&#x2F;helloDev</p><h1 id="娓呯悊涔嬪墠鐨勭紪璇戠粨鏋"><a href="#娓呯悊涔嬪墠鐨勭紪璇戠粨鏋" class="headerlink" title="娓呯悊涔嬪墠鐨勭紪璇戠粨鏋?"></a>娓呯悊涔嬪墠鐨勭紪璇戠粨鏋?</h1><p>make clean<br>3. 璁剧疆鐜鍙橀噺锛?</p><p>export ARCH&#x3D;arm64<br>export CROSS_COMPILE&#x3D;aarch64-linux-gnu-<br>4. 缂栬瘧妯″潡锛?</p><p>make -C &#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;linux M&#x3D;$(pwd) modules<br>5. 楠岃瘉缁撴灉锛?</p><h1 id="妫€鏌ョ敓鎴愮殑妯″潡"><a href="#妫€鏌ョ敓鎴愮殑妯″潡" class="headerlink" title="妫€鏌ョ敓鎴愮殑妯″潡"></a>妫€鏌ョ敓鎴愮殑妯″潡</h1><p>file helloDev.ko</p><h1 id="搴旇鏄剧ず”ARM-aarch64”鏋舵瀯"><a href="#搴旇鏄剧ず”ARM-aarch64”鏋舵瀯" class="headerlink" title="搴旇鏄剧ず”ARM aarch64”鏋舵瀯"></a>搴旇鏄剧ず”ARM aarch64”鏋舵瀯</h1><h1 id="鍔犺浇妯″潡"><a href="#鍔犺浇妯″潡" class="headerlink" title="鍔犺浇妯″潡"></a>鍔犺浇妯″潡</h1><p>sudo insmod helloDev.ko</p><h1 id="妫€鏌ユ槸鍚﹀姞杞芥垚鍔"><a href="#妫€鏌ユ槸鍚﹀姞杞芥垚鍔" class="headerlink" title="妫€鏌ユ槸鍚﹀姞杞芥垚鍔?"></a>妫€鏌ユ槸鍚﹀姞杞芥垚鍔?</h1><p>lsmod | grep helloDev<br>dmesg | tail</p><p>棣栧厛纭繚瀹夎浜咥RM64浜ゅ弶缂栬瘧宸ュ叿閾撅細</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-aarch64-linux-gnu</span><br></pre></td></tr></table></figure><p> *<em>鍏抽敭娉ㄦ剰浜嬮」锛?</em></p><p>蹇呴』浣跨敤涓庤繍琛屽唴鏍?5.10.0)瀹屽叏鐩稿悓鐨勬簮浠ｇ爜鐗堟湰<br>纭繚鍐呮牳閰嶇疆(.config)鍖归厤<br>缂栬瘧鐜鍙橀噺璁剧疆锛?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=arm64</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-</span><br></pre></td></tr></table></figure><p> 浣跨敤姝ｇ‘鐨勬灦鏋勫弬鏁伴噸鏂扮紪璇戞ā鍧楋細</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -C /home/linqiutian/workspace/linux M=$PWD modules</span><br></pre></td></tr></table></figure><p>鍦╭emu涓祴璇曞瓧绗﹂┍鍔?</p><p>  1.鍔犺浇妯″潡鍒板唴鏍革細</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insmod helloDev.ko</span><br></pre></td></tr></table></figure><ol start="2"><li>妫€鏌ユā鍧楀姞杞界姸鎬侊細</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep helloDev</span><br></pre></td></tr></table></figure><ol start="3"><li>鏌ョ湅妯″潡鍒濆鍖栬緭鍑猴細</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | tail -n 10</span><br></pre></td></tr></table></figure><ol start="4"><li>鍗歌浇妯″潡锛?</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rmmod helloDev</span><br></pre></td></tr></table></figure><p>妫€鏌ユā鍧楅€€鍑鸿緭鍑猴細</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | tail -n 10</span><br></pre></td></tr></table></figure><p>棣栧厛鍒涘缓璁惧鑺傜偣锛?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mknod /dev/hello_dev c 511 0</span><br><span class="line">chmod 666 /dev/hello_dev</span><br></pre></td></tr></table></figure><p>鍩烘湰璁惧鏂囦欢娴嬭瘯锛?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l /dev/hello_dev  # 搴旀樉绀篶rw-rw-rw-鏉冮檺</span><br><span class="line">file /dev/hello_dev   # 搴旀樉绀哄瓧绗﹁澶囨枃浠?</span><br></pre></td></tr></table></figure><p>娴嬭瘯璁惧璇诲啓锛堟牴鎹偍鐨勯┍鍔ㄥ疄鐜帮級锛?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 鍐欏叆娴嬭瘯</span><br><span class="line">echo &quot;test message&quot; &gt; /dev/hello_dev</span><br><span class="line"># 璇诲彇娴嬭瘯</span><br><span class="line">cat /dev/hello_dev</span><br></pre></td></tr></table></figure><p>妫€鏌ュ唴鏍告棩蹇楋細</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | tail -n 10</span><br></pre></td></tr></table></figure><p>娴嬭瘯瀹屾垚鍚庢竻鐞嗭細</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm /dev/hello_dev</span><br><span class="line">rmmod helloDev</span><br></pre></td></tr></table></figure><p>杩愯娴嬭瘯绋嬪簭</p><p>棣栧厛鍦ㄤ富鏈轰笂浜ゅ弶缂栬瘧test.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aarch64-linux-gnu-gcc -static -o test test.c</span><br><span class="line">file test  # 纭杈撳嚭涓篈RM aarch64鏋舵瀯</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>灏嗙紪璇戝ソ鐨勭▼搴忎紶杈撳埌QEMU涓細</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp test /qemu_shared/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">./test</span><br><span class="line">[  627.996160] Hello: Device opened</span><br><span class="line">[  627.996437] Hello: Received 22 characters from the user: Hello from user space!</span><br><span class="line">Wrote to device: Hello from user space!</span><br><span class="line">[  628.001305] Hello: Sent 22 characters to the user</span><br><span class="line">Read from device: Hello from user space!</span><br><span class="line">Data verification successful</span><br><span class="line">[  628.002348] Hello: Device closed</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>娴嬭瘯绋嬪簭test宸叉垚鍔熻繍琛岋紝骞朵笌鍐呮牳妯″潡helloDev浜や簰</p><ol start="2"><li>浠庡唴鏍告棩蹇楀彲瑙佸畬鏁寸殑璁惧鎿嶄綔娴佺▼锛?</li></ol><p>璁惧鎵撳紑<br>鐢ㄦ埛绌洪棿鍐欏叆鏁版嵁<br>椹卞姩鎺ユ敹骞跺洖浼犳暟鎹?<br>璁惧鍏抽棴<br>3. 娴嬭瘯缁撴灉鏄剧ず锛?</p><p>鍐欏叆鍜岃鍙栨搷浣滈兘鎴愬姛瀹屾垚<br>鏁版嵁楠岃瘉閫氳繃锛岃〃鏄庨┍鍔ㄥ姛鑳芥甯?<br>4. 缁撹锛?</p><p>椹卞姩妯″潡helloDev.ko宸ヤ綔姝ｅ父<br>娴嬭瘯绋嬪簭test楠岃瘉浜嗛┍鍔ㄧ殑瀹屾暣鍔熻兘<br>娴嬭瘯缁撴灉鍒嗘瀽锛?</p><p>鉁?椹卞姩妯″潡鍔熻兘楠岃瘉鎴愬姛锛?</p><ol><li>璁惧鎿嶄綔娴佺▼瀹屾暣锛?</li></ol><p>鎵撳紑璁惧 (open)<br>鍐欏叆鏁版嵁 (write)<br>璇诲彇鏁版嵁 (read)<br>鍏抽棴璁惧 (close)<br>2. 鏁版嵁娴侀獙璇侊細</p><p>鐢ㄦ埛绌洪棿鍐欏叆: “Hello from user space!”<br>椹卞姩姝ｇ‘鎺ユ敹: 22瀛楃<br>椹卞姩姝ｇ‘鍥炰紶鐩稿悓鏁版嵁<br>鐢ㄦ埛绌洪棿鎴愬姛璇诲彇骞堕獙璇佹暟鎹?</p><ol start="3"><li>鍐呮牳鏃ュ織鏄剧ず锛?</li></ol><p>[  627.996160] Hello: Device opened<br>[  627.996437] Hello: Received 22 chars<br>[  628.001305] Hello: Sent 22 chars<br>[  628.002348] Hello: Device closed<br>4. 鐢ㄦ埛绌洪棿杈撳嚭锛?</p><p>Wrote to device: Hello from user space!<br>Read from device: Hello from user space!<br>Data verification successful</p><h1 id="鍦║buntu20-04铏氭嫙鏈轰腑鍔犺浇锛坕nsmod锛夊瓧绗﹁澶囬┍鍔紝骞垛饯杩愨緩饨も季娴嬭瘯绋嬪簭杩涒緩娴嬭瘯"><a href="#鍦║buntu20-04铏氭嫙鏈轰腑鍔犺浇锛坕nsmod锛夊瓧绗﹁澶囬┍鍔紝骞垛饯杩愨緩饨も季娴嬭瘯绋嬪簭杩涒緩娴嬭瘯" class="headerlink" title="鍦║buntu20.04铏氭嫙鏈轰腑鍔犺浇锛坕nsmod锛夊瓧绗﹁澶囬┍鍔紝骞垛饯杩愨緩饨も季娴嬭瘯绋嬪簭杩涒緩娴嬭瘯"></a>鍦║buntu20.04铏氭嫙鏈轰腑鍔犺浇锛坕nsmod锛夊瓧绗﹁澶囬┍鍔紝骞垛饯杩愨緩饨も季娴嬭瘯绋嬪簭杩涒緩娴嬭瘯</h1><p>鍏堟墽琛屾竻鐞? 閲嶆柊缂栬瘧</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean &amp;&amp; make all</span><br></pre></td></tr></table></figure><h2 id="鍔犺浇妯″潡锛歴udo-insmod-helloDev-ko"><a href="#鍔犺浇妯″潡锛歴udo-insmod-helloDev-ko" class="headerlink" title="鍔犺浇妯″潡锛歴udo insmod helloDev.ko"></a>鍔犺浇妯″潡锛歴udo insmod helloDev.ko</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo insmod helloDev.ko</span><br></pre></td></tr></table></figure><h2 id="鍒涘缓璁惧鑺傜偣锛歴udo-mknod-dev-hello-dev-c-major-0-major鍙蜂細鍦ㄥ姞杞芥椂鎵撳嵃"><a href="#鍒涘缓璁惧鑺傜偣锛歴udo-mknod-dev-hello-dev-c-major-0-major鍙蜂細鍦ㄥ姞杞芥椂鎵撳嵃" class="headerlink" title="鍒涘缓璁惧鑺傜偣锛歴udo mknod &#x2F;dev&#x2F;hello_dev c [major] 0 (major鍙蜂細鍦ㄥ姞杞芥椂鎵撳嵃)"></a>鍒涘缓璁惧鑺傜偣锛歴udo mknod &#x2F;dev&#x2F;hello_dev c [major] 0 (major鍙蜂細鍦ㄥ姞杞芥椂鎵撳嵃)</h2><p> 浠巇mesg杈撳嚭鍙互鐪嬪埌鍐呮牳妯″潡宸叉垚鍔熷姞杞斤紝涓昏澶囧彿涓?37</p><p>妯″潡鏈熸湜鐢ㄦ埛鎵嬪姩鍒涘缓璁惧鑺傜偣锛歮knod &#x2F;dev&#x2F;hello_dev c 237 0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mknod /dev/hello_dev c 237 0</span><br></pre></td></tr></table></figure><p>璁剧疆閫傚綋鐨勬潈闄?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 666 /dev/hello_dev</span><br></pre></td></tr></table></figure><h2 id="浣跨敤test鍜寃rite绋嬪簭娴嬭瘯璁惧"><a href="#浣跨敤test鍜寃rite绋嬪簭娴嬭瘯璁惧" class="headerlink" title="浣跨敤test鍜寃rite绋嬪簭娴嬭瘯璁惧"></a>浣跨敤test鍜寃rite绋嬪簭娴嬭瘯璁惧</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./test</span><br></pre></td></tr></table></figure><dl><dt>sudo .&#x2F;read<br>open file error<br>: No such file or directory<br>linqiutian@ubuntu:~&#x2F;workspace&#x2F;hello$ sudo .&#x2F;write<br>open file error</dt><dd>No such file or directory</dd></dl><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mknod /dev/hello c 237 0 &amp;&amp; sudo chmod 666 /dev/hello</span><br></pre></td></tr></table></figure><h1 id="helloDev-Linux瀛楃璁惧椹卞姩妯″潡"><a href="#helloDev-Linux瀛楃璁惧椹卞姩妯″潡" class="headerlink" title="helloDev - Linux瀛楃璁惧椹卞姩妯″潡"></a>helloDev - Linux瀛楃璁惧椹卞姩妯″潡</h1><h2 id="椤圭洰姒傝堪"><a href="#椤圭洰姒傝堪" class="headerlink" title="椤圭洰姒傝堪"></a>椤圭洰姒傝堪</h2><p>杩欐槸涓€涓畝鍗曠殑Linux瀛楃璁惧椹卞姩妯″潡锛屽疄鐜颁簡鍩烘湰鐨勮澶囨搷浣滄帴鍙?open, read, write, close)銆備富瑕佺敤浜庡涔犲拰婕旂ずLinux璁惧椹卞姩寮€鍙戙€?</p><h2 id="涓昏鏂囦欢"><a href="#涓昏鏂囦欢" class="headerlink" title="涓昏鏂囦欢"></a>涓昏鏂囦欢</h2><ul><li><code>helloDev.c</code>: 涓婚┍鍔ㄤ唬鐮侊紝瀹炵幇璁惧鎿嶄綔</li><li><code>Makefile</code>: 鏋勫缓鑴氭湰</li><li><code>test.c</code>: 缁煎悎娴嬭瘯绋嬪簭</li><li><code>read.c</code>: 璇诲彇璁惧绀轰緥</li><li><code>write.c</code>: 鍐欏叆璁惧绀轰緥</li></ul><h2 id="鏋勫缓鍜屽畨瑁"><a href="#鏋勫缓鍜屽畨瑁" class="headerlink" title="鏋勫缓鍜屽畨瑁?"></a>鏋勫缓鍜屽畨瑁?</h2><ol><li>纭繚宸插畨瑁匧inux鍐呮牳澶存枃浠?</li><li>鎵ц鏋勫缓鍛戒护:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li><li>鍔犺浇鍐呮牳妯″潡:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> insmod helloDev.ko</span><br></pre></td></tr></table></figure></li><li>鍒涘缓璁惧鑺傜偣:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mknod</span> /dev/hello c 250 0</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 666 /dev/hello</span><br></pre></td></tr></table></figure>(娉ㄦ剰: 涓昏澶囧彿250鍙兘闇€瑕佹牴鎹郴缁熻皟鏁?</li></ol><h2 id="浣跨敤绀轰緥"><a href="#浣跨敤绀轰緥" class="headerlink" title="浣跨敤绀轰緥"></a>浣跨敤绀轰緥</h2><h3 id="鍐欏叆鏁版嵁"><a href="#鍐欏叆鏁版嵁" class="headerlink" title="鍐欏叆鏁版嵁"></a>鍐欏叆鏁版嵁</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc write.c -o write</span><br><span class="line">./write</span><br></pre></td></tr></table></figure><h3 id="璇诲彇鏁版嵁"><a href="#璇诲彇鏁版嵁" class="headerlink" title="璇诲彇鏁版嵁"></a>璇诲彇鏁版嵁</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc read.c -o <span class="built_in">read</span></span><br><span class="line">./read</span><br></pre></td></tr></table></figure><h3 id="缁煎悎娴嬭瘯"><a href="#缁煎悎娴嬭瘯" class="headerlink" title="缁煎悎娴嬭瘯"></a>缁煎悎娴嬭瘯</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o <span class="built_in">test</span></span><br><span class="line">./test</span><br></pre></td></tr></table></figure><h2 id="鍗歌浇妯″潡"><a href="#鍗歌浇妯″潡" class="headerlink" title="鍗歌浇妯″潡"></a>鍗歌浇妯″潡</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> rmmod helloDev</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /dev/hello</span><br></pre></td></tr></table></figure><h2 id="娉ㄦ剰浜嬮」"><a href="#娉ㄦ剰浜嬮」" class="headerlink" title="娉ㄦ剰浜嬮」"></a>娉ㄦ剰浜嬮」</h2><ol><li>闇€瑕乺oot鏉冮檺鍔犺浇&#x2F;鍗歌浇妯″潡</li><li>纭繚涓昏澶囧彿涓嶄笌绯荤粺鍏朵粬璁惧鍐茬獊</li><li>娴嬭瘯绋嬪簭鍙兘闇€瑕佹牴鎹疄闄呯郴缁熻皟鏁</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/06/02/test/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/06/02/test/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="git瀛︿範绗旇"><a href="#git瀛︿範绗旇" class="headerlink" title="git瀛︿範绗旇"></a>git瀛︿範绗旇</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式软件调试</title>
      <link href="/2025/06/01/test/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95/"/>
      <url>/2025/06/01/test/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="宓屽叆寮忚蒋浠惰皟璇曠悊璁哄熀纭€"><a href="#宓屽叆寮忚蒋浠惰皟璇曠悊璁哄熀纭€" class="headerlink" title="宓屽叆寮忚蒋浠惰皟璇曠悊璁哄熀纭€"></a>宓屽叆寮忚蒋浠惰皟璇曠悊璁哄熀纭€</h1><h2 id="鈥-浠€涔堟槸杞欢璋冭瘯锛"><a href="#鈥-浠€涔堟槸杞欢璋冭瘯锛" class="headerlink" title="鈥?浠€涔堟槸杞欢璋冭瘯锛?"></a>鈥?浠€涔堟槸杞欢璋冭瘯锛?</h2><p>鈥?鑻辨枃software debug锛屽張璇戣蒋浠朵睛閿?</p><p>鈥?杞欢璋冭瘯杩囩▼锛屽氨鏄彂鐜拌蒋浠跺け鏁堬紝瀹氫綅杞欢閿欒骞跺皢鍏朵慨澶嶇殑杩囩▼</p><p><img src="/images/image-20250602155046456-1748851517687-1.png" alt="image-20250602155046456"></p><h3 id="杞欢璋冭瘯鐨勯噸瑕佹€"><a href="#杞欢璋冭瘯鐨勯噸瑕佹€" class="headerlink" title="杞欢璋冭瘯鐨勯噸瑕佹€?"></a>杞欢璋冭瘯鐨勯噸瑕佹€?</h3><p>鈥?鎹粺璁★細杞欢璋冭瘯銆?debug鏃堕棿涓€鑸崰杞欢寮€鍙戝懆鏈熺殑50%浠ヤ笂锛屾槸杞欢寮€鍙戜腑鑰楁椂鏈€澶氱殑涓€椤规椿鍔?</p><p>鈥?寰堝椤圭洰寤舵湡锛屽線寰€灏辨牻鍦ㄤ笉鑳藉畾浣嶇殑bug涓娿€?</p><p>鈥?闅忕潃杞欢銆佺郴缁熻秺鏉ヨ秺澶嶆潅锛岃蒋浠惰皟璇曟妧鏈渶瑕佷笌杞欢宸ョ▼銆佸紑鍙戞妧鏈悓姝ュ崌绾?</p><p>鈥?杞欢璋冭瘯鐞嗚鍜岀煡璇嗗皻鏈郴缁熷寲锛屽緢澶氬紑鍙戣€呭鍏跺熀鏈師鐞嗙煡涔嬬敋灏戯紝涓嶈兘鏍规嵁瀹為檯鎯呭喌铻嶄細璐€氬湴鍘讳娇鐢ㄥ悇绉嶈皟璇曟妧宸э紝瀵逛簬澶嶆潅闂銆丅UG寰€寰€涓€绛硅帿灞曘€佹棤鑳戒负鍔? </p><h3 id="杞欢璋冭瘯鐨勭壒鐐"><a href="#杞欢璋冭瘯鐨勭壒鐐" class="headerlink" title="杞欢璋冭瘯鐨勭壒鐐?"></a>杞欢璋冭瘯鐨勭壒鐐?</h3><p>鈥?鏄竴椤瑰叿鏈夋寫鎴樻€с€佸緢寮烘妧宸ф€х殑宸ヤ綔<br>鈥?澶嶆潅搴﹂珮銆侀毦搴﹀ぇ锛屽繀椤婚€氳繃鐜拌薄锛屽ぇ閲忕殑鍒嗘瀽锛屾墠鑳介€愭鎺?<br>杩戠湡鐩革紝鐘瑰绂忓皵鎽╂柉鎺㈡锛屾姄浣忚洓涓濋┈杩癸紝灞傚眰鎺ㄧ悊銆?<br>鈥?闇€瑕佺煡璇嗛潰骞匡細璁捐鍒扮‖浠躲€佽蒋浠躲€佹搷浣滅郴缁熴€佺紪璇戝櫒绛夈€?<br>鈥?鏈変簺bug鏋侀毦澶嶇幇锛屽畾浣嶅洶闅俱€?<br>鈥?鏄竴椤逛笉鍙楁杩庣殑宸ヤ綔<br>鈥?瀵瑰績鐞嗗奖鍝嶏細<br>鈥?鎵撳嚮浜虹殑鑷俊銆佹秷纾ㄥ伐浣滅儹鎯呫€佽€冮獙浜虹殑鑰愬績鍜屾姉鍘嬭兘鍔涖€?<br>鎬€鐤戜汉鐢熴€佹€€鐤戣嚜宸辨槸涓嶆槸杩欏潡鏂欌€?<br>鈥?瀵圭敓鐞嗗奖鍝嶏細<br>鈥?鑴炬皵鏆磋簛銆佷笂鐏€佸彛鑵旀簝鐤°€佸け鐪犫€?</p><h3 id="宓屽叆寮忚蒋浠惰皟璇曠壒鐐"><a href="#宓屽叆寮忚蒋浠惰皟璇曠壒鐐" class="headerlink" title="宓屽叆寮忚蒋浠惰皟璇曠壒鐐?"></a>宓屽叆寮忚蒋浠惰皟璇曠壒鐐?</h3><p>鈥?璋冭瘯鐜鍜岃繍琛岀幆澧冧笉鍦ㄤ竴涓钩鍙颁笂锛屽<br>鍔犱簡璋冭瘯鐨勯毦搴?<br>鈥?宓屽叆寮忚澶囧線寰€娌℃湁杈撳嚭銆佹墦鍗扮粓绔紝閬?<br>鍒伴棶棰橈紝鍙兘鐪嬫棩蹇?<br>鈥?鑰冭檻闂杩樿鑰冭檻纭欢闂銆佹椂搴忛棶棰橈紝<br>闇€瑕佽蒋纭欢缁撳悎鍘绘€濊€冮棶棰橈紝澧炲姞浜嗚皟璇?<br>鐨勯毦搴?</p><h3 id="杞欢璋冭瘯涓€浜涘弬鑰冪粡楠"><a href="#杞欢璋冭瘯涓€浜涘弬鑰冪粡楠" class="headerlink" title="杞欢璋冭瘯涓€浜涘弬鑰冪粡楠?"></a>杞欢璋冭瘯涓€浜涘弬鑰冪粡楠?</h3><p>鈥?瀵绘壘绫讳技鐨刡ug锛屼竴浜涘父瑙佺殑鍑洪敊鍦烘櫙<br>鈥?浣跨敤鐗堟湰绠＄悊宸ュ叿鏌ョ湅鏈€杩戜唬鐮佺殑鍙樺寲<br>鈥?鎵撳嵃鏈夋椂鍊欎細澶辨晥锛氭瘮濡傚湪鎵撳嵃涔嬪墠绋嬪簭宸茬粡crash<br>鈥?灏藉彲鑳芥繁鍏ュ噯纭悊瑙ｇ郴缁熴€佷笉閫傚綋鐨勬敼鍔ㄥ彲鑳戒娇浜嬫儏鏇寸碂<br>鈥?浣撳姏涓嶆敮鏃躲€佹病鎬濊矾鏃跺彲浠ョ◢浜嬩紤鎭紝淇濇寔鍏呮矝绮惧姏<br>鈥?瀵逛簬澶氭ā鍧楃郴缁燂紝澶氭矡閫氥€佸浜ゆ祦锛岃€屼笉鏄浉浜掓帹璇?</p><h3 id="甯哥敤鐨勫祵鍏ュ紡杞欢璋冭瘯宸ュ叿"><a href="#甯哥敤鐨勫祵鍏ュ紡杞欢璋冭瘯宸ュ叿" class="headerlink" title="甯哥敤鐨勫祵鍏ュ紡杞欢璋冭瘯宸ュ叿"></a>甯哥敤鐨勫祵鍏ュ紡杞欢璋冭瘯宸ュ叿</h3><p>鈥?杞欢<br>    鈥?IAR銆?ADS&#x2F;AXD銆?Keil銆?MDK銆?RVDS銆?Eclipse銆?H-JTAG銆?Trace32<br>    鈥?GCC銆?GDB銆?KGDB銆?JDB銆?<br>    鈥?鎬ц兘鍒嗘瀽宸ュ叿銆佸唴瀛樺垎鏋愬伐鍏?<br>鈥?纭欢<br>    鈥?涓囩敤琛ㄣ€佺ず娉㈠櫒銆侀€昏緫鍒嗘瀽浠€佷豢鐪熷櫒<br>    鈥?Jlink銆?JTAG</p><h2 id="鈥-甯哥敤鐨勮蒋浠惰皟璇曟妧鏈"><a href="#鈥-甯哥敤鐨勮蒋浠惰皟璇曟妧鏈" class="headerlink" title="鈥?甯哥敤鐨勮蒋浠惰皟璇曟妧鏈?"></a>鈥?甯哥敤鐨勮蒋浠惰皟璇曟妧鏈?</h2><h3 id="杞欢璋冭瘯鎶€鏈垎绫"><a href="#杞欢璋冭瘯鎶€鏈垎绫" class="headerlink" title="杞欢璋冭瘯鎶€鏈垎绫?"></a>杞欢璋冭瘯鎶€鏈垎绫?</h3><p>鈥?鎸夌洰鏍囦唬鐮佺殑鎵ц鏂瑰紡<br>    鈥?鑴氭湰璋冭瘯銆佹墭绠¤皟璇曘€佹湰鍦拌皟璇曘€佹贩鍚堣皟璇?<br>鈥?鎸夌洰鏍囦唬鐮佺殑鎵ц妯″紡<br>    鈥?鐢ㄦ埛鎬佽皟璇曘€佸唴鏍告€佽皟璇?<br>鈥?鎸夎蒋浠舵墍澶勭殑闃舵<br>    鈥?寮€鍙戞湡璋冭瘯銆佷骇鍝佹湡璋冭瘯<br>鈥?鎸夎皟璇曞櫒鍜岃皟璇曠洰鏍囩殑鐩稿浣嶇疆<br>    鈥?鏈湴璋冭瘯銆佽繙绋嬭皟璇?</p><h3 id="鎵撳嵃"><a href="#鎵撳嵃" class="headerlink" title="鎵撳嵃"></a>鎵撳嵃</h3><p>鈥?杈撳嚭璋冭瘯淇℃伅<br>    鈥?鎵撳嵃鍑芥暟鏍堛€佸彉閲忓€?<br>    鈥?鏃ュ織銆佹枃浠惰浆鍌?</p><p>鈥?搴旂敤鍦哄悎<br>    鈥?閿欒绠€鍗曪紝鐩存帴鎵撳嵃姣斾娇鐢ㄨ皟璇曞櫒鏂逛究<br>    鈥?闅句互浣跨敤璋冭瘯鍣ㄧ殑鐜銆佹垨鑰呬娇鐢ㄨ皟璇曞櫒鏃犳硶閲嶇幇</p><h3 id="璋冭瘯鍣"><a href="#璋冭瘯鍣" class="headerlink" title="璋冭瘯鍣?"></a>璋冭瘯鍣?</h3><p>鈥?鏂偣<br>鈥?鍗曟鎵ц<br>鈥?浜嬩欢杩借釜<br>鈥?鏍堝洖婧?<br>鈥?鍙嶆眹缂?<br>鈥?瑙傚療鍜屼慨鏀瑰瘎瀛樺櫒銆佸唴瀛樻暟鎹?<br>鈥?鎺у埗琚皟璇曠殑杩涚▼鎴栫嚎绋?</p><h3 id="浣跨敤璋冭瘯鍣ㄦ湁鍝簺浼樼偣"><a href="#浣跨敤璋冭瘯鍣ㄦ湁鍝簺浼樼偣" class="headerlink" title="浣跨敤璋冭瘯鍣ㄦ湁鍝簺浼樼偣"></a>浣跨敤璋冭瘯鍣ㄦ湁鍝簺浼樼偣</h3><p>鈥?涓嶉渶瑕侀鐭ラ敊璇湪鍝噷</p><p>鈥?鏀寔鍦ㄧ嚎妫€鏌ラ敊璇紝涓嶉渶瑕佹敼浠ｇ爜銆侀噸鏂扮紪璇?</p><p>鈥?鍙互鐪嬪埌杩愯鏃剁殑鍚勭鏁版嵁锛氬彉閲忓€笺€佸瘎瀛樺櫒銆佸唴瀛樻暟鎹€?</p><p>鈥?鍗曟</p><h3 id="璋冭瘯鍣ㄨ皟璇曚竴鑸楠"><a href="#璋冭瘯鍣ㄨ皟璇曚竴鑸楠" class="headerlink" title="璋冭瘯鍣ㄨ皟璇曚竴鑸楠?"></a>璋冭瘯鍣ㄨ皟璇曚竴鑸楠?</h3><p>鈥?瀹氫綅鍑虹幇閿欒鐨勫満鏅?<br>鈥?鍒嗘瀽閿欒銆佺矖鐣ュ畾浣嶅彲鑳藉嚭閿欑殑浠ｇ爜<br>鈥?璁剧疆鍒濆鏂偣<br>鈥?寮€濮嬭皟璇曠▼搴忔垨鑰卆ttach涓€涓凡缁忚繍琛岀殑<br>绋嬪簭杩涚▼<br>鈥?鍦ㄦ柇鐐逛笂瑙傚療鏁版嵁鍚勭鏁版嵁锛氬彉閲忋€佸瘎瀛?<br>鍣ㄣ€佽皟鐢ㄦ爤銆佸弽姹囩紪锛?dump鏈夌敤鐨勬暟鎹?<br>鈥?鍗曟鎵ц銆佹洿鏂版柇鐐?<br>鈥?缁撴潫璋冭瘯鍣?</p><h2 id="鈥-甯歌鐨勯敊璇被鍨"><a href="#鈥-甯歌鐨勯敊璇被鍨" class="headerlink" title="鈥?甯歌鐨勯敊璇被鍨?"></a>鈥?甯歌鐨勯敊璇被鍨?</h2><h3 id="缂栬瘧鍨嬮敊璇"><a href="#缂栬瘧鍨嬮敊璇" class="headerlink" title="缂栬瘧鍨嬮敊璇?"></a>缂栬瘧鍨嬮敊璇?</h3><p>*<em>鈥?璇硶瑙勫垯妫€鏌?</em><br>    鈥?C璇█鐨勫熀鏈娉曘€佸叧閿瓧銆佽繍绠楃銆佽〃杈惧紡<br>*<em>鈥?涓嫳鏂囩鍙?</em><br>    鈥?鍏ㄨ銆佸崐瑙掔殑闂<br><strong>鈥?鍑芥暟闂</strong><br>    鈥?鍑芥暟澹版槑涓庡嚱鏁板畾涔変笉鍖归厤锛氬嚱鏁板弬鏁般€佽繑鍥炵被鍨?<br>    鈥?璇涓哄舰鍙傛敼鍙樹細褰卞搷瀹炲弬鐨勫€?<br>    鈥?鍑芥暟鐨勫疄鍙傚拰褰㈠弬绫诲瀷涓嶄竴鑷?<br>*<em>鈥?鍑芥暟鏈０鏄?</em><br>    鈥?鏈夋椂鍊欎竴涓獁arning涔熸槸寮曡捣杞欢澶辨晥鐨勮鍥?</p><h3 id="杩愯鏃堕敊璇"><a href="#杩愯鏃堕敊璇" class="headerlink" title="杩愯鏃堕敊璇?"></a>杩愯鏃堕敊璇?</h3><p>*<em>鈥?瀵瑰紓甯告湭鍋氬鐞?</em><br>    鈥?鎵撳紑鐨勬枃浠舵湭鎵惧埌<br>    鈥?纾佺洏绌洪棿涓嶈冻<br>    鈥?鍐呭瓨涓嶈冻<br>    鈥?缃戠粶寮傚父<br>    鈥?Scanf杈撳叆鏍煎紡銆佸繕璁板湴鍧€绗?<br><strong>鈥?鍫嗘爤婧㈠嚭</strong><br><strong>鈥?绌烘寚閽堢殑寮曠敤</strong><br>*<em>鈥?鏈垵濮嬪寲灞€閮ㄥ彉閲?</em><br><strong>鈥?鏁扮粍闂</strong><br>    鈥?鏁扮粍瓒婄晫锛?C璇█骞朵笉浼氬鏁扮粍鍋氳竟鐣屾鏌?<br>    鈥?鏁扮粍涓嬫爣<br>    鈥?娣锋穯鏁扮粍鍚嶄笌鎸囬拡鐨勫尯鍒€佹暟缁勪綔涓哄弬鏁扮殑鏃犵敤</p><h3 id="閫昏緫閿欒"><a href="#閫昏緫閿欒" class="headerlink" title="閫昏緫閿欒"></a>閫昏緫閿欒</h3><p>*<em>鈥?杩愮畻绗?</em><br>    鈥?&#x3D;鍜?&#x3D;銆?&amp;鍜?&amp;銆?|鍜寍|娣风敤<br>    鈥?杩愮畻绗︾殑浼樺厛绾у拰缁撳悎鎬?<br><strong>鈥?寰幆鏉′欢璁剧疆闂</strong><br>    鈥?鏈敞鎰廼nt銆?char绫诲瀷鐨勬暟鍊艰寖鍥达紝瀵艰嚧姝诲惊鐜?<br>    鈥?寰幆杈圭晫鎺у埗<br><strong>鈥?閾捐〃鐨勫ご灏惧垽鏂€佺┖閾捐〃澶勭悊</strong><br><strong>鈥?涓氬姟閫昏緫閿欒</strong><br><strong>鈥?姝婚攣</strong><br><strong>鈥?涓嶈壇鐨勭紪绋嬩範鎯拰浠ｇ爜椋庢牸</strong><br>    鈥?涓嶈鍔犲垎鍙风殑鍦版柟鍔犱簡鍒嗗彿鎴栬€呭皯鍔犲垎鍙?<br>    鈥?鑺辨嫭鍙峰繕璁颁娇鐢紝瀵艰嚧閿欒鐨勯€昏緫鍒嗘敮</p><h3 id="鍐呭瓨閿欒"><a href="#鍐呭瓨閿欒" class="headerlink" title="鍐呭瓨閿欒"></a>鍐呭瓨閿欒</h3><p><strong>鈥?鍐呭瓨婧㈠嚭</strong></p><p><strong>鈥?鍐呭瓨娉勯湶</strong></p><p><strong>鈥?鍐呭瓨韪╄笍</strong></p><h2 id="鈥-Debug鏂囦欢鍜宺elease鏂囦欢鐨勫尯鍒"><a href="#鈥-Debug鏂囦欢鍜宺elease鏂囦欢鐨勫尯鍒" class="headerlink" title="鈥?Debug鏂囦欢鍜宺elease鏂囦欢鐨勫尯鍒?"></a>鈥?Debug鏂囦欢鍜宺elease鏂囦欢鐨勫尯鍒?</h2><p>*<em>鐩爣鏂囦欢鐨勯摼鎺ヨ繃绋?</em>  </p><p><img src="/images/image-20250602171053466.png" alt="image-20250602171053466"></p><p><strong>鍙墽琛屾枃浠剁殑杩愯</strong>  </p><p><img src="/images/image-20250602171121938.png" alt="image-20250602171121938" style="zoom: 80%;"><img src="/images/image-20250602171127068.png" alt="image-20250602171127068"></p><h3 id="鈥-璋冭瘯绗﹀彿"><a href="#鈥-璋冭瘯绗﹀彿" class="headerlink" title="鈥?璋冭瘯绗﹀彿"></a><strong>鈥?璋冭瘯绗﹀彿</strong></h3><p> <strong>浠€涔堟槸璋冭瘯绗﹀彿</strong></p><img src="/images/image-20250602172035917.png" alt="image-20250602172035917" style="zoom:67%;">    鈥?浜岃繘鍒朵唬鐮佷笌婧愮▼搴忚仈绯荤殑妗ユ    鈥?寰堝璋冭瘯蹇呴』渚濊禆璋冭瘯绗﹀彿鎵嶈兘宸ヤ綔    鈥?濡?婧愪唬鐮佺骇璋冭瘯銆?鏍堝洖婧€佹寜鍚嶇О鏄剧ず鍙橀噺绛?**鈥?鐢熸垚杩囩▼**    鈥?鍦ㄧ紪璇戣繃绋嬩腑锛岀紪璇戝櫒浠庢簮鏂囦欢鏀堕泦璋冭瘯淇℃伅渚涘紑鍙戣€呰皟璇曚娇鐢?    鈥?杩欎簺淇℃伅浠ヨ〃鏍煎舰寮忚褰曞湪绗﹀彿琛ㄤ腑锛屾槸瀵规簮绋嬪簭鐨勬鎷?    鈥?鍖呮嫭鍙橀噺銆佺被鍨嬨€佸嚱鏁般€佹爣鍙峰拰婧愪唬鐮佽绛夈€?**鈥?瀛樺偍鏂瑰紡**    鈥?鐢辩紪璇戝櫒鏀堕泦鍜屾彁鐐煎悗锛屽啀鐢遍摼鎺ュ櫒鎴栬€呬笓闂ㄥ伐鍏蜂繚瀛樺埌璋冭瘯绗?鍙锋枃浠朵腑銆?<p>鈥?鈥?璋冭瘯绗﹀彿鍙瓨鍌ㄥ湪鍗曠嫭鐨勬枃浠讹紝涔熷彲涓庣洰鏍囨枃浠跺叡浜竴涓枃浠?</p><h3 id="鈥-璋冭瘯淇℃伅鐨勫瓨鍌ㄦ牸寮"><a href="#鈥-璋冭瘯淇℃伅鐨勫瓨鍌ㄦ牸寮" class="headerlink" title="*鈥?璋冭瘯淇℃伅鐨勫瓨鍌ㄦ牸寮?"></a>*<em>鈥?璋冭瘯淇℃伅鐨勫瓨鍌ㄦ牸寮?</em></h3><p><strong>鈥?COFF鏍煎紡</strong><br>    鈥?浜岃繘鍒舵牸寮忥紝鐢ㄦ潵瀛樺偍鍙墽琛屾槧鍍忔枃浠躲€佺洰鏍囨枃浠躲€佸簱鏂囦欢<br><strong>鈥?CodeView鏍煎紡</strong><br>    鈥?涓嶮SC缂栬瘧鍣ㄤ竴璧蜂娇鐢ㄧ殑璋冭瘯鍣?<br>    鈥?CV鏍煎紡鐨勮皟璇曚俊鎭彲浠ヤ笌鏄犲儚鏂囦欢淇濆瓨鍦ㄤ竴璧凤紝涔熷彲鍗曠嫭瀛樻斁<br><strong>鈥?PDB鏍煎紡</strong><br>    鈥?PDB鏍煎紡鐨勮皟璇曚俊鎭渶鍗曠嫭瀛樺偍鍦ㄤ竴涓枃浠朵腑<br>    鈥?濡俈C++6.0涓殑.pdb鏂囦欢<br><strong>鈥?DWARF鏍煎紡</strong><br>    鈥?鍏紑鐨勮皟璇曚俊鎭牸寮忚鑼冿紝涓昏鐢ㄥ湪Unix銆?Linux鍙戣绯荤粺涓?<br>    鈥?GCC鍜孏DB閮芥敮鎸佽繖绉嶆牸寮?</p><h3 id="鈥-鐩爣鏂囦欢涓殑璋冭瘯淇℃伅"><a href="#鈥-鐩爣鏂囦欢涓殑璋冭瘯淇℃伅" class="headerlink" title="鈥?鐩爣鏂囦欢涓殑璋冭瘯淇℃伅"></a><strong>鈥?鐩爣鏂囦欢涓殑璋冭瘯淇℃伅</strong></h3><img src="/images/image-20250602172333724.png" alt="image-20250602172333724" style="zoom: 67%;"><p><strong>鈥?鐩爣鏂囦欢</strong><br>    鈥?缂栬瘧鍣ㄧ敤鏉ュ瓨鏀剧洰鏍囦唬鐮佺殑鏂囦欢<br>    鈥?VC浣跨敤COFF鏍煎紡鏉ュ瓨鍌ㄧ洰鏍囨枃浠?<br><strong>鈥?鐩爣鏂囦欢鏍煎紡</strong><br>    鈥?鏂囦欢澶寸粨鏋?<br>    鈥?鑺傚ご閮ㄦ暟鎹粨鏋勶細<br>    鈥?涓夌鏁版嵁锛?鍘熷鏁版嵁銆?閲嶅畾浣嶄俊鎭€?琛?<br>鍙蜂俊鎭?<br>    鈥?鑺傛暟鎹箣鍚庢槸璋冭瘯绗﹀彿琛ㄥ拰瀛楃涓茶〃<br><strong>鈥?閲嶅畾浣嶄俊鎭拰琛屽彿淇℃伅</strong><br>    鈥?閲嶅畾浣嶄俊鎭細閾炬帴鍜屽姞杞芥槧鍍忔枃浠舵椂搴?<br>濡備綍淇敼鑺傛暟鎹€侀噸瀹氫綅鐨勫湴鍧€鍜屾柟娉?<br>    鈥?琛屽彿淇℃伅锛?鐢ㄦ潵鎻忚堪婧愪唬鐮佽鍜岀洰鏍囦唬<br>鐮佺殑瀵瑰簲鍏崇郴</p><h3 id="鈥-浣跨敤GCC缂栬瘧debug鐩爣鏂囦欢"><a href="#鈥-浣跨敤GCC缂栬瘧debug鐩爣鏂囦欢" class="headerlink" title="鈥?浣跨敤GCC缂栬瘧debug鐩爣鏂囦欢"></a><strong>鈥?浣跨敤GCC缂栬瘧debug鐩爣鏂囦欢</strong></h3><p><img src="/images/image-20250602172457464.png" alt="image-20250602172457464"></p><h2 id="鈥-鏂偣鍜屽崟姝ユ槸鎬庝箞瀹炵幇鐨"><a href="#鈥-鏂偣鍜屽崟姝ユ槸鎬庝箞瀹炵幇鐨" class="headerlink" title="鈥?鏂偣鍜屽崟姝ユ槸鎬庝箞瀹炵幇鐨?"></a>鈥?鏂偣鍜屽崟姝ユ槸鎬庝箞瀹炵幇鐨?</h2><h3 id="鈥-CPU瀵硅皟璇曠殑鏀寔"><a href="#鈥-CPU瀵硅皟璇曠殑鏀寔" class="headerlink" title="鈥?CPU瀵硅皟璇曠殑鏀寔"></a><strong>鈥?CPU瀵硅皟璇曠殑鏀寔</strong></h3><p><strong>鈥?CPU鎸囦护鍜屾寚浠ら泦</strong><br>    鈥?涓烘煇涓€绫籆PU鎵€鏀寔鐨勬寚浠ら泦琚畝绉颁负鎸囦护闆?鏍规嵁鎸囦护闆嗙壒寰侊紝<br>CPU鍙垝鍒嗕负涓ゅぇ闃佃惀锛?RISC鍜孋ISC<br>    鈥?RISC锛氶€氳繃鍑忓皯鎸囦护闆嗘暟閲忓拰绠€鍖栨寚浠ゆ牸寮忔潵鎻愰珮鍜屼紭鍖朇PU鎵ц<br>鎸囦护鏁堢巼銆備緥濡傦細 ARM銆?MIPS銆?Alpha銆?SPARC銆?PowerPC<br>    鈥?CISC锛?X86绯诲垪澶勭悊鍣?</p><p><strong>鈥?CPU瀵规柇鐐硅皟璇曠殑鏀寔</strong><br>    鈥?鏀寔鏂偣璋冭瘯鎸囦护锛?INT 3鎸囦护<br>    鈥?鏍囧織瀵勫瓨鍣細 EFLAGS瀵勫瓨鍣ㄤ腑鐨凾F鏍囧織浣?<br>    鈥?1锛?CPU鎵ц瀹屼竴鏉℃寚浠ら兘浼氫骇鐢熻皟璇曞紓甯革紝 CPU杞埌<br>ISR涓幓锛屽湪璇SR涓彲浠ュ緢澶氳皟璇曟搷浣?<br>    鈥?璇ユ爣蹇楁槸瀹炵幇鍗曟璋冭瘯鐨勫熀纭€<br>    鈥?璋冭瘯瀵勫瓨鍣細 DR0~DR7<br>    鈥?JTAG鏀寔锛氬崟鐙潬杞欢鏃犳硶璋冭瘯鐨勮８鏉裤€佺郴缁焍ringup璋冭瘯</p><h3 id="鈥-鎿嶄綔绯荤粺瀵硅皟璇曠殑鏀寔"><a href="#鈥-鎿嶄綔绯荤粺瀵硅皟璇曠殑鏀寔" class="headerlink" title="鈥?鎿嶄綔绯荤粺瀵硅皟璇曠殑鏀寔"></a><strong>鈥?鎿嶄綔绯荤粺瀵硅皟璇曠殑鏀寔</strong></h3><p>*<em>鈥?鍦ㄥ唴鏍稿眰闈㈡彁渚涙敮鎸?</em><br>    鈥?鎻愪緵鏀寔杩滅▼璋冭瘯鍗忚鐨勯€氫俊妯″潡<br>    鈥?鎻愪緵鏂偣璁剧疆鍑芥暟<br>    鈥?鎻愪緵杞櫡寮傚父澶勭悊锛氳皟璇曞姛鑳?<br>*<em>鈥?瀵圭敤鎴锋€佽皟璇曞櫒鐨勬敮鎸?</em><br>    鈥?鍒涘缓璋冭瘯鐩爣鐨勭郴缁熷嚱鏁?<br>    鈥?鍦ㄨ皟璇曞惊鐜腑澶勭悊璋冭瘯浜嬩欢鐨勭郴缁熷嚱鏁?<br>    鈥?鏌ョ湅鍜屼慨鏀硅皟璇曠洰鏍囩殑绯荤粺鍑芥暟锛岃繖浜涚郴缁熷嚱鏁扮敤浜庤皟璇曚簨浠?<br>鐨勫鐞嗚繃绋嬩腑<br>    鈥?鐢ㄦ埛鎬佽皟璇曞櫒灏嗚繖浜涚郴缁熷嚱鏁颁笌鍏跺畠鍑芥暟缁撳悎璧锋潵锛屼粠鑰屾彁渚?<br>寮哄ぇ鐨勫姛鑳?</p><h3 id="鈥-鍦ㄨ皟璇曞櫒涓姞鍏ユ柇鐐"><a href="#鈥-鍦ㄨ皟璇曞櫒涓姞鍏ユ柇鐐" class="headerlink" title="*鈥?鍦ㄨ皟璇曞櫒涓姞鍏ユ柇鐐?"></a>*<em>鈥?鍦ㄨ皟璇曞櫒涓姞鍏ユ柇鐐?</em></h3><p><img src="/images/image-20250602173346493.png" alt="image-20250602173346493">.</p><h3 id="鈥-鍗曟"><a href="#鈥-鍗曟" class="headerlink" title="鈥?鍗曟"></a><strong>鈥?鍗曟</strong></h3><p><img src="/images/image-20250602173432501.png" alt="image-20250602173432501"></p><h3 id="鈥-鑾峰彇鍙橀噺鍊"><a href="#鈥-鑾峰彇鍙橀噺鍊" class="headerlink" title="*鈥?鑾峰彇鍙橀噺鍊?"></a>*<em>鈥?鑾峰彇鍙橀噺鍊?</em></h3><p> *<em>杩涚▼涓彲浠ヤ互鍦板潃鏉ユ爣璇嗗彉閲忋€佸嚱鏁帮紝浣嗕笉鐭?</em><br>*<em>閬撴瘡涓湴鍧€鐨勫惈涔夈€佸湴鍧€瀵瑰簲鐨勫悕绉?</em><br>*<em>鈥?璋冭瘯鍣ㄤ娇鐢ㄧ鍙疯〃浠庡湴鍧€鑾峰緱鍙橀噺鍚?</em><br>*<em>鈥?璋冭瘯淇℃伅鐨勫唴瀹?</em><br>    鈥?鍦板潃瀵瑰簲鐨勫彉閲忓悕銆佸嚱鏁板悕<br>    鈥?鎸囦护瀵瑰簲鐨勬簮鏂囦欢鍙婂叾琛屽彿<br>    鈥?鏁版嵁缁撴瀯鐨勪俊鎭瓑<br>*<em>鈥?璋冭瘯淇℃伅鐨勪繚瀛?</em><br>    鈥?Debug鐗堟湰绋嬪簭锛氭坊鍔犲埌鐩爣鏂囦欢涓?<br>    鈥?Release鐗堟湰锛氬崟鐙殑绗﹀彿鏂囦欢<br>        鈥?DBG鏂囦欢<br>        鈥?PDB鏂囦欢<br>        鈥?MAP鏂囦欢</p><h3 id="鈥-璇诲啓瀵勫瓨鍣"><a href="#鈥-璇诲啓瀵勫瓨鍣" class="headerlink" title="*鈥?璇诲啓瀵勫瓨鍣?"></a>*<em>鈥?璇诲啓瀵勫瓨鍣?</em></h3><p><strong>鈥?CPU瀵硅皟璇曠殑鏀寔</strong><br>    鈥?CPU鑷韩鎻愪緵鐨勬満鍒?<br>*<em>鈥?ARM缁撴瀯CPU瀵勫瓨鍣?</em><br>    鈥?JTAG鎵弿閾剧數璺?ARM 瀵勫瓨鍣?</p><p><img src="/images/image-20250602173611273.png" alt="image-20250602173611273"></p><p><img src="/images/image-20250602173614370.png" alt="image-20250602173614370"></p><h2 id="鈥-浠跨湡鍣ㄨ皟璇曞師鐞"><a href="#鈥-浠跨湡鍣ㄨ皟璇曞師鐞" class="headerlink" title="鈥?浠跨湡鍣ㄨ皟璇曞師鐞?"></a>鈥?浠跨湡鍣ㄨ皟璇曞師鐞?</h2><h3 id="鈥-宓屽叆寮忓父鐢ㄨ皟璇曟墜娈"><a href="#鈥-宓屽叆寮忓父鐢ㄨ皟璇曟墜娈" class="headerlink" title="鈥?宓屽叆寮忓父鐢ㄨ皟璇曟墜娈?"></a>鈥?宓屽叆寮忓父鐢ㄨ皟璇曟墜娈?</h3><p>*<em>鈥?杞欢妯℃嫙鍣?</em><br>    鈥?鍦≒C涓婃ā鎷熺洰鏍嘋PU骞舵墽琛岀敤鎴风洰鏍囦唬鐮併€傚ARM浠跨湡鍣細 ARM<br>armulator锛屽彲浠ユā鎷熻繍琛孉RM鎸囦护绯荤粺<br><strong>鈥?鐩爣Monitor</strong><br>    鈥?灏嗙洰鏍囦唬鐮佷笅杞藉埌鐢ㄦ埛鐩爣鏉跨殑瀛樺偍鍣ㄩ噸锛屽苟澧炲姞涓€涓猰onitor杞?<br>浠讹紝鐢ㄦ潵鐩戝惉鐢ㄦ埛鐩爣浠ｇ爜鐨勬墽琛屻€傜敤鎴烽€氳繃涓插彛绛夎皟璇曠鍙ｏ紝<br>閫氳繃PC杩涜璋冭瘯銆傚ARM鍩轰簬璋冭瘯浠ｇ悊angel鐨勮皟璇?<br>    鈥?缂虹偣锛氳€楄垂MCU銆?CPU璧勬簮銆佺洰鏍囩郴缁熷繀椤绘槸涓€涓畬鏁寸殑绯荤粺銆?<br>鏃犳硶鍦≧OM鍖鸿缃柇鐐广€佸浜庡瓨鍌ㄥ彈闄愮殑鍗曠墖鏈虹瓑骞朵笉閫傜敤<br>*<em>鈥?浠跨湡鍣?</em><br>    鈥?涓€鑸細鏈変竴涓豢鐪熷ご銆?浠ｆ浛鐩爣绯荤粺涓殑MCU銆?CPU锛?骞朵豢鐪熷叾<br>杩愯锛屽彲浠ヨ繛鎺ョ洰鏍囨澘锛岀敋鑷充笉杩炴帴閮藉彲浠ャ€?<br>    鈥?浠跨湡鍣ㄨ繍琛岃捣鏉ヨ窡瀹為檯鐨勭洰鏍囧鐞嗗櫒涓€鏍凤紝澧炲姞浜嗚皟璇曞姛鑳姐€佹敮<br>鎸佸湪绾胯皟璇?</p><h3 id="鈥-涓轰粈涔堣浣跨敤浠跨湡鍣ㄨ皟璇"><a href="#鈥-涓轰粈涔堣浣跨敤浠跨湡鍣ㄨ皟璇" class="headerlink" title="鈥?涓轰粈涔堣浣跨敤浠跨湡鍣ㄨ皟璇?"></a>鈥?涓轰粈涔堣浣跨敤浠跨湡鍣ㄨ皟璇?</h3><p>*<em>鈥?鍦ㄥ墠鏈熺‖浠堕獙璇佷笂蹇呴』浣跨敤浠跨湡鍣?鐩爣绯?</em><br><strong>缁熺‖浠朵笉瀹屾暣涔熷彲浠ヨ繍琛?</strong><br><strong>鈥?纭欢瀹為檯鎬ц兘娴嬭瘯(鐢佃矾銆佺數瀹广€佺數鎰熺瓑)</strong><br>*<em>鈥?棰濆鐨勪紭鐐?</em><br>    鈥?Monitor瑕佸崰鐢ㄩ澶栫殑瀛樺偍鍜岄€氫俊绔彛锛屼豢鐪熷櫒涓嶉渶瑕佺洰鏍囩郴<br>缁熸垨CPU璧勬簮<br>    鈥?纭欢鏂偣锛氳皟璇昍OM鎴栬€匩OR 瀛樺偍妯″紡鐨勭洰鏍囩郴缁熸鏃犲帇鍔?<br>    鈥?璺熻釜鍔熻兘锛氳兘澶熻褰曟墍鏈夌殑鍙栨寚鎿嶄綔<br>    鈥?鏉′欢瑙﹀彂<br>    鈥?瀹炴椂鏄剧ず瀛樺偍鍣ㄣ€佸唴瀛樺拰I&#x2F;O鍐呭<br>    鈥?纭欢鎬ц兘鍒嗘瀽</p><h3 id="Trace32浠跨湡鍣ㄤ粙缁"><a href="#Trace32浠跨湡鍣ㄤ粙缁" class="headerlink" title="Trace32浠跨湡鍣ㄤ粙缁?"></a>Trace32浠跨湡鍣ㄤ粙缁?</h3><p>鈥?寰峰浗Lauterbach鍏徃鐮斿彂</p><p>鈥?閫氱敤鎬э細鏇存崲浠跨湡澶村瓙鍙互璋冭瘯涓嶅悓鑺墖  </p><p><img src="/images/image-20250602174115438.png" alt="image-20250602174115438"></p><p><img src="/images/image-20250602174118600.png" alt="image-20250602174118600"></p><h3 id="鈥-浠跨湡鍣ㄨ皟璇曠殑缂虹偣"><a href="#鈥-浠跨湡鍣ㄨ皟璇曠殑缂虹偣" class="headerlink" title="鈥?浠跨湡鍣ㄨ皟璇曠殑缂虹偣"></a>鈥?浠跨湡鍣ㄨ皟璇曠殑缂虹偣</h3><p><strong>浠跨湡鍣ㄧ殑缂虹偣</strong>  </p><p>*<em>鈥?璐?</em><br>    鈥?浠跨湡鍣ㄦ湁鑷繁鐨勭洰鏍嘋PU銆?RAM鐢氳嚦ROM浠ュ強杞欢<br><strong>鈥?閫氱敤鎬у樊</strong><br>    鈥?闅忕潃CPU涓嶆柇鍙戝竷銆佸崌绾э紝闇€瑕佸悓姝ュ崌绾с€?<br>*<em>鈥?纭欢浠跨湡鏁堟灉璺熷疄闄呭鐞嗗櫒杩樻槸鏈夊樊寮?</em><br>    鈥?浠跨湡鍣ㄤ腑鐨凜PU璺熺洰鏍囩郴缁熶腑鐨凜PU鐢垫皵鐗规€т笉鍚?<br>    鈥?涓嶈兘鍙嶆槧瀹為檯鏃跺簭</p><h2 id="鈥-JTAG鍜孞LINK璋冭瘯鍘熺悊鍙婂尯鍒"><a href="#鈥-JTAG鍜孞LINK璋冭瘯鍘熺悊鍙婂尯鍒" class="headerlink" title="鈥?JTAG鍜孞LINK璋冭瘯鍘熺悊鍙婂尯鍒?"></a>鈥?JTAG鍜孞LINK璋冭瘯鍘熺悊鍙婂尯鍒?</h2><h3 id="鈥-JTAG璋冭瘯鍘熺悊"><a href="#鈥-JTAG璋冭瘯鍘熺悊" class="headerlink" title="鈥?JTAG璋冭瘯鍘熺悊"></a>鈥?JTAG璋冭瘯鍘熺悊</h3><p>*<em>鈥?娴嬭瘯鎺ュ彛鏍囧噯鍖?</em><br>    鈥?鍦ㄨ姱鐗囧唴閮ㄥ畾涔変竴涓爣鍑嗙殑娴嬭瘯璁块棶鎺ュ彛(TAP ),閫氳繃涓撶敤鐨?<br>JTAG娴嬭瘯宸ュ叿瀵硅姱鐗囧唴閮ㄨ妭鐐硅繘琛屾祴璇曞拰璋冭瘯<br><strong>鈥?JTAG(Joint Test Action Group)</strong><br>    鈥?涓€绉嶅浗闄呮爣鍑嗘祴璇曞崗璁紝涓昏鐢ㄤ簬鑺墖鍐呴儴娴嬭瘯<br>    鈥?鐩墠澶у鏁拌姱鐗囬兘鏀寔JTAG鍗忚锛?ARM銆?DSP銆?FPGA绛?<br><strong>鈥?JTAG鎺ュ彛</strong><br>    鈥?TMS锛氭祴璇曟ā寮忛€夋嫨<br>    鈥?TCK锛氭祴璇曟椂閽熻緭鍏?<br>    鈥?TDI锛?娴嬭瘯鏁版嵁杈撳叆锛屾暟鎹€氳繃TDI寮曡剼杈撳叆JTAG鎺ュ彛<br>    鈥?TDO锛氭祴璇曟暟鎹緭鍑猴紝鏁版嵁閫氳繃TDO寮曡剼浠嶫TAG鎺ュ彛杈撳嚭</p><h3 id="鈥-JTAG鎺ュ彛"><a href="#鈥-JTAG鎺ュ彛" class="headerlink" title="鈥?JTAG鎺ュ彛"></a>鈥?JTAG鎺ュ彛</h3><img src="/images/image-20250602174440435.png" alt="image-20250602174440435" style="zoom: 80%;"><img src="/images/image-20250602174445412.png" alt="image-20250602174445412" style="zoom:80%;"><img src="/images/image-20250602174447903.png" alt="image-20250602174447903" style="zoom:80%;"><p>*<em>JTAG瀹炵墿鍥?</em>  </p><p><img src="/images/image-20250602174604503.png" alt="image-20250602174604503"></p><p><img src="/images/image-20250602174607821.png" alt="image-20250602174607821"></p><p><img src="/images/image-20250602174610282.png" alt="image-20250602174610282"></p><p><img src="/images/image-20250602174713582.png" alt="image-20250602174713582"></p><h3 id="鈥-杈圭晫鎵弿鐢佃矾"><a href="#鈥-杈圭晫鎵弿鐢佃矾" class="headerlink" title="鈥?杈圭晫鎵弿鐢佃矾"></a>鈥?杈圭晫鎵弿鐢佃矾</h3><p><img src="/images/image-20250602174740245.png" alt="image-20250602174740245"></p><p><img src="/images/image-20250602174743608.png" alt="image-20250602174743608"></p><p><img src="/images/image-20250602174825904.png" alt="image-20250602174825904"></p><h3 id="鈥-娴嬭瘯璁块棶鍙AP"><a href="#鈥-娴嬭瘯璁块棶鍙AP" class="headerlink" title="鈥?娴嬭瘯璁块棶鍙AP"></a>鈥?娴嬭瘯璁块棶鍙AP</h3><p><strong>鈥?TAP</strong><br>    鈥?Test Access Port<br>    鈥?鏄竴涓€氱敤绔彛锛岄€氳繃璇ョ鍙ｅ彲浠ヨ闂暟鎹瘎瀛樺櫒鍜屾寚浠ゅ瘎瀛?<br>鍣?<br>    鈥?閫氳繃TAP鎺у埗鍣ㄦ潵瀵规暣涓猅AP绔彛鐨勬帶鍒?<br><strong>鈥?鎬荤粨</strong><br>    鈥?PC鏈哄鐩爣鏉跨殑璋冭瘯灏辨槸閫氳繃TAP鎺ュ彛瀹屾垚瀵规暟鎹瘎瀛樺櫒DR鍜?<br>鎸囦护瀵勫瓨鍣↖R鐨勮闂€?</p><h3 id="鈥-Jlink璋冭瘯鍘熺悊"><a href="#鈥-Jlink璋冭瘯鍘熺悊" class="headerlink" title="鈥?Jlink璋冭瘯鍘熺悊"></a>鈥?Jlink璋冭瘯鍘熺悊</h3><p><strong>鈥?RDI璋冭瘯鎺ュ彛</strong><br>    鈥?ARM鍏徃鎻愬嚭鐨勮皟璇曟帴鍙ｆ爣鍑嗭紝瀹炵幇璺ㄥ钩鍙扮殑纭欢璋冭瘯<br>    鈥?鍚勫ぇ璋冭瘯宸ュ叿Keil銆?ADS銆?IAR绛夐兘浣跨敤RDI鍏叡璋冭瘯鎺ュ彛<br>*<em>鈥?RDI鍛戒护鍒癑TAG鍗忚鐨勮浆鎹?</em><br>鈥?杞欢瀹炵幇<br>    鈥?鍦≒C鍐欎竴涓▼搴忥紝灏咥DS&#x2F;Keil鐨凴DI鍛戒护瑙ｆ瀽鎴怞TAG鍗忚锛岀劧鍚?<br>閫氳繃鐗╃悊杞崲鎺ュ彛(浠呬粎鏄數姘旂墿鐞嗗眰涓婄殑杞崲锛屽儚RS232)锛屽彂<br>閫佸埌鐩爣鏉裤€傚H-JTAG宸ュ叿<br>鈥?纭欢瀹炵幇<br>    鈥?鍋氫竴涓數璺澘锛岀洿鎺ユ帴鏀舵潵鑷狵eil銆?ADS绛夎蒋浠剁殑璋冭瘯鍛戒护锛岀‖<br>浠跺疄鐜癛DI鍒癑TAG鍗忚鐨勮浆鎹紝涓庣洰鏍囨澘閫氫俊銆傚Jlink绫讳技宸ュ叿<br>鈥?鐩稿浜庤蒋浠惰浆鎹紝纭欢閫熷害蹇紝鑰屼笖涓嶉渶瑕佽jtag瑙ｆ瀽杞欢</p><p>Jlink宸ュ叿瀹炵墿鍥?</p><p><img src="/images/image-20250602175114137.png" alt="image-20250602175114137"></p><h1 id="printf鍑芥暟鎵撳嵃楂橀樁鎶€宸"><a href="#printf鍑芥暟鎵撳嵃楂橀樁鎶€宸" class="headerlink" title="printf鍑芥暟鎵撳嵃楂橀樁鎶€宸?"></a>printf鍑芥暟鎵撳嵃楂橀樁鎶€宸?</h1><h2 id="鈥-杈撳嚭閲嶅畾鍚"><a href="#鈥-杈撳嚭閲嶅畾鍚" class="headerlink" title="鈥?杈撳嚭閲嶅畾鍚?"></a>鈥?杈撳嚭閲嶅畾鍚?</h2><h3 id="鈥-娴佺殑姒傚康"><a href="#鈥-娴佺殑姒傚康" class="headerlink" title="鈥?娴佺殑姒傚康"></a>鈥?娴佺殑姒傚康</h3><p><strong>鈥?绋嬪簭杈撳叆鎴栬緭鍑虹殑涓€涓繛缁殑瀛楄妭搴忓垪</strong><br>    鈥?璁惧(榧犳爣銆侀敭鐩樸€佹墦鍗版満銆佸睆骞曗€?鐨勮緭鍏ヨ緭鍑轰娇鐢ㄦ祦鏉ュ鐞?<br>*<em>鈥?鍦–璇█涓紝鎵€鏈夋祦鍧囦互鏂囦欢鐨勫舰寮忓嚭鐜?</em><br>    鈥?缁熶竴浜嗗悇绉嶇‖浠舵搷浣滄帴鍙ｅ甫鏉ョ殑宸紓<br><strong>鈥?C璇█涓彁渚涚殑5涓爣鍑嗘祦</strong></p><table><thead><tr><th>鍚嶇О</th><th>鎻忚堪</th><th>鏂囦欢鎻忚堪绗?</th><th>渚嬪瓙</th></tr></thead><tbody><tr><td>stdin</td><td>鏍囧噯杈撳叆</td><td>0</td><td>閿洏銆侀紶鏍?</td></tr><tr><td>stdout</td><td>鏍囧噯杈撳嚭</td><td>1</td><td>灞忓箷銆?LCD</td></tr><tr><td>stderr</td><td>鏍囧噯閿欒</td><td>2</td><td>灞忓箷銆?LCD</td></tr><tr><td>stdprn</td><td>鏍囧噯鎵撳嵃鏈?</td><td>LPT1绔彛</td><td></td></tr><tr><td>stdaux</td><td>鏍囧噯涓茶璁惧</td><td>COM1绔彛</td><td></td></tr></tbody></table><h3 id="鈥-鍒╃敤shell鐨処-O杩涜杈撳嚭閲嶅畾鍚"><a href="#鈥-鍒╃敤shell鐨処-O杩涜杈撳嚭閲嶅畾鍚" class="headerlink" title="鈥?鍒╃敤shell鐨処&#x2F;O杩涜杈撳嚭閲嶅畾鍚?"></a>鈥?鍒╃敤shell鐨処&#x2F;O杩涜杈撳嚭閲嶅畾鍚?</h3><p><strong>鈥?鍦↙inux涓嬶紝鏂囨湰娴佸拰浜岃繘鍒舵祦鏄浉鍚岀殑</strong><br>    鈥?鏂囨湰娴佹槸鐢辨枃鏈缁勬垚鐨勫簭鍒楋紝浠モ€橽n鈥欑粨灏?鎴栨湁鍥炶溅绗︽崲琛岀<br>浠ｆ浛)锛屼簩杩涘埗娴佺敱鏈粡澶勭悊鐨勫瓧鑺傜粍鎴?</p><p>*<em>鈥?娴佷笌鏂囦欢鐨勮繛鎺?</em><br>    鈥?鎵撳紑涓€涓祦锛岃娴佸皢涓庝竴涓枃浠惰繛鎺ヨ捣鏉ワ紝鍏抽棴娴佸垯鏂紑杩炴帴<br>    鈥?鎸囧悜璇ユ墦寮€鏂囦欢鐨勬寚閽堣褰曚簡鎺у埗璇ユ祦鐨勪俊鎭?<br>    鈥?绋嬪簭鎵ц鏃讹紝 榛樿浼氭墦寮€stdin銆?stdout鍜宻tderr涓変釜鏂囦欢<br><strong>鈥?閲嶅畾鍚戠</strong><br>    鈥?杈撳嚭閲嶅畾鍚戯細 &gt;銆?&gt;&gt;銆?&gt;!<br>    鈥?杈撳叆閲嶅畾鍚戯細 &lt;</p><ul><li>**<code>&gt;</code>**锛氬皢杈撳嚭鍐欏叆鏂囦欢锛岃鐩栧師鏈夊唴瀹广€?</li><li>**<code>&gt;&gt;</code>**锛氬皢杈撳嚭杩藉姞鍒版枃浠讹紝涓嶈鐩栧師鏈夊唴瀹广€?</li><li>**<code>&lt;</code>**锛氬皢鏂囦欢鍐呭浣滀负绋嬪簭鐨勮緭鍏ャ€?</li><li>**<code>&gt;!</code>**锛氬湪鏌愪簺shell涓敤浜庡己鍒惰鐩栨枃浠讹紙浣嗙幇浠hell閫氬父涓嶉渶瑕侊級銆?</li></ul><p>*<em>鈥?鏍囧噯閿欒閲嶅畾鍚?</em><br>    鈥?2&gt;锛氭爣鍑嗛敊璇噸瀹氬悜鍒颁竴涓枃浠讹紝骞惰鐩栧師鏉ョ殑鏂囦欢(b-shell)<br>    鈥?2&gt;&gt;锛氭爣鍑嗛敊璇噸瀹氬悜鍒颁竴涓枃浠?杩藉姞)銆?1&gt;榛樿涓?<br>    鈥?2&gt;&amp;1锛氬皢鏍囧噯閿欒閲嶅畾鍚戝埌鏍囧噯杈撳嚭<br>    鈥?&gt;&amp;锛氬皢涓€涓緭鍑洪噸瀹氬悜鍒板彟涓€涓彞鏌勭殑杈撳叆涓?<br>*<em>鈥?涓轰粈涔堣杩涜閲嶅畾鍚?</em><br>    鈥?灏嗗睆骞曡緭鍑虹殑閲嶈淇℃伅淇濆瓨涓嬫潵<br>    鈥?鏈夋椂鍊欎笉甯屾湜鎵撳嵃骞叉壈灞忓箷<br>    鈥?姝ｇ‘鍜岄敊璇殑淇℃伅闇€瑕佸垎鍒緭鍑烘椂</p><h3 id="鈥-浣跨敤freopen閲嶅畾鍚戣緭鍏ヨ緭鍑烘祦"><a href="#鈥-浣跨敤freopen閲嶅畾鍚戣緭鍏ヨ緭鍑烘祦" class="headerlink" title="鈥?浣跨敤freopen閲嶅畾鍚戣緭鍏ヨ緭鍑烘祦"></a>鈥?浣跨敤freopen閲嶅畾鍚戣緭鍏ヨ緭鍑烘祦</h3><p>*<em>鈥?杈撳嚭閲嶅畾鍚?</em></p><p><img src="/images/image-20250602182244839.png" alt="image-20250602182244839"></p><p>*<em>鈥?閿欒閲嶅畾鍚?</em></p><p><img src="/images/image-20250602182421018.png" alt="image-20250602182421018"></p><h2 id="鈥-鎵撳嵃鏂囦欢鍚嶃€佸嚱鏁板悕銆佽鍙"><a href="#鈥-鎵撳嵃鏂囦欢鍚嶃€佸嚱鏁板悕銆佽鍙" class="headerlink" title="鈥?鎵撳嵃鏂囦欢鍚嶃€佸嚱鏁板悕銆佽鍙?"></a>鈥?鎵撳嵃鏂囦欢鍚嶃€佸嚱鏁板悕銆佽鍙?</h2><p><strong>鈥?ANSIC鏍囧噯涓殑鍑犱釜鏍囧噯棰勫畾涔夊畯</strong><br>    鈥?__LINE__锛氬湪婧愪唬鐮佷腑鎻掑叆褰撳墠婧愪唬鐮佽鍙?<br>    鈥?__FILE__锛氬湪婧愭枃浠朵腑鎻掑叆褰撳墠婧愭枃浠跺悕<br>    鈥?__FUNCTION__锛氬嚱鏁板悕<br>    鈥?__DATE__锛氬湪婧愭枃浠朵腑鎻掑叆褰撳墠鐨勭紪璇戞棩鏈?<br>    鈥?__TIME__锛氬湪婧愭枃浠朵腑鎻掑叆褰撳墠缂栬瘧鏃堕棿<br>    鈥?__STDC__锛氬綋绋嬪簭涓ユ牸閬靛惊ANSI C鏍囧噯鏃惰鏍囪瘑琚祴鍊间负1<br>    鈥?__func__锛?C99鏂板鍔犵殑<br>*<em>鈥?C99鏂板鐨勯瀹氫箟瀹?</em><br>    鈥?__VA_ARGS__锛氱敤浜庢敮鎸佷笉瀹氬弬鏁扮殑瀹忓畾涔?</p><h2 id="鈥-鎵撳嵃缂撳啿闂"><a href="#鈥-鎵撳嵃缂撳啿闂" class="headerlink" title="鈥?鎵撳嵃缂撳啿闂"></a>鈥?鎵撳嵃缂撳啿闂</h2><h2 id="鈥-鎵撳嵃寮€鍏虫帶鍒"><a href="#鈥-鎵撳嵃寮€鍏虫帶鍒" class="headerlink" title="鈥?鎵撳嵃寮€鍏虫帶鍒?"></a>鈥?鎵撳嵃寮€鍏虫帶鍒?</h2><h2 id="鈥-鎵撳嵃绛夌骇鎺у埗"><a href="#鈥-鎵撳嵃绛夌骇鎺у埗" class="headerlink" title="鈥?鎵撳嵃绛夌骇鎺у埗"></a>鈥?鎵撳嵃绛夌骇鎺у埗</h2>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
          <category> 软件调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式调试 </tag>
            
            <tag> 软件测试 </tag>
            
            <tag> 调试技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式软件调试完全指南 - 从理论到实践</title>
      <link href="/2025/06/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2025/06/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="? 前言"></a>? 前言</h2><p>嵌入式软件调试是嵌入式开发中最具挑战性的环节之一。与PC软件不同，嵌入式系统资源有限、调试手段受限，需要掌握专门的调试理论和技巧。本文将从理论基础到实践应用，全面介绍嵌入式软件调试技术。</p><span id="more"></span><h2 id="调试理论基础"><a href="#调试理论基础" class="headerlink" title="? 调试理论基础"></a>? 调试理论基础</h2><h3 id="什么是软件调试？"><a href="#什么是软件调试？" class="headerlink" title="什么是软件调试？"></a>什么是软件调试？</h3><p><strong>软件调试</strong>（Software Debug，又译软件侦错）是发现软件失效、定位软件错误并将其修复的过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">软件调试过程 = 发现问题 → 定位错误 → 修复错误 → 验证修复</span><br></pre></td></tr></table></figure><h3 id="调试的重要性"><a href="#调试的重要性" class="headerlink" title="调试的重要性"></a>调试的重要性</h3><p>? <strong>统计数据显示</strong>：</p><ul><li>软件调试时间一般占软件开发周期的 <strong>50%以上</strong></li><li>是软件开发中耗时最多的一项活动</li><li>很多项目延期往往就栽在不能定位的bug上</li><li>随着系统复杂度增加，调试技术需要同步升级</li></ul><h3 id="嵌入式调试的特殊性"><a href="#嵌入式调试的特殊性" class="headerlink" title="嵌入式调试的特殊性"></a>嵌入式调试的特殊性</h3><p>与PC软件调试相比，嵌入式调试具有以下特点：</p><table><thead><tr><th>特点</th><th>PC软件</th><th>嵌入式软件</th></tr></thead><tbody><tr><td><strong>资源限制</strong></td><td>内存、存储充足</td><td>资源严重受限</td></tr><tr><td><strong>调试环境</strong></td><td>丰富的调试工具</td><td>调试手段有限</td></tr><tr><td><strong>实时性</strong></td><td>实时性要求不高</td><td>严格的实时性要求</td></tr><tr><td><strong>硬件依赖</strong></td><td>标准化硬件平台</td><td>高度依赖特定硬件</td></tr><tr><td><strong>错误影响</strong></td><td>软件崩溃重启</td><td>可能损坏硬件</td></tr></tbody></table><h2 id="调试工具和方法"><a href="#调试工具和方法" class="headerlink" title="? 调试工具和方法"></a>? 调试工具和方法</h2><h3 id="硬件调试工具"><a href="#硬件调试工具" class="headerlink" title="硬件调试工具"></a>硬件调试工具</h3><h4 id="1-JTAG调试器"><a href="#1-JTAG调试器" class="headerlink" title="1. JTAG调试器"></a>1. JTAG调试器</h4><p>JTAG（Joint Test Action Group）是最常用的硬件调试接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">? 可以调试启动代码</span><br><span class="line">? 支持单步调试</span><br><span class="line">? 可以查看寄存器状态</span><br><span class="line">? 支持断点设置</span><br><span class="line">? 需要专门的调试器硬件</span><br><span class="line">? 占用MCU的调试资源</span><br></pre></td></tr></table></figure><p><strong>常用JTAG调试器</strong>：</p><ul><li><strong>J-Link</strong>: Segger公司产品，功能强大，支持多种MCU</li><li><strong>ST-Link</strong>: ST公司产品，专门用于STM32调试</li><li><strong>OpenOCD</strong>: 开源调试方案，成本低廉</li></ul><h4 id="2-SWD调试接口"><a href="#2-SWD调试接口" class="headerlink" title="2. SWD调试接口"></a>2. SWD调试接口</h4><p>SWD（Serial Wire Debug）是ARM推出的调试接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">优势：</span><br><span class="line">? 只需要2根线（SWDIO、SWCLK）</span><br><span class="line">? 比JTAG节省引脚</span><br><span class="line">? 调试功能完整</span><br><span class="line">? 支持热插拔</span><br></pre></td></tr></table></figure><h4 id="3-逻辑分析仪"><a href="#3-逻辑分析仪" class="headerlink" title="3. 逻辑分析仪"></a>3. 逻辑分析仪</h4><p>用于分析数字信号时序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常用逻辑分析仪</span></span><br><span class="line">- Saleae Logic Pro    <span class="comment"># 高端产品，软件功能强大</span></span><br><span class="line">- DSLogic Plus        <span class="comment"># 开源硬件，性价比高</span></span><br><span class="line">- PulseView          <span class="comment"># 开源软件，支持多种硬件</span></span><br></pre></td></tr></table></figure><h4 id="4-示波器"><a href="#4-示波器" class="headerlink" title="4. 示波器"></a>4. 示波器</h4><p>用于分析模拟信号和时序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">应用场景：</span><br><span class="line">? 电源纹波分析</span><br><span class="line">? 信号完整性检查</span><br><span class="line">? 时序关系验证</span><br><span class="line">? EMC问题定位</span><br></pre></td></tr></table></figure><h3 id="软件调试工具"><a href="#软件调试工具" class="headerlink" title="软件调试工具"></a>软件调试工具</h3><h4 id="1-GDB调试器"><a href="#1-GDB调试器" class="headerlink" title="1. GDB调试器"></a>1. GDB调试器</h4><p>GDB是最强大的命令行调试器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本GDB命令</span></span><br><span class="line">gdb program              <span class="comment"># 启动调试</span></span><br><span class="line">(gdb) run               <span class="comment"># 运行程序</span></span><br><span class="line">(gdb) <span class="built_in">break</span> main        <span class="comment"># 在main函数设置断点</span></span><br><span class="line">(gdb) <span class="built_in">break</span> file.c:100  <span class="comment"># 在指定行设置断点</span></span><br><span class="line">(gdb) <span class="built_in">continue</span>          <span class="comment"># 继续执行</span></span><br><span class="line">(gdb) step              <span class="comment"># 单步执行（进入函数）</span></span><br><span class="line">(gdb) next              <span class="comment"># 单步执行（不进入函数）</span></span><br><span class="line">(gdb) <span class="built_in">print</span> variable    <span class="comment"># 打印变量值</span></span><br><span class="line">(gdb) info registers    <span class="comment"># 查看寄存器</span></span><br><span class="line">(gdb) backtrace         <span class="comment"># 查看调用栈</span></span><br><span class="line">(gdb) quit              <span class="comment"># 退出调试</span></span><br></pre></td></tr></table></figure><h4 id="2-集成开发环境"><a href="#2-集成开发环境" class="headerlink" title="2. 集成开发环境"></a>2. 集成开发环境</h4><p><strong>Keil MDK</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">优势：</span><br><span class="line">? 界面友好，易于使用</span><br><span class="line">? 集成度高，工具链完整</span><br><span class="line">? 支持多种ARM内核</span><br><span class="line">? 仿真功能强大</span><br><span class="line">? 商业软件，价格昂贵</span><br><span class="line">? 主要支持ARM架构</span><br></pre></td></tr></table></figure><p><strong>IAR Embedded Workbench</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">优势：</span><br><span class="line">? 代码优化能力强</span><br><span class="line">? 支持多种架构</span><br><span class="line">? 调试功能完善</span><br><span class="line">? 静态分析工具</span><br><span class="line">? 价格昂贵</span><br><span class="line">? 学习曲线陡峭</span><br></pre></td></tr></table></figure><p><strong>STM32CubeIDE</strong>（免费）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">优势：</span><br><span class="line">? 完全免费</span><br><span class="line">? 基于Eclipse，功能丰富</span><br><span class="line">? 集成STM32配置工具</span><br><span class="line">? 支持多种调试器</span><br><span class="line">? 主要针对STM32</span><br><span class="line">? 启动速度较慢</span><br></pre></td></tr></table></figure><h4 id="3-静态分析工具"><a href="#3-静态分析工具" class="headerlink" title="3. 静态分析工具"></a>3. 静态分析工具</h4><p><strong>PC-lint&#x2F;PC-lint Plus</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查常见问题</span></span><br><span class="line">- 未初始化变量</span><br><span class="line">- 内存泄漏</span><br><span class="line">- 数组越界</span><br><span class="line">- 类型转换问题</span><br><span class="line">- 死代码检测</span><br></pre></td></tr></table></figure><p><strong>Cppcheck</strong>（开源）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装和使用</span></span><br><span class="line"><span class="built_in">sudo</span> apt install cppcheck</span><br><span class="line">cppcheck --<span class="built_in">enable</span>=all src/</span><br></pre></td></tr></table></figure><h2 id="常见调试场景"><a href="#常见调试场景" class="headerlink" title="? 常见调试场景"></a>? 常见调试场景</h2><h3 id="1-系统无法启动"><a href="#1-系统无法启动" class="headerlink" title="1. 系统无法启动"></a>1. 系统无法启动</h3><p><strong>可能原因</strong>：</p><ul><li>时钟配置错误</li><li>内存初始化问题</li><li>启动代码错误</li><li>硬件连接问题</li></ul><p><strong>调试步骤</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 检查电源和时钟</span><br><span class="line">2. 使用JTAG连接，查看PC指针位置</span><br><span class="line">3. 单步执行启动代码</span><br><span class="line">4. 检查内存映射配置</span><br><span class="line">5. 验证硬件连接</span><br></pre></td></tr></table></figure><h3 id="2-程序运行异常"><a href="#2-程序运行异常" class="headerlink" title="2. 程序运行异常"></a>2. 程序运行异常</h3><p><strong>Hard Fault异常处理</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hard Fault处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HardFault_Handler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存现场信息</span></span><br><span class="line">    __asm <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;TST lr, #4 \n&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;ITE EQ \n&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;MRSEQ r0, MSP \n&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;MRSNE r0, PSP \n&quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;B hard_fault_handler_c \n&quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hard_fault_handler_c</span><span class="params">(<span class="type">uint32_t</span> *hardfault_args)</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> stacked_r0;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> stacked_r1;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> stacked_r2;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> stacked_r3;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> stacked_r12;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> stacked_lr;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> stacked_pc;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> stacked_psr;</span><br><span class="line">    </span><br><span class="line">    stacked_r0 = ((<span class="type">uint32_t</span>)hardfault_args[<span class="number">0</span>]);</span><br><span class="line">    stacked_r1 = ((<span class="type">uint32_t</span>)hardfault_args[<span class="number">1</span>]);</span><br><span class="line">    stacked_r2 = ((<span class="type">uint32_t</span>)hardfault_args[<span class="number">2</span>]);</span><br><span class="line">    stacked_r3 = ((<span class="type">uint32_t</span>)hardfault_args[<span class="number">3</span>]);</span><br><span class="line">    stacked_r12 = ((<span class="type">uint32_t</span>)hardfault_args[<span class="number">4</span>]);</span><br><span class="line">    stacked_lr = ((<span class="type">uint32_t</span>)hardfault_args[<span class="number">5</span>]);</span><br><span class="line">    stacked_pc = ((<span class="type">uint32_t</span>)hardfault_args[<span class="number">6</span>]);  <span class="comment">// 异常发生地址</span></span><br><span class="line">    stacked_psr = ((<span class="type">uint32_t</span>)hardfault_args[<span class="number">7</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在这里设置断点，查看异常信息</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-内存问题调试"><a href="#3-内存问题调试" class="headerlink" title="3. 内存问题调试"></a>3. 内存问题调试</h3><p><strong>栈溢出检测</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈溢出检测</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_CANARY 0xDEADBEEF</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">stack_overflow_check</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint32_t</span> _estack;</span><br><span class="line">    <span class="type">uint32_t</span> *stack_end = &amp;_estack - <span class="number">100</span>;  <span class="comment">// 预留100字节</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*stack_end != STACK_CANARY) &#123;</span><br><span class="line">        <span class="comment">// 栈溢出！</span></span><br><span class="line">        error_handler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在系统初始化时设置金丝雀值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_stack_canary</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint32_t</span> _estack;</span><br><span class="line">    <span class="type">uint32_t</span> *stack_end = &amp;_estack - <span class="number">100</span>;</span><br><span class="line">    *stack_end = STACK_CANARY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内存泄漏检测</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的内存分配跟踪</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *file;</span><br><span class="line">    <span class="type">int</span> line;</span><br><span class="line">&#125; <span class="type">mem_block_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_MEM_BLOCKS 100</span></span><br><span class="line"><span class="type">static</span> <span class="type">mem_block_t</span> mem_blocks[MAX_MEM_BLOCKS];</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> mem_block_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">debug_malloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">int</span> line)</span> &#123;</span><br><span class="line">    <span class="type">void</span> *ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (ptr &amp;&amp; mem_block_count &lt; MAX_MEM_BLOCKS) &#123;</span><br><span class="line">        mem_blocks[mem_block_count].ptr = ptr;</span><br><span class="line">        mem_blocks[mem_block_count].size = size;</span><br><span class="line">        mem_blocks[mem_block_count].file = file;</span><br><span class="line">        mem_blocks[mem_block_count].line = line;</span><br><span class="line">        mem_block_count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> malloc(size) debug_malloc(size, __FILE__, __LINE__)</span></span><br></pre></td></tr></table></figure><h3 id="4-实时性问题调试"><a href="#4-实时性问题调试" class="headerlink" title="4. 实时性问题调试"></a>4. 实时性问题调试</h3><p><strong>任务执行时间测量</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用DWT计数器测量执行时间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dwt_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    CoreDebug-&gt;DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;</span><br><span class="line">    DWT-&gt;CTRL |= DWT_CTRL_CYCCNTENA_Msk;</span><br><span class="line">    DWT-&gt;CYCCNT = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">get_cycle_count</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> DWT-&gt;CYCCNT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">measure_function_time</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> start_time = get_cycle_count();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行要测量的函数</span></span><br><span class="line">    target_function();</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint32_t</span> end_time = get_cycle_count();</span><br><span class="line">    <span class="type">uint32_t</span> cycles = end_time - start_time;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换为微秒（假设系统时钟为168MHz）</span></span><br><span class="line">    <span class="type">uint32_t</span> us = cycles / <span class="number">168</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Function execution time: %lu us\n&quot;</span>, us);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高级调试技巧"><a href="#高级调试技巧" class="headerlink" title="? 高级调试技巧"></a>? 高级调试技巧</h2><h3 id="1-Printf调试优化"><a href="#1-Printf调试优化" class="headerlink" title="1. Printf调试优化"></a>1. Printf调试优化</h3><p><strong>重定向printf到调试器</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重定向printf到ITM（需要支持SWO的调试器）</span></span><br><span class="line"><span class="type">int</span> _write(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        ITM_SendChar((*ptr++));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者重定向到UART</span></span><br><span class="line"><span class="type">int</span> _write(<span class="type">int</span> file, <span class="type">char</span> *ptr, <span class="type">int</span> len) &#123;</span><br><span class="line">    HAL_UART_Transmit(&amp;huart1, (<span class="type">uint8_t</span>*)ptr, len, HAL_MAX_DELAY);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>条件编译调试信息</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> DBG_PRINT(fmt, args...) printf(<span class="string">&quot;DEBUG: &quot;</span> fmt, ## args)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> DBG_PRINT(fmt, args...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分级调试信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    LOG_ERROR = <span class="number">0</span>,</span><br><span class="line">    LOG_WARN  = <span class="number">1</span>,</span><br><span class="line">    LOG_INFO  = <span class="number">2</span>,</span><br><span class="line">    LOG_DEBUG = <span class="number">3</span></span><br><span class="line">&#125; <span class="type">log_level_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG_LEVEL LOG_INFO</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOG(level, fmt, args...) \</span></span><br><span class="line"><span class="meta">    do &#123; \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (level &lt;= LOG_LEVEL) &#123; \</span></span><br><span class="line"><span class="meta">            printf(<span class="string">&quot;[%s] &quot;</span> fmt <span class="string">&quot;\n&quot;</span>, log_level_str[level], ## args); \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br></pre></td></tr></table></figure><h3 id="2-断言机制"><a href="#2-断言机制" class="headerlink" title="2. 断言机制"></a>2. 断言机制</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义断言宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> ASSERT(expr) \</span></span><br><span class="line"><span class="meta">        do &#123; \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (!(expr)) &#123; \</span></span><br><span class="line"><span class="meta">                printf(<span class="string">&quot;ASSERT failed: %s, file %s, line %d\n&quot;</span>, \</span></span><br><span class="line"><span class="meta">                       #expr, __FILE__, __LINE__); \</span></span><br><span class="line"><span class="meta">                while(1); \</span></span><br><span class="line"><span class="meta">            &#125; \</span></span><br><span class="line"><span class="meta">        &#125; while(0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> ASSERT(expr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">buffer_write</span><span class="params">(<span class="type">uint8_t</span> *buf, <span class="type">int</span> index, <span class="type">uint8_t</span> data)</span> &#123;</span><br><span class="line">    ASSERT(buf != <span class="literal">NULL</span>);</span><br><span class="line">    ASSERT(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; BUFFER_SIZE);</span><br><span class="line">    </span><br><span class="line">    buf[index] = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-看门狗调试"><a href="#3-看门狗调试" class="headerlink" title="3. 看门狗调试"></a>3. 看门狗调试</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 看门狗调试技巧</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">watchdog_debug_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="comment">// 调试模式下禁用看门狗</span></span><br><span class="line">        __HAL_DBGMCU_FREEZE_IWDG();</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分段喂狗，定位死循环位置</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">task_with_watchdog_debug</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    HAL_IWDG_Refresh(&amp;hiwdg);  <span class="comment">// 喂狗点1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 代码段1</span></span><br><span class="line">    process_step1();</span><br><span class="line">    </span><br><span class="line">    HAL_IWDG_Refresh(&amp;hiwdg);  <span class="comment">// 喂狗点2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 代码段2</span></span><br><span class="line">    process_step2();</span><br><span class="line">    </span><br><span class="line">    HAL_IWDG_Refresh(&amp;hiwdg);  <span class="comment">// 喂狗点3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-性能分析"><a href="#4-性能分析" class="headerlink" title="4. 性能分析"></a>4. 性能分析</h3><p><strong>函数调用跟踪</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数进入/退出跟踪</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> FUNCTION_TRACE</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> FUNC_ENTER() printf(<span class="string">&quot;ENTER: %s\n&quot;</span>, __FUNCTION__)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> FUNC_EXIT()  printf(<span class="string">&quot;EXIT:  %s\n&quot;</span>, __FUNCTION__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> FUNC_ENTER()</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> FUNC_EXIT()</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">example_function</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    FUNC_ENTER();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 函数实现</span></span><br><span class="line">    </span><br><span class="line">    FUNC_EXIT();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>内存使用监控</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 堆栈使用情况监控</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_stack_usage</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint32_t</span> _estack;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">uint32_t</span> _sstack;</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint32_t</span> stack_size = (<span class="type">uint32_t</span>)&amp;_estack - (<span class="type">uint32_t</span>)&amp;_sstack;</span><br><span class="line">    <span class="type">uint32_t</span> current_sp;</span><br><span class="line">    </span><br><span class="line">    __asm <span class="title function_">volatile</span> <span class="params">(<span class="string">&quot;mov %0, sp&quot;</span> : <span class="string">&quot;=r&quot;</span> (current_sp))</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint32_t</span> used_stack = (<span class="type">uint32_t</span>)&amp;_estack - current_sp;</span><br><span class="line">    <span class="type">uint32_t</span> usage_percent = (used_stack * <span class="number">100</span>) / stack_size;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack usage: %lu/%lu bytes (%lu%%)\n&quot;</span>, </span><br><span class="line">           used_stack, stack_size, usage_percent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调试环境搭建"><a href="#调试环境搭建" class="headerlink" title="?? 调试环境搭建"></a>?? 调试环境搭建</h2><h3 id="1-OpenOCD配置"><a href="#1-OpenOCD配置" class="headerlink" title="1. OpenOCD配置"></a>1. OpenOCD配置</h3><p><strong>安装OpenOCD</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu/Debian</span></span><br><span class="line"><span class="built_in">sudo</span> apt install openocd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或从源码编译</span></span><br><span class="line">git <span class="built_in">clone</span> https://git.code.sf.net/p/openocd/code openocd</span><br><span class="line"><span class="built_in">cd</span> openocd</span><br><span class="line">./bootstrap</span><br><span class="line">./configure --enable-stlink --enable-jlink</span><br><span class="line">make</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure><p><strong>配置文件示例</strong>：</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># openocd.cfg for STM32F4</span></span><br><span class="line"><span class="keyword">source</span> [find interface/stlink.cfg]</span><br><span class="line"><span class="keyword">source</span> [find target/stm32f4x.cfg]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作区域</span></span><br><span class="line"><span class="variable">$_TARGETNAME</span> configure -work-area-phys <span class="number">0x20000000</span> -work-area-size <span class="number">0x8000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复位配置</span></span><br><span class="line">reset_config srst_only</span><br></pre></td></tr></table></figure><p><strong>启动调试会话</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动OpenOCD</span></span><br><span class="line">openocd -f openocd.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在另一个终端启动GDB</span></span><br><span class="line">arm-none-eabi-gdb firmware.elf</span><br><span class="line">(gdb) target remote localhost:3333</span><br><span class="line">(gdb) monitor reset halt</span><br><span class="line">(gdb) load</span><br><span class="line">(gdb) <span class="built_in">continue</span></span><br></pre></td></tr></table></figure><h3 id="2-VSCode调试配置"><a href="#2-VSCode调试配置" class="headerlink" title="2. VSCode调试配置"></a>2. VSCode调试配置</h3><p><strong>launch.json配置</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Debug STM32&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cortex-debug&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;servertype&quot;</span><span class="punctuation">:</span> <span class="string">&quot;openocd&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;executable&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./build/firmware.elf&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;configFiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;interface/stlink.cfg&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;target/stm32f4x.cfg&quot;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;svdFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./STM32F407.svd&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;runToMain&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;showDevDebugOutput&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="调试最佳实践"><a href="#调试最佳实践" class="headerlink" title="? 调试最佳实践"></a>? 调试最佳实践</h2><h3 id="1-调试策略"><a href="#1-调试策略" class="headerlink" title="1. 调试策略"></a>1. 调试策略</h3><p><strong>分层调试法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">应用层 → 中间件层 → 驱动层 → 硬件层</span><br></pre></td></tr></table></figure><p><strong>二分法定位</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在可疑代码段中间添加检查点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">suspicious_function</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 代码段1</span></span><br><span class="line">    process_part1();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查点1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Checkpoint 1: OK\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 代码段2</span></span><br><span class="line">    process_part2();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查点2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Checkpoint 2: OK\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 代码段3</span></span><br><span class="line">    process_part3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-代码质量保证"><a href="#2-代码质量保证" class="headerlink" title="2. 代码质量保证"></a>2. 代码质量保证</h3><p><strong>防御性编程</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数检查</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">safe_divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        LOG(LOG_ERROR, <span class="string">&quot;Division by zero!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边界检查</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">safe_array_access</span><span class="params">(<span class="type">int</span> *<span class="built_in">array</span>, <span class="type">int</span> size, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        LOG(LOG_ERROR, <span class="string">&quot;Null pointer!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) &#123;</span><br><span class="line">        LOG(LOG_ERROR, <span class="string">&quot;Array index out of bounds: %d&quot;</span>, index);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 安全访问</span></span><br><span class="line">    <span class="built_in">array</span>[index] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-调试信息管理"><a href="#3-调试信息管理" class="headerlink" title="3. 调试信息管理"></a>3. 调试信息管理</h3><p><strong>结构化日志</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> timestamp;</span><br><span class="line">    <span class="type">log_level_t</span> level;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *module;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *message;</span><br><span class="line">&#125; <span class="type">log_entry_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">structured_log</span><span class="params">(<span class="type">log_level_t</span> level, <span class="type">const</span> <span class="type">char</span> *module, </span></span><br><span class="line"><span class="params">                   <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line">    va_list args;</span><br><span class="line">    </span><br><span class="line">    va_start(args, fmt);</span><br><span class="line">    vsnprintf(buffer, <span class="keyword">sizeof</span>(buffer), fmt, args);</span><br><span class="line">    va_end(args);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%lu][%s][%s] %s\n&quot;</span>, </span><br><span class="line">           HAL_GetTick(), log_level_str[level], module, buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line">structured_log(LOG_INFO, <span class="string">&quot;UART&quot;</span>, <span class="string">&quot;Received %d bytes&quot;</span>, count);</span><br></pre></td></tr></table></figure><h2 id="调试安全注意事项"><a href="#调试安全注意事项" class="headerlink" title="? 调试安全注意事项"></a>? 调试安全注意事项</h2><h3 id="1-生产环境安全"><a href="#1-生产环境安全" class="headerlink" title="1. 生产环境安全"></a>1. 生产环境安全</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产版本中移除调试代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PRODUCTION</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> DEBUG_PRINT(fmt, args...) printf(fmt, ## args)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> DEBUG_BREAK() __asm(<span class="string">&quot;bkpt 0&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> DEBUG_PRINT(fmt, args...)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> DEBUG_BREAK()</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="2-敏感信息保护"><a href="#2-敏感信息保护" class="headerlink" title="2. 敏感信息保护"></a>2. 敏感信息保护</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 避免在日志中输出敏感信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">log_user_info</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *username, <span class="type">const</span> <span class="type">char</span> *password)</span> &#123;</span><br><span class="line">    LOG(LOG_INFO, <span class="string">&quot;User login: %s&quot;</span>, username);</span><br><span class="line">    <span class="comment">// 不要记录密码！</span></span><br><span class="line">    <span class="comment">// LOG(LOG_INFO, &quot;Password: %s&quot;, password);  // 危险！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="学习资源和工具"><a href="#学习资源和工具" class="headerlink" title="? 学习资源和工具"></a>? 学习资源和工具</h2><h3 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h3><ul><li>《嵌入式软件调试》- 张友生</li><li>《ARM Cortex-M3权威指南》- Joseph Yiu</li><li>《嵌入式实时操作系统μC&#x2F;OS-III》- Jean J. Labrosse</li></ul><h3 id="在线资源"><a href="#在线资源" class="headerlink" title="在线资源"></a>在线资源</h3><ul><li><a href="https://developer.arm.com/documentation">ARM Developer Documentation</a></li><li><a href="http://openocd.org/doc/html/index.html">OpenOCD User’s Guide</a></li><li><a href="https://www.gnu.org/software/gdb/documentation/">GDB Documentation</a></li></ul><h3 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h3><ul><li><strong>硬件工具</strong>: J-Link, ST-Link, Logic Analyzer</li><li><strong>软件工具</strong>: GDB, OpenOCD, Keil MDK, IAR</li><li><strong>分析工具</strong>: Wireshark, PulseView, PC-lint</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="? 总结"></a>? 总结</h2><p>嵌入式软件调试是一门综合性技术，需要掌握：</p><ol><li><strong>理论基础</strong>: 了解调试原理和方法论</li><li><strong>工具使用</strong>: 熟练使用各种调试工具</li><li><strong>实战经验</strong>: 通过大量实践积累经验</li><li><strong>系统思维</strong>: 从硬件到软件的全栈调试能力</li></ol><p><strong>调试心得</strong>：</p><ul><li>? <strong>细心观察</strong>: 注意每一个异常现象</li><li>? <strong>逻辑思考</strong>: 运用逻辑推理定位问题</li><li>? <strong>记录总结</strong>: 建立个人调试知识库</li><li>? <strong>团队协作</strong>: 善于寻求帮助和分享经验</li></ul><p>掌握这些调试技能，将大大提高你的嵌入式开发效率和问题解决能力！</p><hr><blockquote><p>? <strong>调试金句</strong>: “调试就像侦探工作，需要耐心、细心和逻辑思维。每一个bug都是一个谜题，等待你去解开。”</p></blockquote><p><strong>相关文章推荐</strong>:</p><ul><li><a href="/2025/06/01/embedded-system-design/">嵌入式系统设计原理</a></li><li><a href="/2025/06/01/arm-cortex-programming/">ARM Cortex-M编程指南</a></li><li><a href="/2025/06/01/rtos-principles/">实时操作系统原理与应用</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
          <category> 软件调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件调试 </tag>
            
            <tag> 嵌入式调试 </tag>
            
            <tag> 软件测试 </tag>
            
            <tag> 调试技巧 </tag>
            
            <tag> JTAG </tag>
            
            <tag> GDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试知识</title>
      <link href="/2025/05/05/test/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/"/>
      <url>/2025/05/05/test/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="C-C-题目"><a href="#C-C-题目" class="headerlink" title="C&#x2F;C++ 题目"></a>C&#x2F;C++ 题目</h1><p>一个保险柜，密码是由 <code>NOMONEY</code> 组成的 7 位数字。每个字母对应的数字隐藏在下面的 10 进制加法算式中，相同的字母对应相同的数字，不同的字母对应不同的数字，数字范围 0-9，并且已知密码中没有 4。请解码密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G I V E</span><br><span class="line">+ M O R E</span><br><span class="line"></span><br><span class="line">  M O N E Y</span><br></pre></td></tr></table></figure><ul><li><p><strong>M &#x3D; 1</strong>（因两四位数相加得五位数，最高位必为1）</p></li><li><p><strong>G &#x3D; 9</strong>（9 + 1 &#x3D; 10，产生进位，满足五位数）</p></li><li><p><strong>O &#x3D; 0</strong>（千位相加：9 + 1 + 0 &#x3D; 10，进位后万位为1）</p></li><li><p><strong>E &#x3D; 8</strong>（个位：6 + 6 &#x3D; 12 → Y &#x3D; 2，进位1）</p></li><li><p><strong>Y &#x3D; 6</strong>（由E &#x3D; 8推导）</p></li><li><p><strong>V &#x3D; 5，R &#x3D; 2</strong>（十位：7 + 5 + 进位1 &#x3D; 13 → 进位1，E &#x3D; 6）  </p></li><li><p><strong>I &#x3D; 3</strong>（百位：8 + 进位1 &#x3D; 9 → N &#x3D; 9，但需调整后最终得出N &#x3D; 2）</p></li><li><p><strong>N &#x3D; 7</strong>（实际验证后调整）</p><p>答案不对 题目错了</p></li></ul><h4 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h4><p><strong>题目描述：</strong> 请用 C 语言写一个函数，实现如下功能：输入年、月、日，返回这一天是这一年的第几天？请注意算法的效率（空间时间）。</p><p><strong>答案：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dayOfYear</span><span class="params">(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">    <span class="type">int</span> daysInMonth[] = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; <span class="number">2</span> &amp;&amp; (y % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">100</span> != <span class="number">0</span> || y % <span class="number">400</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">        daysInMonth[<span class="number">1</span>] = <span class="number">29</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> day = d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        day += daysInMonth[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h4><p><strong>题目描述：</strong> 什么样的代码是优美的？哪些好的习惯有助于提高代码质量？</p><p><strong>答案：</strong> 优美的代码通常具有以下特点：</p><ol><li><strong>可读性</strong>：代码结构清晰，命名规范，注释充分。</li><li><strong>简洁性</strong>：代码简洁，避免冗余，使用合适的数据结构和算法。</li><li><strong>可维护性</strong>：模块化设计，易于理解和修改。</li><li><strong>健壮性</strong>：代码能够处理异常情况，进行错误检查和处理。</li></ol><p>提高代码质量的好习惯包括：</p><ol><li><strong>代码审查</strong>：定期进行代码审查，发现并修复潜在问题。</li><li><strong>单元测试</strong>：编写单元测试，确保代码的正确性和稳定性。</li><li><strong>持续重构</strong>：定期重构代码，保持代码的简洁和可维护性。</li><li><strong>遵循编码规范</strong>：遵循团队或项目的编码规范，保持代码风格的一致性。</li></ol><h4 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h4><p><strong>题目描述：</strong> C 和 C++ 有哪些主要区别？</p><p><strong>答案：</strong> C 和 C++ 的主要区别包括：</p><ol><li><strong>面向过程 vs 面向对象</strong>：C 是面向过程的语言，而 C++ 支持面向对象编程。</li><li><strong>类和对象</strong>：C++ 支持类和对象，可以进行封装、继承和多态。</li><li><strong>标准模板库（STL）</strong>：C++ 提供了标准模板库，支持容器、算法和迭代器。</li><li><strong>异常处理</strong>：C++ 支持异常处理机制，而 C 使用错误码。</li><li><strong>命名空间</strong>：C++ 支持命名空间，避免命名冲突。</li><li><strong>构造函数和析构函数</strong>：C++ 支持构造函数和析构函数，进行资源管理。</li></ol><h4 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h4><p><strong>题目描述：</strong> 请从下面三个问题任选一个（15 分） a) 请描述 C++ 中各种智能指针（shared_ptr、auto_ptr、unique_ptr、weak_ptr）的适用场景及注意事项。 b) 请简述一下 Linux 中几种多路复用机制（select&#x2F;poll&#x2F;epoll）的优缺点对比。</p><p><strong>答案：</strong> a) C++ 中各种智能指针的适用场景及注意事项：</p><ul><li><strong>shared_ptr</strong>：适用于多个指针需要共享所有权的场景。注意事项：循环引用可能导致内存泄漏。</li><li><strong>auto_ptr</strong>：已在 C++11 中被弃用，不推荐使用。</li><li><strong>unique_ptr</strong>：适用于独占所有权的场景。注意事项：不能被复制，只能被移动。</li><li><strong>weak_ptr</strong>：用于解决 shared_ptr 的循环引用问题。注意事项：需要与 shared_ptr 配合使用。</li></ul><p>b) Linux 中几种多路复用机制的优缺点对比：</p><ul><li><strong>select</strong>：优点：简单易用。缺点：文件描述符数量有限，性能较差。</li><li><strong>poll</strong>：优点：没有文件描述符数量限制。缺点：性能仍然较差，尤其是在大量文件描述符的情况下。</li><li><strong>epoll</strong>：优点：性能优异，支持大量文件描述符。缺点：实现复杂，需要内核支持。</li></ul><h4 id="题目5"><a href="#题目5" class="headerlink" title="题目5"></a>题目5</h4><p><strong>题目描述：</strong> 翻译：When developing embedded software, you must consider the following:</p><ul><li>Understand the default compilation tool behavior and the target environment so that you appreciate the steps necessary to move from a debug or development build to a fully standalone production version of the application.</li><li>Some C library functionality executes by using debug environment resources. If used, you must implement this functionality to make use of target hardware.</li><li>The toolchain has no inherent knowledge of the memory map of any given target. You must tailor the image this functionality has no inherent knowledge of the memory map of the target hardware.</li><li>An embedded application must perform some initialization, such as stack and heap initialization, before the application can be run. A complete initialization sequence requires code that you implement in addition to the Arm Compiler C library initialization routines.</li></ul><p><strong>答案：</strong> 在开发嵌入式软件时，必须考虑以下几点：</p><ul><li>了解默认编译工具的行为和目标环境，以便理解从调试或开发版本迁移到完全独立的生产版本应用程序所需的步骤。</li><li>一些 C 库功能通过使用调试环境资源来执行。如果使用这些功能，您必须实现这些功能以利用目标硬件。</li><li>工具链对任何给定目标的内存映射没有固有的知识。您必须调整该功能对目标硬件内存映射的了解。</li><li>嵌入式应用程序必须执行一些初始化，例如堆栈和堆初始化，然后才能运行应用程序。完整的初始化序列需要您实现的代码，以补充 Arm 编译器 C 库初始化例程。</li></ul><h4 id="题目6"><a href="#题目6" class="headerlink" title="题目6"></a>题目6</h4><p><strong>题目描述：</strong> 找出下面代码中所有的错误以及不合理的地方，并请说明原因。（20 分）</p><ol><li><p>找出下面代码中所有的错误以及不合理的地方，并请说明原因。（20 分）</p><p>c</p><p>复制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    A() &#123; m_jCount = <span class="number">0</span>; &#125;</span><br><span class="line">    ~A() &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> m_jCount;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    B() : A() &#123; m_jCount = <span class="number">1</span>; &#125;</span><br><span class="line">    ~B()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    A* a = new B();</span><br><span class="line">    FILE* f;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">        n = argv[<span class="number">0</span>];</span><br><span class="line">    <span class="type">char</span>* stuff = new <span class="type">char</span>[n];</span><br><span class="line">    f = fopen(<span class="string">&quot;c:\\abc\\aa.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fread(f, n, stuff);</span><br><span class="line">    n = <span class="built_in">strlen</span>(stuff);</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(stuff, <span class="number">0</span>, <span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line">    fwrite(f, <span class="number">1</span>, n, stuff);</span><br><span class="line">    delete stuff;</span><br><span class="line">    delete a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stuff;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>答案：</strong> 代码中的错误和不合理之处包括：</p><ol><li><code>A* a = new B();</code>：<code>new B()</code> 应该使用 <code>new B</code>，而不是 <code>new B()</code>。</li><li><code>int m;</code>：变量 <code>m</code> 未初始化，可能导致未定义行为。</li><li><code>if (argc &gt; 1)</code>：如果 <code>argc</code> 小于等于 1，程序会直接返回 -1，没有进行任何处理。</li><li><code>char* stuff = new char[n];</code>：<code>new char[n]</code> 应该使用 <code>new char[n+1]</code>，并在最后添加一个空字符 <code>\0</code>。</li><li><code>memset(stuff, 0, 20, 10);</code>：<code>memset</code> 的第三个参数应该是要设置的字节数，而不是重复次数。</li><li><code>delete stuff;</code>：<code>delete</code> 应该使用 <code>delete[] stuff;</code>，因为 <code>stuff</code> 是一个数组。</li><li><code>cout &lt;&lt; stuff;</code>：<code>stuff</code> 可能包含未初始化的内存，直接输出可能导致未定义行为。</li></ol><p>这些错误和不合理之处需要修正以确保程序的正确性和稳定性。</p><h1 id="Uboot-引导嵌入式Linux操作系统启动的大概顺序是？"><a href="#Uboot-引导嵌入式Linux操作系统启动的大概顺序是？" class="headerlink" title="Uboot 引导嵌入式Linux操作系统启动的大概顺序是？"></a>Uboot 引导嵌入式Linux操作系统启动的大概顺序是？</h1><p>第一阶段：ROM code（芯片厂商内置的代码）初始化一些基本的时钟，从选定的设备中去加载FSBL的代码，并启动FSBL代码</p><p>第二阶段：FSBL first stage boot loader 完成时钟的初始化，初始化DDR，从选定的设备中去加载SSBL的代码，并启动SSBL代码</p><p>第三阶段：从外部储存或者网络中加载linux系统，通过启动动画向用户反馈启动过程，启动linux内核</p><p>第四阶段：linux内核初始化，挂载根文件系统，启动用户空间的init程序</p><p>最后进入到linux用户空间</p><h3 id="第一阶段：ROM-Code（芯片厂商内置的代码）"><a href="#第一阶段：ROM-Code（芯片厂商内置的代码）" class="headerlink" title="第一阶段：ROM Code（芯片厂商内置的代码）"></a>第一阶段：ROM Code（芯片厂商内置的代码）</h3><ul><li><strong>比喻</strong>：就像你刚睁开眼睛，身体还在床上，但你已经开始动脑子思考下一步要做什么。</li><li><strong>实际操作</strong>：计算机刚开机时，芯片里有一些预先写好的代码（ROM Code），这些代码会做一些最基本的事情，比如检查硬件是否正常，设置一些基本的时钟（就像你调整闹钟一样），然后从某个地方（比如硬盘或者USB）找到一个叫做FSBL（First Stage Boot Loader）的程序，并把它加载到内存里，然后开始运行这个程序。</li></ul><h3 id="第二阶段：FSBL（First-Stage-Boot-Loader）"><a href="#第二阶段：FSBL（First-Stage-Boot-Loader）" class="headerlink" title="第二阶段：FSBL（First Stage Boot Loader）"></a>第二阶段：FSBL（First Stage Boot Loader）</h3><ul><li><strong>比喻</strong>：你从床上爬起来，开始穿衣服，准备出门。</li><li><strong>实际操作</strong>：FSBL程序接手后，会做一些更具体的事情，比如初始化DDR（一种内存，就像你整理书包一样），设置更精确的时钟（就像你调整手表时间），然后从某个地方找到SSBL（Second Stage Boot Loader）的代码，加载到内存里，并开始运行SSBL。</li></ul><h3 id="第三阶段：加载Linux系统"><a href="#第三阶段：加载Linux系统" class="headerlink" title="第三阶段：加载Linux系统"></a>第三阶段：加载Linux系统</h3><ul><li><strong>比喻</strong>：你出门去学校，路上可能会看看风景，听听音乐，这些都是你在路上的“启动动画”。</li><li><strong>实际操作</strong>：SSBL程序会从外部存储设备（比如硬盘）或者网络中找到Linux系统的代码，加载到内存里。在这个过程中，可能会有一些启动动画显示给用户，让用户知道计算机正在启动，就像你在路上看到的风景一样。最后，Linux内核（计算机的大脑）开始运行。</li></ul><h3 id="第四阶段：Linux内核初始化"><a href="#第四阶段：Linux内核初始化" class="headerlink" title="第四阶段：Linux内核初始化"></a>第四阶段：Linux内核初始化</h3><ul><li><strong>比喻</strong>：你到了学校，开始上课，老师开始讲解课程内容。</li><li><strong>实际操作</strong>：Linux内核开始运行后，会初始化各种系统功能，比如挂载根文件系统（就像老师准备好教材一样），然后启动用户空间的init程序（就像老师开始讲解课程内容）。这个init程序就像是计算机的“老师”，它会启动其他各种程序和服务，让计算机能够正常工作。</li></ul><h3 id="最后：进入Linux用户空间"><a href="#最后：进入Linux用户空间" class="headerlink" title="最后：进入Linux用户空间"></a>最后：进入Linux用户空间</h3><ul><li><strong>比喻</strong>：你开始认真听讲，参与课堂活动。</li><li><strong>实际操作</strong>：当init程序启动完成后，计算机就进入了用户空间，这意味着用户可以开始使用计算机了，就像你开始参与课堂活动一样。用户可以打开各种应用程序，进行各种操作。</li></ul><h1 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h1><p>1、栈区是系统自动申请自动释放，且空间较小</p><p>2、堆区是需要手动申请，手动释放，空间较大</p><p>3、栈区常用来存放局部变量等</p><p>4、堆区常用来存放全局变量等</p><p>5、栈的空间是连续的，而堆不是</p><h3 id="1-栈区（Stack）"><a href="#1-栈区（Stack）" class="headerlink" title="1. 栈区（Stack）"></a>1. 栈区（Stack）</h3><ul><li><strong>比喻</strong>：想象你有一个书桌，书桌上有一个固定的区域用来放书本和文具。每次你写作业的时候，就会在这个区域放一些书本、笔记本和铅笔。写完作业后，你就会把这些东西收起来，这个区域又变得干净了。</li><li><strong>实际操作</strong>：<ul><li><strong>自动申请和释放</strong>：栈区是由系统自动管理的。当你在函数中定义局部变量（比如<code>int a = 5;</code>）时，系统会自动在栈区分配一小块空间来存储这个变量。当函数执行完毕后，系统会自动清理这块空间。</li><li><strong>空间较小</strong>：栈区的空间相对较小，通常只有几MB。</li><li>xxxxxxxxxx ​#include &lt;stdio.h&gt;​&#x2F;*​    快速排序:实现从小到大排序 *&#x2F;​void quickSort(int arr[], int size){​    subSort(arr, 0, size - 1);}​void subSort(int arr[], int start, int end){​    if (start &lt; end)    {        int base &#x3D; arr[start];        int low &#x3D; start;        int high &#x3D; end + 1;​        while (1)        {​            while (low &lt; end &amp;&amp; arr[++low] &lt;&#x3D; base)                ; &#x2F;&#x2F; 找到从前往后第1个比base大的元素            while (high &gt; start &amp;&amp; arr[–high] &gt;&#x3D; base)                ; &#x2F;&#x2F; 找到从后往前第1个比base小的元素​            if (low &lt; high)            {                &#x2F;&#x2F; 交换low和high位置的元素                int temp &#x3D; arr[low];                arr[low] &#x3D; arr[high];                arr[high] &#x3D; temp;            }            else            {                break;            }        }​        &#x2F;&#x2F; 交换start和high索引位置上的元素        int temp1 &#x3D; arr[start];        arr[start] &#x3D; arr[high];        arr[high] &#x3D; temp1;​        &#x2F;&#x2F; 递归调用        subSort(arr, start, high - 1); &#x2F;&#x2F; 前半段继续排序        subSort(arr, high + 1, end);   &#x2F;&#x2F; 后半段继续排序    }}​int main(){​    int arr[] &#x3D; {23, 45, 2, 46, 77, 2, 99, -9, -32, 0, 66};​    int size &#x3D; sizeof(arr) &#x2F; sizeof(int);    &#x2F;&#x2F; 遍历    for (int i &#x3D; 0; i &lt; size; i++)    {        printf(“%d  “, arr[i]);    }​    printf(“\n”);​    &#x2F;&#x2F; 排序    quickSort(arr, size);​    &#x2F;&#x2F; 遍历    for (int i &#x3D; 0; i &lt; size; i++)    {        printf(“%d  “, arr[i]);    }​    printf(“\n”);​    getchar();​    return 0;}c:数据结构.md</li></ul></li></ul><h3 id="2-堆区（Heap）"><a href="#2-堆区（Heap）" class="headerlink" title="2. 堆区（Heap）"></a>2. 堆区（Heap）</h3><ul><li><strong>比喻</strong>：想象你有一个大仓库，这个仓库可以用来放各种各样的东西，比如家具、玩具、书籍等。你需要的时候可以随时往里面放东西，用完之后也可以随时拿出来。</li><li><strong>实际操作</strong>：<ul><li><strong>手动申请和释放</strong>：堆区是由程序员手动管理的。当你需要一个较大的空间来存储数据（比如一个大的数组或者一个复杂的数据结构）时，你需要手动申请这块空间（比如用<code>malloc</code>函数）。用完之后，也需要手动释放这块空间（比如用<code>free</code>函数）。</li><li><strong>空间较大</strong>：堆区的空间相对较大，通常可以达到几百MB甚至更多。</li><li><strong>用途</strong>：堆区常用来存放动态分配的变量，比如全局变量、动态数组等。</li></ul></li></ul><h3 id="3-栈区常用来存放局部变量"><a href="#3-栈区常用来存放局部变量" class="headerlink" title="3. 栈区常用来存放局部变量"></a>3. 栈区常用来存放局部变量</h3><ul><li><strong>比喻</strong>：你在书桌上写作业，每次写作业都会用到一些书本和文具，这些就是局部变量。写完作业后，这些书本和文具就被收起来了。</li><li><strong>实际操作</strong>：在函数中定义的变量（局部变量）通常存放在栈区。这些变量在函数执行期间有效，函数执行完毕后，这些变量就会被自动清理。</li></ul><h3 id="4-堆区常用来存放全局变量等"><a href="#4-堆区常用来存放全局变量等" class="headerlink" title="4. 堆区常用来存放全局变量等"></a>4. 堆区常用来存放全局变量等</h3><ul><li><strong>比喻</strong>：你在仓库里放了一些家具和玩具，这些是你长期需要的东西，不会轻易拿出来。这些就是全局变量。</li><li><strong>实际操作</strong>：全局变量和动态分配的变量（比如用<code>malloc</code>分配的内存）通常存放在堆区。这些变量在程序的整个运行过程中都有效，直到你手动释放它们。</li></ul><h3 id="5-栈的空间是连续的，而堆不是"><a href="#5-栈的空间是连续的，而堆不是" class="headerlink" title="5. 栈的空间是连续的，而堆不是"></a>5. 栈的空间是连续的，而堆不是</h3><ul><li><strong>比喻</strong>：你的书桌是一个固定的区域，所有的东西都放在一起，空间是连续的。而仓库里的东西可以放在不同的地方，空间是不连续的。</li><li><strong>实际操作</strong>：<ul><li><strong>栈区</strong>：栈区的空间是连续的，系统会自动管理这块空间，确保每次分配和释放都是连续的。</li><li><strong>堆区</strong>：堆区的空间是不连续的，因为堆区是由程序员手动管理的，每次申请和释放的空间可能在不同的位置。</li></ul></li></ul><h1 id="什么是野指针，产后的原因是什么"><a href="#什么是野指针，产后的原因是什么" class="headerlink" title="什么是野指针，产后的原因是什么"></a>什么是野指针，产后的原因是什么</h1><p>1、野指针是指向位置是随机的且不正确的</p><p>2、产生原因  定义时未初始化，指向位置随机</p><p>或者在释放时没有指向null，从而指向垃圾内存</p><h3 id="1-什么是野指针？"><a href="#1-什么是野指针？" class="headerlink" title="1. 什么是野指针？"></a>1. 什么是野指针？</h3><p><strong>比喻</strong>：想象你手里拿着一张地图，但地图上的地址是乱写的，或者地图根本就没有地址，你按照这个地图去寻找某个地方，很可能就会迷失方向，甚至走到一个完全错误的地方。</p><p><strong>实际操作</strong>：</p><ul><li><strong>野指针</strong>：在编程中，指针是一个变量，它用来存储另一个变量的内存地址。如果一个指针指向了一个随机的、不正确的内存地址，或者指向了一个已经被释放的内存地址，这个指针就被称为“野指针”。</li><li><strong>野指针的危害</strong>：野指针可能会导致程序访问到错误的内存区域，从而引发程序崩溃、数据损坏等不可预测的问题。</li></ul><h3 id="2-产生原因"><a href="#2-产生原因" class="headerlink" title="2. 产生原因"></a>2. 产生原因</h3><h4 id="1-定义时未初始化"><a href="#1-定义时未初始化" class="headerlink" title="1. 定义时未初始化"></a>1. 定义时未初始化</h4><p><strong>比喻</strong>：你手里拿着一张地图，但地图上没有写地址，你不知道它指向哪里，所以你可能会走到一个完全错误的地方。</p><p><strong>实际操作</strong>：</p><ul><li><p>当你定义了一个指针变量，但没有给它一个具体的地址时，这个指针变量的值是随机的。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr; <span class="comment">// 没有初始化，ptr的值是随机的</span></span><br></pre></td></tr></table></figure></li><li><p>这个随机的值可能指向一个完全错误的内存地址，这就是野指针。</p></li></ul><h4 id="2-释放后未指向NULL"><a href="#2-释放后未指向NULL" class="headerlink" title="2. 释放后未指向NULL"></a>2. 释放后未指向NULL</h4><p><strong>比喻</strong>：你手里拿着一张地图，地图上写了一个地址，但这个地址的房子已经被拆掉了。你按照这个地图去寻找，可能会走到一个空地，或者一个完全不同的地方。</p><p><strong>实际操作</strong>：</p><ul><li><p>当你用<code>malloc</code>等函数分配了一块内存，并用一个指针变量指向它，然后释放了这块内存，但没有把指针变量设置为<code>NULL</code>，这个指针变量就会变成野指针。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配内存</span></span><br><span class="line"><span class="built_in">free</span>(ptr); <span class="comment">// 释放内存</span></span><br><span class="line"><span class="comment">// 此时ptr仍然指向原来的内存地址，但这块内存已经被释放了</span></span><br></pre></td></tr></table></figure></li><li><p>如果你继续使用<code>ptr</code>，它就会指向一个已经被释放的内存地址，这就是野指针。</p></li></ul><h2 id="如何避免野指针的问题"><a href="#如何避免野指针的问题" class="headerlink" title="如何避免野指针的问题"></a>如何避免野指针的问题</h2><h3 id="1-初始化指针"><a href="#1-初始化指针" class="headerlink" title="1. 初始化指针"></a>1. 初始化指针</h3><p><strong>建议</strong>：在定义指针时，始终初始化指针为<code>NULL</code>或指向一个有效的地址。</p><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="literal">NULL</span>; <span class="comment">// 初始化为NULL</span></span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;value; <span class="comment">// 初始化为一个有效的地址</span></span><br></pre></td></tr></table></figure><p><strong>解释</strong>：初始化为<code>NULL</code>可以让你在后续使用指针时，通过检查是否为<code>NULL</code>来避免使用未初始化的指针。</p><h3 id="2-释放内存后将指针置为NULL"><a href="#2-释放内存后将指针置为NULL" class="headerlink" title="2. 释放内存后将指针置为NULL"></a>2. 释放内存后将指针置为<code>NULL</code></h3><p><strong>建议</strong>：在释放动态分配的内存后，立即将指针置为<code>NULL</code>。</p><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用ptr</span></span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">ptr = <span class="literal">NULL</span>; <span class="comment">// 释放内存后将指针置为NULL</span></span><br></pre></td></tr></table></figure><p><strong>解释</strong>：这样可以避免指针继续指向已经被释放的内存，从而防止野指针的产生。</p><h3 id="3-检查指针是否为NULL"><a href="#3-检查指针是否为NULL" class="headerlink" title="3. 检查指针是否为NULL"></a>3. 检查指针是否为<code>NULL</code></h3><p><strong>建议</strong>：在使用指针之前，始终检查指针是否为<code>NULL</code>。</p><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用ptr</span></span><br><span class="line">*ptr = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">ptr = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：通过检查指针是否为<code>NULL</code>，可以避免对未初始化或已经释放的指针进行操作。</p><h3 id="4-使用智能指针（C-）"><a href="#4-使用智能指针（C-）" class="headerlink" title="4. 使用智能指针（C++）"></a>4. 使用智能指针（C++）</h3><p><strong>建议</strong>：如果你使用的是C++，尽量使用智能指针（如<code>std::unique_ptr</code>或<code>std::shared_ptr</code>）来管理动态内存。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 使用ptr</span></span><br></pre></td></tr></table></figure><p><strong>解释</strong>：智能指针会自动管理内存的分配和释放，避免手动管理内存带来的风险。</p><h3 id="5-避免重复释放"><a href="#5-避免重复释放" class="headerlink" title="5. 避免重复释放"></a>5. 避免重复释放</h3><p><strong>建议</strong>：确保内存只被释放一次，避免重复释放。</p><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用ptr</span></span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">ptr = <span class="literal">NULL</span>; <span class="comment">// 释放内存后将指针置为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免重复释放</span></span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：通过将指针置为<code>NULL</code>，可以避免重复释放的问题。</p><h3 id="6-使用工具检测野指针"><a href="#6-使用工具检测野指针" class="headerlink" title="6. 使用工具检测野指针"></a>6. 使用工具检测野指针</h3><p><strong>建议</strong>：使用内存检测工具（如<code>valgrind</code>）来检测野指针和内存泄漏问题。</p><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind ./your_program</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：<code>valgrind</code>等工具可以检测内存访问错误，帮助你发现野指针问题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p><strong>野指针</strong>：指向一个随机的、不正确的内存地址的指针。</p></li><li><p><strong>产生原因</strong>：</p><ol><li><strong>定义时未初始化</strong>：指针变量没有被赋予一个具体的地址，它的值是随机的。</li><li><strong>释放后未指向NULL</strong>：指针变量指向的内存被释放了，但指针变量没有被设置为<code>NULL</code>，它仍然指向原来的内存地址。</li></ol></li></ul><h1 id="dma有什么用"><a href="#dma有什么用" class="headerlink" title="dma有什么用"></a>dma有什么用</h1><p>主要是起一个搬运数据的作用，搬运通道可以时从外设到寄存器，外设到外设，寄存器到外设。</p><p>官方回答：DMA是在专门的硬件（ DMA）控制下，实现高速外设和主存储器之间自动成批交换数据尽量减少CPU干预的输入&#x2F;输出操作方式。主要作用就是减少CPU的负担。</p><h1 id="进程间通信的方法"><a href="#进程间通信的方法" class="headerlink" title="进程间通信的方法"></a>进程间通信的方法</h1><p>管道（有名管道和无名管道）</p><p>消息队列</p><p>共享内存</p><p>信号</p><p>信号量  </p><p>套接字</p><h1 id="程序中的内存分配方法"><a href="#程序中的内存分配方法" class="headerlink" title="程序中的内存分配方法"></a>程序中的内存分配方法</h1><p>连续分配，分段，分页，段页式</p>]]></content>
      
      
      <categories>
          
          <category> 面试知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>车载C知识</title>
      <link href="/2024/09/06/test/%E8%BD%A6%E8%BD%BDc%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/09/06/test/%E8%BD%A6%E8%BD%BDc%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>c<br>记录一些自己不会的 和理解不够深的</p><p><img src="/images/image-20250513220710273.png" alt="image-20250513220710273"></p><ol><li><p><strong>存储方式</strong>：</p><ul><li>C风格字符串通过字符数组（<code>char[]</code>）表示，以<code>&#39;\0&#39;</code>（空字符）结尾。</li><li>C++中使用<code>std::string</code>类来表示字符串，更加抽象和方便。</li></ul></li><li><p><strong>动态内存管理</strong>：</p><ul><li>C风格字符串需要手动进行内存分配和释放，使用如<code>malloc()</code>或<code>new</code>来分配内存，并使用<code>free()</code>或<code>delete</code>释放内存。</li><li>C++的<code>std::string</code>类自动管理内存，通过构造函数和析构函数自动处理内存，无需手动分配或释放内存。</li></ul></li><li><p><strong>字符串操作</strong>：</p><ul><li>C风格字符串的操作需要使用一系列的字符串处理函数（如<code>strcpy()</code>、<code>strcat()</code>、<code>strlen()</code>等），这些函数需要将字符串指针作为参数。</li><li>C++的<code>std::string</code>类提供了丰富的成员函数，如<code>append()</code>、<code>length()</code>、<code>find()</code>等，可以直接操作字符串对象，更加方便和易用。</li></ul></li><li><p><strong>安全性</strong>：</p><ul><li><p>C风格字符串没有提供越界检查，需要开发人员自行保证字符串的正确性。</p><ul><li>C++的<code>std::string</code>类具有越界检查功能，可以避免缓冲区溢出等安全问题。</li></ul><p><img src="/images/image-20250513220823443.png" alt="image-20250513220823443"></p></li></ul><p>连接字符串常用</p><p><img src="/images/image-20250513220915980.png" alt="image-20250513220915980"></p><h3 id="向量的概念和优势"><a href="#向量的概念和优势" class="headerlink" title="向量的概念和优势"></a>向量的概念和优势</h3><ol><li><strong>动态数组容器</strong>：<ul><li>向量是C++标准库提供的一种动态数组容器，使用前需要包含头文件<code>&lt;vector&gt;</code>。</li></ul></li><li><strong>线性存储</strong>：<ul><li>向量是一种线性容器，可以存储同一类型的元素。</li></ul></li><li><strong>顺序存储</strong>：<ul><li>向量中的元素按照它们在向量中的顺序进行存储。</li></ul></li><li><strong>随机访问</strong>：<ul><li>向量支持随机访问，可以通过索引访问向量中的元素。</li></ul></li><li><strong>动态调整大小</strong>：<ul><li>向量的大小可以动态调整，可以根据需要动态添加或删除元素。</li></ul></li><li><strong>优势</strong>：<ul><li>向量具有动态大小、随机访问、内存管理简单、较好的可扩展性等优势。</li></ul></li></ol><h3 id="向量的创建和初始化"><a href="#向量的创建和初始化" class="headerlink" title="向量的创建和初始化"></a>向量的创建和初始化</h3><ol><li><p><strong>创建空向量</strong>：</p><ul><li>使用<code>std::vector&lt;int&gt; myVector;</code>创建一个空的整型向量。</li></ul></li><li><p><strong>初始化向量</strong>：</p><ul><li>可以通过初始化列表、使用迭代器、使用默认值等方式初始化向量。</li></ul><p><img src="/images/image-20250513221111990.png" alt="image-20250513221111990"></p></li></ol><p><img src="/images/image-20250513221125703.png" alt="image-20250513221125703"></p></li></ol><p><img src="/images/image-20250513221153145.png" alt="image-20250513221153145"></p><h1 id="指针的声明和初始化"><a href="#指针的声明和初始化" class="headerlink" title="指针的声明和初始化"></a>指针的声明和初始化</h1><ol><li><p><strong>声明与初始化语法</strong>：</p><ul><li><p>语法格式为：<code>&lt;数据类型&gt;* &lt;指针名称&gt; = &lt;空指针或已存在变量地址&gt;;</code></p></li><li><p>示例：声明一个指向整数的指针并初始化为空指针。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>内存分配</strong>：</p><ul><li><p>在使用指针之前，确保为指针分配了合适的内存空间或者将其初始化为有效的内存地址。</p></li><li><p>示例：使用动态内存分配为指针分配内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>释放内存</strong>：</p><ul><li><p>使用动态分配的内存后，要记得使用<code>delete</code>运算符释放该内存，以避免内存泄漏。</p></li><li><p>示例：释放之前分配的内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> ptr;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>当然，这里有一个使用<code>new</code>和<code>delete</code>运算符进行动态内存分配和释放的实际例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 动态分配一个整数的内存</span></span><br><span class="line">    <span class="type">int</span>* dynamicInt = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">// 分配内存并初始化为0（对于基本数据类型）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给动态分配的内存赋值</span></span><br><span class="line">    *dynamicInt = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出动态分配内存中的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value of dynamicInt is: &quot;</span> &lt;&lt; *dynamicInt &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用完动态分配的内存后，释放它</span></span><br><span class="line">    <span class="keyword">delete</span> dynamicInt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放后，尝试访问dynamicInt将会导致未定义行为</span></span><br><span class="line">    <span class="comment">// *dynamicInt = 100; // 这行代码如果被执行，将会导致错误</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Memory has been freed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ol><li>使用<code>new int</code>为一个整数动态分配了内存，并将返回的指针赋值给<code>dynamicInt</code>。</li><li>通过解引用指针<code>*dynamicInt</code>给这块内存赋值为42。</li><li>输出这块内存中的值。</li><li>使用<code>delete dynamicInt</code>释放了之前分配的内存。</li><li>释放内存后，<code>dynamicInt</code>指针不再指向有效的内存区域，如果再次访问它将会导致未定义行为，可能是程序崩溃或其他不可预知的结果。</li></ol><p>请注意，对于数组，应该使用<code>delete[]</code>来释放内存：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* dynamicIntArray = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]; <span class="comment">// 动态分配一个整数数组的内存</span></span><br><span class="line"><span class="comment">// ... 使用数组</span></span><br><span class="line"><span class="keyword">delete</span>[] dynamicIntArray; <span class="comment">// 释放数组内存</span></span><br></pre></td></tr></table></figure><p>正确地管理内存是非常重要的，因为它可以防止内存泄漏和其他内存相关的问题。在现代C++中，通常推荐使用智能指针（如<code>std::unique_ptr</code>和<code>std::shared_ptr</code>），因为它们可以自动管理内存，从而减少内存泄漏的风险。</p><p>是的，<code>std::unique_ptr</code>和<code>std::shared_ptr</code>是C++11及以后版本中引入的智能指针，它们可以帮助自动管理内存，减少内存泄漏的风险。使用这些智能指针，通常不需要（也不应该）手动调用<code>delete</code>来释放内存。智能指针会在适当的时候自动释放它们所管理的资源。</p><h3 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h3><p><code>std::unique_ptr</code>代表独占所有权的智能指针，意味着同一时间只能有一个<code>std::unique_ptr</code>指向特定资源。当<code>std::unique_ptr</code>被销毁时（例如，当它离开作用域或被重新赋值时），它会自动释放所管理的资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionUsingUniquePtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 当ptr离开作用域时，它所管理的内存将自动被释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">functionUsingUniquePtr</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，当<code>ptr</code>离开<code>functionUsingUniquePtr</code>函数的作用域时，它所管理的内存会自动被释放。</p><h3 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h3><p><code>std::shared_ptr</code>代表共享所有权的智能指针，允许多个<code>std::shared_ptr</code>实例共同拥有同一资源。资源的释放是在最后一个拥有该资源的<code>std::shared_ptr</code>被销毁或被赋值为其他资源时自动进行的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">createSharedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">createSharedPtr</span>();</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1; <span class="comment">// 现在ptr1和ptr2共享同一个资源</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *ptr1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ptr1和ptr2离开作用域时，它们所管理的内存不会被释放，因为引用计数不为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>ptr1</code>和<code>ptr2</code>共享同一个资源。当<code>main</code>函数结束时，这两个智能指针都会被销毁，因为它们的引用计数都变为0，所以它们管理的内存会被自动释放。</p><p>总的来说，使用<code>std::unique_ptr</code>和<code>std::shared_ptr</code>可以大大简化内存管理，减少内存泄漏和其他内存管理错误的风险。然而，智能指针也有其开销，因此在性能敏感的应用中，需要权衡使用智能指针的便利性和性能开销。</p><h3 id="指针的简单使用"><a href="#指针的简单使用" class="headerlink" title="指针的简单使用"></a>指针的简单使用</h3><ol><li><p><strong>变量地址获取</strong>：</p><ul><li><p>使用<code>&amp;</code>运算符可以获取变量的地址，并将其赋值给指针。</p></li><li><p>示例：获取变量的地址并赋值给指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;var;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>解引用</strong>：</p><ul><li><p>使用<code>*</code>运算符可以解引用指针，即访问指针所指向的变量的值。</p></li><li><p>示例：通过指针访问变量的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; *ptr;  <span class="comment">// 输出：10</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>动态内存分配</strong>：</p><ul><li><p>使用<code>new</code>运算符可以动态分配内存，返回指向该内存的指针。</p></li><li><p>示例：动态分配内存并初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>数组操作</strong>：</p><ul><li><p>指针可以用于数组的访问和操作。</p></li><li><p>示例：使用指针遍历数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptr = arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; *(ptr + i) &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出：1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>函数参数传递</strong>：</p><ul><li><p>指针可以被用来在函数之间传递参数，使得函数可以直接修改指向对象的值。</p></li><li><p>示例：通过指针修改变量的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> *ptr)</span> </span>&#123;</span><br><span class="line">    *ptr = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">modify</span>(&amp;var);</span><br><span class="line">    std::cout &lt;&lt; var;  <span class="comment">// 输出：30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="C-容器与智能指针"><a href="#C-容器与智能指针" class="headerlink" title="C++容器与智能指针"></a>C++容器与智能指针</h1><p><img src="/images/image-20250514182018774.png" alt="image-20250514182018774"></p><p><img src="/images/image-20250514182052165.png" alt="image-20250514182052165"></p><p><img src="/images/image-20250514182157447.png" alt="image-20250514182157447"></p><p><img src="/images/image-20250514182150823.png" alt="image-20250514182150823"></p><h3 id="数组（固定大小的连续存储空间）"><a href="#数组（固定大小的连续存储空间）" class="headerlink" title="数组（固定大小的连续存储空间）"></a>数组（固定大小的连续存储空间）</h3><ul><li><strong>声明和定义</strong>：<ul><li>使用声明符号<code>[]</code>来声明数组，并指定数组的大小。</li><li>数组的大小必须是常量表达式，可以在编译时确定。</li><li>数组的元素类型可以是任意的基本类型（如整数、浮点数、字符等），也可以是自定义的类型。</li></ul></li><li><strong>数组元素的访问</strong>：<ul><li>数组元素通过索引访问，索引从0开始，到数组大小减1结束。</li><li>使用方括号<code>[]</code>运算符和元素的索引来访问数组元素。</li></ul></li><li><strong>数组的初始化</strong>：<ul><li>可以在声明数组时同时进行初始化，或者在后续的操作中对数组元素进行赋值。</li><li>使用花括号<code>&#123;&#125;</code>来提供初始值。可以使用花括号列表初始化整个数组，或者使用索引逐个初始化数组元素。</li></ul></li><li><strong>数组的遍历</strong>：<ul><li>可以使用循环结构（如<code>for</code>循环）来遍历数组，以访问和处理数组中的每个元素。</li></ul></li></ul><h3 id="向量（Vector，动态数组，可变大小的连续存储空间）"><a href="#向量（Vector，动态数组，可变大小的连续存储空间）" class="headerlink" title="向量（Vector，动态数组，可变大小的连续存储空间）"></a>向量（Vector，动态数组，可变大小的连续存储空间）</h3><ul><li><strong>声明和定义向量</strong>：<ul><li>使用<code>std::vector</code>类模板来声明和定义向量。</li><li>指定向量中元素的类型作为模板参数。</li></ul></li><li><strong>向量的操作</strong>：<ul><li>向量提供了一系列成员函数和操作符来进行元素的插入、删除、访问和修改等操作。</li><li>通过成员函数和操作符，可以获取向量的大小、清空向量、判断向量是否为空等。</li></ul></li><li><strong>向量的遍历</strong>：<ul><li>可以使用循环结构（如<code>for</code>循环）来遍历向量，以访问和处理向量中的每个元素。</li></ul></li></ul><h3 id="列表（List，双向链表结构）"><a href="#列表（List，双向链表结构）" class="headerlink" title="列表（List，双向链表结构）"></a>列表（List，双向链表结构）</h3><ul><li><strong>声明和定义列表</strong>：<ul><li>使用<code>std::list</code>类模板来声明和定义列表。</li><li>指定列表中元素的类型作为模板参数。</li></ul></li><li><strong>列表的操作</strong>：<ul><li>列表提供了一系列成员函数来进行元素的插入、删除、访问和修改等操作。</li><li>通过成员函数，可以获取列表的大小、清空列表、判断列表是否为空等。</li></ul></li><li><strong>列表的遍历</strong>：<ul><li>可以使用迭代器或循环结构（如<code>for</code>循环）来遍历列表，以访问和处理列表中的每个元素。</li></ul></li></ul><p>这些容器各有特点和适用场景，选择哪种容器取决于具体的应用需求。例如，如果需要频繁地在容器中间插入或删除元素，列表可能是更好的选择；如果需要快速随机访问元素，向量或数组可能更合适。</p><p><img src="/images/image-20250514182631401.png" alt="image-20250514182631401"></p><h3 id="映射（Map）容器概述"><a href="#映射（Map）容器概述" class="headerlink" title="映射（Map）容器概述"></a>映射（Map）容器概述</h3><ul><li><strong>定义</strong>：映射（Map）是一种键值对的容器，用于存储和管理键值对（key-value）数据。</li><li><strong>特点</strong>：映射是C++标准库中的一种容器，提供了方便的操作和管理键值对数据的方法。</li><li><strong>键的唯一性</strong>：映射类似于字典的概念，其中键是唯一的，可以用于快速查找和访问对应的值。</li><li><strong>头文件</strong>：映射类定义在<code>&lt;map&gt;</code>头文件中，需要引入该头文件才能使用映射。</li></ul><h3 id="声明和定义映射"><a href="#声明和定义映射" class="headerlink" title="声明和定义映射"></a>声明和定义映射</h3><ul><li><strong>使用<code>std::map</code>类模板</strong>：使用<code>std::map</code>类模板来声明和定义映射。</li><li><strong>模板参数</strong>：指定键和值的类型作为模板参数。</li></ul><h3 id="映射的操作"><a href="#映射的操作" class="headerlink" title="映射的操作"></a>映射的操作</h3><ul><li><strong>成员函数和操作符</strong>：映射提供了一系列成员函数和操作符来进行键值对的插入、删除、查找和访问等操作。</li><li><strong>获取映射大小</strong>：通过成员函数，可以获取映射的大小。</li><li><strong>清空映射</strong>：可以清空映射，即删除映射中的所有键值对。</li><li><strong>判断映射是否为空</strong>：可以判断映射是否为空。</li></ul><h3 id="映射的遍历"><a href="#映射的遍历" class="headerlink" title="映射的遍历"></a>映射的遍历</h3><ul><li><strong>迭代器或循环结构</strong>：可以使用迭代器或循环结构（如<code>for</code>循环）来遍历映射，以访问和处理映射中的每个键值对。</li></ul><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><ul><li><p><strong>声明映射</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; studentGrades; <span class="comment">// 声明一个字符串到整数的映射</span></span><br><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; phoneBook; <span class="comment">// 声明一个整数到字符串的映射</span></span><br></pre></td></tr></table></figure></li><li><p><strong>插入键值对</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">studentGrades[<span class="string">&quot;Alice&quot;</span>] = <span class="number">90</span>; <span class="comment">// 插入一个键值对</span></span><br><span class="line">studentGrades[<span class="string">&quot;Bob&quot;</span>] = <span class="number">85</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>访问键值对</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; studentGrades[<span class="string">&quot;Alice&quot;</span>] &lt;&lt; std::endl; <span class="comment">// 访问键对应的值</span></span><br></pre></td></tr></table></figure></li><li><p><strong>遍历映射</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (std::map&lt;std::string, <span class="type">int</span>&gt;::iterator it = studentGrades.<span class="built_in">begin</span>(); it != studentGrades.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl; <span class="comment">// 输出键值对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="常见容器的分类"><a href="#常见容器的分类" class="headerlink" title="常见容器的分类"></a>常见容器的分类</h1><p><img src="/images/image-20250514183545638.png" alt="image-20250514183545638"></p><h4 id="1-顺序容器（Sequence-Container）"><a href="#1-顺序容器（Sequence-Container）" class="headerlink" title="1. 顺序容器（Sequence Container）"></a>1. 顺序容器（Sequence Container）</h4><ul><li><strong>存储方式</strong>：顺序容器按照元素的插入顺序来存储元素，元素在容器中的位置由插入顺序决定。</li><li><strong>访问方式</strong>：可以使用迭代器（iterator）或下标运算符来访问容器中的元素。</li><li><strong>示例容器</strong>：包括向量（vector）、双向链表（list）、双端队列（deque）等。</li></ul><h4 id="2-有序容器（Ordered-Container）"><a href="#2-有序容器（Ordered-Container）" class="headerlink" title="2. 有序容器（Ordered Container）"></a>2. 有序容器（Ordered Container）</h4><ul><li><strong>存储方式</strong>：有序容器按照一定的排序准则对元素进行排序，并在插入时维持元素的有序性。</li><li><strong>访问方式</strong>：可以使用迭代器或下标运算符来访问容器中的元素（元素的顺序是根据排序准则来决定的）。</li><li><strong>示例容器</strong>：包括集合（set）、映射（map）、多重集合（multiset）、多重映射（multimap）等。</li></ul><h3 id="其他区别"><a href="#其他区别" class="headerlink" title="其他区别"></a>其他区别</h3><ul><li><strong>适用场景</strong>：<ul><li>顺序容器适用于需要保留元素插入顺序的场景。</li><li>有序容器适用于需要根据排序准则进行存储和访问的场景。</li></ul></li><li><strong>插入和删除操作</strong>：<ul><li>顺序容器的插入和删除操作可能会导致元素在内存中的重新分配和移动。</li><li>有序容器则需要保持元素的有序性，因此插入和删除操作可能更复杂。</li></ul></li><li><strong>查找操作</strong>：<ul><li>顺序容器的查找操作通常需要遍历整个容器，时间复杂度为O(n)。</li><li>有序容器可以利用内部的排序结构进行快速的查找，时间复杂度为O(log n)。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>顺序容器</strong>：适用于需要保留元素插入顺序的场景，如向量、列表、双端队列。</li><li><strong>有序容器</strong>：适用于需要根据排序准则进行存储和访问的场景，如集合、映射、多重集合、多重映射。</li><li><strong>性能差异</strong>：顺序容器的查找操作通常较慢，而有序容器可以利用排序结构进行快速查找。</li></ul><p><img src="/images/image-20250514183612141.png" alt="image-20250514183612141"></p><p><img src="/images/image-20250514183634954.png" alt="image-20250514183634954"></p><h3 id="遍历容器元素"><a href="#遍历容器元素" class="headerlink" title="遍历容器元素"></a>遍历容器元素</h3><h4 id="使用迭代器遍历容器元素"><a href="#使用迭代器遍历容器元素" class="headerlink" title="使用迭代器遍历容器元素"></a>使用迭代器遍历容器元素</h4><ul><li><strong>迭代器</strong>：是一种能够遍历容器元素的对象，类似于指针。</li><li><strong>获取迭代器</strong>：容器类通常提供<code>begin()</code>和<code>end()</code>成员函数来获取迭代器的起始和结束位置。</li><li><strong>遍历方法</strong>：可以使用循环结构（如<code>while</code>或<code>for</code>循环）和迭代器逐个访问容器元素。</li></ul><h4 id="使用范围-for循环遍历容器元素"><a href="#使用范围-for循环遍历容器元素" class="headerlink" title="使用范围-for循环遍历容器元素"></a>使用范围-for循环遍历容器元素</h4><ul><li><strong>范围-for循环</strong>：是C++11引入的语法，可以简化容器元素的遍历。</li><li><strong>自动类型推断</strong>：使用<code>auto</code>关键字来推断迭代器的类型，并使用范围-for循环对容器进行遍历。</li></ul><h3 id="容器的遍历和常用操作"><a href="#容器的遍历和常用操作" class="headerlink" title="容器的遍历和常用操作"></a>容器的遍历和常用操作</h3><h4 id="插入和删除元素"><a href="#插入和删除元素" class="headerlink" title="插入和删除元素"></a>插入和删除元素</h4><ul><li><strong>插入元素</strong>：<ul><li>顺序容器中使用<code>push_back()</code>或<code>push_front()</code>函数，分别在容器尾部和头部插入元素。</li><li>有序容器中使用<code>insert()</code>函数，在容器指定位置插入元素。</li></ul></li><li><strong>删除元素</strong>：<ul><li>顺序容器中使用<code>pop_back()</code>或<code>pop_front()</code>函数，分别删除在容器尾部和头部的元素。</li><li>使用<code>erase()</code>函数，删除有序容器和映射中指定位置或者指定键的元素。</li></ul></li></ul><h4 id="查找和替换元素"><a href="#查找和替换元素" class="headerlink" title="查找和替换元素"></a>查找和替换元素</h4><ul><li><strong>查找元素</strong>：<ul><li>有序容器和映射中，使用<code>find()</code>函数在容器中查找指定元素，并返回该元素的迭代器。</li><li>有序容器和映射中，使用<code>count()</code>函数计算容器中指定元素的个数。</li></ul></li><li><strong>替换元素</strong>：<ul><li>可以使用迭代器来直接修改容器中的元素。</li><li>使用下标运算符[]直接修改容器中的元素。</li></ul></li></ul><h4 id="容器大小和容量的操作"><a href="#容器大小和容量的操作" class="headerlink" title="容器大小和容量的操作"></a>容器大小和容量的操作</h4><ul><li><strong>容器大小</strong>：<ul><li>使用容器的成员函数<code>size()</code>函数获取容器中的元素个数。</li><li>使用容器的成员函数<code>empty()</code>函数检查容器是否为空，容器中没有元素则返回true，否则返回false。</li></ul></li><li><strong>容器容量</strong>：<ul><li>使用容器的成员函数<code>capacity()</code>，获取容器重新分配内容之前可以容纳的元素个数。</li><li>使用容器的成员函数<code>reserve()</code>，为容器设置预留的容量，可以避免频繁的重新分配内存。</li></ul></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这些操作涵盖了C++容器的基本使用，包括遍历、插入、删除、查找、替换以及获取容器的大小和容量等。通过这些操作，可以有效地管理和操作容器中的数据。使用迭代器和范围-for循环可以方便地遍历容器，而各种成员函数则提供了对容器元素的增删改查等操作。理解这些基本概念和操作对于在C++中有效地使用容器至关重要。</p><p><img src="/images/image-20250518220951020.png" alt="image-20250518220951020"></p><h3 id="公有成员"><a href="#公有成员" class="headerlink" title="公有成员"></a>公有成员</h3><ul><li><strong>定义</strong>：通过公有访问修饰符<code>public</code>修饰的成员变量或成员函数。</li><li><strong>访问权限</strong>：<ul><li><strong>公有成员变量</strong>：可以被类的对象和类外部代码直接访问和修改。</li><li><strong>公有成员函数</strong>：可以被类的对象和类外部代码调用。</li></ul></li></ul><h3 id="保护成员"><a href="#保护成员" class="headerlink" title="保护成员"></a>保护成员</h3><ul><li><strong>定义</strong>：通过保护访问修饰符<code>protected</code>修饰的成员变量或成员函数。</li><li><strong>访问权限</strong>：<ul><li><strong>保护成员变量</strong>：只能被类的派生类访问和修改。</li><li><strong>保护成员函数</strong>：只能被类的派生类调用。</li></ul></li></ul><h3 id="私有成员"><a href="#私有成员" class="headerlink" title="私有成员"></a>私有成员</h3><ul><li><strong>定义</strong>：通过私有访问修饰符<code>private</code>修饰的成员变量或成员函数。</li><li><strong>访问权限</strong>：<ul><li><strong>私有成员变量</strong>：只能被类的成员函数访问和修改。</li><li><strong>私有成员函数</strong>：只能被类的其他成员函数调用。</li></ul></li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>公有成员</strong>：具有最宽松的访问权限，可以被类的对象和类外部代码访问。</li><li><strong>保护成员</strong>：具有中等的访问权限，只能被类的派生类访问。</li><li><strong>私有成员</strong>：具有最严格的访问权限，只能被类的成员函数访问。</li></ul><p><img src="/images/image-20250518220805025.png" alt="image-20250518220805025"></p><h3 id="函数覆盖的概念和使用"><a href="#函数覆盖的概念和使用" class="headerlink" title="函数覆盖的概念和使用"></a>函数覆盖的概念和使用</h3><ul><li><strong>函数覆盖</strong>：派生类重写（覆盖）基类中的虚函数，以实现特定行为。这是实现运行时多态性的一种机制。</li><li><strong>使用关键字</strong>：<ul><li>在基类中声明虚函数时，使用关键字<code>virtual</code>来标识。</li><li>在派生类中重写（覆盖）基类中的虚函数。</li></ul></li></ul><h3 id="使用override和final关键字"><a href="#使用override和final关键字" class="headerlink" title="使用override和final关键字"></a>使用override和final关键字</h3><ul><li><strong>override关键字</strong>：<ul><li>在C++中，<code>override</code>和<code>final</code>是两个关键字，用于对虚函数进行重写和类进行继承的修饰。</li><li><code>override</code>关键字帮助我们确保正确地进行函数重写。</li><li><code>final</code>关键字防止派生和重写。</li><li><strong>用法</strong>：<ul><li><code>override</code>关键字可用于派生类中对基类虚函数的重写，以确保正确地进行函数覆盖。</li><li>在派生类中使用<code>override</code>关键字标识对基类中虚函数的重写，可以帮助我们在编译时捕获一些常见的错误，如函数签名不匹配的情况。</li><li>如果派生类中的函数声明使用<code>override</code>关键字，但实际上并没有重写基类中的虚函数，编译器将会发出错误提示。</li></ul></li></ul></li><li><strong>final关键字</strong>：<ul><li><code>final</code>关键字用于修饰类、虚函数或成员函数，表示它们是最终版本，禁止进一步的派生或重写。</li><li><strong>用法</strong>：<ul><li>在类声明中使用<code>final</code>关键字修饰类，表示该类是最终类，不能再被继承。</li><li>在虚函数声明中使用<code>final</code>关键字修饰虚函数，表示该虚函数不能再被派生类重写。</li><li>在成员函数声明中使用<code>final</code>关键字修饰成员函数，表示该成员函数不能在派生类中被重写。</li></ul></li></ul></li></ul><p>总结来说，<code>override</code>和<code>final</code>关键字在C++中用于确保类的继承和函数的重写符合预期，避免错误和歧义。</p><p><img src="/images/image-20250514183659851.png" alt="image-20250514183659851"></p><p><img src="/images/image-20250514183713078.png" alt="image-20250514183713078"></p><h1 id="C-常用总结"><a href="#C-常用总结" class="headerlink" title="C++常用总结"></a>C++常用总结</h1><p>​</p><ol><li><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a><strong>文件操作</strong></h1><ul><li>文件操作通常涉及创建、读取、写入和删除文件。在C++中，可以使用标准库中的<code>&lt;fstream&gt;</code>头文件提供的类，如<code>std::ifstream</code>（输入文件流）、<code>std::ofstream</code>（输出文件流）和<code>std::fstream</code>（输入输出文件流）来进行文件操作。</li></ul></li></ol><p>​文件指针的操作</p><p>在C++中，文件指针用于定位和控制文件中的读写位置。以下是文件指针操作的主要方法：</p><h4 id="获取文件指针的位置"><a href="#获取文件指针的位置" class="headerlink" title="获取文件指针的位置"></a>获取文件指针的位置</h4><ul><li>**<code>tellg()</code>**：用于获取输入文件流的当前读取位置。</li><li>**<code>tellp()</code>**：用于获取输出文件流的当前写入位置。</li></ul><h4 id="设置文件指针的位置"><a href="#设置文件指针的位置" class="headerlink" title="设置文件指针的位置"></a>设置文件指针的位置</h4><ul><li>**<code>seekg(pos)</code>**：将输入文件流的读取位置设置为相对于文件开头的<code>pos</code>位置。</li><li>**<code>seekp(pos)</code>**：将输出文件流的写入位置设置为相对于文件开头的<code>pos</code>位置。</li><li>**<code>seekg(offset, dir)</code> 和 <code>seekp(offset, dir)</code>**：在当前位置的基础上相对于<code>offset</code>进行偏移，<code>dir</code>可以是以下常量之一：<ul><li>**<code>std::ios::beg</code>**：相对于文件开头进行偏移。</li><li>**<code>std::ios::cur</code>**：相对于当前位置进行偏移。</li><li>**<code>std::ios::end</code>**：相对于文件末尾进行偏移。</li></ul></li></ul><h4 id="检查文件指针的有效性"><a href="#检查文件指针的有效性" class="headerlink" title="检查文件指针的有效性"></a>检查文件指针的有效性</h4><ul><li>**<code>good()</code>**：成员函数检查文件指针是否有效。如果文件指针有效，则返回<code>true</code>；否则返回<code>false</code>。</li></ul><ol><li><h1 id="空指针的处理"><a href="#空指针的处理" class="headerlink" title="空指针的处理"></a><strong>空指针的处理</strong></h1><ul><li>空指针是指没有指向任何对象的指针。在C++中，空指针通常用<code>nullptr</code>表示。处理空指针时，需要检查指针是否为空，避免解引用空指针，这会导致程序崩溃。可以使用条件语句来检查指针是否为<code>nullptr</code>。</li></ul></li></ol><p><img src="/images/image-20250514221542740.png" alt="image-20250514221542740"></p><h3 id="空指针的判断和使用"><a href="#空指针的判断和使用" class="headerlink" title="空指针的判断和使用"></a>空指针的判断和使用</h3><ul><li><p><strong>判断空指针</strong>：</p><ul><li><p>使用条件判断语句将目标指针与<code>nullptr</code>进行比较。如果指针为空（即没有指向任何对象），则条件为真；否则为假。</p></li><li><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 指针为空的处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>空指针的特性</strong>：</p><ul><li>空指针没有有效的内存地址，访问空指针指向的对象是不安全的，可能导致程序崩溃或未定义行为。</li><li>将<code>nullptr</code>赋值给指针，可以将指针显式地设置为空指针。</li></ul></li></ul><h3 id="避免空指针的错误"><a href="#避免空指针的错误" class="headerlink" title="避免空指针的错误"></a>避免空指针的错误</h3><ul><li><p><strong>检查动态分配的内存</strong>：</p><ul><li><p>在动态分配内存后，应该检查分配的指针是否为空，以确保内存分配成功。如果分配失败，指针将为<code>nullptr</code>。</p></li><li><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 内存分配失败的处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用指针前检查</strong>：</p><ul><li><p>在使用指针之前，始终检查指针是否为空，并尽量避免访问空指针。</p></li><li><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 安全地使用指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>空指针是C++编程中常见的问题，处理不当可能导致程序崩溃或未定义行为。以下是一些关键点：</p><ol><li><p><strong>判断空指针</strong>：使用条件判断语句将指针与<code>nullptr</code>比较，确保指针不为空后再使用。</p></li><li><p><strong>显式设置空指针</strong>：将<code>nullptr</code>赋值给指针，显式地将指针设置为空。</p></li><li><p><strong>检查动态内存分配</strong>：在动态分配内存后，检查指针是否为空，确保内存分配成功。</p></li><li><p><strong>使用前检查指针</strong>：在每次使用指针之前，检查指针是否为空，避免访问空指针。</p></li><li><h1 id="常用版本特性"><a href="#常用版本特性" class="headerlink" title="常用版本特性"></a><strong>常用版本特性</strong></h1><ul><li>这可能指的是C++语言的不同版本中引入的新特性。例如，C++11引入了自动类型推断（<code>auto</code>）、范围<code>for</code>循环、智能指针等。了解不同版本的新特性可以帮助开发者编写更现代、更高效的代码。</li></ul><p><img src="/images/image-20250514221601991.png" alt="image-20250514221601991"></p><h3 id="C-11-的特性和改进"><a href="#C-11-的特性和改进" class="headerlink" title="C++11 的特性和改进"></a>C++11 的特性和改进</h3><ol><li><strong>自动类型推导</strong>：<ul><li>引入了关键字 <code>auto</code>，可以根据初始化表达式的类型自动推导变量的类型。这简化了代码编写，特别是在处理复杂类型时。</li></ul></li><li><strong>统一的初始化语法</strong>：<ul><li>引入了初始化列表语法 <code>&#123;&#125;</code>，可以用于初始化数组、容器、结构体等各种类型的对象。这种语法提供了一种统一且直观的方式来初始化对象。</li></ul></li><li><strong>范围-based for 循环</strong>：<ul><li>引入了新的循环语法 <code>for (element : sequence)</code>，用于遍历容器、数组等序列中的元素。这种循环语法使代码更加简洁和易读。</li></ul></li><li><strong>空指针常量</strong>：<ul><li>引入了关键字 <code>nullptr</code>，用于表示空指针。它可以用来替代旧的表示空指针的 <code>NULL</code> 或者 <code>0</code>，提供了更强的类型安全。</li></ul></li><li><strong>强类型枚举</strong>：<ul><li>引入了新的枚举语法，允许为枚举类型指定底层类型，并提供了更强的类型检查。这使得枚举类型更加安全和灵活。</li></ul></li><li><strong>Lambda 表达式</strong>：<ul><li>引入了匿名函数的概念，允许在代码中定义小型的匿名函数。Lambda 表达式可以捕获外部变量，并可以作为函数对象使用，这在编写回调函数和处理事件时非常有用。</li></ul></li><li><strong>智能指针</strong>：<ul><li>引入了三种智能指针类型：<code>std::unique_ptr</code>、<code>std::shared_ptr</code> 和 <code>std::weak_ptr</code>。这些智能指针类型简化了动态内存管理，自动管理内存的分配和释放，减少了内存泄漏的风险。</li></ul></li><li><strong>并发编程支持</strong>：<ul><li>引入了线程库、互斥量、条件变量等多线程和并发编程的支持。这些特性使得C++能够更好地支持并发编程，方便开发者编写并发程序。</li></ul></li></ol><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>C++11标准引入了大量新特性和改进，这些特性不仅提高了代码的可读性和安全性，还简化了代码编写和内存管理。通过使用这些新特性，开发者可以编写更简洁、更安全、更高效的代码，充分利用C++语言的强大功能。同时，这些特性也使得C++语言在现代软件开发中更具竞争力，适用于各种应用场景。</p></li><li><h1 id="常见的编码技巧和最佳实践"><a href="#常见的编码技巧和最佳实践" class="headerlink" title="常见的编码技巧和最佳实践"></a><strong>常见的编码技巧和最佳实践</strong></h1><ul><li>编码技巧和最佳实践包括代码的组织结构、命名约定、内存管理、错误处理等。例如，使用有意义的变量名、避免魔法数字、编写可重用的代码、进行异常处理等。这些实践有助于提高代码的可读性、可维护性和性能。</li></ul><p><img src="/images/image-20250514221828341.png" alt="image-20250514221828341"></p></li></ol><p><img src="/images/image-20250514221850561.png" alt="image-20250514221850561"></p><p><img src="/images/image-20250514221906985.png" alt="image-20250514221906985"></p><p><img src="/images/image-20250514221943742.png" alt="image-20250514221943742"></p><ol><li><h1 id="一些友善的建议"><a href="#一些友善的建议" class="headerlink" title="一些友善的建议"></a><strong>一些友善的建议</strong></h1><ul><li>这可能包括编程时的一些软技能建议，如团队合作、代码审查、持续学习等。友善的建议有助于提高开发者的工作效率和团队的整体表现。</li></ul></li></ol><p><img src="/images/image-20250514222009032.png" alt="image-20250514222009032"></p><p><img src="/images/image-20250514222021860.png" alt="image-20250514222021860"></p><p><img src="/images/image-20250514222048606.png" alt="image-20250514222048606"></p><h1 id="车载事业部C-代码规范培训"><a href="#车载事业部C-代码规范培训" class="headerlink" title="车载事业部C++代码规范培训"></a>车载事业部C++代码规范培训</h1><p><img src="/images/image-20250514222156466.png" alt="image-20250514222156466"></p><p><img src="/images/image-20250515212602980.png" alt="image-20250515212602980"></p><p><img src="/images/image-20250515215400176.png" alt="image-20250515215400176"></p><h2 id="1-预处理宏"><a href="#1-预处理宏" class="headerlink" title="1. 预处理宏"></a>1. 预处理宏</h2><p>主要目的是<strong>避免宏带来的问题</strong>，给出了一些规范和建议：</p><ul><li>不要在 .h 文件中定义宏。<ul><li>避免头文件被多处引用时意外影响其它代码。</li></ul></li><li>在马上要使用时才进行 #define，使用后要立即 #undef。<ul><li>这样可以减少宏对其它代码的影响，做到用完即丢。</li></ul></li><li>不要只是对已经存在的宏使用 #undef，选择一个不会冲突的名称。<ul><li>避免冲突和潜在的命名污染。</li></ul></li><li>不要试图使用展开后会导致 C++ 构造不稳定的宏，否则至少要附上文档说明其行为。<ul><li>指的是有些宏展开后可能对 C++ 构造（如类、函数等）产生不可预期影响，因此要谨慎使用并注明。</li></ul></li><li>不要用 ## 处理函数、类和变量的名字。<ul><li>这是宏拼接符，容易导致名字混淆，可读性和可维护性差。</li></ul></li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>这些规范旨在<strong>减少预处理宏带来的副作用</strong>，提高代码的可维护性和安全性。</p><hr><h2 id="2-整型变量的定义"><a href="#2-整型变量的定义" class="headerlink" title="2. 整型变量的定义"></a>2. 整型变量的定义</h2><p>主要讲述<strong>整型变量的选择</strong>，以及推荐用法：</p><ul><li><p><strong>优先用 C++ 内建类型 int。</strong></p></li><li><p>需要不同大小时建议用 <code>&lt;stdint.h&gt;</code> 里的精确整型 如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int16_t  int32_t  int32_t</span><br></pre></td></tr></table></figure><ul><li>这样可以明确表达变量的位数，提升代码可移植性和准确性。</li></ul></li><li><p>如果变量可能超过 int 能表示的范围，比如大于 2^31（2GiB），就应该直接用 64 位变量 int64_t。</p><ul><li>这样可以避免溢出和数据错误。</li></ul></li><li><p>即使值不会超过 int 表示的范围，在计算过程中也可能溢出。</p><ul><li>所以宁可用大类型，不要“拿不准时用更大的类型”。</li></ul></li></ul><h3 id="介绍："><a href="#介绍：" class="headerlink" title="&lt;stdint.h&gt; 介绍："></a><code>&lt;stdint.h&gt;</code> 介绍：</h3><ul><li>里面定义了 <code>int16_t</code>、<code>uint32_t</code>、<code>int64_t</code> 等精确大小的整型。</li><li>如果需要保证整型大小，可以用这些类型代替 <code>short</code>、<code>unsigned long long</code> 等。</li></ul><hr><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>宏的使用要谨慎，避免污染、冲突、难以维护。</strong><ul><li><strong>整型变量建议用精确类型，防止溢出和类型不确定的问题，提升代码的健壮性和可移植性</strong></li></ul></li></ul><h1 id="DTS"><a href="#DTS" class="headerlink" title="DTS"></a>DTS</h1><h3 id="一、什么是DTS"><a href="#一、什么是DTS" class="headerlink" title="一、什么是DTS"></a>一、什么是DTS</h3><p>DTS是一种描述硬件设备信息的文件格式，主要用于Linux内核中。它以文本的形式描述硬件设备的属性、连接关系等信息，然后通过设备树编译器（DTC）将其编译成设备树二进制文件（.dtb），供内核在启动时加载和解析，从而实现对硬件设备的识别和初始化。</p><h3 id="二、需要了解DTS的情况"><a href="#二、需要了解DTS的情况" class="headerlink" title="二、需要了解DTS的情况"></a>二、需要了解DTS的情况</h3><ol><li><strong>使用Linux内核的嵌入式开发</strong><ul><li>如果你开发的嵌入式系统使用Linux内核，那么了解DTS是非常重要的。因为Linux内核从3.5版本开始，对于许多嵌入式平台（如ARM、RISC-V等）都推荐使用设备树来描述硬件。例如，在开发基于ARM架构的嵌入式设备时，你需要通过DTS文件来告诉内核硬件设备的详细信息，如GPIO引脚的用途、外设的地址范围、时钟配置等。只有这样，内核才能正确地初始化和驱动硬件设备。</li><li>例如，对于一个带有多功能GPIO引脚的嵌入式开发板，你可能需要在DTS文件中指定某个GPIO引脚用于I2C通信，而另一个引脚用于普通数字输入输出。如果DTS文件配置错误，可能会导致硬件设备无法正常工作。</li></ul></li><li><strong>硬件平台的移植和定制开发</strong><ul><li>当你需要将Linux内核移植到一个新的硬件平台或者对现有硬件平台进行定制开发时，DTS文件的编写和修改是必不可少的。因为不同的硬件平台有不同的硬件架构和设备配置，你需要通过DTS文件来适配这些差异。比如，当你将一个Linux内核版本从一个开发板移植到另一个具有不同外设的开发板时，就需要修改DTS文件，以确保内核能够正确识别和管理新开发板上的硬件设备。</li></ul></li><li><strong>驱动开发</strong><ul><li>对于嵌入式系统中的驱动开发，DTS文件提供了硬件设备的接口信息。驱动开发者可以通过DTS文件获取硬件设备的寄存器地址、中断号等关键信息，从而编写出能够正确与硬件设备交互的驱动程序。例如，开发一个SPI设备的驱动时，驱动代码需要从DTS文件中获取SPI控制器的设备树节点信息，包括SPI设备的片选号、时钟速率等参数，才能实现对SPI设备的有效控制。</li></ul></li></ol><h3 id="三、不需要了解DTS的情况"><a href="#三、不需要了解DTS的情况" class="headerlink" title="三、不需要了解DTS的情况"></a>三、不需要了解DTS的情况</h3><ol><li><strong>使用非Linux内核的嵌入式开发</strong><ul><li>如果你的嵌入式系统使用的是其他操作系统（如RTOS，即实时操作系统，像FreeRTOS、μC&#x2F;OS-II等）或者无操作系统，那么DTS文件通常不会被用到。因为这些系统通常采用不同的方式来管理硬件设备，例如通过直接在代码中硬编码硬件设备的地址和配置信息，而不是依赖于像DTS这样的设备树描述机制。</li></ul></li><li><strong>使用封装良好的开发平台和硬件抽象层</strong><ul><li>在一些嵌入式开发平台中，硬件厂商可能已经提供了高度封装的硬件抽象层（HAL）或者中间件，这些抽象层直接隐藏了硬件设备的具体细节，包括DTS文件的使用。在这种情况下，开发者可以直接调用抽象层提供的接口函数来操作硬件设备，而无需关心DTS文件。例如，一些基于STM32微控制器的开发平台，通过STM32 HAL库封装了硬件操作，开发者可以直接使用库函数来控制GPIO、定时器等外设，而无需编写DTS文件。</li></ul></li></ol><h1 id="QNX共享内存"><a href="#QNX共享内存" class="headerlink" title="QNX共享内存"></a>QNX共享内存</h1><p><img src="/images/image-20250521153325554.png" alt="image-20250521153325554"></p><h3 id="一、什么是QNX共享内存"><a href="#一、什么是QNX共享内存" class="headerlink" title="一、什么是QNX共享内存"></a>一、什么是QNX共享内存</h3><p>QNX是一个基于微内核的实时操作系统，其设计目标是提供高效的进程间通信（IPC）和资源管理机制。共享内存是QNX中一种重要的进程间通信方式，允许多个进程共享同一块物理内存区域，从而实现高效的数据交换和通信。</p><p>在QNX中，共享内存的使用通常涉及以下几个关键概念：</p><ol><li><strong>共享内存段（Shared Memory Segment）</strong>：这是共享内存的基本单位，由一个或多个进程创建和访问。</li><li><strong>内存映射（Memory Mapping）</strong>：通过内存映射机制，将共享内存段映射到进程的地址空间中，使得进程可以像访问普通内存一样访问共享内存。</li><li><strong>同步机制（Synchronization）</strong>：由于多个进程可能同时访问共享内存，因此需要使用同步机制（如信号量、互斥锁等）来避免数据竞争和不一致性问题。</li></ol><p><img src="/images/image-20250521153608341.png" alt="image-20250521153608341"></p><p><img src="/images/image-20250521153633809.png" alt="image-20250521153633809"></p><h3 id="QNX共享内存的优缺点"><a href="#QNX共享内存的优缺点" class="headerlink" title="QNX共享内存的优缺点"></a>QNX共享内存的优缺点</h3><ol><li><strong>优点</strong><ul><li><strong>高效性</strong>：共享内存是一种非常高效的进程间通信方式，因为它避免了数据的多次复制和传输。多个进程可以直接访问同一块物理内存，从而大大提高了数据交换的效率。</li><li><strong>灵活性</strong>：QNX的共享内存机制提供了灵活的控制方式，可以通过多种系统调用和库函数来创建、管理和访问共享内存。同时，还可以结合同步机制来实现复杂的并发控制。</li><li><strong>实时性</strong>：在实时系统中，共享内存可以快速地传递数据，满足实时性要求。例如，在高精度的工业控制系统中，共享内存可以用于实时传递传感器数据和控制指令。</li></ul></li><li><strong>缺点</strong><ul><li><strong>同步复杂性</strong>：由于多个进程可能同时访问共享内存，因此需要使用同步机制来避免数据竞争和不一致性问题。同步机制的使用增加了编程的复杂性，需要开发者仔细设计和实现。</li><li><strong>安全性问题</strong>：共享内存的访问权限需要严格控制，否则可能会导致安全问题。例如，如果一个恶意进程访问了共享内存，可能会篡改数据或导致系统崩溃。因此，在使用共享内存时，需要确保只有授权的进程才能访问共享内存。</li><li><strong>内存管理复杂性</strong>：共享内存的生命周期管理需要特别注意。如果某个进程意外崩溃或退出，可能会导致共享内存无法被正确释放，从而造成内存泄漏。因此，需要在程序设计中仔细处理共享内存的创建、使用和销毁过程。</li></ul></li></ol><h3 id="是否需要了解QNX共享内存"><a href="#是否需要了解QNX共享内存" class="headerlink" title="是否需要了解QNX共享内存"></a>是否需要了解QNX共享内存</h3><p>是否需要了解QNX共享内存，取决于你的开发需求和目标平台：</p><ol><li><strong>需要了解的情况</strong><ul><li>如果你正在开发基于QNX操作系统的嵌入式系统，尤其是涉及到多进程协作、实时数据交换或资源管理的场景，那么了解QNX共享内存是非常重要的。掌握共享内存的使用方法可以帮助你设计出高效、可靠的系统架构，提高系统的性能和实时性。</li><li>例如，在开发一个实时监控系统时，多个进程需要实时交换图像数据和传感器数据。通过使用QNX共享内存，可以快速地传递这些数据，同时结合同步机制确保数据的一致性和完整性。</li></ul></li><li><strong>不需要了解的情况</strong><ul><li>如果你的嵌入式系统不使用QNX操作系统，或者你的开发场景中不需要使用共享内存机制（例如，系统中只有一个进程，或者数据交换量非常小），那么了解QNX共享内存可能不是必要的。</li><li>另外，如果你使用的是封装良好的开发框架或中间件，这些框架可能已经隐藏了共享内存的实现细节，你只需要调用相关的接口函数即可实现进程间通信，而无需深入了解共享内存的底层机制。</li></ul></li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="/images/image-20250521154241355.png" alt="image-20250521154241355"></p><p><img src="/images/image-20250521154302419.png" alt="image-20250521154302419"></p><p>一个使用共享内存（Shared Memory）和互斥锁（Mutex）在QNX操作系统中进行进程间通信（IPC）的示例。下面我将详细解释这个示例的代码和运行结果。</p><h3 id="示例代码解释"><a href="#示例代码解释" class="headerlink" title="示例代码解释"></a>示例代码解释</h3><h4 id="shmemcreator-c"><a href="#shmemcreator-c" class="headerlink" title="shmemcreator.c"></a><code>shmemcreator.c</code></h4><p>这个程序创建共享内存和一个信号量，并在共享内存中写入一些文本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shmemcreator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *programname = <span class="string">&quot;shmemcreator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">shmem_t</span> *ptr;</span><br><span class="line">    <span class="type">pthread_mutexattr_t</span> myattr;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> myshmmutex;</span><br><span class="line"></span><br><span class="line">    pthread_mutexattr_init(&amp;myattr);</span><br><span class="line">    pthread_mutexattr_setpshared(&amp;myattr, PTHREAD_PROCESS_SHARED);</span><br><span class="line">    pthread_mutex_init(&amp;ptr-&gt;myshmemmutex, &amp;myattr);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;ptr-&gt;myshmemmutex);</span><br><span class="line">    <span class="built_in">strcpy</span>(ptr-&gt;text, <span class="string">&quot;Text by shmemcreator.c&quot;</span>); <span class="comment">/* write to the shared memory */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Shared memory created and semaphore initialized to 0.\n&quot;</span>,</span><br><span class="line">            programname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Wrote text &#x27;%s&#x27; to shared memory.\n&quot;</span>,</span><br><span class="line">            programname, ptr-&gt;text);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Sleeping for 20 seconds. While this program is sleeping\n&quot;</span>,</span><br><span class="line">            programname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: run &#x27;example_shmem_user&#x27;\n&quot;</span>, programname, programname);</span><br><span class="line">    sleep(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Woke up. Now unlocking the mutex.\n&quot;</span>, programname);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;ptr-&gt;myshmemmutex);</span><br><span class="line"></span><br><span class="line">    close(fd); <span class="comment">// Closing the file descriptor</span></span><br><span class="line">    munmap(ptr, <span class="keyword">sizeof</span>(<span class="type">shmem_t</span>)); <span class="comment">// removing the mapping</span></span><br><span class="line">    shm_unlink(<span class="string">&quot;/myshmemobject&quot;</span>); <span class="comment">// Delete the shared memory object</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shmemuser-c"><a href="#shmemuser-c" class="headerlink" title="shmemuser.c"></a><code>shmemuser.c</code></h4><p>这个程序打开共享内存对象，等待信号量，访问共享内存并读取其中的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shmemcreator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *programname = <span class="string">&quot;shmemuser&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">shmem_t</span> *ptr;</span><br><span class="line"></span><br><span class="line">    fd = shm_open(<span class="string">&quot;/myshmemobject&quot;</span>, O_RDWR, S_IRWXU);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: error opening the shared memory object: %s\n&quot;</span>,</span><br><span class="line">                programname, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr = mmap(<span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">shmem_t</span>),</span><br><span class="line">               PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Waiting on the mutex. Run &#x27;pidin&#x27;. I should be MUTEX_blocked.\n&quot;</span>,</span><br><span class="line">            programname);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;ptr-&gt;myshmemmutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Got the mutex, now accessing shared memory\n&quot;</span>, programname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Shared memory contains &#x27;%s&#x27;\n&quot;</span>, programname, ptr-&gt;text);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;ptr-&gt;myshmemmutex);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    munmap(ptr, <span class="keyword">sizeof</span>(<span class="type">shmem_t</span>));</span><br><span class="line">    <span class="keyword">return</span> (EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ./shmemcreator</span><br><span class="line">shmemcreator: Shared memory created and semaphore initialized to <span class="number">0.</span></span><br><span class="line">shmemcreator: Wrote text <span class="string">&#x27;Text by shmemcreator.c&#x27;</span> to shared memory</span><br><span class="line">shmemcreator: Sleeping <span class="keyword">for</span> <span class="number">20</span> seconds. While this program is sleeping</span><br><span class="line">shmemcreator: run <span class="string">&#x27;example_shmem_user&#x27;</span></span><br><span class="line"></span><br><span class="line"># ./shmemuser</span><br><span class="line">shmemuser: Waiting on the mutex. Run <span class="string">&#x27;pidin&#x27;</span>. I should be MUTEX_blocked.</span><br><span class="line">shmemuser: Got the mutex, now accessing shared memory</span><br><span class="line">shmemuser: The shared memory contains <span class="string">&#x27;Text by shmemcreator.c&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="运行结果解释"><a href="#运行结果解释" class="headerlink" title="运行结果解释"></a>运行结果解释</h4><p><strong><code>shmemcreator</code> 程序</strong>：</p><ul><li>创建共享内存和信号量，初始化为0。</li><li>写入文本 <code>&quot;Text by shmemcreator.c&quot;</code> 到共享内存。</li><li>打印共享内存创建和信号量初始化的信息。</li><li>打印写入共享内存的文本。</li><li>打印程序将要休眠20秒的信息。</li><li>休眠20秒。</li><li>解锁信号量。</li><li>关闭文件描述符，解除映射，删除共享内存对象。</li></ul><p><strong><code>shmemuser</code> 程序</strong>：</p><ul><li>打开共享内存对象。</li><li>将共享内存对象映射到进程地址空间。</li><li>等待信号量（此时会被阻塞，因为 <code>shmemcreator</code> 程序已经锁定了信号量）。</li><li>获取信号量后，访问共享内存并读取其中的内容。</li><li>打印读取到的共享内存内容。</li><li>解锁信号量。</li><li>关闭文件描述符，解除映射。</li></ul><p>运行 <code>shmemcreator</code> 程序后，它会创建共享内存，写入文本，然后休眠20秒。在此过程中，运行 <code>shmemuser</code> 程序，它会等待信号量，因为 <code>shmemcreator</code> 程序已经锁定了信号量。20秒后，<code>shmemcreator</code> 程序解锁信号量，<code>shmemuser</code> 程序获取信号量，访问共享内存并读取其中的内容。</p><p>这个示例展示了如何在QNX操作系统中使用共享内存和互斥锁进行进程间通信。<code>shmemcreator</code> 程序创建共享内存并写入数据，然后休眠一段时间。<code>shmemuser</code> 程序等待信号量，获取信号量后访问共享内存并读取数据。通过这种方式，可以实现多个进程之间的高效数据交换。</p><h2 id="通俗解释QNX程序"><a href="#通俗解释QNX程序" class="headerlink" title="通俗解释QNX程序"></a>通俗解释QNX程序</h2><p>想象你和朋友们在做一个团队项目，需要共享一些信息。为了避免混乱，你们决定用一个特别的“共享笔记本”来记录信息。这个笔记本就像电脑里的“共享内存”，大家都能看和写。</p><ol><li><strong>创建共享笔记本</strong>：<ul><li>你（<code>shmemcreator</code>程序）首先创建了这个共享笔记本，并写下了第一条信息：“Text by shmemcreator.c”。</li><li>然后你锁上了笔记本（使用互斥锁），这样其他人就不能同时写入，避免信息混乱。</li><li>你告诉其他人，你要休息20秒（程序休眠20秒），在这期间他们可以开始读取笔记本。</li></ul></li><li><strong>读取共享笔记本</strong>：<ul><li>你的朋友（<code>shmemuser</code>程序）看到你锁上了笔记本，就等着（等待互斥锁）。</li><li>20秒后，你回来解锁了笔记本，告诉你的朋友可以看了。</li><li>你的朋友打开笔记本，看到了你写的信息：“Text by shmemcreator.c”，然后他把这条信息告诉了团队里的其他人。</li></ul></li><li><strong>结束工作</strong>：<ul><li>你和你的朋友都完成了工作，你把笔记本收起来，这样其他人就不能再次访问它了。</li></ul></li></ol><p><strong>运行结果</strong>：</p><ul><li>你先创建了共享内存，写入了信息，然后休息了20秒。</li><li>在这期间，你的朋友尝试读取共享内存，但因为你锁定了它，所以他必须等待。</li><li>20秒后，你解锁了共享内存，你的朋友读取了里面的信息，并告诉了团队其他人。</li></ul><p>20秒等待主要是为了演示和测试的目的：</p><ol><li><p><strong>演示互斥锁的效果</strong>：<code>shmemcreator</code>程序通过锁定互斥锁来确保在它休眠的20秒内，<code>shmemuser</code>程序能够体验到等待互斥锁释放的过程。这展示了互斥锁的同步机制，即一个程序在访问共享资源时如何等待另一个程序释放锁。(你有足够的时间完成所有与笔记本相关的操作)</p></li><li><p><strong>测试共享内存的访问</strong>：通过在写入数据后休眠，<code>shmemcreator</code>程序确保了<code>shmemuser</code>程序在其休眠期间运行并尝试读取共享内存。这样可以测试<code>shmemuser</code>程序是否能够正确地等待互斥锁，以及在互斥锁释放后是否能够成功读取共享内存中的数据。(其他人不会在你完成之前干扰笔记本中的内容。)</p></li><li><p><strong>模拟实际应用场景</strong>：在实际应用中，可能存在一个程序需要在完成数据写入后，让另一个程序来处理这些数据的情况。通过休眠20秒，<code>shmemcreator</code>程序模拟了这种场景，即在一个程序完成数据处理后，另一个程序开始处理这些数据。(当你解锁笔记本时，其他人可以安全地访问最新的、完整的信息。)</p></li><li><p><strong>为什么你的朋友不能自己打开笔记本？</strong></p><ul><li>因为你在笔记本上加了一把锁（这就像是电脑里的互斥锁）。这把锁是为了防止大家同时写入笔记本，造成信息混乱。所以，只有你（或者有钥匙的人）能打开这个锁，其他人必须等待。</li></ul></li><li><p><strong>为什么一定要等20秒后才能打开给他看？</strong></p><ul><li>你告诉团队，你要休息20秒。在这期间，你的朋友不能打开笔记本，因为笔记本被锁住了。这20秒就像是你处理一些事情的时间，比如写一些重要的信息到笔记本里。</li></ul></li><li><p><strong>如果我打开了，不就是两个人一起看了吗？</strong></p><ul><li>当你20秒后回来，你打开了笔记本的锁，这时候你的朋友就可以看了。但是，即使他看了，也只有一个人能同时写入笔记本，因为每次只能有一个人拿着钥匙（解锁）。这样，其他人就不会同时写入，造成混乱。</li></ul></li></ol><h1 id="C语言编码规范"><a href="#C语言编码规范" class="headerlink" title="C语言编码规范"></a>C语言编码规范</h1><p><img src="/images/image-20250521164427381.png" alt="image-20250521164427381"></p><p><img src="/images/image-20250521164537900.png" alt="image-20250521164537900"></p><p><img src="/images/image-20250521164502982.png" alt="image-20250521164502982"></p><h3 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h3><ol><li><strong>组成</strong>：<ul><li>只能包含字母、数字和下划线。</li><li>不能以数字开头。</li><li>下划线不能出现在开头或结尾。</li></ul></li><li><strong>目的</strong>：<ul><li>让代码更易读。</li><li>避免混淆，例如 <code>variable_name</code> 和 <code>variable___name</code>。</li></ul></li><li><strong>命名原则</strong>：<ul><li>使用完整的英文描述。</li><li>遵循“最小长度 &amp; 最大信息”原则，谨慎使用缩写。</li></ul></li><li><strong>说明</strong>：<ul><li>如果缩写，需在代码中统一使用。例如，<code>num</code> 代表 <code>number</code>，则全程使用 <code>num</code>。</li></ul></li></ol><p>这样命名标识符可以让代码更清晰、更一致。</p><p><img src="/images/image-20250521164739687.png" alt="image-20250521164739687"></p><p><strong>规则</strong>：</p><ul><li>文件名必须全部小写。</li><li>单词之间用下划线分隔。</li><li>文件后缀只能是 <code>.h</code> 或 <code>.c</code>。</li></ul><p><strong>正确示例</strong>：</p><ul><li><code>bw_media_scan_service.c</code></li><li><code>bw_media_scan_service.h</code></li></ul><p><strong>错误示例</strong>：</p><ul><li><code>MediaScanner.inc</code> （文件名不对）</li><li><code>mediascanner.cc</code> （文件名和后缀都不对）</li><li><code>Media_Scanner.hpp</code> （文件名和后缀都不对）</li></ul><p><img src="/images/image-20250521165229163.png" alt="image-20250521165229163"></p><p><img src="/images/image-20250521165317163.png" alt="image-20250521165317163"></p><p><img src="/images/image-20250521165423756.png" alt="image-20250521165423756"></p><p><img src="/images/image-20250521165442890.png" alt="image-20250521165442890"></p><p><img src="/images/image-20250521165606544.png" alt="image-20250521165606544"></p><p><img src="/images/image-20250521171346648.png" alt="image-20250521171346648"></p><h1 id="智能汽车技术培训-操作系统基础"><a href="#智能汽车技术培训-操作系统基础" class="headerlink" title="智能汽车技术培训-操作系统基础"></a>智能汽车技术培训-操作系统基础</h1><p><img src="/images/image-20250521171816673.png" alt="image-20250521171816673"></p><p><img src="/images/image-20250521171850212.png" alt="image-20250521171850212"></p>]]></content>
      
      
      <categories>
          
          <category> 车载c知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 车载C知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell语法复习</title>
      <link href="/2024/08/07/test/shell%E8%AF%AD%E6%B3%95%E5%A4%8D%E4%B9%A0/"/>
      <url>/2024/08/07/test/shell%E8%AF%AD%E6%B3%95%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>以下是完善后的 Markdown 文件内容，标题已添加超链接：</p><hr><h1 id="Linux硬件开发常用Shell指令笔记"><a href="#Linux硬件开发常用Shell指令笔记" class="headerlink" title="Linux硬件开发常用Shell指令笔记"></a>Linux硬件开发常用Shell指令笔记</h1><h2 id="一、系统信息查看"><a href="#一、系统信息查看" class="headerlink" title="一、系统信息查看"></a><a href="#%E4%B8%80%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%9F%A5%E7%9C%8B">一、系统信息查看</a></h2><ol><li><p><strong>查看系统信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统内核版本、主机名、硬件架构等详细信息。</li><li><strong>用途</strong>：确认系统环境是否符合开发要求。</li></ul></li><li><p><strong>查看CPU信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示CPU的详细信息，包括型号、核心数、主频等。</li><li><strong>用途</strong>：确认CPU性能是否满足需求。</li></ul></li><li><p><strong>查看内存信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/meminfo</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统的内存信息，包括总内存、可用内存等。</li><li><strong>用途</strong>：评估内存是否足够支持程序运行。</li></ul></li><li><p><strong>查看系统负载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uptime</span></span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统当前的负载情况，包括平均负载值。</li><li><strong>用途</strong>：监控系统运行状态，判断是否需要优化。</li></ul></li></ol><hr><h2 id="二、硬件设备检测"><a href="#二、硬件设备检测" class="headerlink" title="二、硬件设备检测"></a><a href="#%E4%BA%8C%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87%E6%A3%80%E6%B5%8B">二、硬件设备检测</a></h2><ol><li><p><strong>查看设备文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：列出系统中所有设备文件。</li><li><strong>用途</strong>：确认设备是否被正确识别。</li></ul></li><li><p><strong>查看USB设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsusb</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示当前连接的USB设备信息。</li><li><strong>用途</strong>：检测USB接口的硬件设备是否连接成功。</li></ul></li><li><p><strong>查看PCI设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统中所有PCI设备信息。</li><li><strong>用途</strong>：确认PCI接口的硬件设备是否被识别。</li></ul></li><li><p><strong>查看硬件信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lshw</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：详细列出系统中的硬件信息，包括CPU、内存、硬盘等。</li><li><strong>用途</strong>：全面了解硬件配置。</li></ul></li></ol><hr><h2 id="三、文件系统操作"><a href="#三、文件系统操作" class="headerlink" title="三、文件系统操作"></a><a href="#%E4%B8%89%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C">三、文件系统操作</a></h2><ol><li><p><strong>查看文件系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示文件系统的磁盘使用情况，包括挂载点、总容量、已用容量等。</li><li><strong>用途</strong>：确认存储空间是否足够。</li></ul></li><li><p><strong>查看文件类型</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file &lt;文件名&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示文件的类型信息。</li><li><strong>用途</strong>：确认文件格式是否符合要求。</li></ul></li><li><p><strong>挂载文件系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount &lt;设备&gt; &lt;挂载点&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：将设备挂载到指定的挂载点。</li><li><strong>用途</strong>：挂载外部存储设备。</li></ul></li><li><p><strong>卸载文件系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount &lt;挂载点&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：卸载指定的挂载点。</li><li><strong>用途</strong>：安全地卸载外部存储设备。</li></ul></li></ol><hr><h2 id="四、网络操作"><a href="#四、网络操作" class="headerlink" title="四、网络操作"></a><a href="#%E5%9B%9B%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C">四、网络操作</a></h2><ol><li><p><strong>查看网络接口</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示网络接口的配置信息，包括IP地址、子网掩码等。</li><li><strong>用途</strong>：确认网络接口是否正常。<strong>注意</strong>：在现代Linux系统中，<code>ip addr</code> 更常用。</li></ul></li><li><p><strong>查看网络连接</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示当前的网络连接状态。</li><li><strong>用途</strong>：调试网络通信问题。<strong>注意</strong>：在现代Linux系统中，<code>ss -an</code> 更常用。</li></ul></li><li><p><strong>网络测试</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping &lt;IP地址&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：测试与指定IP地址的网络连通性。</li><li><strong>用途</strong>：确认网络连接是否正常。</li></ul></li><li><p><strong>查看DNS配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/resolv.conf</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示DNS服务器的配置信息。</li><li><strong>用途</strong>：确认DNS配置是否正确。</li></ul></li></ol><hr><h2 id="五、系统管理"><a href="#五、系统管理" class="headerlink" title="五、系统管理"></a><a href="#%E4%BA%94%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86">五、系统管理</a></h2><ol><li><p><strong>查看进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统中所有进程的详细信息。</li><li><strong>用途</strong>：监控进程运行状态。</li></ul></li><li><p><strong>杀死进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> &lt;进程ID&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：终止指定的进程。</li><li><strong>用途</strong>：停止异常运行的进程。</li></ul></li><li><p><strong>查看日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/messages</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：查看系统日志文件。</li><li><strong>用途</strong>：调试系统运行中的问题。<strong>注意</strong>：在现代Linux系统中，<code>journalctl</code> 更常用。</li></ul></li><li><p><strong>更新系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get upgrade</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：更新系统软件包。</li><li><strong>用途</strong>：确保系统环境是最新的。适用于基于Debian&#x2F;Ubuntu的系统。</li></ul></li></ol><hr><h2 id="六、脚本与自动化"><a href="#六、脚本与自动化" class="headerlink" title="六、脚本与自动化"></a><a href="#%E5%85%AD%E8%84%9A%E6%9C%AC%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96">六、脚本与自动化</a></h2><ol><li><p><strong>运行Shell脚本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;脚本文件&gt;.sh</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：执行Shell脚本文件。</li><li><strong>用途</strong>：自动化执行一系列命令。</li></ul></li><li><p><strong>查看脚本权限</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l &lt;脚本文件&gt;.sh</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：查看脚本文件的权限。</li><li><strong>用途</strong>：确保脚本具有可执行权限。</li></ul></li><li><p><strong>设置脚本权限</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x &lt;脚本文件&gt;.sh</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：为脚本文件设置可执行权限。</li><li><strong>用途</strong>：确保脚本可以正常运行。</li></ul></li></ol><hr><h2 id="七、硬件调试"><a href="#七、硬件调试" class="headerlink" title="七、硬件调试"></a><a href="#%E4%B8%83%E7%A1%AC%E4%BB%B6%E8%B0%83%E8%AF%95">七、硬件调试</a></h2><ol><li><p><strong>查看串口设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep <span class="built_in">tty</span></span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示串口设备的初始化信息。</li><li><strong>用途</strong>：确认串口设备是否被正确识别。</li></ul></li><li><p><strong>查看GPIO状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/class/gpio/gpio&lt;号&gt;/value</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：查看指定GPIO引脚的状态。</li><li><strong>用途</strong>：调试GPIO相关的硬件问题。</li></ul></li><li><p><strong>设置GPIO状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> &lt;值&gt; &gt; /sys/class/gpio/gpio&lt;号&gt;/value</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：设置指定GPIO引脚的状态。</li><li><strong>用途</strong>：控制GPIO引脚。</li></ul></li><li><p><strong>查看I2C设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i2cdetect -y &lt;总线号&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：扫描I2C总线上的设备。</li><li><strong>用途</strong>：确认I2C设备是否被正确识别。</li></ul></li><li><p><strong>查看SPI设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev/spi*</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：列出SPI设备文件。</li><li><strong>用途</strong>：确认SPI设备是否被正确识别。</li></ul></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell脚本 </tag>
            
            <tag> 硬件调试 </tag>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux驱动学习笔记--11.Linux中断实验</title>
      <link href="/2024/08/07/test/Linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0--Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/"/>
      <url>/2024/08/07/test/Linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0--Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="正点原子-Linux驱动学习笔记–11-Linux中断实验"><a href="#正点原子-Linux驱动学习笔记–11-Linux中断实验" class="headerlink" title="[正点原子]Linux驱动学习笔记–11.Linux中断实验"></a>[正点原子]Linux驱动学习笔记–11.Linux中断实验</h1><h1 id="1-Cortex-A7中断系统详解"><a href="#1-Cortex-A7中断系统详解" class="headerlink" title="1. Cortex-A7中断系统详解"></a>1. Cortex-A7中断系统详解</h1><h2 id="1-1-Cortex-A7中断系统简介"><a href="#1-1-Cortex-A7中断系统简介" class="headerlink" title="1.1 Cortex-A7中断系统简介"></a>1.1 Cortex-A7中断系统简介</h2><p>跟 STM32 一样， Cortex-A7 也有中断向量表，中断向量表也是在代码的最前面。 CortexA7 内核有 8 个异常中断，这 8 个异常中断的中断向量表如下所示：</p><p><img src="/2024/08/07/test/Linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0--Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/n" alt="image51dbe76ff1870146.png"></p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux智能家居产品</title>
      <link href="/2024/08/07/test/linux%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E4%BA%A7%E5%93%81/"/>
      <url>/2024/08/07/test/linux%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E4%BA%A7%E5%93%81/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- 驱动开发与设备树配置：</span><br><span class="line">    - 成功移植并实现了 DHT11 温湿度传感器、SR501 红外人体感应器、AP3216C 环境光与接近传感器以及 SG90 伺服电机控制器等外设的 Linux 驱动程序。</span><br><span class="line">    - 通过对设备树（Device Tree）的精确配置，确保了硬件资源的有效管理和外设的正确识别。</span><br><span class="line">     GPIO、I2C、PWM 和中断管理：</span><br><span class="line">    - 利用 GPIO（通用输入输出接口）、I2C（串行总线协议）、PWM（脉宽调制）等接口的管理，为外设提供了灵活的控制手段。</span><br><span class="line">    - 利用高效的中断处理机制，保证了系统可靠性。</span><br><span class="line">    LCD 显示与 Input 子系统：</span><br><span class="line">    - 利用 LCD 显示屏，支持显示图形界面和其他相关信息。</span><br><span class="line">    - 开发板集成了 Input 子系统，用于处理来自触摸屏或其他输入设备的用户输入。</span><br><span class="line">    - Pinctrl 子系统与同步机制：</span><br><span class="line">    - 应用了 Pinctrl（引脚控制）子系统来动态配置引脚功能，提高了系统的灵活性。</span><br><span class="line">    - 实现了多任务间的同步与互斥机制，确保了多线程操作的一致性和稳定性。</span><br><span class="line">    关键技术：驱动开发、应用开发，设备树配置、QT移植与应用开发、MQTT移植，gpio、i2c、pwm、Interrupt, lcd,Input子系统,Pinctrl子系统,同步与互斥</span><br></pre></td></tr></table></figure><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p><strong>项目名称：</strong> <strong>基于 IMX6ULL PRO 的智能家居控制系统</strong></p><p><strong>项目概述：</strong>本项目开发一套简易智能家居控制系统，利用 IMX6ULL PRO 开发板作为核心硬件平台，搭载 Linux 实时操作系统。项目通过移植和开发各类驱动及应用程序，实现了对家居环境的有效监测与智能控制。</p><p><strong>关键技术与实现：</strong></p><ul><li>驱动开发与设备树配置：<ul><li>成功移植并实现了 DHT11 温湿度传感器、SR501 红外人体感应器、AP3216C 环境光与接近传感器以及 SG90 伺服电机控制器等外设的 Linux 驱动程序。</li><li>通过对设备树（Device Tree）的精确配置，确保了硬件资源的有效管理和外设的正确识别。</li></ul></li><li>QT 图形界面移植与开发：<ul><li>使用 Qt 框架开发了用于设备控制和状态显示的图形用户界面，并成功移植到 ARM 架构的开发板上运行。</li></ul></li><li>MQTT 协议栈移植：<ul><li>移植了 MQTT 协议栈到 ARM 开发板上，确保设备与阿里云服务器之间的稳定数据传输。</li></ul></li><li>GPIO、I2C、PWM 和中断管理：<ul><li>利用 GPIO（通用输入输出接口）、I2C（串行总线协议）、PWM（脉宽调制）等接口的管理，为外设提供了灵活的控制手段。</li><li>利用高效的中断处理机制，保证了系统可靠性。</li></ul></li><li>LCD 显示与 Input 子系统：<ul><li>利用 LCD 显示屏，支持显示图形界面和其他相关信息。</li><li>开发板集成了 Input 子系统，用于处理来自触摸屏或其他输入设备的用户输入。</li></ul></li><li>Pinctrl 子系统与同步机制：<ul><li>应用了 Pinctrl（引脚控制）子系统来动态配置引脚功能，提高了系统的灵活性。</li><li>实现了多任务间的同步与互斥机制，确保了多线程操作的一致性和稳定性。</li></ul></li></ul><p><strong>系统架构与功能：</strong></p><ul><li>通过集成开发板内置的 Wi-Fi 模块，实现了设备与互联网的无缝连接。</li><li>移植 MQTT 协议栈，确保了与阿里云服务器之间的高效数据交换。</li><li>开发了网页端交互界面，支持远程控制家居自动化模块，使得用户可以通过任何联网设备轻松管理家庭环境。</li></ul><p><strong>关键技术：驱动开发、应用开发，设备树配置、QT 移植与应用开发、MQTT 移植，gpio、i2c、pwm、Interrupt, lcd,Input 子系统，Pinctrl 子系统，同步与互斥</strong></p><p>这是一个基于嵌入式Linux的智能家居项目，目标是在开发板上实现一个可以通过本地界面和微信小程序控制的设备。主要功能包括控制LED灯、显示温湿度值等，并通过MQTT(paho mqtt)协议与云平台通信。</p><p>该项目涵盖了硬件设计、嵌入式系统开发、网络通信、图形用户界面设计以及云平台对接等多个领域，涉及的技术栈丰富多样，包括但不限于Linux内核定制、驱动程序开发、Qt框架应用、JsonRPC远程调用、MQTT协议等。整个项目从需求分析、系统设计、代码实现到测试部署，历经多个阶段，历时数月完成，充分体现了我在嵌入式系统开发领域的综合能力。</p><ul><li><p><strong>项目成果与创新点</strong>：</p><ul><li>成功实现了通过本地QT界面以及微信小程序远程控制LED灯开关、显示温湿度值等功能，为用户提供了灵活多样的操作方式。</li><li>在开发过程中，采用了JsonRPC实现前后台分离的架构设计，提高了系统的可维护性和可扩展性，降低了前后台程序之间的耦合度。</li><li>利用MQTT协议实现了设备与云平台之间的高效通信，使得设备能够实时上传数据并接收来自云端的控制指令，为后续的智能家居设备互联互通和智能化管理奠定了基础。<ul><li>自主设计并实现了一套完整的智能家居设备控制协议，确保了不同设备之间的兼容性和互操作性，为后续产品的升级和扩展提供了便利。</li></ul></li></ul></li><li><p><strong>项目影响力与应用前景</strong>：本项目的成功实施不仅为智能家居领域提供了一种可行的技术解决方案，也为相关产品的研发和推广提供了有益的借鉴。通过将嵌入式Linux技术与物联网技术相结合，可以广泛应用于家庭自动化、智能安防、能源管理等多个场景，具有广阔的市场应用前景和商业价值。</p></li></ul><h1 id="关于项目技术细节"><a href="#关于项目技术细节" class="headerlink" title="关于项目技术细节"></a>关于项目技术细节</h1><h3 id="1-你在项目中使用了JsonRPC实现前后台分离，具体是如何实现的？为什么要选择这种架构？"><a href="#1-你在项目中使用了JsonRPC实现前后台分离，具体是如何实现的？为什么要选择这种架构？" class="headerlink" title="1.你在项目中使用了JsonRPC实现前后台分离，具体是如何实现的？为什么要选择这种架构？"></a>1.你在项目中使用了JsonRPC实现前后台分离，具体是如何实现的？为什么要选择这种架构？</h3><ul><li><p><strong>具体实现方式</strong>：在项目中，前后台程序通过 JsonRPC 进行通信。前台程序负责图形用户界面（GUI）的显示和用户交互，后台程序负责处理硬件操作和业务逻辑。前后台程序分别运行在不同的进程中，通过网络通信（TCP&#x2F;UDP）进行数据交换。前台程序通过 JsonRPC 客户端向后台程序发送请求，后台程序通过 JsonRPC 服务器接收请求并返回结果。</p></li><li><p><strong>选择这种架构的原因</strong>：</p><ul><li><strong>降低耦合度</strong>：前后台程序分别独立开发，降低了相互之间的依赖，便于维护和扩展。</li><li><strong>提高可维护性</strong>：前后台程序的职责明确，便于单独进行功能测试和优化。</li><li><strong>支持多平台</strong>：前后台程序可以通过网络通信在不同的设备上运行，提高了系统的灵活性和可扩展性。</li></ul></li></ul><h3 id="2-MQTT协议在项目中起到了什么作用？你是如何处理MQTT消息的订阅和发布的？"><a href="#2-MQTT协议在项目中起到了什么作用？你是如何处理MQTT消息的订阅和发布的？" class="headerlink" title="2.MQTT协议在项目中起到了什么作用？你是如何处理MQTT消息的订阅和发布的？"></a>2.MQTT协议在项目中起到了什么作用？你是如何处理MQTT消息的订阅和发布的？</h3><ul><li><p><strong>作用</strong>：MQTT 协议在项目中用于实现设备与云平台之间的通信，支持一对多的消息发布和订阅。通过 MQTT 协议，设备可以将数据上传到云平台，同时云平台也可以向设备发送指令。</p></li><li><p><strong>消息处理</strong>：</p><ul><li><p><strong>订阅消息</strong>：设备端程序通过 MQTT 客户端订阅云平台的特定主题，如 <code>$thing/down/property/&#123;ProductID&#125;/&#123;DeviceName&#125;</code>，用于接收来自云平台的指令。</p></li><li><p><strong>发布消息</strong>：设备端程序通过 MQTT 客户端向云平台的特定主题发布数据，如 <code>$thing/up/property/&#123;ProductID&#125;/&#123;DeviceName&#125;</code>，用于上传设备的状态数据。</p></li><li><p><strong>消息格式</strong>：消息内容通常为 JSON 格式，便于解析和处理。例如，上传温湿度数据的消息格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;report&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;clientToken&quot;</span><span class="punctuation">:</span> <span class="string">&quot;v2530526688yDDou::d791c1a6-1a4b-4a44-b313-f911d704d765&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1628646783</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;params&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;temp_value&quot;</span><span class="punctuation">:</span> <span class="number">28</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;humi_value&quot;</span><span class="punctuation">:</span> <span class="number">98</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-在开发嵌入式Linux应用时，你是如何进行系统调试和优化的？有没有遇到什么技术难题，是如何解决的？"><a href="#3-在开发嵌入式Linux应用时，你是如何进行系统调试和优化的？有没有遇到什么技术难题，是如何解决的？" class="headerlink" title="3.在开发嵌入式Linux应用时，你是如何进行系统调试和优化的？有没有遇到什么技术难题，是如何解决的？"></a>3.在开发嵌入式Linux应用时，你是如何进行系统调试和优化的？有没有遇到什么技术难题，是如何解决的？</h3><ul><li><p><strong>调试方法</strong>：</p><ul><li><p><strong>日志记录</strong>：在关键位置添加日志记录，记录程序的运行状态和错误信息，便于问题排查。</p></li><li><p><strong>断点调试</strong>：使用 GDB 等调试工具设置断点，逐步跟踪程序的执行流程，定位问题。</p></li><li><p><strong>网络抓包</strong>：使用 Wireshark 等工具抓取网络数据包，分析网络通信过程中的问题。</p></li><li><p><strong>优化方法</strong>：</p><ul><li><strong>代码优化</strong>：通过代码分析工具（如 Valgrind）检测内存泄漏和性能瓶颈，优化代码。</li><li><strong>硬件优化</strong>：合理配置硬件资源，如调整 GPIO 引脚的配置，优化驱动程序。</li></ul></li><li><p><strong>遇到的技术难题及解决方法</strong>：</p><ul><li><strong>问题</strong>：在开发过程中，遇到了跨平台兼容性问题，不同开发板的硬件资源和驱动程序存在差异。</li><li><strong>解决方法</strong>：通过编写跨平台的代码，使用条件编译（如 <code>#ifdef</code>）来处理不同平台的差异。同时，为每个开发板编写详细的硬件资源文档，确保代码的可移植性。</li></ul></li></ul></li></ul><h3 id="4-你对Qt框架的掌握程度如何？在项目中是如何利用Qt开发图形用户界面的？"><a href="#4-你对Qt框架的掌握程度如何？在项目中是如何利用Qt开发图形用户界面的？" class="headerlink" title="4.你对Qt框架的掌握程度如何？在项目中是如何利用Qt开发图形用户界面的？"></a>4.你对Qt框架的掌握程度如何？在项目中是如何利用Qt开发图形用户界面的？</h3><ul><li><strong>掌握程度</strong>：对 Qt 框架有深入的了解，熟悉 Qt 的主要组件和功能，如 QWidget、QLabel、QPushButton 等。能够使用 Qt Designer 设计图形用户界面，并通过代码实现界面的动态交互。</li><li><strong>GUI 开发</strong>：<ul><li><strong>界面设计</strong>：使用 Qt Designer 设计界面布局，添加控件（如按钮、标签等）。</li><li><strong>代码实现</strong>：通过 Qt 框架提供的类和方法，实现控件的事件处理和数据绑定。例如，为按钮添加点击事件处理函数，更新标签显示的内容。</li></ul></li></ul><h1 id="关于项目设计与规划"><a href="#关于项目设计与规划" class="headerlink" title="关于项目设计与规划"></a>关于项目设计与规划</h1><h3 id="1-项目的整体架构是怎样的？你是如何进行模块划分和功能设计的？"><a href="#1-项目的整体架构是怎样的？你是如何进行模块划分和功能设计的？" class="headerlink" title="1.项目的整体架构是怎样的？你是如何进行模块划分和功能设计的？"></a>1.项目的整体架构是怎样的？你是如何进行模块划分和功能设计的？</h3><ul><li><p><strong>架构设计</strong>：项目采用分层架构，分为硬件层、驱动层、后台服务层和前台界面层。</p><ul><li><strong>硬件层</strong>：负责与硬件设备进行直接交互，如 GPIO 控制、温湿度传感器读取等。</li><li><strong>驱动层</strong>：提供硬件设备的驱动程序，封装硬件操作的细节，为上层提供统一的接口。</li><li><strong>后台服务层</strong>：处理业务逻辑，如数据处理、网络通信等。使用 JsonRPC 和 MQTT 协议与前台界面层进行通信。</li><li><strong>前台界面层</strong>：负责图形用户界面的显示和用户交互，通过 JsonRPC 调用后台服务层的接口。</li></ul><p><strong>. 模块划分和功能设计</strong></p><ul><li><p><strong>模块划分</strong>：</p><ul><li><p><strong>硬件控制模块</strong>：负责控制 LED 灯、读取温湿度传感器数据等。</p></li><li><p><strong>网络通信模块</strong>：负责与云平台的 MQTT 通信，处理订阅和发布消息。</p></li><li><p><strong>数据处理模块</strong>：负责处理从硬件设备获取的数据，并将其格式化为 JSON 格式。</p></li><li><p><strong>用户界面模块</strong>：负责显示温湿度数据和控制 LED 灯的开关。</p></li><li><p><strong>功能设计</strong>：</p><ul><li><strong>本地控制</strong>：通过图形用户界面控制 LED 灯的开关，显示温湿度数据。</li><li><strong>远程控制</strong>：通过微信小程序远程控制 LED 灯的开关，获取设备状态数据。</li><li><strong>数据上传</strong>：将设备的温湿度数据上传到云平台。</li><li><strong>指令接收</strong>：接收云平台下发的控制指令，如开关 LED 灯。</li></ul></li></ul></li></ul></li></ul><h3 id="2-在项目开发过程中，你是如何进行需求分析和需求变更管理的？"><a href="#2-在项目开发过程中，你是如何进行需求分析和需求变更管理的？" class="headerlink" title="2.在项目开发过程中，你是如何进行需求分析和需求变更管理的？"></a>2.在项目开发过程中，你是如何进行需求分析和需求变更管理的？</h3><ul><li><strong>需求分析</strong>：<ul><li><strong>用户调研</strong>：通过与用户沟通，了解用户的需求和期望。</li><li><strong>功能规划</strong>：根据用户需求，规划项目的功能模块和开发计划。</li><li><strong>技术选型</strong>：选择适合的技术栈和工具，确保项目的可行性。</li></ul></li><li><strong>需求变更管理</strong>：<ul><li><strong>变更记录</strong>：记录需求变更的详细信息，包括变更原因、内容和影响范围。</li><li><strong>影响评估</strong>：评估需求变更对项目进度和质量的影响。</li><li><strong>沟通协调</strong>：与团队成员和用户进行沟通，确保需求变更的顺利实施。</li></ul></li></ul><h3 id="3-你如何确保项目的进度和质量？有没有使用过项目管理工具或方法？"><a href="#3-你如何确保项目的进度和质量？有没有使用过项目管理工具或方法？" class="headerlink" title="3.你如何确保项目的进度和质量？有没有使用过项目管理工具或方法？"></a>3.你如何确保项目的进度和质量？有没有使用过项目管理工具或方法？</h3><ul><li><strong>进度管理</strong>：<ul><li><strong>制定计划</strong>：根据项目需求，制定详细的开发计划，包括各个阶段的里程碑和时间表。</li><li><strong>定期检查</strong>：定期检查项目进度，及时发现和解决问题。</li><li><strong>调整计划</strong>：根据实际情况，适时调整项目计划，确保项目按时完成。</li></ul></li><li><strong>项目管理工具</strong>：使用 Trello、Jira 等项目管理工具，跟踪项目进度和任务状态。</li></ul><p><img src="/images/image-20250526212910856.png" alt="image-20250526212910856"></p><h1 id="1-2-2-软件结构"><a href="#1-2-2-软件结构" class="headerlink" title="1.2.2 软件结构"></a>1.2.2 软件结构</h1><p>  <img src="/images/image-20250526212925438.png" alt="image-20250526212925438"></p><p>使用文件 IO 操作硬件  </p><p><img src="/images/image-20250526213759330.png" alt="image-20250526213759330"></p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;int main(int argc, char *argv[]) &#123;    int fd, ret;    char buf[2];/* 2. 打开文件 */fd = open(&quot;/dev/100ask_led&quot;, O_RDWR);if (fd == -1) &#123;    printf(&quot;can not open file /dev/100ask_led\n&quot;);    return -1;&#125;if (argc == 3) &#123;    /* write */    buf[0] = strtol(argv[1], NULL, 0); // 哪个LED    if (strcmp(argv[2], &quot;on&quot;) == 0)        buf[1] = 0; // 状态    else        buf[1] = 1;    ret = write(fd, buf, 2);&#125;close(fd);return 0;</code></pre><p>}</p><p>这段代码的主要功能是通过文件操作来控制一个LED灯的开关状态。代码首先尝试以读写模式打开一个名为<code>/dev/100ask_led</code>的设备文件，这个文件通常代表一个硬件设备，可能是一个LED灯。如果文件打开失败，程序会打印一条错误信息并返回-1，表示程序执行失败。如果文件成功打开，程序会检查命令行参数的数量是否为3。这里期望有两个额外的参数，第一个参数用于指定要控制的LED灯编号，第二个参数用于指定LED灯的状态（开或关）。代码使用<code>strtol</code>函数将第一个参数转换为长整型数，并存储在<code>buf[0]</code>中。然后，程序比较第二个参数是否为字符串”on”，如果是，则将<code>buf[1]</code>设置为0，表示LED灯关闭；如果不是，则将<code>buf[1]</code>设置为1，表示LED灯打开。最后，程序使用<code>write</code>函数将<code>buf</code>数组写入到文件描述符<code>fd</code>中，以此来控制LED灯的状态。</p><h1 id="使用-JsonRPC-实现前后台"><a href="#使用-JsonRPC-实现前后台" class="headerlink" title="使用 JsonRPC 实现前后台"></a>使用 JsonRPC 实现前后台</h1><h2 id="把程序拆分为前后台"><a href="#把程序拆分为前后台" class="headerlink" title="把程序拆分为前后台"></a>把程序拆分为前后台</h2><h4 id="为何要拆分？"><a href="#为何要拆分？" class="headerlink" title="为何要拆分？"></a>为何要拆分？</h4><p>对于比较复杂的程序，前台界面显示、后台程序由不同的团队进行开发，双方定义好交互的接口即可。这样，前台、后台程序可以分别独立开发，降低相互之间的依赖。<br>比如：<br>① 当更改硬件，比如更换LED引脚时，前台程序无需改变，只需要修改后台程序<br>② 想调整界面时，只需要修改前台程序，无需修改后台程序</p><ul><li><p><strong>降低耦合性</strong>：前后台程序分别由不同的团队开发，通过定义接口，降低相互依赖。</p></li><li><p><strong>便于扩展和维护</strong>：更改硬件或调整界面时，只需修改对应的部分，无需改动另一部分。</p></li></ul><p><img src="/images/image-20250526214437761.png" alt="image-20250526214437761"></p><p>RPC 是远程过程调用（Remote Procedure Call）的意思，而 json 是比较流行的传递信息的格式。  </p><h4 id="如何拆分？"><a href="#如何拆分？" class="headerlink" title="如何拆分？"></a>如何拆分？</h4><ul><li><strong>定义接口</strong>：前后台程序通过网络通信实现交互，使用JsonRPC远程调用。</li><li><strong>实现前后台程序</strong>：前台程序负责界面显示，后台程序负责具体功能实现，通过JsonRPC进行通信。</li></ul><h4 id="网络传输中的-2-个对象：-server-和-client"><a href="#网络传输中的-2-个对象：-server-和-client" class="headerlink" title="网络传输中的 2 个对象： server 和 client"></a>网络传输中的 2 个对象： server 和 client</h4><p>我们经常访问网站，这涉及 2 个对象：网站服务器，浏览器。网站服务器平时安静地呆着，浏览器主动发起数据请求。网站服务器、浏览器可以抽象成 2 个软件的概念： server 程序、 client 程序。</p><p><img src="/images/image-20250526214512905.png" alt="image-20250526214512905"></p><h4 id="两种传输方式：-TCP-UDP"><a href="#两种传输方式：-TCP-UDP" class="headerlink" title="两种传输方式： TCP&#x2F;UDP"></a>两种传输方式： TCP&#x2F;UDP</h4><p><img src="/images/image-20250526214535322.png" alt="image-20250526214535322"></p><ol><li><p><strong>应用层（Application Layer）</strong>：</p><ul><li>这是用户直接交互的层，负责处理特定的应用程序细节，如电子邮件、文件传输和网页浏览。它定义了用于应用程序间通信的协议和标准。</li></ul></li><li><p><strong>运输层（Transport Layer）</strong>：</p><ul><li><p>负责在网络中的两个节点之间提供可靠的数据传输。它确保数据的完整性和顺序性，并且处理端到端的通信。常见的运输层协议包括TCP（传输控制协议）和UDP（用户数据报协议）。</p><p>运输层主要使用以下两种协议：<br>① 传输控制协议 TCP(Transmission Control Protocol)：面向连接的，数据传输的单位是报文段，能够提供可靠的交付。<br>② 用户数据包协议 UDP(User Datagram Protocol)：无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。</p></li></ul></li><li><p><strong>网络层（Network Layer）</strong>：</p><ul><li>负责将被称为数据包（datagram）的网络层分组从一台主机移动到另一台主机。</li></ul></li><li><p><strong>链路层（Data Link Layer）</strong>：</p><ul><li>因特网的网络层通过源和目的地之间的一系列路由器路由数据报</li></ul></li><li><p><strong>物理层（Physical Layer）</strong>：</p><ul><li>在物理层上所传数据的单位是比特。物理层的任务就是透明地传送比特流</li></ul><p>我们需要使用“<strong>运输层”</strong>编写应用程序，我们的应用程序位于“<strong>应用层</strong>”。</p></li></ol><p>使用“运输层”时，可以选择 TCP 协议，也可以选择 UDP 协议。  </p><h5 id="TCP-和-UDP-原理上的区别"><a href="#TCP-和-UDP-原理上的区别" class="headerlink" title="TCP 和 UDP 原理上的区别"></a>TCP 和 UDP 原理上的区别</h5><p>TCP 向它的应用程序提供了面向连接的服务。这种服务有 2 个特点：可靠传输、流量控制（即发送方&#x2F;接收方速率匹配）。它包括了应用层报文划分为短报文，并提供拥塞控制机制。</p><p>UDP 协议向它的应用程序提供无连接服务。它没有可靠性，没有流量控制，也没有拥塞控制。  </p><h5 id="为何存在-UDP-协议"><a href="#为何存在-UDP-协议" class="headerlink" title="为何存在 UDP 协议"></a>为何存在 UDP 协议</h5><p>既然 TCP 提供了可靠数据传输服务，而 UDP 不能提供，那么 TCP 是否总是首选呢？<br>答案是否定的，因为有许多应用更适合用 UDP，举个例子：视频通话时，使用 UDP，偶尔的丢包、偶尔的花屏时可以忍受的；如果使用 TCP，每个数据包都要确保可靠传输，当它出错时就重传，这会导致后续的数据包被阻滞，视频效果反而不好。</p><h2 id="网络编程主要函数介绍"><a href="#网络编程主要函数介绍" class="headerlink" title="网络编程主要函数介绍"></a>网络编程主要函数介绍</h2><h3 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h3><p><strong>此函数用于创建一个套接字。</strong>   </p><p>socket本来也是用于同主机的进程间通信的</p><p>后来又了TCP&#x2F;IP协议族的加入，才能实现网络通信</p><p>socket是什么？</p><p>是一个编程接口</p><p>是一种特殊的文件描述符 (everything in Unix is a file)</p><p>并不仅限于TCP&#x2F;IP协议</p><p>并不仅限于linux</p><p>面向连接 (Transmission Control Protocol - TCP&#x2F;IP)</p><p>无连接 (User Datagram Protocol -UDP 和 Inter-network Packet Exchange - IPX)</p><p>socket是内核给我们提供的函数，将复杂的网络通的过程转换成了我们熟悉的IO操作</p><p>TCP&#x2F;IP协议被集成到操作系统的内核中，引入了新型的“I&#x2F;O”操作，我们操作套接字，</p><p>只需要通过传参的方式，来指定想使用的协议即可。</p><p>对套接字的read操作，就是在套接字上接收数据</p><p>对套接字的write操作，就是向套接字上发送数据</p><p>套接字的类型：</p><p>流式套接字(SOCK_STREAM)—-给TCP使用</p><p> 提供了一个面向连接、可靠的数据传输服务，数据无差</p><p> 错、无重复的发送且按发送顺序接收。内设置流量控制，</p><p> 避免数据流淹没慢的接收方。数据被看作是字节流，</p><p> 无长度限制。</p><p>数据报套接字(SOCK_DGRAM)—-给UDP使用</p><p>提供无连接服务。数据包以独立数据包的形式被发送，</p><p>不提供无差错保证，数据可能丢失或重复，顺序发送，</p><p>可能乱序接收。</p><p>原始套接字(SOCK_RAW)</p><p>可以对较低层次协议如IP、ICMP直接访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line">功能：</span><br><span class="line">创建套接字</span><br><span class="line">参数：</span><br><span class="line">domain：通信域</span><br><span class="line">AF_UNIX, AF_LOCAL本地通信使用</span><br><span class="line">AF_INETIPV4使用</span><br><span class="line">AF_INET6IPV6使用</span><br><span class="line">AF_PACKET原始套接字使用</span><br><span class="line">type：套接字的类型</span><br><span class="line">SOCK_STREAMTCP使用</span><br><span class="line">SOCK_DGRAMUDP使用</span><br><span class="line">SOCK_RAW原始套接字使用</span><br><span class="line">protocol：附加协议</span><br><span class="line">没有可以传 <span class="number">0</span></span><br><span class="line">返回值：</span><br><span class="line">成功  套接字(文件描述符)</span><br><span class="line">失败 <span class="number">-1</span> 重置错误码</span><br></pre></td></tr></table></figure><h3 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h3><p>从函数用于将地址绑定到一个套接字。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int bind(int sockfd, const struct sockaddr *addr,</span><br><span class="line">                socklen_t addrlen);</span><br><span class="line">功能：绑定套接字和网络信息结构体</span><br><span class="line">参数：</span><br><span class="line">    sockfd：套接字</span><br><span class="line">    addr：</span><br><span class="line">        struct sockaddr &#123;</span><br><span class="line">            sa_family_t sa_family;</span><br><span class="line">            char        sa_data[14];</span><br><span class="line">        &#125;</span><br><span class="line">        上面的结构体只是为了强转防止编译警告的，实际使用的是下面的结构体</span><br><span class="line">        struct sockaddr_in &#123;</span><br><span class="line">            sa_family_t    sin_family; /* AF_INET */</span><br><span class="line">            in_port_t      sin_port;   /* 网络字节序的端口号 */</span><br><span class="line">            struct in_addr sin_addr;   /* IP地址 */</span><br><span class="line">        &#125;;</span><br><span class="line">        /* Internet address. */</span><br><span class="line">        struct in_addr &#123;</span><br><span class="line">            uint32_t       s_addr;     /* 网络字节序的无符号4字节整型的IP地址 */</span><br><span class="line">        &#125;;</span><br><span class="line">    addrlen：addr的长度</span><br><span class="line">返回值：</span><br><span class="line">    成功 0</span><br><span class="line">    失败 -1 重置错误码 </span><br></pre></td></tr></table></figure><h3 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int listen(int sockfd, int backlog);</span><br><span class="line">功能：</span><br><span class="line">    将套接字设置成被动监听状态 只有这个状态的套接字才能用于等待客户端连接</span><br><span class="line">参数：</span><br><span class="line">    sockfd：套接字</span><br><span class="line">    backlog：半连接队列的长度，一般传 5 10 都行 不是0就行</span><br><span class="line">返回值：</span><br><span class="line">    成功 0</span><br><span class="line">    失败 -1 重置错误码</span><br></pre></td></tr></table></figure><h3 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h3><p>服务器使用此函数获得连接请求，并且建立连接。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br><span class="line">功能：</span><br><span class="line">    提取半连接队列中的第一个客户端连接，如果成功，会返回一个</span><br><span class="line">    新的套接字，专门用于和当前客户端通信，返回的套接字和原套接字类型相同</span><br><span class="line">参数：</span><br><span class="line">    sockfd：listen后的sockfd</span><br><span class="line">    addr：用来保存客户端网络信息结构体的缓冲区的首地址</span><br><span class="line">        如果不关心 可以传 NULL</span><br><span class="line">    addrlen：addr的长度，如果不关心 可以传 NULL</span><br><span class="line">返回值：</span><br><span class="line">    成功 返回新的文件描述符 专门用于和当前客户端通信</span><br><span class="line">    失败 -1 重置错误码</span><br></pre></td></tr></table></figure><h3 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h3><p>可以用connect建立一个连接，在connect中所指定的地址是想与之通信的服务器的地址  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int connect(int sockfd, const struct sockaddr *addr,</span><br><span class="line">                   socklen_t addrlen);</span><br><span class="line">功能：</span><br><span class="line">    与服务器建立连接</span><br><span class="line">参数：</span><br><span class="line">    sockfd：套接字</span><br><span class="line">    addr：服务器的网络信息结构体</span><br><span class="line">    addrlen：addr的长度</span><br><span class="line">返回值：</span><br><span class="line">    成功 0</span><br><span class="line">    失败 -1 重置错误码</span><br></pre></td></tr></table></figure><h2 id="JSON-RPC-示例与情景分析"><a href="#JSON-RPC-示例与情景分析" class="headerlink" title="JSON-RPC 示例与情景分析"></a>JSON-RPC 示例与情景分析</h2><h4 id="JSON-是什么"><a href="#JSON-是什么" class="headerlink" title="JSON 是什么"></a>JSON 是什么</h4><p>JSON（JavaScript Object Notation， JavaScript 对象表示法）是基于 ECMAScript 的一个子集设计的，是一种开放标准的文件格式和数据交换格式，它易于人阅读和编写，同时也易于机器解析和生成。 JSON 独立于语言设计，很多编程语言都支持 JSON 格式的数据交换。 JSON 是一种常用的数据格式，在电子数据交换中有多种用途，包括与服务器之间的Web 应用程序的数据交换。其简洁和清晰的层次结构有效地提升了网络传输效率，使其成为理想的数据交换语言。其文件通常使用扩展名.json。</p><h2 id="基于-JSON-RPC-操作硬件"><a href="#基于-JSON-RPC-操作硬件" class="headerlink" title="基于 JSON-RPC 操作硬件"></a>基于 JSON-RPC 操作硬件</h2><p>程序A：调用rpc_led_control发起远程调用，让程序B去控制LED。<br>程序A：调用rpc_dht11_read发起远程调用，让程序B去读取温湿度的值</p><p>在 Ubuntu 中交叉编译程序。先编译 libev 库，再编译 jsonrpc 库，最后编译、执行测试程序测试程序。  </p><p>编译 libev 库    编译 jsonrpc 库  </p><h1 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h1><p>线程（LWP）是轻量级的进程，进程是资源分配的最小单位，线程是系统调度的最小单位。</p><p>线程不会分配内存空间，一个进程内至少有一个线程，叫做主线程，</p><p>也可以有多个线程，这多个线程共用进程的内存空间(0-3G)。</p><p>多线程没有对进程安全，多线程的效率比较高。</p><p>多线程的函数是使用第三方的库函数</p><p>编程时，需要包含头文件  <strong>#include  &lt;pthread.h&gt;</strong></p><p>编译时，需要链接线程的函数库 <strong>-lpthread</strong></p><h1 id="①-MQTT-网络技术"><a href="#①-MQTT-网络技术" class="headerlink" title="① MQTT 网络技术"></a>① MQTT 网络技术</h1><h3 id="MQTT-概述"><a href="#MQTT-概述" class="headerlink" title="MQTT 概述"></a>MQTT 概述</h3><ul><li><h2 id="Paho-MQTT：-Paho-MQTT-是-Eclipse-Paho-项目的一部分，是一个开源的-MQTT-客户端库，支持多种编程语言，包括-C、C-、Java、Python、JavaScript-等。它的目标是为开发者提供一个简单易用的-MQTT-客户端库，以便在各种平台和设备上实现-MQTT-协议。"><a href="#Paho-MQTT：-Paho-MQTT-是-Eclipse-Paho-项目的一部分，是一个开源的-MQTT-客户端库，支持多种编程语言，包括-C、C-、Java、Python、JavaScript-等。它的目标是为开发者提供一个简单易用的-MQTT-客户端库，以便在各种平台和设备上实现-MQTT-协议。" class="headerlink" title="Paho MQTT：- Paho MQTT 是 Eclipse Paho 项目的一部分，是一个开源的 MQTT 客户端库，支持多种编程语言，包括 C、C++、Java、Python、JavaScript 等。它的目标是为开发者提供一个简单易用的 MQTT 客户端库，以便在各种平台和设备上实现 MQTT 协议。"></a><strong>Paho MQTT</strong>：<br>- Paho MQTT 是 Eclipse Paho 项目的一部分，是一个开源的 MQTT 客户端库，支持多种编程语言，包括 C、C++、Java、Python、JavaScript 等。它的目标是为开发者提供一个简单易用的 MQTT 客户端库，以便在各种平台和设备上实现 MQTT 协议。</h2></li></ul><p>MQTT 协议全称是 Message Queuing Telemetry Transport， 即“消息队列遥测传输协议” ，它是物联网常用的应用层协议，运行在 TCP&#x2F;IP 中的应用层中，依赖 TCP 协议，因此它具有非常高的可靠性。 同时它是基于 TCP 协议的“客户端-服务器” 模型发布&#x2F;订阅主题消息的轻量级协议。<br>MQTT 协议提供一对多的消息发布，可以降低应用程序的耦合性，用户只需要编写极少量的应用代码就能完成一对多的消息发布与订阅，该协议是基于“客户端-服务器” 模型，在协议中主要有三种身份：发布者（ Publisher）、服务器（ Broker）以及订阅者（Subscriber）。其中， MQTT 消息的发布者和订阅者都是客户端，服务器只是作为一个中转的存在，将发布者发布的消息进行转发给所有订阅该主题的订阅者；发布者可以发布在其权限之内的所有主题，并且消息发布者可以同时是订阅者，实现了生产者与消费者的脱耦，发布的消息可以同时被多个订阅者订阅。<br>MQTT 通信模型示意图如下</p><p><img src="/images/image-20250527145600470.png" alt="image-20250527145600470"></p><p>MQTT 客户端的功能：<br>① 发布消息给其它相关的客户端。<br>② 订阅主题请求接收相关的应用消息。<br>③ 取消订阅主题请求移除接收应用消息。<br>④ 从服务端终止连接。</p><p>MQTT 服务器常被称为 Broker（消息代理），以是一个应用程序或一台设备，它一般为云服务器，比如 BTA 三巨头的一些物联网平台就是常使用 MQTT 协议，它是位于消息发布者和订阅者之间，以便用于接收消息并发送到订阅者之中，它的功能有：<br>① 接受来自客户端的网络连接请求。<br>② 接受客户端发布的应用消息。<br>③ 处理客户端的订阅和取消订阅请求。<br>④ 转发应用消息给符合条件的已订阅客户端（包括发布者自身）。</p><h2 id="MQTT-概述2"><a href="#MQTT-概述2" class="headerlink" title="MQTT 概述2"></a>MQTT 概述2</h2><ul><li><ul><li><h3 id="1-MQTT协议概述"><a href="#1-MQTT协议概述" class="headerlink" title="1. MQTT协议概述"></a><strong>1. MQTT协议概述</strong></h3><ul><li><strong>定义</strong>：MQTT（Message Queuing Telemetry Transport）是一种轻量级的消息传输协议，常用于物联网（IoT）领域。它基于TCP&#x2F;IP协议，支持低带宽、高延迟或不可靠的网络环境。</li><li><strong>特点</strong>：<ul><li><strong>轻量级</strong>：协议简单，数据包小，适合在带宽受限的网络中使用。</li><li><strong>高可靠性</strong>：基于TCP协议，确保消息的可靠传输。</li><li><strong>一对多通信</strong>：支持发布&#x2F;订阅模型，一个发布者可以向多个订阅者发送消息。</li><li><strong>低功耗</strong>：适合电池供电的设备，减少网络通信的能耗。</li></ul></li></ul><h3 id="2-MQTT通信模型"><a href="#2-MQTT通信模型" class="headerlink" title="2. MQTT通信模型"></a><strong>2. MQTT通信模型</strong></h3><ul><li><strong>发布者（Publisher）</strong>：负责发布消息到特定主题（Topic）。</li><li><strong>订阅者（Subscriber）</strong>：订阅特定主题，接收发布者发送的消息。</li><li><strong>Broker（消息代理）</strong>：作为中间服务器，接收发布者的消息并转发给订阅者。常见的Broker有EMQX、Mosquitto等。</li></ul><p><strong>3. MQTT消息类型</strong></p><ul><li><strong>CONNECT</strong>：客户端连接到Broker的请求。</li><li><strong>CONNACK</strong>：Broker对连接请求的响应。</li><li><strong>PUBLISH</strong>：发布消息到特定主题。</li><li><strong>SUBSCRIBE</strong>：订阅特定主题。</li><li><strong>SUBACK</strong>：Broker对订阅请求的响应。</li><li><strong>UNSUBSCRIBE</strong>：取消订阅特定主题。</li><li><strong>UNSUBACK</strong>：Broker对取消订阅请求的响应。</li><li><strong>PINGREQ</strong>：客户端发送的心跳检测消息。</li><li><strong>PINGRESP</strong>：Broker对心跳检测消息的响应。</li><li><strong>DISCONNECT</strong>：客户端断开连接的请求。</li></ul><p><strong>4. MQTT QoS（服务质量）</strong></p><ul><li><strong>QoS 0</strong>：最多一次，消息可能丢失。</li><li><strong>QoS 1</strong>：至少一次，消息可能重复。</li><li><strong>QoS 2</strong>：恰好一次，确保消息只被接收一次。</li></ul><h4 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a><strong>5. 应用场景</strong></h4><ul><li><strong>智能家居</strong>：设备之间通过MQTT协议通信，实现远程控制和状态上报。</li><li><strong>工业物联网</strong>：传感器设备通过MQTT将数据发送到服务器，服务器进行数据分析和处理。</li><li><strong>车联网</strong>：车辆与服务器之间通过MQTT协议进行数据交互，实现远程监控和故障诊断。</li></ul></li></ul></li></ul><h1 id="②-配置文件处理"><a href="#②-配置文件处理" class="headerlink" title="② 配置文件处理"></a>② 配置文件处理</h1><h4 id="1-配置文件的作用"><a href="#1-配置文件的作用" class="headerlink" title="1**. 配置文件的作用**"></a>1**. 配置文件的作用**</h4><ul><li><strong>存储参数</strong>：用于存储程序运行时需要的参数，如网络配置、设备信息、用户设置等。</li><li><strong>灵活性</strong>：通过修改配置文件，可以在不修改代码的情况下调整程序的行为。</li><li><strong>可维护性</strong>：便于程序的维护和升级，减少硬编码带来的问题。</li></ul><h4 id="2-配置文件的格式"><a href="#2-配置文件的格式" class="headerlink" title="2. 配置文件的格式"></a><strong>2. 配置文件的格式</strong></h4><ul><li><p><strong>INI格式</strong>：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[section1]</span></span><br><span class="line"><span class="attr">key1</span>=value1</span><br><span class="line"><span class="attr">key2</span>=value2</span><br><span class="line"></span><br><span class="line"><span class="section">[section2]</span></span><br><span class="line"><span class="attr">key3</span>=value3</span><br></pre></td></tr></table></figure></li><li><p><strong>JSON格式</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;section1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;key1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;key2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;section2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;key3&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>XML格式</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key1</span>&gt;</span>value1<span class="tag">&lt;/<span class="name">key1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key2</span>&gt;</span>value2<span class="tag">&lt;/<span class="name">key2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key3</span>&gt;</span>value3<span class="tag">&lt;/<span class="name">key3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="③-RPC-远程调用"><a href="#③-RPC-远程调用" class="headerlink" title="③ RPC 远程调用"></a>③ RPC 远程调用</h1><h4 id="1-RPC概述"><a href="#1-RPC概述" class="headerlink" title="1. RPC概述"></a><strong>1. RPC概述</strong></h4><ul><li><strong>定义</strong>：RPC（Remote Procedure Call）是一种允许一个程序调用另一个程序中的函数或方法的协议，就好像调用本地函数一样。</li><li><strong>特点</strong>：<ul><li><strong>透明性</strong>：客户端调用远程函数时，就像调用本地函数一样，无需关心底层的通信细节。</li><li><strong>异构性</strong>：支持不同平台、不同语言之间的通信。</li><li><strong>效率</strong>：减少网络通信的开销，提高通信效率。</li></ul></li></ul><h4 id="2-JSON-RPC协议"><a href="#2-JSON-RPC协议" class="headerlink" title="2. JSON-RPC协议"></a><strong>2. JSON-RPC协议</strong></h4><ul><li><p><strong>定义</strong>：JSON-RPC是一种基于JSON格式的RPC协议，使用JSON作为数据交换格式。</p></li><li><p><strong>消息结构</strong>：</p><ul><li><p><strong>请求消息</strong>：</p><p>JSON</p><p>复制</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;jsonrpc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;methodName&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;params&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>param1<span class="punctuation">,</span> param2<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>响应消息</strong>：</p><p>JSON</p><p>复制</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;jsonrpc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;result&quot;</span><span class="punctuation">:</span> <span class="string">&quot;resultValue&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>错误处理</strong>：</p><p>JSON</p><p>复制</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;jsonrpc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">-32601</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Method not found&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-RPC在项目中的应用"><a href="#3-RPC在项目中的应用" class="headerlink" title="3. RPC在项目中的应用"></a><strong>3. RPC在项目中的应用</strong></h4><ul><li><strong>前后台分离</strong>：通过RPC实现前后台程序的分离，前台程序负责用户界面，后台程序负责硬件操作和业务逻辑。</li><li><strong>远程控制</strong>：客户端通过RPC调用服务器端的函数，实现远程控制设备的功能。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>华勤技术面试准备</title>
      <link href="/2024/08/07/test/%E5%8D%8E%E5%8B%A4%E6%8A%80%E6%9C%AF/"/>
      <url>/2024/08/07/test/%E5%8D%8E%E5%8B%A4%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="华勤技术面试准备"><a href="#华勤技术面试准备" class="headerlink" title="华勤技术面试准备"></a>华勤技术面试准备</h1><p>（文章内容）</p>]]></content>
      
      
      <categories>
          
          <category> 面试求职 </category>
          
          <category> 嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 华勤技术 </tag>
            
            <tag> 嵌入式面试 </tag>
            
            <tag> Linux驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式工程师面试宝典 - 技术面试全攻略</title>
      <link href="/2024/08/07/%E9%9D%A2%E8%AF%95%E6%B1%82%E8%81%8C/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/"/>
      <url>/2024/08/07/%E9%9D%A2%E8%AF%95%E6%B1%82%E8%81%8C/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="? 前言"></a>? 前言</h2><p>嵌入式工程师面试不仅考查编程能力，更注重硬件理解、系统思维和实际项目经验。本文整理了嵌入式面试中的高频问题和答题技巧，帮助你在面试中脱颖而出。</p><span id="more"></span><h2 id="面试准备清单"><a href="#面试准备清单" class="headerlink" title="? 面试准备清单"></a>? 面试准备清单</h2><h3 id="技术知识准备"><a href="#技术知识准备" class="headerlink" title="技术知识准备"></a>技术知识准备</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">? C语言基础和高级特性</span><br><span class="line">? 数据结构和算法</span><br><span class="line">? 单片机原理和应用</span><br><span class="line">? 硬件电路基础</span><br><span class="line">? 通信协议（UART、SPI、I2C等）</span><br><span class="line">? 实时操作系统（RTOS）</span><br><span class="line">? 调试工具和方法</span><br><span class="line">? 项目经验总结</span><br></pre></td></tr></table></figure><h3 id="简历优化要点"><a href="#简历优化要点" class="headerlink" title="简历优化要点"></a>简历优化要点</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">? 突出项目经验和技术栈</span><br><span class="line">? 量化项目成果和贡献</span><br><span class="line">? 展示解决问题的能力</span><br><span class="line">? 体现持续学习的态度</span><br></pre></td></tr></table></figure><h2 id="C语言面试题精选"><a href="#C语言面试题精选" class="headerlink" title="? C语言面试题精选"></a>? C语言面试题精选</h2><h3 id="基础语法题"><a href="#基础语法题" class="headerlink" title="基础语法题"></a>基础语法题</h3><p><strong>1. 指针和数组的区别</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 面试官常问：以下代码的区别</span></span><br><span class="line"><span class="type">char</span> *p = <span class="string">&quot;hello&quot;</span>;     <span class="comment">// 指针，指向字符串常量</span></span><br><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// 数组，在栈上分配空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键区别：</span></span><br><span class="line"><span class="comment">// 1. 内存分配位置不同</span></span><br><span class="line"><span class="comment">// 2. 是否可以修改内容</span></span><br><span class="line"><span class="comment">// 3. sizeof结果不同</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(p) = %zu\n&quot;</span>, <span class="keyword">sizeof</span>(p));     <span class="comment">// 指针大小（4或8字节）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(arr) = %zu\n&quot;</span>, <span class="keyword">sizeof</span>(arr)); <span class="comment">// 数组大小（6字节）</span></span><br></pre></td></tr></table></figure><p><strong>2. const关键字的用法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常考的const用法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;           <span class="comment">// 常量</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> b = <span class="number">20</span>;           <span class="comment">// 同上</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p1;              <span class="comment">// 指向常量的指针</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p2 = &amp;a;        <span class="comment">// 常量指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p3 = &amp;a;  <span class="comment">// 指向常量的常量指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 记忆技巧：从右往左读</span></span><br><span class="line"><span class="comment">// const int *p：p是指针，指向const int</span></span><br><span class="line"><span class="comment">// int * const p：p是const指针，指向int</span></span><br></pre></td></tr></table></figure><p><strong>3. volatile关键字</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 嵌入式中volatile的重要性</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint32_t</span> *GPIO_REG = (<span class="type">uint32_t</span>*)<span class="number">0x40020000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么需要volatile？</span></span><br><span class="line"><span class="comment">// 1. 防止编译器优化</span></span><br><span class="line"><span class="comment">// 2. 确保每次都从内存读取</span></span><br><span class="line"><span class="comment">// 3. 硬件寄存器访问必须使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例（没有volatile）</span></span><br><span class="line"><span class="type">uint32_t</span> *reg = (<span class="type">uint32_t</span>*)<span class="number">0x40020000</span>;</span><br><span class="line"><span class="keyword">while</span>(*reg &amp; <span class="number">0x01</span>);  <span class="comment">// 可能被优化为死循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确示例（使用volatile）</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">uint32_t</span> *reg = (<span class="keyword">volatile</span> <span class="type">uint32_t</span>*)<span class="number">0x40020000</span>;</span><br><span class="line"><span class="keyword">while</span>(*reg &amp; <span class="number">0x01</span>);  <span class="comment">// 每次都会读取寄存器</span></span><br></pre></td></tr></table></figure><h3 id="内存管理题"><a href="#内存管理题" class="headerlink" title="内存管理题"></a>内存管理题</h3><p><strong>4. 栈和堆的区别</strong></p><table><thead><tr><th>特性</th><th>栈(Stack)</th><th>堆(Heap)</th></tr></thead><tbody><tr><td><strong>分配速度</strong></td><td>快</td><td>慢</td></tr><tr><td><strong>内存大小</strong></td><td>有限（通常几KB到几MB）</td><td>较大</td></tr><tr><td><strong>管理方式</strong></td><td>自动管理</td><td>手动管理</td></tr><tr><td><strong>内存碎片</strong></td><td>无</td><td>可能产生</td></tr><tr><td><strong>访问速度</strong></td><td>快</td><td>相对慢</td></tr><tr><td><strong>生命周期</strong></td><td>函数结束自动释放</td><td>需要手动释放</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈分配示例</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stack_example</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">100</span>];  <span class="comment">// 在栈上分配</span></span><br><span class="line">    <span class="comment">// 函数结束时自动释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆分配示例</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heap_example</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">malloc</span>(<span class="number">100</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">// 在堆上分配</span></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用内存</span></span><br><span class="line">        <span class="built_in">free</span>(p);  <span class="comment">// 必须手动释放</span></span><br><span class="line">        p = <span class="literal">NULL</span>; <span class="comment">// 防止野指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5. 内存泄漏检测</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的内存泄漏检测机制</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> malloc_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> free_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">debug_malloc</span><span class="params">(<span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    <span class="type">void</span> *ptr = <span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">        malloc_count++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Malloc: %p, count: %d\n&quot;</span>, ptr, malloc_count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">debug_free</span><span class="params">(<span class="type">void</span> *ptr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">        <span class="built_in">free</span>(ptr);</span><br><span class="line">        free_count++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Free: %p, count: %d\n&quot;</span>, ptr, free_count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查内存泄漏</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">check_memory_leak</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Malloc count: %d, Free count: %d\n&quot;</span>, malloc_count, free_count);</span><br><span class="line">    <span class="keyword">if</span> (malloc_count != free_count) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Memory leak detected!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位操作题"><a href="#位操作题" class="headerlink" title="位操作题"></a>位操作题</h3><p><strong>6. 常用位操作技巧</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 嵌入式开发中的位操作精华</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_BIT(reg, bit)    ((reg) |= (1U &lt;&lt; (bit)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLEAR_BIT(reg, bit)  ((reg) &amp;= ~(1U &lt;&lt; (bit)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TOGGLE_BIT(reg, bit) ((reg) ^= (1U &lt;&lt; (bit)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> READ_BIT(reg, bit)   (((reg) &gt;&gt; (bit)) &amp; 1U)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 面试常考：不用临时变量交换两个数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap_without_temp</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">    *a = *a ^ *b;</span><br><span class="line">    *b = *a ^ *b;</span><br><span class="line">    *a = *a ^ *b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个数是否为2的幂</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">is_power_of_2</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (n != <span class="number">0</span>) &amp;&amp; ((n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算一个数中1的个数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">count_bits</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        n &amp;= (n - <span class="number">1</span>);  <span class="comment">// 清除最低位的1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="硬件知识面试题"><a href="#硬件知识面试题" class="headerlink" title="? 硬件知识面试题"></a>? 硬件知识面试题</h2><h3 id="单片机基础"><a href="#单片机基础" class="headerlink" title="单片机基础"></a>单片机基础</h3><p><strong>7. 单片机启动过程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. 上电复位</span><br><span class="line">   ├── 硬件复位电路工作</span><br><span class="line">   ├── 复位向量加载</span><br><span class="line">   └── PC指针指向复位地址</span><br><span class="line"></span><br><span class="line">2. 时钟初始化</span><br><span class="line">   ├── 配置系统时钟源</span><br><span class="line">   ├── 设置分频系数</span><br><span class="line">   └── 启动PLL（如果使用）</span><br><span class="line"></span><br><span class="line">3. 内存初始化</span><br><span class="line">   ├── 初始化RAM</span><br><span class="line">   ├── 复制初始化数据</span><br><span class="line">   └── 清零BSS段</span><br><span class="line"></span><br><span class="line">4. 外设初始化</span><br><span class="line">   ├── 配置GPIO</span><br><span class="line">   ├── 初始化定时器</span><br><span class="line">   └── 设置中断向量表</span><br><span class="line"></span><br><span class="line">5. 跳转到main函数</span><br></pre></td></tr></table></figure><p><strong>8. 中断处理机制</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中断处理的关键概念</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">interrupt_concepts</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    中断优先级：</span></span><br><span class="line"><span class="comment">    - 高优先级中断可以打断低优先级中断</span></span><br><span class="line"><span class="comment">    - 相同优先级按照中断号排序</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    中断嵌套：</span></span><br><span class="line"><span class="comment">    - 允许高优先级中断嵌套</span></span><br><span class="line"><span class="comment">    - 需要合理设计避免栈溢出</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    中断延迟：</span></span><br><span class="line"><span class="comment">    - 中断响应时间</span></span><br><span class="line"><span class="comment">    - 中断处理时间</span></span><br><span class="line"><span class="comment">    - 中断恢复时间</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断服务程序设计原则</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">UART_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 尽快确定中断源</span></span><br><span class="line">    <span class="keyword">if</span> (UART-&gt;SR &amp; UART_SR_RXNE) &#123;</span><br><span class="line">        <span class="comment">// 2. 快速处理，避免长时间占用</span></span><br><span class="line">        <span class="type">uint8_t</span> data = UART-&gt;DR;</span><br><span class="line">        rx_buffer[rx_index++] = data;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 复杂处理放到主循环</span></span><br><span class="line">        rx_flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 清除中断标志</span></span><br><span class="line">    UART-&gt;SR &amp;= ~UART_SR_RXNE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p><strong>9. UART、SPI、I2C对比</strong></p><table><thead><tr><th>特性</th><th>UART</th><th>SPI</th><th>I2C</th></tr></thead><tbody><tr><td><strong>线数</strong></td><td>2线（TX&#x2F;RX）</td><td>4线（MOSI&#x2F;MISO&#x2F;SCK&#x2F;CS）</td><td>2线（SDA&#x2F;SCL）</td></tr><tr><td><strong>通信方式</strong></td><td>异步</td><td>同步</td><td>同步</td></tr><tr><td><strong>速度</strong></td><td>中等</td><td>快</td><td>慢</td></tr><tr><td><strong>设备数量</strong></td><td>点对点</td><td>一主多从</td><td>多主多从</td></tr><tr><td><strong>硬件复杂度</strong></td><td>简单</td><td>中等</td><td>简单</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UART配置示例</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart_init</span><span class="params">(<span class="type">uint32_t</span> baudrate)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 使能时钟</span></span><br><span class="line">    RCC-&gt;APB2ENR |= RCC_APB2ENR_USART1EN;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 配置GPIO</span></span><br><span class="line">    <span class="comment">// PA9: TX, PA10: RX</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 配置波特率</span></span><br><span class="line">    USART1-&gt;BRR = SystemCoreClock / baudrate;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 使能发送和接收</span></span><br><span class="line">    USART1-&gt;CR1 |= USART_CR1_TE | USART_CR1_RE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 使能UART</span></span><br><span class="line">    USART1-&gt;CR1 |= USART_CR1_UE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SPI配置示例</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spi_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 使能时钟</span></span><br><span class="line">    RCC-&gt;APB2ENR |= RCC_APB2ENR_SPI1EN;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 配置为主机模式</span></span><br><span class="line">    SPI1-&gt;CR1 |= SPI_CR1_MSTR;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 设置时钟分频</span></span><br><span class="line">    SPI1-&gt;CR1 |= SPI_CR1_BR_1;  <span class="comment">// 分频4</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 使能SPI</span></span><br><span class="line">    SPI1-&gt;CR1 |= SPI_CR1_SPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="电路基础"><a href="#电路基础" class="headerlink" title="电路基础"></a>电路基础</h3><p><strong>10. 上拉电阻和下拉电阻</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为什么需要上拉/下拉电阻？</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 确定默认电平状态</span></span><br><span class="line"><span class="comment">2. 防止引脚悬空</span></span><br><span class="line"><span class="comment">3. 提供驱动能力</span></span><br><span class="line"><span class="comment">4. 降低功耗</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">典型应用：</span></span><br><span class="line"><span class="comment">- 按键输入（下拉电阻）</span></span><br><span class="line"><span class="comment">- I2C总线（上拉电阻）</span></span><br><span class="line"><span class="comment">- 复位电路（上拉电阻）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GPIO配置示例</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">gpio_config_example</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 配置为输入，内部上拉</span></span><br><span class="line">    GPIOA-&gt;MODER &amp;= ~(<span class="number">3U</span> &lt;&lt; (<span class="number">0</span> * <span class="number">2</span>));  <span class="comment">// 输入模式</span></span><br><span class="line">    GPIOA-&gt;PUPDR |= (<span class="number">1U</span> &lt;&lt; (<span class="number">0</span> * <span class="number">2</span>));   <span class="comment">// 上拉</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置为输出，推挽输出</span></span><br><span class="line">    GPIOA-&gt;MODER |= (<span class="number">1U</span> &lt;&lt; (<span class="number">1</span> * <span class="number">2</span>));   <span class="comment">// 输出模式</span></span><br><span class="line">    GPIOA-&gt;OTYPER &amp;= ~(<span class="number">1U</span> &lt;&lt; <span class="number">1</span>);       <span class="comment">// 推挽输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目经验面试"><a href="#项目经验面试" class="headerlink" title="? 项目经验面试"></a>? 项目经验面试</h2><h3 id="项目介绍模板"><a href="#项目介绍模板" class="headerlink" title="项目介绍模板"></a>项目介绍模板</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">项目背景：</span><br><span class="line">- 项目目标和需求</span><br><span class="line">- 技术挑战和难点</span><br><span class="line">- 团队规模和角色</span><br><span class="line"></span><br><span class="line">技术方案：</span><br><span class="line">- 硬件平台选择</span><br><span class="line">- 软件架构设计</span><br><span class="line">- 关键技术点</span><br><span class="line"></span><br><span class="line">个人贡献：</span><br><span class="line">- 负责的模块</span><br><span class="line">- 解决的问题</span><br><span class="line">- 创新点和优化</span><br><span class="line"></span><br><span class="line">项目成果：</span><br><span class="line">- 性能指标</span><br><span class="line">- 商业价值</span><br><span class="line">- 经验总结</span><br></pre></td></tr></table></figure><h3 id="常见项目问题"><a href="#常见项目问题" class="headerlink" title="常见项目问题"></a>常见项目问题</h3><p><strong>11. 如何优化系统功耗？</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 功耗优化策略</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">power_optimization_strategies</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    硬件层面：</span></span><br><span class="line"><span class="comment">    1. 选择低功耗MCU</span></span><br><span class="line"><span class="comment">    2. 优化电路设计</span></span><br><span class="line"><span class="comment">    3. 使用低功耗外设</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    软件层面：</span></span><br><span class="line"><span class="comment">    1. 使用睡眠模式</span></span><br><span class="line"><span class="comment">    2. 动态调频调压</span></span><br><span class="line"><span class="comment">    3. 关闭不用的外设</span></span><br><span class="line"><span class="comment">    4. 优化算法减少计算</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 睡眠模式示例</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_sleep_mode</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭不必要的外设</span></span><br><span class="line">    RCC-&gt;APB1ENR &amp;= ~RCC_APB1ENR_TIM2EN;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 配置唤醒源</span></span><br><span class="line">    EXTI-&gt;IMR |= EXTI_IMR_MR0;  <span class="comment">// 使能外部中断0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入睡眠模式</span></span><br><span class="line">    __WFI();  <span class="comment">// Wait For Interrupt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>12. 如何处理实时性要求？</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实时性保证措施</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">real_time_strategies</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 中断优先级设计</span></span><br><span class="line"><span class="comment">       - 高优先级给实时任务</span></span><br><span class="line"><span class="comment">       - 合理分配中断优先级</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    2. 任务调度优化</span></span><br><span class="line"><span class="comment">       - 使用RTOS</span></span><br><span class="line"><span class="comment">       - 设置合适的任务优先级</span></span><br><span class="line"><span class="comment">       - 避免优先级反转</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    3. 代码优化</span></span><br><span class="line"><span class="comment">       - 减少中断处理时间</span></span><br><span class="line"><span class="comment">       - 使用DMA减少CPU负担</span></span><br><span class="line"><span class="comment">       - 优化关键路径代码</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实时任务示例</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">real_time_task_example</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 高优先级中断处理</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">TIM1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 快速处理，设置标志</span></span><br><span class="line">        real_time_flag = <span class="number">1</span>;</span><br><span class="line">        TIM1-&gt;SR &amp;= ~TIM_SR_UIF;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主循环中处理</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (real_time_flag) &#123;</span><br><span class="line">            real_time_flag = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 执行实时任务</span></span><br><span class="line">            process_real_time_data();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他非实时任务</span></span><br><span class="line">        process_background_tasks();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法和数据结构"><a href="#算法和数据结构" class="headerlink" title="? 算法和数据结构"></a>? 算法和数据结构</h2><h3 id="嵌入式常用算法"><a href="#嵌入式常用算法" class="headerlink" title="嵌入式常用算法"></a>嵌入式常用算法</h3><p><strong>13. 环形缓冲区实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 环形缓冲区 - 嵌入式中的经典数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> *buffer;</span><br><span class="line">    <span class="type">uint32_t</span> size;</span><br><span class="line">    <span class="type">uint32_t</span> head;</span><br><span class="line">    <span class="type">uint32_t</span> tail;</span><br><span class="line">    <span class="type">uint32_t</span> count;</span><br><span class="line">&#125; <span class="type">ring_buffer_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ring_buffer_init</span><span class="params">(<span class="type">ring_buffer_t</span> *rb, <span class="type">uint8_t</span> *buffer, <span class="type">uint32_t</span> size)</span> &#123;</span><br><span class="line">    rb-&gt;buffer = buffer;</span><br><span class="line">    rb-&gt;size = size;</span><br><span class="line">    rb-&gt;head = <span class="number">0</span>;</span><br><span class="line">    rb-&gt;tail = <span class="number">0</span>;</span><br><span class="line">    rb-&gt;count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入数据</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ring_buffer_put</span><span class="params">(<span class="type">ring_buffer_t</span> *rb, <span class="type">uint8_t</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rb-&gt;count &gt;= rb-&gt;size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 缓冲区满</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rb-&gt;buffer[rb-&gt;head] = data;</span><br><span class="line">    rb-&gt;head = (rb-&gt;head + <span class="number">1</span>) % rb-&gt;size;</span><br><span class="line">    rb-&gt;count++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ring_buffer_get</span><span class="params">(<span class="type">ring_buffer_t</span> *rb, <span class="type">uint8_t</span> *data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (rb-&gt;count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 缓冲区空</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    *data = rb-&gt;buffer[rb-&gt;tail];</span><br><span class="line">    rb-&gt;tail = (rb-&gt;tail + <span class="number">1</span>) % rb-&gt;size;</span><br><span class="line">    rb-&gt;count--;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>14. 状态机实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态机 - 嵌入式控制逻辑的利器</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    STATE_IDLE,</span><br><span class="line">    STATE_RUNNING,</span><br><span class="line">    STATE_PAUSED,</span><br><span class="line">    STATE_ERROR</span><br><span class="line">&#125; <span class="type">system_state_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    EVENT_START,</span><br><span class="line">    EVENT_STOP,</span><br><span class="line">    EVENT_PAUSE,</span><br><span class="line">    EVENT_RESUME,</span><br><span class="line">    EVENT_ERROR</span><br><span class="line">&#125; <span class="type">system_event_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态转换表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">system_state_t</span> current_state;</span><br><span class="line">    <span class="type">system_event_t</span> event;</span><br><span class="line">    <span class="type">system_state_t</span> next_state;</span><br><span class="line">    <span class="type">void</span> (*action)(<span class="type">void</span>);</span><br><span class="line">&#125; <span class="type">state_transition_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态转换表定义</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">state_transition_t</span> state_table[] = &#123;</span><br><span class="line">    &#123;STATE_IDLE,    EVENT_START,  STATE_RUNNING, start_action&#125;,</span><br><span class="line">    &#123;STATE_RUNNING, EVENT_STOP,   STATE_IDLE,    stop_action&#125;,</span><br><span class="line">    &#123;STATE_RUNNING, EVENT_PAUSE,  STATE_PAUSED,  pause_action&#125;,</span><br><span class="line">    &#123;STATE_PAUSED,  EVENT_RESUME, STATE_RUNNING, resume_action&#125;,</span><br><span class="line">    <span class="comment">// ... 更多状态转换</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态机处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">state_machine_process</span><span class="params">(<span class="type">system_event_t</span> event)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">system_state_t</span> current_state = STATE_IDLE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(state_table)/<span class="keyword">sizeof</span>(state_table[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state_table[i].current_state == current_state &amp;&amp; </span><br><span class="line">            state_table[i].event == event) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 执行动作</span></span><br><span class="line">            <span class="keyword">if</span> (state_table[i].action) &#123;</span><br><span class="line">                state_table[i].action();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 状态转换</span></span><br><span class="line">            current_state = state_table[i].next_state;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面试技巧和注意事项"><a href="#面试技巧和注意事项" class="headerlink" title="? 面试技巧和注意事项"></a>? 面试技巧和注意事项</h2><h3 id="技术面试策略"><a href="#技术面试策略" class="headerlink" title="技术面试策略"></a>技术面试策略</h3><p><strong>回答问题的STAR法则</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Situation（情况）：描述项目背景</span><br><span class="line">Task（任务）：说明你的职责</span><br><span class="line">Action（行动）：详述你的具体行动</span><br><span class="line">Result（结果）：展示最终成果</span><br></pre></td></tr></table></figure><p><strong>代码题解题步骤</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 理解题意：确认输入输出和约束条件</span><br><span class="line">2. 分析思路：说出解题思路和时间复杂度</span><br><span class="line">3. 编写代码：注意边界条件和错误处理</span><br><span class="line">4. 测试验证：用示例数据验证正确性</span><br><span class="line">5. 优化改进：讨论可能的优化方案</span><br></pre></td></tr></table></figure><h3 id="常见面试陷阱"><a href="#常见面试陷阱" class="headerlink" title="常见面试陷阱"></a>常见面试陷阱</h3><p><strong>15. 指针陷阱题</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 陷阱1：返回局部变量地址</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">get_string</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="keyword">return</span> str;            <span class="comment">// 危险！返回栈地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确做法</span></span><br><span class="line"><span class="type">char</span>* <span class="title function_">get_string_correct</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> str[] = <span class="string">&quot;hello&quot;</span>;  <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">return</span> str;                   <span class="comment">// 安全</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 陷阱2：数组名和指针的区别</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">array_pointer_trap</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> arr1[] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="type">char</span> *arr2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(arr1) = %zu\n&quot;</span>, <span class="keyword">sizeof</span>(arr1));  <span class="comment">// 6</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(arr2) = %zu\n&quot;</span>, <span class="keyword">sizeof</span>(arr2));  <span class="comment">// 4或8</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// arr1[0] = &#x27;H&#x27;;  // 可以修改</span></span><br><span class="line">    <span class="comment">// arr2[0] = &#x27;H&#x27;;  // 运行时错误！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>16. 宏定义陷阱</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 陷阱：宏定义没有加括号</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) x * x</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result = SQUARE(<span class="number">3</span> + <span class="number">2</span>);  <span class="comment">// 期望25，实际13</span></span><br><span class="line"><span class="comment">// 展开为：3 + 2 * 3 + 2 = 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 陷阱：多语句宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_PRINT(x) printf(<span class="string">&quot;Debug: &quot;</span>); printf(x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    DEBUG_PRINT(<span class="string">&quot;error&quot;</span>);  <span class="comment">// 只有第一个printf在if中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG_PRINT(x) do &#123; \</span></span><br><span class="line"><span class="meta">    printf(<span class="string">&quot;Debug: &quot;</span>); \</span></span><br><span class="line"><span class="meta">    printf(x); \</span></span><br><span class="line"><span class="meta">&#125; while(0)</span></span><br></pre></td></tr></table></figure><h3 id="薪资谈判技巧"><a href="#薪资谈判技巧" class="headerlink" title="薪资谈判技巧"></a>薪资谈判技巧</h3><p><strong>薪资谈判策略</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. 了解市场行情</span><br><span class="line">   - 查看招聘网站薪资范围</span><br><span class="line">   - 咨询同行朋友</span><br><span class="line">   - 参考行业报告</span><br><span class="line"></span><br><span class="line">2. 评估自身价值</span><br><span class="line">   - 技术能力水平</span><br><span class="line">   - 项目经验丰富度</span><br><span class="line">   - 解决问题能力</span><br><span class="line"></span><br><span class="line">3. 谈判技巧</span><br><span class="line">   - 不要第一个报价</span><br><span class="line">   - 给出合理范围</span><br><span class="line">   - 考虑整体package</span><br><span class="line">   - 保持专业态度</span><br></pre></td></tr></table></figure><h2 id="面试复习资源"><a href="#面试复习资源" class="headerlink" title="? 面试复习资源"></a>? 面试复习资源</h2><h3 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h3><ul><li>《C和指针》- Kenneth A.Reek</li><li>《嵌入式C语言程序设计》- Mark Siegesmund</li><li>《ARM Cortex-M3权威指南》- Joseph Yiu</li><li>《程序员面试金典》- Gayle McDowell</li></ul><h3 id="在线资源"><a href="#在线资源" class="headerlink" title="在线资源"></a>在线资源</h3><ul><li><a href="https://leetcode.com/">LeetCode</a> - 算法练习</li><li><a href="https://www.nowcoder.com/">牛客网</a> - 面试题库</li><li><a href="http://www.embedu.org/">嵌入式客栈</a> - 嵌入式知识</li><li><a href="https://developer.arm.com/documentation">ARM官方文档</a></li></ul><h3 id="实践项目建议"><a href="#实践项目建议" class="headerlink" title="实践项目建议"></a>实践项目建议</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">入门级项目：</span><br><span class="line">- LED流水灯控制</span><br><span class="line">- 数码管显示</span><br><span class="line">- 按键检测和消抖</span><br><span class="line">- UART通信</span><br><span class="line"></span><br><span class="line">进阶项目：</span><br><span class="line">- 温度监控系统</span><br><span class="line">- 步进电机控制</span><br><span class="line">- 简单的RTOS应用</span><br><span class="line">- 无线通信模块</span><br><span class="line"></span><br><span class="line">高级项目：</span><br><span class="line">- 完整的产品原型</span><br><span class="line">- 多传感器数据融合</span><br><span class="line">- 网络通信应用</span><br><span class="line">- 图像处理应用</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="? 总结"></a>? 总结</h2><p>嵌入式工程师面试成功的关键在于：</p><h3 id="技术能力"><a href="#技术能力" class="headerlink" title="技术能力"></a>技术能力</h3><ul><li><strong>扎实的C语言基础</strong>：指针、内存管理、位操作</li><li><strong>硬件理解能力</strong>：单片机原理、电路基础、通信协议</li><li><strong>系统思维</strong>：从硬件到软件的全栈理解</li><li><strong>调试能力</strong>：快速定位和解决问题</li></ul><h3 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h3><ul><li><strong>完整的项目经历</strong>：从需求到实现的全过程</li><li><strong>问题解决能力</strong>：遇到困难如何分析和解决</li><li><strong>技术创新</strong>：在项目中的技术亮点和创新</li><li><strong>团队协作</strong>：与团队成员的配合和沟通</li></ul><h3 id="面试技巧"><a href="#面试技巧" class="headerlink" title="面试技巧"></a>面试技巧</h3><ul><li><strong>充分准备</strong>：技术知识、项目经验、常见问题</li><li><strong>清晰表达</strong>：逻辑清楚、重点突出</li><li><strong>诚实回答</strong>：不会的问题诚实说明，展示学习能力</li><li><strong>积极态度</strong>：展现对技术的热情和持续学习的意愿</li></ul><h3 id="持续学习"><a href="#持续学习" class="headerlink" title="持续学习"></a>持续学习</h3><ul><li><strong>跟上技术趋势</strong>：IoT、AI、边缘计算等新技术</li><li><strong>深入专业领域</strong>：选择一个方向深入研究</li><li><strong>实践项目</strong>：通过项目巩固和提升技能</li><li><strong>技术分享</strong>：通过博客、论坛分享经验</li></ul><p>记住，面试不仅是公司选择你，也是你选择公司的过程。保持自信，展现真实的技术实力和学习能力，相信你一定能找到理想的工作！</p><hr><blockquote><p>? <strong>面试金句</strong>: “技术可以学习，但解决问题的思维和持续学习的能力更加重要。”</p></blockquote><p><strong>相关文章推荐</strong>:</p><ul><li><a href="/2024/08/07/embedded-learning-path/">嵌入式开发学习路线图</a></li><li><a href="/2024/08/07/advanced-c-programming/">C语言进阶编程技巧</a></li><li><a href="/2024/08/07/mcu-project-guide/">单片机项目实战指南</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试求职 </category>
          
          <category> 嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式面试 </tag>
            
            <tag> 面试准备 </tag>
            
            <tag> 技术面试 </tag>
            
            <tag> 求职指南 </tag>
            
            <tag> C语言面试 </tag>
            
            <tag> 硬件知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux驱动学习笔记--11.Linux中断实验</title>
      <link href="/2024/08/07/test/liunx%E9%A9%B1%E5%8A%A8/Linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0--Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/"/>
      <url>/2024/08/07/test/liunx%E9%A9%B1%E5%8A%A8/Linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0--Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="正点原子-Linux驱动学习笔记–11-Linux中断实验"><a href="#正点原子-Linux驱动学习笔记–11-Linux中断实验" class="headerlink" title="[正点原子]Linux驱动学习笔记–11.Linux中断实验"></a>[正点原子]Linux驱动学习笔记–11.Linux中断实验</h1><h1 id="1-Cortex-A7中断系统详解"><a href="#1-Cortex-A7中断系统详解" class="headerlink" title="1. Cortex-A7中断系统详解"></a>1. Cortex-A7中断系统详解</h1><h2 id="1-1-Cortex-A7中断系统简介"><a href="#1-1-Cortex-A7中断系统简介" class="headerlink" title="1.1 Cortex-A7中断系统简介"></a>1.1 Cortex-A7中断系统简介</h2><p>跟 STM32 一样， Cortex-A7 也有中断向量表，中断向量表也是在代码的最前面。 CortexA7 内核有 8 个异常中断，这 8 个异常中断的中断向量表如下所示：</p><p><img src="/2024/08/07/test/liunx%E9%A9%B1%E5%8A%A8/Linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0--Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/n" alt="image51dbe76ff1870146.png"></p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vi学习</title>
      <link href="/2024/08/06/test/2024-08-06-vi%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/08/06/test/2024-08-06-vi%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2024/08/06/test/2024-08-06-vi%E5%AD%A6%E4%B9%A0/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20240906200054194.png" alt="image-20240906200054194"></p><p>a  光标后一位插入  A 行尾插入</p><p>i   光标原位置插入 I行首插入</p><p>o 光标下一行插入 O 光标上一行插入</p><p><img src="/2024/08/06/test/2024-08-06-vi%E5%AD%A6%E4%B9%A0/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20240906200102904.png" alt="image-20240906200102904"></p><p>nyy 复制 ndd删除  p光标下边复制 P光标下边复制 u撤回</p><p><img src="/2024/08/06/test/2024-08-06-vi%E5%AD%A6%E4%B9%A0/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20240906200109699.png" alt="image-20240906200109699"></p><p><img src="/2024/08/06/test/2024-08-06-vi%E5%AD%A6%E4%B9%A0/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20240906200754220.png" alt="image-20240906200754220"></p><p>​      k（上）</p><p>​h（左）     l（右）</p><p>​j（下）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一些liunx问题</title>
      <link href="/2024/08/06/test/Linux%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2024/08/06/test/Linux%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="1-内核空间与用户空间的区别"><a href="#1-内核空间与用户空间的区别" class="headerlink" title="1. 内核空间与用户空间的区别"></a>1. 内核空间与用户空间的区别</h3><h4 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h4><ul><li><strong>定义</strong>：内核空间是操作系统的核心部分，直接管理硬件资源和系统资源。</li><li><strong>稳定性与安全性</strong>：内核代码需要高度的稳定性和安全性，不能依赖于用户空间的库。</li><li><strong>特权模式</strong>：内核代码运行在特权模式下，可以直接访问硬件资源和系统内存。</li><li><strong>开发原则</strong>：内核开发中尽量避免使用用户空间的库，以减少复杂性和潜在的稳定性问题。</li></ul><h4 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h4><ul><li><strong>定义</strong>：用户空间是应用程序运行的环境，通常依赖于各种标准库（如 glibc）来实现复杂的功能。</li><li><strong>非特权模式</strong>：用户空间代码运行在非特权模式下，需要通过系统调用与内核交互。</li></ul><hr><h3 id="2-Linux-驱动开发中的库使用"><a href="#2-Linux-驱动开发中的库使用" class="headerlink" title="2. Linux 驱动开发中的库使用"></a>2. Linux 驱动开发中的库使用</h3><h4 id="内核提供的-API"><a href="#内核提供的-API" class="headerlink" title="内核提供的 API"></a>内核提供的 API</h4><p>Linux 内核本身提供了一套丰富的 API，用于驱动开发。这些 API 包括：</p><ul><li><strong>内存管理</strong>：<code>kmalloc</code>、<code>kfree</code> 等函数用于动态内存分配和释放。</li><li><strong>文件操作</strong>：<code>file_operations</code> 结构体用于实现设备文件的读写操作。</li><li><strong>中断处理</strong>：<code>request_irq</code>、<code>free_irq</code> 等函数用于注册和释放中断。</li><li><strong>定时器</strong>：<code>timer_setup</code>、<code>del_timer</code> 等函数用于定时器的创建和删除。</li><li><strong>设备树</strong>：在嵌入式 Linux 开发中，设备树（Device Tree）用于描述硬件设备的配置信息。</li></ul><p>这些 API 是内核的一部分，专门用于驱动开发，因此驱动代码通常不需要额外的用户空间库。</p><h4 id="硬件抽象层（HAL）"><a href="#硬件抽象层（HAL）" class="headerlink" title="硬件抽象层（HAL）"></a>硬件抽象层（HAL）</h4><p>在某些情况下，硬件供应商会提供硬件抽象层（HAL）库，用于简化硬件访问。这些库通常是内核模块的一部分，而不是用户空间库。例如，NXP 的 i.MX 系列处理器提供了专门的 HAL 库，用于访问硬件寄存器和外设。</p><hr><h3 id="3-为什么看起来像是“不用库”"><a href="#3-为什么看起来像是“不用库”" class="headerlink" title="3. 为什么看起来像是“不用库”"></a>3. 为什么看起来像是“不用库”</h3><h4 id="直接硬件访问"><a href="#直接硬件访问" class="headerlink" title="直接硬件访问"></a>直接硬件访问</h4><ul><li>在驱动开发中，开发者需要直接与硬件交互，因此会直接操作硬件寄存器，而不是通过复杂的用户空间库。</li><li>例如，访问 GPIO、定时器、中断控制器等硬件资源时，通常会直接使用内核提供的 API 或硬件寄存器操作。</li></ul><h4 id="轻量级开发"><a href="#轻量级开发" class="headerlink" title="轻量级开发"></a>轻量级开发</h4><ul><li>驱动代码通常需要轻量级和高效，以减少对系统资源的占用。使用内核提供的 API 可以实现这一点，而不需要依赖于复杂的用户空间库。</li></ul><h4 id="稳定性和安全性"><a href="#稳定性和安全性" class="headerlink" title="稳定性和安全性"></a>稳定性和安全性</h4><ul><li>内核代码需要保持高度的稳定性和安全性，避免引入用户空间库可能带来的潜在问题（如内存泄漏、线程安全问题等）。</li></ul><hr><h3 id="4-特殊情况"><a href="#4-特殊情况" class="headerlink" title="4. 特殊情况"></a>4. 特殊情况</h3><h4 id="用户空间驱动"><a href="#用户空间驱动" class="headerlink" title="用户空间驱动"></a>用户空间驱动</h4><ul><li>在某些情况下，驱动程序可以运行在用户空间，而不是内核空间。这种情况下，驱动程序可以使用用户空间的库（如 glibc）。</li><li>例如，某些 USB 设备驱动或网络设备驱动可以运行在用户空间。</li></ul><h4 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h4><ul><li>在某些复杂的驱动开发场景中，可能会使用第三方库来实现特定功能。例如，某些图形驱动可能会使用 OpenGL 或 DirectFB 等库。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Linux 驱动开发并不是完全不使用库，而是尽量减少对用户空间库的依赖，转而使用内核提供的 API 和硬件抽象层。这种做法可以提高驱动代码的稳定性和效率，同时减少对系统资源的占用。在某些特殊情况下，驱动开发可能会使用用户空间库或第三方库，但这取决于具体的开发需求和应用场景。</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Makefile学习</title>
      <link href="/2024/08/06/test/Makefile/"/>
      <url>/2024/08/06/test/Makefile/</url>
      
        <content type="html"><![CDATA[<p>以下是一些推荐的学习Makefile的网站和资源，可以帮助你快速掌握Makefile的常用规则、结构和示例：</p><ol><li><strong>廖雪峰的官方网站</strong><br>廖雪峰的Makefile教程从基础概念讲起，通过简单易懂的例子逐步深入，非常适合作为入门学习。<br>网址：<a href="https://liaoxuefeng.com/books/makefile/makefile-basic/">Makefile基础 - Makefile教程 - 廖雪峰的官方网站</a></li><li><strong>腾讯云技术文档</strong><br>腾讯云上有一篇关于Makefile的详细解释和示例，涵盖了从基础到进阶的内容，包括如何编写Makefile以及一些高级用法。<br>网址：<a href="https://cloud.tencent.com/developer/article/1065286">超清晰的makefile解释、编写与示例 - 腾讯云</a></li><li>博客园 - Makefile语法总结<br>这篇文章总结了Makefile的常用语法和规则，并通过具体示例进行解析，适合有一定基础的读者深入学习。<br>网址：<a href="https://www.cnblogs.com/zxdplay/p/17782281.html">Makefile语法详细总结及示例解析（快速掌握）</a></li><li><strong>CSDN博客 - Makefile教程</strong><br>CSDN上有许多关于Makefile的教程和示例，其中一些文章提供了详细的规则和实际项目中的Makefile模板。<br>网址：<a href="https://blog.csdn.net/weixin_46097907/article/details/135816235">makefile常用的命令总结及简单示例 - CSDN博客</a></li><li><strong>GitHub Pages - Makefile教程</strong><br>这是一个开源的Makefile教程，提供了从入门到高级的详细内容，并且包含了许多实用的示例。<br>网址：<a href="https://gavinliu6.github.io/Makefile-Tutorial-zh-CN/">Makefile 教程 - GitHub Pages</a></li><li><strong>CSDN博客 - 通用Makefile模板</strong><br>这篇文章提供了一个通用的Makefile模板，适用于C++项目的编译和链接，是一个很好的参考。<br>网址：<a href="https://blog.csdn.net/wg_cheeky/article/details/108014390">makeFile基本介绍, 语法, 示例,通用makefile - CSDN博客</a></li></ol><h3 id="Makefile-的基本概念"><a href="#Makefile-的基本概念" class="headerlink" title="Makefile 的基本概念"></a>Makefile 的基本概念</h3><ul><li><strong>定义</strong>：Makefile 是一个用于自动化编译和构建项目的文件，它描述了工程的编译、链接等规则，包括哪些源文件需要编译、如何编译、如何生成目标文件等。</li><li><strong>作用</strong>：通过编写 Makefile，可以使用 <code>make</code> 命令工具来自动化编译过程，避免手动输入繁琐的编译命令，提高开发效率。</li></ul><h3 id="Makefile-的基本结构"><a href="#Makefile-的基本结构" class="headerlink" title="Makefile 的基本结构"></a>Makefile 的基本结构</h3><ul><li><strong>变量定义</strong>：用于简化和统一文件名或命令的书写。例如：<ul><li><code>CC = gcc</code>：定义编译器为 gcc。</li><li><code>CFLAGS = -Wall -g</code>：定义编译选项，<code>-Wall</code> 显示所有警告，<code>-g</code> 启用调试信息。</li><li><code>TARGET = my_program</code>：定义目标文件名为 <code>my_program</code>。</li><li><code>OBJECTS = main.o utils.o</code>：定义目标文件列表。</li></ul></li><li><strong>规则定义</strong>：指定目标文件、依赖文件和生成目标文件的命令。基本格式如下：<ul><li><code>target: dependencies</code>：目标文件和依赖文件。</li><li><code>command</code>：生成目标文件的命令，必须以 Tab 键开始。</li></ul></li><li><strong>伪目标</strong>：用于执行一些特定的操作，如清理编译生成的文件。例如：<ul><li><code>.PHONY: clean</code>：声明 <code>clean</code> 是一个伪目标。</li><li><code>clean:</code>：定义清理操作的命令。</li></ul></li></ul><h3 id="Makefile-的基本语法"><a href="#Makefile-的基本语法" class="headerlink" title="Makefile 的基本语法"></a>Makefile 的基本语法</h3><ul><li><p><strong>目标和依赖</strong>：目标是要生成的文件，依赖是生成目标所需要的文件。基本格式如下：</p><ul><li><code>target: dependencies</code>：目标文件和依赖文件。</li><li><code>command</code>：生成目标文件的命令，必须以 Tab 键开始。</li></ul></li><li><p><strong>内置变量</strong>：Makefile 提供了一些内置变量，常用的包括：</p><ul><li><code>$@</code>：目标文件的名称。</li><li><code>$^</code>：所有依赖文件的名称。</li><li><code>$&lt;</code>：第一个依赖文件的名称。</li></ul><p>  <img src="/2024/08/06/test/Makefile/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20250423142456075.png" alt="image-20250423142456075"></p></li><li><p><strong>通配符</strong>：用于匹配文件名或文件路径中的多个字符，以便在规则中批量处理文件。常见的通配符有：</p><ul><li><code>*</code>：匹配零个或多个字符。</li><li><code>?</code>：匹配一个任意字符。</li><li><code>[...]</code>：匹配方括号内的任意一个字符。</li><li><code>[!...]</code>：匹配除了方括号内的字符之外的任意一个字符。</li></ul></li><li><p><strong>模式规则</strong>：用于定义一种模式，告诉 Make 工具如何将一类文件转换成另一类文件。例如：</p><ul><li><code>%.o: %.c</code>：表示所有以 <code>.c</code> 结尾的源文件都可以生成对应的 <code>.o</code> 目标文件。</li></ul></li><li><p><strong>自动化变量</strong>：在规则的命令中使用，代表了与规则相关联的文件名。常用的自动化变量包括：</p><ul><li><code>$@</code>：表示规则中的目标文件名。</li><li><code>$&lt;</code>：表示规则中的第一个依赖文件名。</li><li><code>$^</code>：表示规则中的所有依赖文件名，以空格分隔。</li></ul></li></ul><h3 id="Makefile-的实际应用"><a href="#Makefile-的实际应用" class="headerlink" title="Makefile 的实际应用"></a>Makefile 的实际应用</h3><ul><li><strong>简单示例</strong>：<ul><li>假设有一个简单的 C 项目，包含 <code>main.c</code> 和 <code>utils.c</code> 两个源文件 ，目标是生成可执行文件 <code>my_program</code>。Makefile 内容如下：<ul><li><pre><code class="makefile">CC = gccCFLAGS = -Wall -gTARGET = my_programOBJECTS = main.o utils.oall: $(TARGET)$(TARGET): $(OBJECTS)    $(CC) $(CFLAGS) -o $(TARGET) $(OBJECTS)main.o: main.c    $(CC) $(CFLAGS) -c main.cutils.o: utils.c    $(CC) $(CFLAGS) -c utils.c.PHONY: cleanclean:    rm -f $(TARGET) $(OBJECTS)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    - 在项目目录中执行 `make` 命令即可编译项目，执行 `make clean` 命令可以清理编译生成的文件。</span><br><span class="line">- **复杂项目**：</span><br><span class="line">    - 对于复杂的嵌入式 Linux 项目，可能包含多个源文件、头文件、汇编文件等，需要更复杂的 Makefile 来管理。例如：</span><br><span class="line">        - ```makefile</span><br><span class="line">          CROSS_COMPILE  ?= arm-linux-gnueabihf-</span><br><span class="line">          TARGET   ?= bsp</span><br><span class="line">          CC := $(CROSS_COMPILE)gcc</span><br><span class="line">          LD:= $(CROSS_COMPILE)ld</span><br><span class="line">          OBJCOPY := $(CROSS_COMPILE)objcopy</span><br><span class="line">          OBJDUMP := $(CROSS_COMPILE)objdump</span><br><span class="line">          INCDIRS := imx6ul \</span><br><span class="line">                             bsp/clk \</span><br><span class="line">                             bsp/led \</span><br><span class="line">                             bsp/delay</span><br><span class="line">          SRCDIRS:= project \</span><br><span class="line">                             bsp/clk \</span><br><span class="line">                             bsp/led \</span><br><span class="line">                             bsp/delay</span><br><span class="line">          INCLUDE:= $(patsubst %, -I %, $(INCDIRS))</span><br><span class="line">          SFILES:= $(foreach dir, $(SRCDIRS), $(wildcard $(dir)/*.S))</span><br><span class="line">          CFILES:= $(foreach dir, $(SRCDIRS), $(wildcard $(dir)/*.c))</span><br><span class="line">          SFILENDIR:= $(notdir  $(SFILES))</span><br><span class="line">          CFILENDIR:= $(notdir  $(CFILES))</span><br><span class="line">          SOBJS:= $(patsubst %, obj/%, $(SFILENDIR:.S=.o))</span><br><span class="line">          COBJS:= $(patsubst %, obj/%, $(CFILENDIR:.c=.o))</span><br><span class="line">          OBJS:= $(SOBJS) $(COBJS)</span><br><span class="line">          VPATH:= $(SRCDIRS)</span><br><span class="line">          .PHONY: clean</span><br><span class="line">          $(TARGET).bin : $(OBJS)</span><br><span class="line">              $(LD) -Timx6ul.lds -o $(TARGET).elf $^</span><br><span class="line">              $(OBJCOPY) -O binary -S $(TARGET).elf $@</span><br><span class="line">              $(OBJDUMP) -D -m arm $(TARGET).elf &gt; $(TARGET).dis</span><br><span class="line">          $(SOBJS) : obj/%.o : %.S</span><br><span class="line">              $(CC) -Wall -nostdlib -c -O2  $(INCLUDE) -o $@ $&lt;</span><br><span class="line">          $(COBJS) : obj/%.o : %.c</span><br><span class="line">              $(CC) -Wall -nostdlib -c -O2  $(INCLUDE) -o $@ $&lt;</span><br><span class="line">          clean:</span><br><span class="line">              rm -rf $(TARGET).elf $(TARGET).dis $(TARGET).bin $(COBJS) $(SOBJS)</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li>该 Makefile 使用了交叉编译工具链，支持多个源文件和汇编文件的编译，生成二进制可执行文件、ELF 格式文件和反汇编文件。</li></ul></li></ul><h3 id="Makefile-的调试"><a href="#Makefile-的调试" class="headerlink" title="Makefile 的调试"></a>Makefile 的调试</h3><ul><li><strong>查看 <code>make</code> 过程</strong>：使用 <code>make -n</code> 命令可以显示将会执行的命令，但不会实际执行。</li><li><strong>增加详细输出</strong>：使用 <code>make --debug</code> 命令可以提供详细的调试信息，帮助排查问题。</li></ul><h3 id="Makefile-的高级功能"><a href="#Makefile-的高级功能" class="headerlink" title="Makefile 的高级功能"></a>Makefile 的高级功能</h3><ul><li><p><strong>条件语句</strong>：可以根据不同的条件执行不同的规则或设置变量。常见的条件语句有 <code>ifeq</code>、<code>ifneq</code>、<code>ifdef</code>、<code>ifndef</code>。</p><ul><li>示例：根据操作系统设置不同的编译选项。<ul><li><pre><code class="makefile">CC = gccCFLAGS = -Wall -gifeq ($(OS),Windows_NT)    CFLAGS += -DWIN32else    CFLAGS += -DUNIXendifTARGET = my_programSRCS = main.c utils.call: $(TARGET)$(TARGET): $(SRCS)    $(CC) $(CFLAGS) -o $(TARGET) $(SRCS)clean:    rm -f $(TARGET)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">- **使用函数**：Makefile 提供了一些内建函数，帮助处理字符串和文件操作等任务。常用函数包括：</span><br><span class="line">    - `$(wildcard pattern)`：返回匹配模式的所有文件。</span><br><span class="line">    - `$(patsubst pattern,replacement,text)`：用指定的替换文本替换模式。</span><br><span class="line">    - `$(basename names)`：去除文件名的扩展名部分。</span><br><span class="line">    - `$(dir names)`：返回文件的目录路径。</span><br><span class="line">    - 示例：使用 `wildcard` 和 `patsubst`。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### **Makefile基础笔记**</span><br><span class="line"></span><br><span class="line">#### **1. Makefile概述**</span><br><span class="line">- **Makefile的作用**：</span><br><span class="line">  - 在Linux环境下，`make`命令会查找当前目录下的`Makefile`文件。</span><br><span class="line">  - 根据Makefile中定义的规则，`make`可以自动化地执行命令，例如编译源代码、生成目标文件等。</span><br><span class="line">  - Makefile的核心思想是通过定义规则来描述如何生成目标文件。</span><br><span class="line"></span><br><span class="line">- **基本逻辑示例**：</span><br><span class="line">  - 假设有文件`a.txt`、`b.txt`和`c.txt`，需要先合并`a.txt`和`b.txt`生成中间文件`m.txt`，再将`m.txt`与`c.txt`合并生成最终文件`x.txt`。</span><br><span class="line">  - Makefile通过规则定义这种依赖关系和生成过程。</span><br><span class="line"></span><br><span class="line">#### **2. Makefile规则的基本格式**</span><br><span class="line">- **规则格式**：</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>目标文件: 依赖文件1 依赖文件2 …<br>    命令1<br>    命令2<br>    …</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  - **目标文件**：需要生成的文件。</span><br><span class="line">  - **依赖文件**：生成目标文件所需的文件。</span><br><span class="line">  - **命令**：用于生成目标文件的具体命令，必须以Tab键开头。</span><br><span class="line"></span><br><span class="line">- **示例**：</span><br><span class="line">  </span><br><span class="line">  ```makefile</span><br><span class="line">  m.txt: a.txt b.txt</span><br><span class="line">      cat a.txt b.txt &gt; m.txt</span><br><span class="line">  </span><br><span class="line">  x.txt: m.txt c.txt</span><br><span class="line">      cat m.txt c.txt &gt; x.txt</span><br></pre></td></tr></table></figure><ul><li><code>m.txt</code>依赖于<code>a.txt</code>和<code>b.txt</code>，通过<code>cat</code>命令合并生成。</li><li><code>x.txt</code>依赖于<code>m.txt</code>和<code>c.txt</code>，同样通过<code>cat</code>命令生成。</li></ul></li></ul><h4 id="3-Makefile的执行逻辑"><a href="#3-Makefile的执行逻辑" class="headerlink" title="3. Makefile的执行逻辑"></a><strong>3. Makefile的执行逻辑</strong></h4><ul><li><p><strong>增量编译</strong>：</p><ul><li><code>make</code>会检查目标文件和依赖文件的修改时间。</li><li>如果目标文件的修改时间晚于所有依赖文件，则认为目标文件是最新的，不会重新生成。</li><li>如果依赖文件中的任何一个被修改，则会重新执行规则生成目标文件。</li></ul></li><li><p><strong>默认规则</strong>：</p><ul><li><code>make</code>默认执行Makefile中的第一条规则。</li><li>例如，如果要生成<code>x.txt</code>，<code>make</code>会先检查<code>m.txt</code>是否存在，如果不存在则先生成<code>m.txt</code>，然后再生成<code>x.txt</code>。</li></ul></li></ul><h4 id="4-伪目标（Phony-Target）"><a href="#4-伪目标（Phony-Target）" class="headerlink" title="4. 伪目标（Phony Target）"></a><strong>4. 伪目标（Phony Target）</strong></h4><ul><li><p><strong>定义</strong>：</p><ul><li>伪目标不是实际的文件名，而是用于执行特定任务的规则。</li><li>例如，<code>clean</code>规则通常用于删除生成的文件。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f m.txt x.txt</span><br></pre></td></tr></table></figure><ul><li>执行<code>make clean</code>会删除<code>m.txt</code>和<code>x.txt</code>。</li></ul></li><li><p><strong>避免冲突</strong>：</p><ul><li>如果存在名为<code>clean</code>的文件，<code>make clean</code>可能不会执行。</li><li>可以使用<code>.PHONY</code>声明伪目标：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f m.txt x.txt</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="5-执行多条命令"><a href="#5-执行多条命令" class="headerlink" title="5. 执行多条命令"></a><strong>5. 执行多条命令</strong></h4><ul><li><p><strong>独立命令</strong>：</p><ul><li>每条命令默认在独立的Shell环境中执行。</li><li>例如，<code>cd</code>命令不会影响后续命令的执行环境。</li></ul></li><li><p><strong>多条命令的写法</strong>：</p><ul><li>使用<code>;</code>分隔命令：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">    pwd; cd ..; pwd</span><br></pre></td></tr></table></figure></li><li>使用<code>\</code>换行：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">    pwd; \</span><br><span class="line">    cd ..; \</span><br><span class="line">    pwd</span><br></pre></td></tr></table></figure></li><li>使用<code>&amp;&amp;</code>确保命令顺序执行：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">    pwd &amp;&amp; cd .. &amp;&amp; pwd</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="6-控制命令输出"><a href="#6-控制命令输出" class="headerlink" title="6. 控制命令输出"></a><strong>6. 控制命令输出</strong></h4><ul><li><strong>隐藏命令输出</strong>：<ul><li>在命令前加<code>@</code>可以隐藏命令的打印输出，但命令仍然会执行。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">no_output:</span></span><br><span class="line">    @echo &#x27;not display&#x27;</span><br><span class="line">    echo &#x27;will display&#x27;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="7-错误处理"><a href="#7-错误处理" class="headerlink" title="7. 错误处理"></a><strong>7. 错误处理</strong></h4><ul><li><p><strong>默认行为</strong>：</p><ul><li>如果命令返回非0值，<code>make</code>会中断执行并报错。</li></ul></li><li><p><strong>忽略错误</strong>：</p><ul><li>在命令前加<code>-</code>可以忽略错误，继续执行后续命令。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ignore_error:</span></span><br><span class="line">    -rm zzz.txt</span><br><span class="line">    echo &#x27;ok&#x27;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h4><p>Makefile通过定义规则来自动化生成目标文件，核心在于描述目标文件与依赖文件之间的关系以及生成目标文件的具体命令。掌握以下要点：</p><ul><li>规则的基本格式：目标文件、依赖文件和命令。</li><li>增量编译的逻辑：基于文件的修改时间。</li><li>伪目标的使用：如<code>clean</code>。</li><li>多条命令的写法：使用<code>;</code>、<code>\</code>或<code>&amp;&amp;</code>。</li><li>控制命令输出：使用<code>@</code>。</li><li>错误处理：使用<code>-</code>忽略错误。</li></ul><hr><hr><h3 id="编译C程序-Makefile教程笔记"><a href="#编译C程序-Makefile教程笔记" class="headerlink" title="编译C程序 - Makefile教程笔记"></a><strong>编译C程序 - Makefile教程笔记</strong></h3><h4 id="1-C程序编译的基本步骤"><a href="#1-C程序编译的基本步骤" class="headerlink" title="1. C程序编译的基本步骤"></a><strong>1. C程序编译的基本步骤</strong></h4><p>编译C程序通常分为两步：</p><ol><li><strong>编译阶段</strong>：将每个<code>.c</code>文件编译为<code>.o</code>文件（目标文件）。</li><li><strong>链接阶段</strong>：将所有<code>.o</code>文件链接为最终的可执行文件。</li></ol><h4 id="2-示例项目结构"><a href="#2-示例项目结构" class="headerlink" title="2. 示例项目结构"></a><strong>2. 示例项目结构</strong></h4><p>假设一个简单的C项目，包含以下文件：</p><ul><li><code>hello.c</code>：定义了一个<code>hello</code>函数。</li><li><code>hello.h</code>：声明了<code>hello</code>函数。</li><li><code>main.c</code>：主程序，调用了<code>hello</code>函数。</li></ul><p><strong>文件内容</strong>：</p><ul><li>**<code>hello.c</code>**：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>**<code>hello.h</code>**：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li><li>**<code>main.c</code>**：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start...\n&quot;</span>);</span><br><span class="line">    hello();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-Makefile编写"><a href="#3-Makefile编写" class="headerlink" title="3. Makefile编写"></a><strong>3. Makefile编写</strong></h4><p>根据上述项目结构，Makefile可以定义如下规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 hello.c</span></span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">cc -c hello.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 main.c</span></span><br><span class="line"><span class="section">main.o: main.c hello.h</span></span><br><span class="line">cc -c main.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理生成的文件</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o world.out</span><br></pre></td></tr></table></figure><h4 id="4-Makefile执行逻辑"><a href="#4-Makefile执行逻辑" class="headerlink" title="4. Makefile执行逻辑"></a><strong>4. Makefile执行逻辑</strong></h4><ul><li><p><strong>增量编译</strong>：</p><ul><li><code>make</code>会根据文件的修改时间来判断是否需要重新编译。</li><li>如果<code>hello.c</code>被修改，<code>make</code>会重新编译<code>hello.c</code>生成<code>hello.o</code>，并重新链接生成<code>world.out</code>。</li><li>如果<code>hello.h</code>被修改，<code>make</code>会重新编译所有依赖<code>hello.h</code>的文件（如<code>main.c</code>），并重新链接生成<code>world.out</code>。</li></ul></li><li><p><strong>执行过程</strong>：</p><ul><li>初始运行<code>make</code>时，会依次执行以下步骤：<ol><li>编译<code>hello.c</code>生成<code>hello.o</code>。</li><li>编译<code>main.c</code>生成<code>main.o</code>。</li><li>链接<code>hello.o</code>和<code>main.o</code>生成<code>world.out</code>。</li></ol></li><li>如果修改了<code>hello.c</code>，再次运行<code>make</code>时，只会重新编译<code>hello.c</code>并重新链接<code>world.out</code>。</li><li>如果修改了<code>hello.h</code>，<code>make</code>会重新编译<code>main.c</code>并重新链接<code>world.out</code>。</li></ul></li></ul><h4 id="5-清理规则"><a href="#5-清理规则" class="headerlink" title="5. 清理规则"></a><strong>5. 清理规则</strong></h4><ul><li><strong><code>clean</code>规则</strong>：<ul><li>用于删除所有生成的文件，包括<code>.o</code>文件和可执行文件。</li><li>执行命令：<code>make clean</code>。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.o world.out</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="6-规则优化"><a href="#6-规则优化" class="headerlink" title="6. 规则优化"></a><strong>6. 规则优化</strong></h4><p>随着项目规模的扩大，手动维护Makefile中的规则会变得繁琐。后续可以学习如何使用变量、模式规则等高级特性来简化Makefile的编写。</p><h4 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a><strong>7. 小结</strong></h4><ul><li><strong>Makefile的作用</strong>：通过定义规则，<code>make</code>可以自动化编译C程序。</li><li><strong>规则的基本格式</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标文件: 依赖文件</span><br><span class="line">    命令</span><br></pre></td></tr></table></figure></li><li><strong>增量编译</strong>：<code>make</code>根据文件的修改时间来决定是否重新编译。</li><li><strong>清理规则</strong>：使用<code>clean</code>规则删除生成的文件，方便重新编译。</li></ul><p>以下是根据廖雪峰的《使用隐式规则》教程整理的笔记，主要介绍了Makefile中隐式规则的概念、使用方法以及其潜在问题。</p><hr><h3 id="使用隐式规则-Makefile教程笔记"><a href="#使用隐式规则-Makefile教程笔记" class="headerlink" title="使用隐式规则 - Makefile教程笔记"></a><strong>使用隐式规则 - Makefile教程笔记</strong></h3><h4 id="1-隐式规则的概念"><a href="#1-隐式规则的概念" class="headerlink" title="1. 隐式规则的概念"></a><strong>1. 隐式规则的概念</strong></h4><ul><li><p><strong>隐式规则（Implicit Rule）</strong>：</p><ul><li>Makefile中的一种特殊规则，用于自动推导目标文件的生成规则。</li><li>当Makefile中没有明确定义某个目标文件的规则时，<code>make</code>会尝试使用内置的隐式规则来生成该目标文件。</li></ul></li><li><p><strong>内置规则的作用</strong>：</p><ul><li>为了简化Makefile的编写，<code>make</code>为常见的编译任务（如C、C++、ASM等）提供了默认的隐式规则。</li><li>例如，对于C程序，<code>make</code>会自动应用以下隐式规则：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xyz.o: xyz.c</span><br><span class="line">    cc -c -o xyz.o xyz.c</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-示例：隐式规则的应用"><a href="#2-示例：隐式规则的应用" class="headerlink" title="2. 示例：隐式规则的应用"></a><strong>2. 示例：隐式规则的应用</strong></h4><p>假设有一个C项目，包含<code>hello.c</code>、<code>main.c</code>和<code>hello.h</code>，目标是生成可执行文件<code>world.out</code>。</p><p><strong>项目结构</strong>：</p><ul><li><code>hello.c</code>：定义了一个<code>hello</code>函数。</li><li><code>hello.h</code>：声明了<code>hello</code>函数。</li><li><code>main.c</code>：主程序，调用了<code>hello</code>函数。</li></ul><p><strong>Makefile</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只保留生成 world.out 的规则</span></span><br><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">    cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.o world.out</span><br></pre></td></tr></table></figure><p><strong>执行过程</strong>：</p><ul><li>执行<code>make</code>命令时，<code>make</code>会自动推导出<code>hello.o</code>和<code>main.o</code>的生成规则：<ul><li><code>hello.o</code>依赖于<code>hello.c</code>，使用<code>cc -c -o hello.o hello.c</code>生成。</li><li><code>main.o</code>依赖于<code>main.c</code>，使用<code>cc -c -o main.o main.c</code>生成。</li></ul></li><li>最后，<code>make</code>会链接<code>hello.o</code>和<code>main.o</code>生成<code>world.out</code>。</li></ul><p><strong>输出</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc    -c -o hello.o hello.c</span><br><span class="line">cc    -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure><h4 id="3-隐式规则的优势"><a href="#3-隐式规则的优势" class="headerlink" title="3. 隐式规则的优势"></a><strong>3. 隐式规则的优势</strong></h4><ul><li><strong>减少重复规则</strong>：<ul><li>隐式规则可以减少Makefile中大量重复的编译规则。</li><li>例如，对于多个<code>.c</code>文件，无需为每个文件单独编写<code>.o</code>文件的生成规则。</li></ul></li></ul><h4 id="4-隐式规则的潜在问题"><a href="#4-隐式规则的潜在问题" class="headerlink" title="4. 隐式规则的潜在问题"></a><strong>4. 隐式规则的潜在问题</strong></h4><ul><li><strong>无法跟踪头文件的修改</strong>：<ul><li>隐式规则的一个主要问题是无法自动跟踪头文件（如<code>.h</code>文件）的修改。</li><li>例如，如果修改了<code>hello.h</code>，隐式规则<code>main.o: main.c</code>不会自动检测到<code>hello.h</code>的修改，导致<code>main.c</code>不会被重新编译。</li><li>这可能导致生成的可执行文件中包含过时的代码。</li></ul></li></ul><h4 id="5-解决隐式规则的潜在问题"><a href="#5-解决隐式规则的潜在问题" class="headerlink" title="5. 解决隐式规则的潜在问题"></a><strong>5. 解决隐式规则的潜在问题</strong></h4><ul><li><p><strong>手动添加依赖</strong>：</p><ul><li>为了确保头文件的修改能够触发重新编译，需要手动在Makefile中添加头文件的依赖关系。</li><li>例如：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main.o: main.c hello.h</span></span><br><span class="line">    cc -c main.c</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>自动生成依赖文件</strong>：</p><ul><li>在实际项目中，可以通过工具（如<code>gcc -M</code>）自动生成依赖文件，并将其包含在Makefile中。</li><li>例如，使用<code>gcc -M</code>生成依赖文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -M main.c &gt; main.d</span><br></pre></td></tr></table></figure></li><li>然后在Makefile中包含这些依赖文件：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-include</span> main.d</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a><strong>6. 小结</strong></h4><ul><li><strong>隐式规则的作用</strong>：减少重复的编译规则，简化Makefile的编写。</li><li><strong>隐式规则的潜在问题</strong>：无法自动跟踪头文件的修改，可能导致生成的可执行文件包含过时代码。</li><li><strong>解决方法</strong>：手动添加头文件依赖或使用工具自动生成依赖文件。</li></ul><hr><p>以下是根据廖雪峰的《使用变量》教程整理的笔记，主要介绍了Makefile中变量的使用方法、内置变量和自动变量的概念。</p><hr><h3 id="使用变量-Makefile教程笔记"><a href="#使用变量-Makefile教程笔记" class="headerlink" title="使用变量 - Makefile教程笔记"></a><strong>使用变量 - Makefile教程笔记</strong></h3><h4 id="1-变量的作用"><a href="#1-变量的作用" class="headerlink" title="1. 变量的作用"></a><strong>1. 变量的作用</strong></h4><ul><li><strong>解决重复问题</strong>：<ul><li>在Makefile中，文件名或命令可能会重复出现多次，手动修改容易出错。</li><li>使用变量可以简化Makefile的编写，提高可维护性。</li></ul></li></ul><h4 id="2-定义和使用变量"><a href="#2-定义和使用变量" class="headerlink" title="2. 定义和使用变量"></a><strong>2. 定义和使用变量</strong></h4><ul><li><p><strong>定义变量</strong>：</p><ul><li>使用<code>变量名 = 值</code>或<code>变量名 := 值</code>定义变量。</li><li>通常变量名使用全大写，例如<code>TARGET</code>、<code>OBJS</code>等。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TARGET = world.out</span><br><span class="line">OBJS = hello.o main.o</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>引用变量</strong>：</p><ul><li>使用<code>$(变量名)</code>引用变量。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">    cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="3-动态生成变量"><a href="#3-动态生成变量" class="headerlink" title="3. 动态生成变量"></a><strong>3. 动态生成变量</strong></h4><ul><li><p><strong>使用<code>wildcard</code>函数</strong>：</p><ul><li><code>wildcard</code>函数可以匹配当前目录下的文件模式。</li><li>示例：<code>$(wildcard *.c)</code>会列出当前目录下所有<code>.c</code>文件。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用<code>patsubst</code>函数</strong>：</p><ul><li><code>patsubst</code>函数用于模式替换。</li><li>示例：<code>$(patsubst %.c,%.o,$(wildcard *.c))</code>会将所有<code>.c</code>文件名替换为<code>.o</code>文件名。</li><li>这样，每当添加新的<code>.c</code>文件时，<code>OBJS</code>变量会自动更新，无需手动修改Makefile。</li></ul></li></ul><h4 id="4-内置变量"><a href="#4-内置变量" class="headerlink" title="4. 内置变量"></a><strong>4. 内置变量</strong></h4><ul><li><p><strong>内置变量</strong>：</p><ul><li><code>make</code>提供了一些内置变量，例如<code>$(CC)</code>表示C编译器，默认值是<code>cc</code>。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>修改内置变量</strong>：</p><ul><li>可以重新定义内置变量的值。</li><li>示例：使用交叉编译器时，可以设置<code>CC = riscv64-linux-gnu-gcc</code>。</li></ul></li></ul><h4 id="5-自动变量"><a href="#5-自动变量" class="headerlink" title="5. 自动变量"></a><strong>5. 自动变量</strong></h4><ul><li><p><strong>自动变量</strong>：</p><ul><li>在规则中自动指向特定值的变量。</li><li>常用的自动变量：<ul><li><code>$@</code>：目标文件名。</li><li><code>$&lt;</code>：依赖列表中的第一个文件。</li><li><code>$^</code>：所有依赖文件。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">    @echo &#x27;$<span class="variable">$@</span> = <span class="variable">$@</span>&#x27; <span class="comment"># 目标文件名</span></span><br><span class="line">    @echo &#x27;$<span class="variable">$&lt;</span> = <span class="variable">$&lt;</span>&#x27; <span class="comment"># 第一个依赖文件</span></span><br><span class="line">    @echo &#x27;$<span class="variable">$^</span> = <span class="variable">$^</span>&#x27; <span class="comment"># 所有依赖文件</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>输出示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$@</span> = world.out</span><br><span class="line">$&lt; = hello.o</span><br><span class="line">$^ = hello.o main.o</span><br><span class="line">$(CC) -o world.out hello.o main.o</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-变量的调试"><a href="#6-变量的调试" class="headerlink" title="6. 变量的调试"></a><strong>6. 变量的调试</strong></h4><ul><li><strong>打印变量</strong>：<ul><li>使用<code>@echo</code>打印变量的值，便于调试。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">    @echo &#x27;$<span class="variable">$@</span> = <span class="variable">$@</span>&#x27;</span><br><span class="line">    @echo &#x27;$<span class="variable">$&lt;</span> = <span class="variable">$&lt;</span>&#x27;</span><br><span class="line">    @echo &#x27;$<span class="variable">$^</span> = <span class="variable">$^</span>&#x27;</span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="7-小结-1"><a href="#7-小结-1" class="headerlink" title="7. 小结"></a><strong>7. 小结</strong></h4><ul><li><strong>变量的作用</strong>：简化Makefile的编写，减少重复，提高可维护性。</li><li><strong>变量的定义和引用</strong>：使用<code>变量名 = 值</code>定义，使用<code>$(变量名)</code>引用。</li><li><strong>动态生成变量</strong>：使用<code>wildcard</code>和<code>patsubst</code>函数自动生成文件列表。</li><li><strong>内置变量</strong>：使用内置变量（如<code>$(CC)</code>）简化命令。</li><li><strong>自动变量</strong>：使用自动变量（如<code>$@</code>、<code>$&lt;</code>、<code>$^</code>）简化规则。</li></ul><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法自带格式(如何写博客)</title>
      <link href="/2024/08/06/test/Markdown%E8%AF%AD%E6%B3%95%E8%87%AA%E5%B8%A6%E6%A0%BC%E5%BC%8F(%E5%A6%82%E4%BD%95%E5%86%99%E5%8D%9A%E5%AE%A2)/"/>
      <url>/2024/08/06/test/Markdown%E8%AF%AD%E6%B3%95%E8%87%AA%E5%B8%A6%E6%A0%BC%E5%BC%8F(%E5%A6%82%E4%BD%95%E5%86%99%E5%8D%9A%E5%AE%A2)/</url>
      
        <content type="html"><![CDATA[<p><img src="/./images/bywind.png" alt="图"></p><p>用Typora软件更简单</p><p><a href="https://www.bilibili.com/video/BV1iHaTe9EZ3/?spm_id_from=333.337.search-card.all.click&vd_source=390e7ea253547d9c75882d502ff42a1b">Typora安装激活流程_哔哩哔哩_bilibili</a></p><p>Typora安装文件及下载地址~<br>链接:<a href="https://pan.baidu.com/s/17CunIoob5JbtQZ1N5ZIyfg?pwd=zspz">https://pan.baidu.com/s/17CunIoob5JbtQZ1N5ZIyfg?pwd=zspz</a> 提取码:zspz</p><p>一键3连 上传代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl&amp;&amp;hexo g&amp;&amp;hexo d</span><br></pre></td></tr></table></figure><h2 id="多级标题"><a href="#多级标题" class="headerlink" title="多级标题"></a>多级标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure><h2 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span>&gt;</span></span>5号字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>这里的背景色是：MistyRosen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure><h2 id="1-5-分割线"><a href="#1-5-分割线" class="headerlink" title="1.5 分割线"></a>1.5 分割线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><p>​分栏 tab</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><ol><li>Unique name :<ul><li>选项卡块标签的唯一名称，不带逗号。</li><li>将在#id中用作每个标签及其索引号的前缀。</li><li>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</li><li>仅当前帖子&#x2F;页面的URL必须是唯一的！</li></ul></li><li>[index]:<ul><li>活动选项卡的索引号。</li><li>如果未指定，将选择第一个标签（1）。</li><li>如果index为-1，则不会选择任何选项卡。</li><li>可选参数。</li></ul></li><li>[Tab caption]:<ul><li>当前选项卡的标题。</li><li>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</li><li>如果未指定标题，但指定了图标，则标题将为空。</li><li>可选参数。</li></ul></li><li>[@icon]:<ul><li>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</li><li>可以指定带空格或不带空格；</li><li>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</li><li>可选参数。</li></ul></li></ol><p>示例1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>示例2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line">**tab名字为第一个Tab**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line">**只有图标 没有Tab名字**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line">**名字+icon**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>示例1</p><p>.<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">test1 1</button><button type="button" class="tab">test1 2</button><button type="button" class="tab">test1 3</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>This is Tab 1.</strong></p></div><div class="tab-item-content"><p><strong>This is Tab 2.</strong></p></div><div class="tab-item-content"><p><strong>This is Tab 3.</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></p><p>示例2</p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">第一个Tab</button><button type="button" class="tab"><i class="fab fa-apple-pay"></i></button><button type="button" class="tab"><i class="fas fa-bomb"></i>炸弹</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>tab名字为第一个Tab</strong></p></div><div class="tab-item-content"><p><strong>只有图标 没有Tab名字</strong></p></div><div class="tab-item-content"><p><strong>名字+icon</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="音频-audio"><a href="#音频-audio" class="headerlink" title="音频 audio"></a>音频 audio</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">参数配置</button><button type="button" class="tab">示例代码</button><button type="button" class="tab">演示</button></div><div class="tab-contents"><div class="tab-item-content active"></div><div class="tab-item-content"></div><div class="tab-item-content"></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> 博客写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 写作技巧 </tag>
            
            <tag> 博客指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STUDY210学习</title>
      <link href="/2024/08/06/test/STUDY210(%E6%9C%B1%E6%9C%89%E9%B9%8F)/"/>
      <url>/2024/08/06/test/STUDY210(%E6%9C%B1%E6%9C%89%E9%B9%8F)/</url>
      
        <content type="html"><![CDATA[<h1 id="隐藏文件与非隐藏文件"><a href="#隐藏文件与非隐藏文件" class="headerlink" title="隐藏文件与非隐藏文件"></a>隐藏文件与非隐藏文件</h1><p>Windows中：文件隐藏与不隐藏通过设置文件属性实现的，可以点击文件，右键属性，选择勾选隐藏选项来设置文件为隐藏文件。。在Windows中查看隐藏文件方法：菜单栏 工具-&gt;文件夹选项-&gt;查看-&gt;显示所有文件<br>和文件夹。<br>Linux中：linux中隐藏文件特点是文件名以.开头，跟文件属性无关。在linux中查看隐藏文件用ls -a命令（普通显示ls）</p><h1 id="相对路径与绝对路径"><a href="#相对路径与绝对路径" class="headerlink" title="相对路径与绝对路径"></a>相对路径与绝对路径</h1><p>什么是路径：路径是用来标识一个文件在操作系统的文件系统中存储位置的。pathname<br>举例：<br>D:\winshare\enum.c 全路径 pathname<br>D:\winshare路径 path<br>enum.c文件名name</p><p>绝对路径：路径是从绝对位置开始的。譬如Windows中从某一个盘符开始（C:\），linux中从根目录&#x2F;开始<br>相对路径：指明路径的时候，是从当前所在的位置开始的。</p><p>举例：<br>D:\我的文档\123\123.txt<br>D:\我的文档\abc\abc.txt<br>当前在123.txt，但是要去abc.txt<br>方式1：采用绝对路径。D:\我的文档\abc\abc.txt<br>方式2：采用相对路径。..&#x2F;abc&#x2F;abc.txt (..表示上一层)<br>从当前路径开始，往上走一层，再往下走一层（abc）就到了</p><p>测试：<br>&#x2F;abc&#x2F;123&#x2F;def.txt是linux绝对路径<br>abc&#x2F;123&#x2F;def.txt不是linux绝对路径<br>F:\abc\123\def.txt是windows绝对路径<br>abc\123\def.txt不是windows绝对路径</p><h1 id="linux内核、发行版"><a href="#linux内核、发行版" class="headerlink" title="linux内核、发行版"></a>linux内核、发行版</h1><p>linux本身指的是一个操作系统内核，只有内核是无法直接使用的。我们需要的，可以使用的操作系统是一个包含了内核和一批有用的应用程序的一个集合体，这个就叫linux发行版。<br>ubuntu、redhat就是linux的不同的发行版。</p><h1 id="GUI（图形用户界面）和cmdline（命令行）"><a href="#GUI（图形用户界面）和cmdline（命令行）" class="headerlink" title="GUI（图形用户界面）和cmdline（命令行）"></a>GUI（图形用户界面）和cmdline（命令行）</h1><p>GUI：grahics user interface，图形用户界面。<br>cmdline：command line，命令行。<br>人机交互：人和机器（计算机）进行交互，常用的有命令行和GUI。<br>Windows下既有GUI，又有命令行。linux中也是既有GUI，又有命令行。<br>但是，在linux中我们常用命令行(生产用)，在Windows中常用GUI（娱乐用）</p><h1 id="linux常用命令："><a href="#linux常用命令：" class="headerlink" title="linux常用命令："></a>linux常用命令：</h1><p>(1) ls（list，列表）<br>作用：使用列表把当前文件夹下所有文件显示出来<br>    ls -a显示所有文件，包括隐藏文件<br>    ls -l以详细信息显示<br>    ls -a -l<br>    ls -l -a<br>    ls -la<br>    ls -al四种方式都是可以的</p><p>man 作用：查询帮助信息</p><p>man 1 查询linux命令 </p><p>man2 查询api   </p><p>man3查询C库函数</p><p>(2)cd（change directory，更改目录）</p><p>作用：用来切换目录<br>涉及到相对路径和绝对路径<br>cd ....代表上一层目录<br>cd.   .代表当前目录</p><p>(3) pwd（print work directory，打印工作目录）<br>作用：打印出当前的绝对路径</p><p>(4) mkdir（make directory，创建文件夹）<br>作用：创建空文件夹<br>    mkdir -p 级联创建文件夹  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir runoob        #在工作目录下，建立一个名为 runoob 的子目录 </span><br><span class="line">mkdir -p runoob2/test   #在工作目录下的 runoob2 目录中，建立一个名为 test 的子目录。</span><br><span class="line">若 runoob2 目录原本不存在，则建立一个。（注：本例若不加 -p 参数，且原本 runoob2 目录不存在，则产生错误。）</span><br></pre></td></tr></table></figure><p>(5) mv（move，移动）<br>作用：在目录间移动文件，重命名文件<br>    mv 源文件pathname 目的文件pathname</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv source_file(文件) dest_file(文件) #将源文件名 source_file 改为目标文件名 dest_file</span><br><span class="line">mv source_file(文件) dest_directory(目录) #将文件 source_file 移动到目标目录 dest_directory 中</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>freeRTOS</title>
      <link href="/2024/08/06/test/freerots/"/>
      <url>/2024/08/06/test/freerots/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="什么是RTOS"><a href="#什么是RTOS" class="headerlink" title="什么是RTOS"></a>什么是RTOS</h2><p>RTOS全称 Real Time Operating System，中文名就是实时操作系统。</p><h4 id="1、RTOS全称-Real-Time-Operating-System，中文名就是实时操作系统"><a href="#1、RTOS全称-Real-Time-Operating-System，中文名就是实时操作系统" class="headerlink" title="1、RTOS全称 Real Time Operating System，中文名就是实时操作系统"></a>1、RTOS全称 Real Time Operating System，中文名就是实时操作系统</h4><h4 id="2、RTOS是指一类操作系统。而不是单指某一个操作系统，比如UCOS，FreeRTOS，RT-Thread等这些都是RTOS操作系统"><a href="#2、RTOS是指一类操作系统。而不是单指某一个操作系统，比如UCOS，FreeRTOS，RT-Thread等这些都是RTOS操作系统" class="headerlink" title="2、RTOS是指一类操作系统。而不是单指某一个操作系统，比如UCOS，FreeRTOS，RT-Thread等这些都是RTOS操作系统"></a>2、RTOS是指一类操作系统。而不是单指某一个操作系统，比如UCOS，FreeRTOS，RT-Thread等这些都是RTOS操作系统</h4><h4 id="3、在单片机开发过程中有两种开发方式"><a href="#3、在单片机开发过程中有两种开发方式" class="headerlink" title="3、在单片机开发过程中有两种开发方式"></a>3、在单片机开发过程中有两种开发方式</h4><p>​1、裸机开发</p><p>​2、RTOS开发</p><p>​两者的区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">裸机开发</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        打游戏();</span><br><span class="line">        聊天();</span><br><span class="line">    <span class="comment">//两者相互有影响，要打完游戏再聊天，要么聊完天再打游戏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">RTOS开发</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    创建任务（打游戏）;</span><br><span class="line">    创建任务（聊天）;</span><br><span class="line">    启动任务调度；</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> 打游戏()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        只打游戏();<span class="comment">//不说话</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> 聊天()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        只聊天();<span class="comment">//不打游戏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这两个任务不断的相互切换交替执行，只有任务切换的时间足够快，</span></span><br><span class="line">你玩游戏的队友和聊天的女朋友就感觉不到你没有去做别的事情</span><br></pre></td></tr></table></figure><h3 id="2》什么是freeRTOS"><a href="#2》什么是freeRTOS" class="headerlink" title="2》什么是freeRTOS"></a>2》什么是freeRTOS</h3><p>​1、根据名字，我们可以分成两部分：free和rtos,free就是免费、自由，不受约束的意思。</p><p>​2、是RTOS中的一种，freeRTOS十分小巧，可以在很多有限的微控制器上进行运行，单从文件上来说就要比UCOS小得多</p><h3 id="3》为什么要用freeRTOS"><a href="#3》为什么要用freeRTOS" class="headerlink" title="3》为什么要用freeRTOS"></a>3》为什么要用freeRTOS</h3><p>​1、freertos是免费的这点是选择它的最重要的一点，企业做产品肯定是要控制成本的，所以就这一点我们的freertos就是最好选择</p><p>​2、使用者很多，资料多，解决问题时方面查找，市场占有率很高，很多厂商提供的SDK包都支持freertos，尤其是一些带蓝牙、WIFI协议栈的芯片或者模块</p><p>​3、简单，文件数量少，方便移植和上手</p><p>​4、可以移植到很多不同的微控制器上，比如STM32  F1\F3\F4\F7上都可以移植</p><h3 id="4》什么是任务"><a href="#4》什么是任务" class="headerlink" title="4》什么是任务"></a>4》什么是任务</h3><p>​任务是一个运行的函数（包括函数和栈），是一段保存在FLASH上的代码，在CPU上运行</p><p>​ARM架构</p><p>​F407中有：</p><p>​CPU:中央处理器(计算单元进行计算)</p><p>​FLASH:存放代码 通过JLINK等专业的工具烧入到FLASH（保证代码不会被轻易破坏）</p><p>​RAM：存放数据  可读可写</p><p>​串口等等模块</p><p>​CPU和内存的关系</p><p>​CPU RAM：存放数据</p><p>​&#x2F;&#x2F;对于内存来说只有两个功能，将数据读出来和写进去</p><p>​&#x2F;&#x2F;要实现a&#x3D;a+b这条语句CPU需要怎么操作</p><p>​——————————————</p><p>1.读出a变量的值(对应的汇编指令LDR load register)     </p><p>2.读出b变量的值</p><p>3.进行计算a、b的和(对应的汇编指令add)</p><p>4.将结果放到a的地址(对应汇编指令STR  store)</p><p>​CUP内部的寄存器 R0、R1……R15；R0-R12可以任意用来计算  R13-R15具有特殊功能：R13-SP(栈)，R14-LR(返回地址)，R15-PC(当前指令的地址)</p><p>​ARM7架构处理器采用三级流水线的结构。包括取指(fetch)-&gt;译码(decode)-&gt;执行(execute)三级。</p><p>​当第指令执行时，第二指令正在译码，第三条指令正在取指阶段。也就是说当第一条指令在执行时，PC寄存器应当指向第三条指令</p><p>​也就是说只要处理器是三级流水结构时，PC寄存器总是指向第三条指令</p><h3 id="5》任务的状态"><a href="#5》任务的状态" class="headerlink" title="5》任务的状态"></a>5》任务的状态</h3><p>​1、运行态</p><p>​2、就绪态</p><p>​3、阻塞态</p><p>​4、挂起态（暂停态）</p><p>  5、停止态</p><h3 id="6》任务之间的转换（参考freertos任务转换图）"><a href="#6》任务之间的转换（参考freertos任务转换图）" class="headerlink" title="6》任务之间的转换（参考freertos任务转换图）"></a>6》任务之间的转换（参考freertos任务转换图）</h3><p><img src="/images/1701947563704-99caeacf-b96d-4cfb-a981-ba13e3ce8815.png" alt="img"></p><h3 id="7》任务优先级（数字越大。优先级越高）"><a href="#7》任务优先级（数字越大。优先级越高）" class="headerlink" title="7》任务优先级（数字越大。优先级越高）"></a>7》任务优先级（数字越大。优先级越高）</h3><p>-—————————————————————————————————————–</p><h3 id="源码获取"><a href="#源码获取" class="headerlink" title="源码获取"></a>源码获取</h3><h3 id="1》free官网https-www-freertos-org"><a href="#1》free官网https-www-freertos-org" class="headerlink" title="1》free官网https://www.freertos.org/"></a>1》free官网<a href="https://www.freertos.org/">https://www.freertos.org/</a></h3><h3 id="2》源码文件夹介绍"><a href="#2》源码文件夹介绍" class="headerlink" title="2》源码文件夹介绍"></a>2》源码文件夹介绍</h3><p>​1、FreeRTOS和FreeRTOS-Plus是freertos的源码</p><p>​FreeRTOS文件中</p><p>​Demo文件夹中是放的针对不同MCU提供的相关例程</p><p>​License文件夹中是放相关的许可信息</p><p>​Source文件夹中是放FREERTOS的源码，也就是我们后面打交道的重要资料</p><p>​include放头文件</p><p>​portable放freertos系统和具体硬件之间的桥梁，只需要留下keil、memmang、RVDS三个文件夹，其余的文件夹都可以删除</p><p>​keil使用MDK编译环境所需要文件信息</p><p>​Menmang内存管理文件</p><p>​RVDS针对不同架构的MCU做了详细分类，stm32f407可以参考ARM_CM4F中的内容</p><h3 id="移植步骤"><a href="#移植步骤" class="headerlink" title="移植步骤"></a>移植步骤</h3><p>​1、找一个demo工程，在文件夹下新建一个freertos的文件夹</p><p>​2、将FreeRTOSv9.0.0\FreeRTOS\Source下的所有文件拷贝到新建freertos文件夹下</p><p>​3、打开KEIL工程，在工程目录下新建一个freertos文件夹并添加如下文件</p><p>​demo\freertos下的所有.c文件</p><p>​demo\freertos\portable\MemMang下的heap_4.c文件</p><p>​demo\freertos\portable\RVDS\ARM_CM4F下的port.c文件</p><p>​4、添加freertos需要的头文件路径</p><p>​5、编译报如下错</p><p>​..\freertos\include\FreeRTOS.h(98): error:  #5: cannot open source input file “FreeRTOSConfig.h”: No such file or directory</p><p>​6、到源码\FreeRTOSv9.0.0\FreeRTOS\Demo\CORTEX_M4F_STM32F407ZG-SK下将FreeRTOSConfig.h拷贝到\demo\freertos\include下</p><p>​7、编译报如下错</p><p>​..\freertos\portable\RVDS\ARM_CM4F\port.c(713): error:  #20: identifier “SystemCoreClock” is undefined</p><p>​8、对FreeRTOSConfig.h文件的第87-90行代码进行如下修改</p><p>​&#x2F;&#x2F;#ifdef <strong>ICCARM</strong></p><p>​#include &lt;stdint.h&gt;</p><p>​extern uint32_t SystemCoreClock;</p><p>​&#x2F;&#x2F;#endif</p><p>​9、编译报如下错</p><p>​.\Objects\demo.axf: Error: L6200E: Symbol PendSV_Handler multiply defined (by port.o and stm32f4xx_it.o).</p><p>​.\Objects\demo.axf: Error: L6200E: Symbol SVC_Handler multiply defined (by port.o and stm32f4xx_it.o).</p><p>​.\Objects\demo.axf: Error: L6200E: Symbol SysTick_Handler multiply defined (by port.o and stm32f4xx_it.o).</p><p>​10、将stm32f4xx_it.c文件下的PendSV_Handler、SVC_Handler、SysTick_Handler屏蔽</p><p>​11、编译报如下错</p><p>​.\Objects\demo.axf: Error: L6218E: Undefined symbol vApplicationIdleHook (referred from tasks.o).</p><p>​.\Objects\demo.axf: Error: L6218E: Undefined symbol vApplicationStackOverflowHook (referred from tasks.o).</p><p>​.\Objects\demo.axf: Error: L6218E: Undefined symbol vApplicationTickHook (referred from tasks.o).</p><p>​.\Objects\demo.axf: Error: L6218E: Undefined symbol vApplicationMallocFailedHook (referred from heap_4.o).</p><p>​12、在FreeRTOSConfig.h文件中将vApplicationIdleHook、vApplicationStackOverflowHook,vApplicationTickHook,vApplicationMallocFailedHook这四个的钩子函数功能关闭</p><p>​13、编译0警告、0错误代表移植成功</p><p>​“.\Objects\demo.axf” - 0 Error(s), 0 Warning(s).</p><p>​FreeRTOSConfig.h文件用于对freertos系统的配置文件，可以通过对里面的开关进行修改实现对freertos功能的裁剪</p><h3 id="1、动态创建任务"><a href="#1、动态创建任务" class="headerlink" title="1、动态创建任务"></a>1、动态创建任务</h3><p>​BaseType_t xTaskCreate(TaskFunction_t pxTaskCode,</p><p>​const char * const pcName,</p><p>​const uint16_t usStackDepth,</p><p>​void * const pvParameters,</p><p>​UBaseType_t uxPriority,</p><p>​TaskHandle_t * const pxCreatedTask )</p><p>​参数1：  指向任务函数的入口，任务的函数名</p><p>​参数2： 字符串，任务的函数名</p><p>​参数3：  任务堆栈大小，实际分配的大小是需要乘上4</p><p>​参数4： 需要传递给任务的参数</p><p>​参数5：   任务优先级，取值范围0~configMAX_PRIORITIES-1</p><p>​参数6：   任务句柄</p><p>​返回值：pdPASS：任务创建成功，会返回任务的句柄</p><p>​错误码参考projdefs.h中的定义</p><h3 id="2、启动动任务调度"><a href="#2、启动动任务调度" class="headerlink" title="2、启动动任务调度"></a>2、启动动任务调度</h3><p>​vTaskStartScheduler();</p><p>-————————————————————————————————————</p><h3 id="任务的几个关键函数"><a href="#任务的几个关键函数" class="headerlink" title="任务的几个关键函数"></a>任务的几个关键函数</h3><p>​xTaskCreate()&#x2F;&#x2F;使用动态的方法创建一个任务（默认）</p><p>​xTaskCreateStatic()&#x2F;&#x2F;使用静态的方法创建一个任务  </p><p>​xTaskCreateRestricted();&#x2F;&#x2F;创建一个使用MPU(内存管理单元)进行限制的任务，相关内存采用动态内存分配</p><p>​vTaskDelete();&#x2F;&#x2F;删除一个任务</p><p>​vTaskStartScheduler();&#x2F;&#x2F;启动任务调度</p><p>​vTaskSuspend();&#x2F;&#x2F;任务挂起</p><p>​vTaskResume()；&#x2F;&#x2F;恢复一个挂起任务</p><p>​xTaskResumeFromISR()&#x2F;&#x2F;在中断中恢复挂起任务</p><h3 id="1、动态创建任务-1"><a href="#1、动态创建任务-1" class="headerlink" title="1、动态创建任务"></a>1、动态创建任务</h3><p>​aseType_t xTaskCreate(TaskFunction_t pxTaskCode,</p><p>​const char * const pcName,</p><p>​const uint16_t usStackDepth,</p><p>​void * const pvParameters,</p><p>​UBaseType_t uxPriority,</p><p>​TaskHandle_t * const pxCreatedTask )</p><p>​参数1：  指向任务函数的入口，任务的函数名</p><p>​参数2：  字符串，任务的函数名</p><p>​参数3：  任务堆栈大小，实际分配的大小是需要乘上4</p><p>​参数4：  需要传递给任务的参数</p><p>​参数5：   任务优先级，取值范围0~configMAX_PRIORITIES-1</p><p>​参数6：   任务句柄</p><p>​返回值：pdPASS：任务创建成功，会返回任务的句柄</p><p>​错误码参考projdefs.h中的定义</p><h3 id="2、静态创建任务接口函数"><a href="#2、静态创建任务接口函数" class="headerlink" title="2、静态创建任务接口函数"></a>2、静态创建任务接口函数</h3><p>​TaskHandle_t xTaskCreateStatic(TaskFunction_t pxTaskCode,</p><p>​const char * const pcName,</p><p>​const uint32_t ulStackDepth,</p><p>​void * const pvParameters,</p><p>​UBaseType_t uxPriority,</p><p>​StackType_t * const puxStackBuffer,</p><p>​StaticTask_t * const pxTaskBuffer )</p><p>​参数1：指向任务函数的入口，任务的函数名</p><p>​参数2： 字符串，任务的函数名</p><p>​参数3：任务堆栈大小，实际分配的大小是需要乘上4</p><p>​参数4： 需要传递给任务的参数</p><p>​参数5：   任务优先级，取值范围0~configMAX_PRIORITIES-1</p><p>​参数6：任务堆栈，一般是数组，成员类型需要是StackType_t类型</p><p>​参数7：任务控制块，必须要指向类型为StaticTask_t的变量，这个变量用于保存创建任务的数据结构（TCB），因此它必须是持久</p><p>​返回值:NULL，代表创建失败</p><p>​   其它值，代表成功，任务句柄 </p><p>​注意：使用静态创建任务时需要用户自己实现两个函数vApplicationGetIdleTaskMemory()和vApplicationGetTimerTaskMemory();</p><p>​通过这个两个函数来给空闲任务和定时器服务任务的任务堆栈和任务控制块分配内存</p><p>​我们可以在main.c文件的main涵数之前进行定义</p><p>​static StaticTask_t IdleTaskTCB;</p><p>​static StackType_t dleTaskStack[configMINIMAL_STACK_SIZE];</p><p>​static StaticTask_t TimerTaskTCB;</p><p>​static StackType_t TimerTaskStack[configTIMER_TASK_STACK_DEPTH];</p><p>​void vApplicationGetIdleTaskMemory(StaticTask_t * * ppxIdleTaskTCBBuffer, StackType_t * * ppxIdleTaskStackBuffer, uint32_t * pulIdleTaskStackSize)</p><p>​{</p><p>​* ppxIdleTaskTCBBuffer &#x3D; &IdleTaskTCB;&#x2F;&#x2F;空闲任务控制块</p><p>​* ppxIdleTaskStackBuffer &#x3D; dleTaskStack;&#x2F;&#x2F;空闲任务的堆栈</p><p>​* pulIdleTaskStackSize &#x3D; configMINIMAL_STACK_SIZE;&#x2F;&#x2F;堆栈大小</p><p>​}</p><p>​void vApplicationGetTimerTaskMemory(StaticTask_t * * ppxTimerTaskTCBBuffer, StackType_t * * ppxTimerTaskStackBuffer, uint32_t * pulTimerTaskStackSize)</p><p>​{</p><p>​* ppxTimerTaskTCBBuffer &#x3D; &TimerTaskTCB;&#x2F;&#x2F;任务控制块</p><p>​* ppxTimerTaskStackBuffer &#x3D; TimerTaskStack;&#x2F;&#x2F;任务堆栈</p><p>​* pulTimerTaskStackSize &#x3D; configTIMER_TASK_STACK_DEPTH;&#x2F;&#x2F;堆栈大小</p><p>​}</p><h3 id="任务怎么暂停和恢复"><a href="#任务怎么暂停和恢复" class="headerlink" title="任务怎么暂停和恢复"></a>任务怎么暂停和恢复</h3><p>​ 假如创建3三个任务</p><p>​任务1</p><p>​任务2</p><p>​任务3</p><p>​执行过程</p><p>​任务1-》任务2-》任务3</p><p>​void 任务1()</p><p>​{</p><p>​while(1)</p><p>​{</p><p>​A();</p><p>​———&gt;运行到这个地方时，系统进行了一次调度（切换任务）。</p><p>​B();</p><p>​}</p><p>​}</p><p>​&#x2F;&#x2F;前面我们有说任务是一段保存在FLASH上的代码（函数），如仅仅只是一段代码，更不不需要报存，但是这段代码一旦运行了，就会产生数据比如局部变量，PC寄存器的值，代码运行的位置。</p><h3 id="切任务时需要做的事情"><a href="#切任务时需要做的事情" class="headerlink" title="切任务时需要做的事情"></a>切任务时需要做的事情</h3><p>​1、保存程序执行的位置</p><p>​2、保存任务中产生的变量的值</p><p>​等等</p><p>​当程序运行时被打断，需要现场保护，也就是前面所说的16个寄存器的值，将他们保存起来，保存在哪里？-》保存在栈里面</p><p>堆栈的作用</p><h3 id="1》栈（stack）"><a href="#1》栈（stack）" class="headerlink" title="1》栈（stack）"></a>1》栈（stack）</h3><p>​1、函数的形参，以及函数里面定义的局部变量就是存储在栈里，（我们的局部变量，数组这些不能超过1K），否则程序会进入hardfault</p><p>​2、实时操作系统的现场保护，返回地址也是保存在栈里</p><p>​3、栈的增长方向是从高地址到低地址</p><h3 id="2》堆（heap）"><a href="#2》堆（heap）" class="headerlink" title="2》堆（heap）"></a>2》堆（heap）</h3><p>​1、malloc()函数动态分配的内存就是从堆空间分配</p><h3 id="3》静态空间区域"><a href="#3》静态空间区域" class="headerlink" title="3》静态空间区域"></a>3》静态空间区域</h3><p>​全局变量，静态变量是不存在堆里的，堆以外的静态空间区域</p><h3 id="4》栈的大小怎么分"><a href="#4》栈的大小怎么分" class="headerlink" title="4》栈的大小怎么分"></a>4》栈的大小怎么分</h3><p> —取决于局部变量的大小和调用的深度，只能估算，没有刚好的确定值（由大到小去调节）</p><h3 id="5》栈从哪里分配"><a href="#5》栈从哪里分配" class="headerlink" title="5》栈从哪里分配"></a>5》栈从哪里分配</h3><p> —-heap4.c中有一个很大的数组，从这个数组中划分出去各个任务的栈</p><h3 id="任务调度的机制"><a href="#任务调度的机制" class="headerlink" title="任务调度的机制"></a>任务调度的机制</h3><h4 id="1》在创建任务时做了以下事情"><a href="#1》在创建任务时做了以下事情" class="headerlink" title="1》在创建任务时做了以下事情"></a>1》在创建任务时做了以下事情</h4><p>​1、分配栈空间</p><p>​2、将函数地址给PC，也就是R15</p><p>​3、将参数给到R0</p><p>​4、分配优先级</p><p>​5、分配了TCB结构体</p><p>​任务切换时需要将R0-R15寄存器的值保存到栈里，再次运行时，需要从栈里面恢复R0-R15寄存器的值</p><h4 id="2》优先级"><a href="#2》优先级" class="headerlink" title="2》优先级"></a>2》优先级</h4><p>​1、高优先级的任务可以抢占低优先级任务</p><p>​2、高优先级的任务不主动放弃CPU资源，低优先级的任务永远无法运行</p><p>​3、同等优先级的任务按时间片轮询依次执行</p><p>​4、空闲任务礼让其他同级别的任务—空闲任务主动放弃一次运行机会</p><h4 id="3》怎么去管理任务"><a href="#3》怎么去管理任务" class="headerlink" title="3》怎么去管理任务"></a>3》怎么去管理任务</h4><p>​1、找到最高优先级的任务运行</p><p>​2、优先级相同轮流执行，排队，排在就绪列表前的先执行，运行一个tick后，让出CPU的使用权，去链表尾部排队</p><h4 id="4》高优先级任务怎么主动释放CPU使用权"><a href="#4》高优先级任务怎么主动释放CPU使用权" class="headerlink" title="4》高优先级任务怎么主动释放CPU使用权"></a>4》高优先级任务怎么主动释放CPU使用权</h4><p>​用vTaskDelay()函数可以释放CPU使用权</p><h4 id="5》空闲任务"><a href="#5》空闲任务" class="headerlink" title="5》空闲任务"></a>5》空闲任务</h4><p>​1、主要起清理作用，比如一个任务自杀了，由空闲任务来释放任务的栈空间</p><p>​2、当创建的任务优先级都为0时，最先运行的是空闲任务，因为空闲任务是在启动任务调度器时才创建</p><h3 id="启动文件"><a href="#启动文件" class="headerlink" title="启动文件"></a>启动文件</h3><p>​Stack_Size      EQU     0x00000400&#x2F;&#x2F;分配了一个栈空间</p><p>​                AREA    STACK, NOINIT, READWRITE, ALIGN&#x3D;3&#x2F;&#x2F;定义一个段，代码节或数据节，说明定义段的相关属性</p><p>​Stack_Mem       SPACE   Stack_Size</p><p>​&#x2F;&#x2F;SPACE(申请一段空间)用于分配大小等于Stack_Size连续内存空间，单位为字节&#x2F;&#x2F;类似MALLOC</p><p>​__initial_sp  &#x2F;&#x2F;表示这块区域的高地址指向栈顶 “先进后出”</p><p>​ STACK表示这块区域的名称没有限制写啥都行</p><p>​ NOINIT表示这块区域不需要初始化</p><p>​ READWRITE表示这块区域可读可写，可读写(内存)，ROM是指读区域</p><p>​ ALIGN&#x3D;3表示按照2^3(8)字节对齐</p><p>​ 启动文件中的堆栈空间是用来管理裸机开发时有用，freertos中的堆栈是由heap4.c管理</p><h4 id="6》在freertos中，最低优先级的中断也比最好优先级的任务先运行，中断永远都是先执行"><a href="#6》在freertos中，最低优先级的中断也比最好优先级的任务先运行，中断永远都是先执行" class="headerlink" title="6》在freertos中，最低优先级的中断也比最好优先级的任务先运行，中断永远都是先执行"></a>6》在freertos中，最低优先级的中断也比最好优先级的任务先运行，中断永远都是先执行</h4><h3 id="任务之间的通信"><a href="#任务之间的通信" class="headerlink" title="任务之间的通信"></a>任务之间的通信</h3><p>​1、消息队列</p><p>​2、共享内存</p><p>​3、信号量</p><p>​4、二值信号量</p>]]></content>
      
      
      <categories>
          
          <category> RTOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法碎片</title>
      <link href="/2024/08/06/test/%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E7%A2%8E%E7%89%87/"/>
      <url>/2024/08/06/test/%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E7%A2%8E%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="蔡勒公式："><a href="#蔡勒公式：" class="headerlink" title="蔡勒公式："></a>蔡勒公式：</h1><p>计算星期几的常用方法之一是使用“<strong>蔡勒公式</strong>”（Zeller’s Congruence）。这个公式可以计算给定日期对应的星期几，具体步骤如下：</p><h1 id="蔡勒公式的步骤："><a href="#蔡勒公式的步骤：" class="headerlink" title="蔡勒公式的步骤："></a><strong>蔡勒公式的步骤</strong>：</h1><ol><li><p><strong>调整月份与年份</strong>：</p><ul><li>如果月份是1月（1）或2月（2），则将其视为前一年的13月或14月，并将年份减1。</li><li>对于其他月份，直接使用该月份和年份。</li></ul></li><li><p><strong>设定公式变量</strong>：</p><ul><li>设定以下变量：<ul><li>：日期（一个月中的日）</li><li>：月份（3-12代表3月到12月，1月和2月用13和14表示）</li><li>：年份的后两位（year % 100）</li><li>：年份的前两位（year &#x2F; 100）</li></ul></li></ul></li><li><p><strong>应用公式计算</strong>：</p><ul><li><p>使用公式计算： </p></li><li><p><img src="/2024/08/06/test/%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E7%A2%8E%E7%89%87/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20241113212816146.png" alt="image-20241113212816146"></p></li><li><p>其中，</p><p>的值代表星期：</p><ul><li>0 &#x3D; Saturday</li><li>1 &#x3D; Sunday</li><li>2 &#x3D; Monday</li><li>3 &#x3D; Tuesday</li><li>4 &#x3D; Wednesday</li><li>5 &#x3D; Thursday</li><li>6 &#x3D; Friday</li></ul></li></ul></li></ol><h2 id="示例C语言实现："><a href="#示例C语言实现：" class="headerlink" title="示例C语言实现："></a><strong>示例C语言实现</strong>：</h2><p>以下是使用蔡勒公式计算任何给定日期的星期几的示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getDayOfWeek</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (month &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        month += <span class="number">12</span>; <span class="comment">// 将1月和2月视为上一年的13月和14月</span></span><br><span class="line">        year--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> q = day;                       <span class="comment">// 日期</span></span><br><span class="line">    <span class="type">int</span> m = month;                     <span class="comment">// 月份</span></span><br><span class="line">    <span class="type">int</span> K = year % <span class="number">100</span>;                <span class="comment">// 年份的后两位</span></span><br><span class="line">    <span class="type">int</span> J = year / <span class="number">100</span>;                <span class="comment">// 年份的前两位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 蔡勒公式</span></span><br><span class="line">    <span class="type">int</span> h = (q + (<span class="number">13</span> * (m + <span class="number">1</span>)) / <span class="number">5</span> + K + (K / <span class="number">4</span>) + (J / <span class="number">4</span>) - <span class="number">2</span> * J) % <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h; <span class="comment">// 返回星期几</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> year = <span class="number">2024</span>;</span><br><span class="line">    <span class="type">int</span> month = <span class="number">10</span>; <span class="comment">// 例如10月</span></span><br><span class="line">    <span class="type">int</span> day = <span class="number">1</span>;    <span class="comment">// 例如1日</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> weekday = getDayOfWeek(year, month, day);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;日期 %d-%d-%d 是星期：%d\n&quot;</span>, year, month, day, weekday);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CopyInsert</p><p>运行这段代码可以计算给定日期（例如2024年10月1日）对应的星期几。在这个示例中，输出的星期会以数字形式显示，可以根据前面提到的对应关系来判断具体是哪一天。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程技巧 </tag>
            
            <tag> 代码优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>韦东山</title>
      <link href="/2024/08/06/test/%E9%9F%A6%E4%B8%9C%E5%B1%B1linux/"/>
      <url>/2024/08/06/test/%E9%9F%A6%E4%B8%9C%E5%B1%B1linux/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/image-20250521175813146.png" alt="image-20250521175813146"></p><p>hexdump是Linux下的一个二进制文件查看工具，它可以将二进制文件转换为ASCII、八进制、十进制、十六进制格式进行查看。</p><p><code>echo</code> 是 Linux 系统中一个非常常用的命令，主要用于在终端输出字符串或变量的值。</p>]]></content>
      
      
      <categories>
          
          <category> 韦东山linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程技巧 </tag>
            
            <tag> 韦东山linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++知识整理</title>
      <link href="/2024/08/06/test/c%E5%92%8Cc++/c++%E6%95%B4%E7%90%86/"/>
      <url>/2024/08/06/test/c%E5%92%8Cc++/c++%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="C-知识整理"><a href="#C-知识整理" class="headerlink" title="C++知识整理"></a>C++知识整理</h1><h2 id="Day1-内容梳理"><a href="#Day1-内容梳理" class="headerlink" title="Day1 内容梳理"></a>Day1 内容梳理</h2><h3 id="一、标准输入输出"><a href="#一、标准输入输出" class="headerlink" title="一、标准输入输出"></a>一、标准输入输出</h3><ul><li><code>cin</code> - 标准输入</li><li><code>cout</code> - 标准输出</li><li><code>cerr</code> - 标准错误输出</li><li><code>clog</code> - 标准日志输出</li></ul><h3 id="二、内存分区模型"><a href="#二、内存分区模型" class="headerlink" title="二、内存分区模型"></a>二、内存分区模型</h3><p>在C++中内存主要分为：</p><ul><li>代码区</li><li>全局区</li><li>栈区</li><li>堆区</li></ul><h3 id="三、命名空间-namespace"><a href="#三、命名空间-namespace" class="headerlink" title="三、命名空间 namespace"></a>三、命名空间 namespace</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><p>命名空间是用户自定义的一个作用域</p><h4 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h4><p>处理程序中常见的命名冲突</p><h4 id="3、三种使用方式"><a href="#3、三种使用方式" class="headerlink" title="3、三种使用方式"></a>3、三种使用方式</h4><h5 id="全部引用"><a href="#全部引用" class="headerlink" title="全部引用"></a>全部引用</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><h5 id="部分引用"><a href="#部分引用" class="headerlink" title="部分引用"></a>部分引用</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br></pre></td></tr></table></figure><h5 id="域调用"><a href="#域调用" class="headerlink" title="域调用"></a>域调用</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h3 id="四、new-delete-和-malloc-free"><a href="#四、new-delete-和-malloc-free" class="headerlink" title="四、new&#x2F;delete 和 malloc&#x2F;free"></a>四、new&#x2F;delete 和 malloc&#x2F;free</h3><h4 id="1、new-申请空间"><a href="#1、new-申请空间" class="headerlink" title="1、new 申请空间"></a>1、new 申请空间</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);      <span class="comment">// 申请并初始化为10</span></span><br><span class="line"><span class="type">int</span> *arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]&#123;<span class="number">0</span>&#125;;  <span class="comment">// 申请数组并初始化为0</span></span><br></pre></td></tr></table></figure><h4 id="2、delete-释放空间"><a href="#2、delete-释放空间" class="headerlink" title="2、delete 释放空间"></a>2、delete 释放空间</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;      <span class="comment">// 释放单个</span></span><br><span class="line"><span class="keyword">delete</span>[] arr;  <span class="comment">// 释放数组</span></span><br></pre></td></tr></table></figure><h4 id="3、区别（面试题）"><a href="#3、区别（面试题）" class="headerlink" title="3、区别（面试题）"></a>3、区别（面试题）</h4><ul><li><code>malloc/free</code> 是C语言库函数，<code>new/delete</code> 是C++运算符</li><li><code>new</code> 会调用构造函数，<code>delete</code> 会调用析构函数</li><li><code>new</code> 返回具体类型指针，<code>malloc</code> 返回 <code>void*</code></li></ul><h3 id="五、引用与指针"><a href="#五、引用与指针" class="headerlink" title="五、引用与指针"></a>五、引用与指针</h3><p>（待补充…）</p><h3 id="六、函数的默认参数"><a href="#六、函数的默认参数" class="headerlink" title="六、函数的默认参数"></a>六、函数的默认参数</h3><p>（待补充…）</p><h3 id="七、函数重载"><a href="#七、函数重载" class="headerlink" title="七、函数重载"></a>七、函数重载</h3><p>（待补充…）</p><hr><blockquote><p>注：此文档需要重新整理，原内容因编码问题丢失</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> C++ </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++常见问答</title>
      <link href="/2024/08/06/test/c%E5%92%8Cc++/c++%E9%97%AE%E7%AD%94/"/>
      <url>/2024/08/06/test/c%E5%92%8Cc++/c++%E9%97%AE%E7%AD%94/</url>
      
        <content type="html"><![CDATA[<h1 id="C-三大特性"><a href="#C-三大特性" class="headerlink" title="C++三大特性"></a>C++三大特性</h1><p>C++三大特性之一：<strong>封装</strong><br>C++三大特性之二：<strong>继承</strong><br>C++三大特性之三：<strong>多态</strong></p><h2 id="1-封装"><a href="#1-封装" class="headerlink" title="1. 封装"></a>1. 封装</h2><p>封装就像是把东西装进盒子里。在C++中，封装意味着将数据（变量）和操作这些数据的代码（函数）打包在一起，形成一个类（Class）。</p><h2 id="2-继承"><a href="#2-继承" class="headerlink" title="2. 继承"></a>2. 继承</h2><p>继承就像是孩子从父母那里继承特性。在C++中，继承允许一个类（子类）继承另一个类（父类或基类）的属性和方法。</p><h2 id="3-多态"><a href="#3-多态" class="headerlink" title="3. 多态"></a>3. 多态</h2><p>多态就像是同一个接口可以有不同的实现方式。在C++中，多态允许不同的类以自己的方式实现相同的接口。</p><hr><h1 id="C-问答"><a href="#C-问答" class="headerlink" title="C++问答"></a>C++问答</h1><h2 id="一、C-强制类型转化"><a href="#一、C-强制类型转化" class="headerlink" title="一、C++强制类型转化"></a>一、C++强制类型转化</h2><h3 id="1、C强制转换与C-强制转换"><a href="#1、C强制转换与C-强制转换" class="headerlink" title="1、C强制转换与C++强制转换"></a>1、C强制转换与C++强制转换</h3><p>C语言强制类型转换语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(type-id)expression    <span class="comment">// 转换格式1</span></span><br><span class="line">type-<span class="built_in">id</span>(expression)    <span class="comment">// 转换格式2</span></span><br></pre></td></tr></table></figure><p>C++新增四种强制类型转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;new_type&gt;(expression)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;new_type&gt;(expression)</span><br><span class="line"><span class="built_in">const_cast</span>&lt;new_type&gt;(expression)</span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;new_type&gt;(expression)</span><br></pre></td></tr></table></figure><h3 id="2、C-四种强制类型转换"><a href="#2、C-四种强制类型转换" class="headerlink" title="2、C++四种强制类型转换"></a>2、C++四种强制类型转换</h3><h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h4><p>用于基本数据类型之间的转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(a);</span><br></pre></td></tr></table></figure><h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><p>用于多态类型的转换，运行时检查：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base* base = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Derived* derived = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(base);</span><br></pre></td></tr></table></figure><h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h4><p>用于去除或添加 const 属性：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* p1 = &amp;a;</span><br><span class="line"><span class="type">int</span>* p2 = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(p1);</span><br></pre></td></tr></table></figure><h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><p>用于指针类型之间的转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">long</span> addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">long</span>&gt;(p);</span><br></pre></td></tr></table></figure><hr><h2 id="二、智能指针"><a href="#二、智能指针" class="headerlink" title="二、智能指针"></a>二、智能指针</h2><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><ul><li>共享所有权</li><li>引用计数</li><li>注意循环引用问题</li></ul><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><ul><li>独占所有权</li><li>不能复制，只能移动</li></ul><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><ul><li>弱引用</li><li>解决 shared_ptr 循环引用问题</li></ul><hr><h2 id="三、虚函数与多态"><a href="#三、虚函数与多态" class="headerlink" title="三、虚函数与多态"></a>三、虚函数与多态</h2><p>（待补充…）</p><h2 id="四、STL容器"><a href="#四、STL容器" class="headerlink" title="四、STL容器"></a>四、STL容器</h2><p>（待补充…）</p><hr><blockquote><p>注：此文档需要重新整理，原内容因编码问题丢失</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 面试题 </tag>
            
            <tag> 问答 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法碎片</title>
      <link href="/2024/08/06/test/c%E5%92%8Cc++/%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E7%A2%8E%E7%89%87/"/>
      <url>/2024/08/06/test/c%E5%92%8Cc++/%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E7%A2%8E%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="蔡勒公式："><a href="#蔡勒公式：" class="headerlink" title="蔡勒公式："></a>蔡勒公式：</h1><p>计算星期几的常用方法之一是使用“<strong>蔡勒公式</strong>”（Zeller’s Congruence）。这个公式可以计算给定日期对应的星期几，具体步骤如下：</p><h1 id="蔡勒公式的步骤："><a href="#蔡勒公式的步骤：" class="headerlink" title="蔡勒公式的步骤："></a><strong>蔡勒公式的步骤</strong>：</h1><ol><li><p><strong>调整月份与年份</strong>：</p><ul><li>如果月份是1月（1）或2月（2），则将其视为前一年的13月或14月，并将年份减1。</li><li>对于其他月份，直接使用该月份和年份。</li></ul></li><li><p><strong>设定公式变量</strong>：</p><ul><li>设定以下变量：<ul><li>：日期（一个月中的日）</li><li>：月份（3-12代表3月到12月，1月和2月用13和14表示）</li><li>：年份的后两位（year % 100）</li><li>：年份的前两位（year &#x2F; 100）</li></ul></li></ul></li><li><p><strong>应用公式计算</strong>：</p><ul><li><p>使用公式计算： </p></li><li><p><img src="/2024/08/06/test/c%E5%92%8Cc++/%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E7%A2%8E%E7%89%87/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20241113212816146.png" alt="image-20241113212816146"></p></li><li><p>其中，</p><p>的值代表星期：</p><ul><li>0 &#x3D; Saturday</li><li>1 &#x3D; Sunday</li><li>2 &#x3D; Monday</li><li>3 &#x3D; Tuesday</li><li>4 &#x3D; Wednesday</li><li>5 &#x3D; Thursday</li><li>6 &#x3D; Friday</li></ul></li></ul></li></ol><h2 id="示例C语言实现："><a href="#示例C语言实现：" class="headerlink" title="示例C语言实现："></a><strong>示例C语言实现</strong>：</h2><p>以下是使用蔡勒公式计算任何给定日期的星期几的示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getDayOfWeek</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (month &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        month += <span class="number">12</span>; <span class="comment">// 将1月和2月视为上一年的13月和14月</span></span><br><span class="line">        year--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> q = day;                       <span class="comment">// 日期</span></span><br><span class="line">    <span class="type">int</span> m = month;                     <span class="comment">// 月份</span></span><br><span class="line">    <span class="type">int</span> K = year % <span class="number">100</span>;                <span class="comment">// 年份的后两位</span></span><br><span class="line">    <span class="type">int</span> J = year / <span class="number">100</span>;                <span class="comment">// 年份的前两位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 蔡勒公式</span></span><br><span class="line">    <span class="type">int</span> h = (q + (<span class="number">13</span> * (m + <span class="number">1</span>)) / <span class="number">5</span> + K + (K / <span class="number">4</span>) + (J / <span class="number">4</span>) - <span class="number">2</span> * J) % <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h; <span class="comment">// 返回星期几</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> year = <span class="number">2024</span>;</span><br><span class="line">    <span class="type">int</span> month = <span class="number">10</span>; <span class="comment">// 例如10月</span></span><br><span class="line">    <span class="type">int</span> day = <span class="number">1</span>;    <span class="comment">// 例如1日</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> weekday = getDayOfWeek(year, month, day);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;日期 %d-%d-%d 是星期：%d\n&quot;</span>, year, month, day, weekday);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CopyInsert</p><p>运行这段代码可以计算给定日期（例如2024年10月1日）对应的星期几。在这个示例中，输出的星期会以数字形式显示，可以根据前面提到的对应关系来判断具体是哪一天。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程技巧 </tag>
            
            <tag> 代码优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法自带格式(如何写博客)</title>
      <link href="/2024/08/06/test/%E5%8D%9A%E5%AE%A2/Markdown%E8%AF%AD%E6%B3%95%E8%87%AA%E5%B8%A6%E6%A0%BC%E5%BC%8F(%E5%A6%82%E4%BD%95%E5%86%99%E5%8D%9A%E5%AE%A2)/"/>
      <url>/2024/08/06/test/%E5%8D%9A%E5%AE%A2/Markdown%E8%AF%AD%E6%B3%95%E8%87%AA%E5%B8%A6%E6%A0%BC%E5%BC%8F(%E5%A6%82%E4%BD%95%E5%86%99%E5%8D%9A%E5%AE%A2)/</url>
      
        <content type="html"><![CDATA[<p><img src="/./images/bywind.png" alt="图"></p><p>用Typora软件更简单</p><p><a href="https://www.bilibili.com/video/BV1iHaTe9EZ3/?spm_id_from=333.337.search-card.all.click&vd_source=390e7ea253547d9c75882d502ff42a1b">Typora安装激活流程_哔哩哔哩_bilibili</a></p><p>Typora安装文件及下载地址~<br>链接:<a href="https://pan.baidu.com/s/17CunIoob5JbtQZ1N5ZIyfg?pwd=zspz">https://pan.baidu.com/s/17CunIoob5JbtQZ1N5ZIyfg?pwd=zspz</a> 提取码:zspz</p><p>一键3连 上传代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl&amp;&amp;hexo g&amp;&amp;hexo d</span><br></pre></td></tr></table></figure><h2 id="多级标题"><a href="#多级标题" class="headerlink" title="多级标题"></a>多级标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure><h2 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span>&gt;</span></span>5号字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>这里的背景色是：MistyRosen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure><h2 id="1-5-分割线"><a href="#1-5-分割线" class="headerlink" title="1.5 分割线"></a>1.5 分割线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><p>​分栏 tab</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><ol><li>Unique name :<ul><li>选项卡块标签的唯一名称，不带逗号。</li><li>将在#id中用作每个标签及其索引号的前缀。</li><li>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</li><li>仅当前帖子&#x2F;页面的URL必须是唯一的！</li></ul></li><li>[index]:<ul><li>活动选项卡的索引号。</li><li>如果未指定，将选择第一个标签（1）。</li><li>如果index为-1，则不会选择任何选项卡。</li><li>可选参数。</li></ul></li><li>[Tab caption]:<ul><li>当前选项卡的标题。</li><li>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</li><li>如果未指定标题，但指定了图标，则标题将为空。</li><li>可选参数。</li></ul></li><li>[@icon]:<ul><li>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</li><li>可以指定带空格或不带空格；</li><li>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</li><li>可选参数。</li></ul></li></ol><p>示例1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>示例2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line">**tab名字为第一个Tab**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line">**只有图标 没有Tab名字**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line">**名字+icon**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>示例1</p><p>.<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">test1 1</button><button type="button" class="tab">test1 2</button><button type="button" class="tab">test1 3</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>This is Tab 1.</strong></p></div><div class="tab-item-content"><p><strong>This is Tab 2.</strong></p></div><div class="tab-item-content"><p><strong>This is Tab 3.</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></p><p>示例2</p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">第一个Tab</button><button type="button" class="tab"><i class="fab fa-apple-pay"></i></button><button type="button" class="tab"><i class="fas fa-bomb"></i>炸弹</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>tab名字为第一个Tab</strong></p></div><div class="tab-item-content"><p><strong>只有图标 没有Tab名字</strong></p></div><div class="tab-item-content"><p><strong>名字+icon</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="音频-audio"><a href="#音频-audio" class="headerlink" title="音频 audio"></a>音频 audio</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">参数配置</button><button type="button" class="tab">示例代码</button><button type="button" class="tab">演示</button></div><div class="tab-contents"><div class="tab-item-content active"></div><div class="tab-item-content"></div><div class="tab-item-content"></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> 博客写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 写作技巧 </tag>
            
            <tag> 博客指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>技术博客写作完全指南 - 从零开始打造影响力</title>
      <link href="/2024/08/06/%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2024/08/06/%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C/%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="?? 前言"></a>?? 前言</h2><p>技术博客不仅是知识分享的平台，更是个人品牌建设和职业发展的重要工具。本文将从零开始，教你如何创作高质量的技术博客，建立自己的技术影响力。</p><span id="more"></span><h2 id="为什么要写技术博客？"><a href="#为什么要写技术博客？" class="headerlink" title="? 为什么要写技术博客？"></a>? 为什么要写技术博客？</h2><h3 id="个人收益"><a href="#个人收益" class="headerlink" title="个人收益"></a>个人收益</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? 知识巩固：写作过程中深化理解</span><br><span class="line">? 职业发展：展示技术能力和思考深度</span><br><span class="line">? 个人品牌：建立技术领域的影响力</span><br><span class="line">? 人脉拓展：结识同行和技术专家</span><br><span class="line">? 思维训练：提升逻辑思维和表达能力</span><br></pre></td></tr></table></figure><h3 id="技术社区价值"><a href="#技术社区价值" class="headerlink" title="技术社区价值"></a>技术社区价值</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">? 知识传承：将经验传递给后来者</span><br><span class="line">? 问题解决：帮助他人解决技术难题</span><br><span class="line">? 技术讨论：促进技术交流和创新</span><br><span class="line">? 行业推动：推动技术发展和标准化</span><br></pre></td></tr></table></figure><h2 id="博客写作流程"><a href="#博客写作流程" class="headerlink" title="? 博客写作流程"></a>? 博客写作流程</h2><h3 id="1-选题策划"><a href="#1-选题策划" class="headerlink" title="1. 选题策划"></a>1. 选题策划</h3><p><strong>选题原则</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? 自己熟悉的领域</span><br><span class="line">? 有实际价值的内容</span><br><span class="line">? 读者感兴趣的话题</span><br><span class="line">? 有一定深度的思考</span><br><span class="line">? 能够持续更新的方向</span><br></pre></td></tr></table></figure><p><strong>选题来源</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? 工作中遇到的问题和解决方案</span><br><span class="line">? 学习新技术的心得体会</span><br><span class="line">?? 开源项目的使用经验</span><br><span class="line">? 技术趋势的分析和思考</span><br><span class="line">? 面试经验和求职心得</span><br></pre></td></tr></table></figure><h3 id="2-内容规划"><a href="#2-内容规划" class="headerlink" title="2. 内容规划"></a>2. 内容规划</h3><p><strong>文章结构模板</strong>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 标题（吸引人且准确）</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 前言</span></span><br><span class="line"><span class="bullet">-</span> 问题背景</span><br><span class="line"><span class="bullet">-</span> 文章价值</span><br><span class="line"><span class="bullet">-</span> 阅读收获</span><br><span class="line"></span><br><span class="line"><span class="section">## 正文</span></span><br><span class="line"><span class="section">### 理论基础</span></span><br><span class="line"><span class="section">### 实践操作</span></span><br><span class="line"><span class="section">### 代码示例</span></span><br><span class="line"><span class="section">### 注意事项</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 总结</span></span><br><span class="line"><span class="bullet">-</span> 关键要点</span><br><span class="line"><span class="bullet">-</span> 最佳实践</span><br><span class="line"><span class="bullet">-</span> 延伸思考</span><br><span class="line"></span><br><span class="line"><span class="section">## 参考资料</span></span><br></pre></td></tr></table></figure><h3 id="3-写作技巧"><a href="#3-写作技巧" class="headerlink" title="3. 写作技巧"></a>3. 写作技巧</h3><p><strong>开头写作技巧</strong>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">? 避免：今天我要介绍...</span><br><span class="line">? 推荐：在嵌入式开发中，内存管理是一个关键挑战...</span><br><span class="line"></span><br><span class="line">? 避免：这篇文章讲述了...</span><br><span class="line">? 推荐：你是否遇到过程序莫名其妙崩溃的问题？</span><br><span class="line"></span><br><span class="line">? 避免：大家好，我是...</span><br><span class="line">? 推荐：直接进入主题，用问题或场景引入</span><br></pre></td></tr></table></figure><p><strong>正文写作要点</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? 逻辑清晰：使用递进、并列、对比等逻辑关系</span><br><span class="line">? 数据支撑：用具体数据和案例说明问题</span><br><span class="line">? 代码规范：代码要完整、可运行、有注释</span><br><span class="line">?? 图文并茂：适当使用图表、流程图、截图</span><br><span class="line">? 引用权威：引用官方文档、权威资料</span><br></pre></td></tr></table></figure><h2 id="Markdown写作技巧"><a href="#Markdown写作技巧" class="headerlink" title="? Markdown写作技巧"></a>? Markdown写作技巧</h2><h3 id="基础语法精通"><a href="#基础语法精通" class="headerlink" title="基础语法精通"></a>基础语法精通</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"><span class="section">### 三级标题</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line"><span class="emphasis">*斜体文本*</span></span><br><span class="line">~~删除线~~</span><br><span class="line"><span class="code">`行内代码`</span></span><br><span class="line"></span><br><span class="line"><span class="quote">&gt; 引用文本</span></span><br><span class="line"><span class="quote">&gt; 可以多行</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 无序列表项1</span><br><span class="line"><span class="bullet">-</span> 无序列表项2</span><br><span class="line"><span class="bullet">  -</span> 嵌套列表项</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 有序列表项1</span><br><span class="line"><span class="bullet">2.</span> 有序列表项2</span><br><span class="line"></span><br><span class="line">[<span class="string">链接文本</span>](<span class="link">https://example.com</span>)</span><br><span class="line">![<span class="string">图片描述</span>](<span class="link">image.jpg</span>)</span><br><span class="line"></span><br><span class="line">| 表头1 | 表头2 | 表头3 |</span><br><span class="line">|-------|-------|-------|</span><br><span class="line">| 内容1 | 内容2 | 内容3 |</span><br></pre></td></tr></table></figure><h3 id="代码块最佳实践"><a href="#代码块最佳实践" class="headerlink" title="代码块最佳实践"></a>代码块最佳实践</h3><p><strong>语法高亮</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C语言代码示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>带行号的代码</strong>：</p><figure class="highlight javascript"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript代码示例</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fibonacci</span>(n - <span class="number">1</span>) + <span class="title function_">fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fibonacci</span>(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><p><strong>代码差异对比</strong>：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 修改前</span><br><span class="line"><span class="deletion">- const result = data.map(item =&gt; item.value);</span></span><br><span class="line">// 修改后</span><br><span class="line"><span class="addition">+ const result = data.map(item =&gt; item.value || 0);</span></span><br></pre></td></tr></table></figure><h3 id="高级Markdown技巧"><a href="#高级Markdown技巧" class="headerlink" title="高级Markdown技巧"></a>高级Markdown技巧</h3><p><strong>数学公式</strong>（需要MathJax支持）：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">行内公式：$E = mc^2$</span><br><span class="line"></span><br><span class="line">块级公式：</span><br><span class="line">$$</span><br><span class="line">\sum<span class="emphasis">_&#123;i=1&#125;^&#123;n&#125; i = \frac&#123;n(n+1)&#125;&#123;2&#125;</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><p><strong>流程图</strong>（需要Mermaid支持）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[开始] --&gt; B&#123;条件判断&#125;</span><br><span class="line">    B --&gt;|是| C[执行操作A]</span><br><span class="line">    B --&gt;|否| D[执行操作B]</span><br><span class="line">    C --&gt; E[结束]</span><br><span class="line">    D --&gt; E</span><br></pre></td></tr></table></figure><p><strong>任务列表</strong>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> [x] 已完成的任务</span><br><span class="line"><span class="bullet">-</span> [ ] 未完成的任务</span><br><span class="line"><span class="bullet">-</span> [ ] 另一个未完成的任务</span><br></pre></td></tr></table></figure><h2 id="内容创作技巧"><a href="#内容创作技巧" class="headerlink" title="? 内容创作技巧"></a>? 内容创作技巧</h2><h3 id="技术文章类型"><a href="#技术文章类型" class="headerlink" title="技术文章类型"></a>技术文章类型</h3><p><strong>1. 教程类文章</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line"><span class="bullet">-</span> 步骤清晰，易于跟随</span><br><span class="line"><span class="bullet">-</span> 包含完整的代码示例</span><br><span class="line"><span class="bullet">-</span> 有明确的学习目标</span><br><span class="line"></span><br><span class="line">结构：</span><br><span class="line"><span class="bullet">1.</span> 环境准备</span><br><span class="line"><span class="bullet">2.</span> 基础概念</span><br><span class="line"><span class="bullet">3.</span> 实践步骤</span><br><span class="line"><span class="bullet">4.</span> 常见问题</span><br><span class="line"><span class="bullet">5.</span> 进阶扩展</span><br></pre></td></tr></table></figure><p><strong>2. 经验分享类</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line"><span class="bullet">-</span> 基于真实项目经验</span><br><span class="line"><span class="bullet">-</span> 包含踩坑和解决方案</span><br><span class="line"><span class="bullet">-</span> 有深度思考和总结</span><br><span class="line"></span><br><span class="line">结构：</span><br><span class="line"><span class="bullet">1.</span> 项目背景</span><br><span class="line"><span class="bullet">2.</span> 遇到的问题</span><br><span class="line"><span class="bullet">3.</span> 解决方案对比</span><br><span class="line"><span class="bullet">4.</span> 最终选择和实现</span><br><span class="line"><span class="bullet">5.</span> 经验总结</span><br></pre></td></tr></table></figure><p><strong>3. 技术分析类</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line"><span class="bullet">-</span> 深入分析技术原理</span><br><span class="line"><span class="bullet">-</span> 对比不同方案优劣</span><br><span class="line"><span class="bullet">-</span> 有自己的见解和判断</span><br><span class="line"></span><br><span class="line">结构：</span><br><span class="line"><span class="bullet">1.</span> 技术背景</span><br><span class="line"><span class="bullet">2.</span> 原理分析</span><br><span class="line"><span class="bullet">3.</span> 方案对比</span><br><span class="line"><span class="bullet">4.</span> 适用场景</span><br><span class="line"><span class="bullet">5.</span> 发展趋势</span><br></pre></td></tr></table></figure><h3 id="写作风格建议"><a href="#写作风格建议" class="headerlink" title="写作风格建议"></a>写作风格建议</h3><p><strong>技术准确性</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">? 使用准确的技术术语</span><br><span class="line">? 提供可验证的代码示例</span><br><span class="line">? 引用权威资料和文档</span><br><span class="line">? 承认不确定的地方</span><br><span class="line">? 避免模糊不清的表述</span><br><span class="line">? 不要传播错误信息</span><br></pre></td></tr></table></figure><p><strong>可读性优化</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">? 使用简洁明了的语言</span><br><span class="line">? 适当使用类比和比喻</span><br><span class="line">? 合理使用标点符号</span><br><span class="line">? 控制段落长度</span><br><span class="line">? 避免过于复杂的句式</span><br><span class="line">? 不要使用过多的专业术语</span><br></pre></td></tr></table></figure><h2 id="SEO优化技巧"><a href="#SEO优化技巧" class="headerlink" title="? SEO优化技巧"></a>? SEO优化技巧</h2><h3 id="标题优化"><a href="#标题优化" class="headerlink" title="标题优化"></a>标题优化</h3><p><strong>好标题的特征</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? 准确描述内容</span><br><span class="line">? 包含关键词</span><br><span class="line">? 吸引读者点击</span><br><span class="line">? 长度适中（50-60字符）</span><br><span class="line">? 可以包含数字</span><br></pre></td></tr></table></figure><p><strong>标题示例对比</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">? 普通：关于React的一些思考</span><br><span class="line">? 优化：React Hooks最佳实践：5个提升性能的技巧</span><br><span class="line"></span><br><span class="line">? 普通：数据库优化</span><br><span class="line">? 优化：MySQL查询优化实战：从30秒到0.1秒的性能提升</span><br><span class="line"></span><br><span class="line">? 普通：我的学习心得</span><br><span class="line">? 优化：零基础学习机器学习：3个月从入门到实战的完整路线</span><br></pre></td></tr></table></figure><h3 id="关键词策略"><a href="#关键词策略" class="headerlink" title="关键词策略"></a>关键词策略</h3><p><strong>关键词选择</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 主关键词：文章核心主题</span><br><span class="line">2. 长尾关键词：更具体的搜索词</span><br><span class="line">3. 相关关键词：相关技术和概念</span><br><span class="line">4. 品牌关键词：技术栈、工具名称</span><br></pre></td></tr></table></figure><p><strong>关键词布局</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? 标题：包含主关键词</span><br><span class="line">? 描述：自然融入关键词</span><br><span class="line">? 正文：合理分布，避免堆砌</span><br><span class="line">? 标签：使用相关关键词</span><br><span class="line">? 图片alt：描述性关键词</span><br></pre></td></tr></table></figure><h3 id="内容结构优化"><a href="#内容结构优化" class="headerlink" title="内容结构优化"></a>内容结构优化</h3><p><strong>层次结构</strong>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1标题（页面唯一）</span></span><br><span class="line"><span class="section">## H2标题（章节标题）</span></span><br><span class="line"><span class="section">### H3标题（小节标题）</span></span><br><span class="line"><span class="section">#### H4标题（细分内容）</span></span><br></pre></td></tr></table></figure><p><strong>内部链接</strong>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">相关文章推荐：</span><br><span class="line"><span class="bullet">-</span> [<span class="string">Git版本控制完全指南</span>](<span class="link">/2024/08/06/git-guide/</span>)</span><br><span class="line"><span class="bullet">-</span> [<span class="string">Linux命令行实战</span>](<span class="link">/2024/08/06/linux-commands/</span>)</span><br><span class="line"><span class="bullet">-</span> [<span class="string">数据结构与算法</span>](<span class="link">/2024/08/06/data-structures/</span>)</span><br></pre></td></tr></table></figure><h2 id="博客平台选择"><a href="#博客平台选择" class="headerlink" title="? 博客平台选择"></a>? 博客平台选择</h2><h3 id="主流平台对比"><a href="#主流平台对比" class="headerlink" title="主流平台对比"></a>主流平台对比</h3><table><thead><tr><th>平台</th><th>优势</th><th>劣势</th><th>适合人群</th></tr></thead><tbody><tr><td><strong>GitHub Pages + Hexo</strong></td><td>免费、可定制、版本控制</td><td>需要技术基础</td><td>程序员</td></tr><tr><td><strong>掘金</strong></td><td>技术氛围好、流量大</td><td>平台限制多</td><td>前端开发者</td></tr><tr><td><strong>CSDN</strong></td><td>用户基数大、SEO好</td><td>广告多、体验差</td><td>初学者</td></tr><tr><td><strong>知乎</strong></td><td>用户质量高、讨论活跃</td><td>算法推荐机制</td><td>技术专家</td></tr><tr><td><strong>Medium</strong></td><td>国际化、设计优美</td><td>国内访问慢</td><td>英文写作者</td></tr></tbody></table><h3 id="Hexo博客优化"><a href="#Hexo博客优化" class="headerlink" title="Hexo博客优化"></a>Hexo博客优化</h3><p><strong>主题选择建议</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">推荐主题：</span><br><span class="line">? Butterfly：功能丰富，美观大方</span><br><span class="line">? NexT：简洁优雅，文档完善</span><br><span class="line">? Fluid：现代化设计，响应式布局</span><br><span class="line">? Icarus：多栏布局，功能全面</span><br></pre></td></tr></table></figure><p><strong>插件推荐</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _config.yml 插件配置</span></span><br><span class="line"><span class="attr">plugins:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo-generator-sitemap</span>      <span class="comment"># 生成sitemap</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo-generator-feed</span>         <span class="comment"># RSS订阅</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo-deployer-git</span>          <span class="comment"># Git部署</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo-wordcount</span>             <span class="comment"># 字数统计</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo-generator-search</span>      <span class="comment"># 本地搜索</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">hexo-filter-nofollow</span>       <span class="comment"># 外链nofollow</span></span><br></pre></td></tr></table></figure><h2 id="博客推广策略"><a href="#博客推广策略" class="headerlink" title="? 博客推广策略"></a>? 博客推广策略</h2><h3 id="内容推广"><a href="#内容推广" class="headerlink" title="内容推广"></a>内容推广</h3><p><strong>社交媒体分享</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">? Twitter：分享技术见解和文章链接</span><br><span class="line">? 微博：参与技术话题讨论</span><br><span class="line">? LinkedIn：建立专业形象</span><br><span class="line">? B站：制作技术视频内容</span><br></pre></td></tr></table></figure><p><strong>技术社区参与</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">? GitHub：贡献开源项目，在README中链接博客</span><br><span class="line">?? Stack Overflow：回答问题时引用自己的文章</span><br><span class="line">? Reddit：在相关subreddit分享内容</span><br><span class="line">? Hacker News：分享有价值的技术文章</span><br></pre></td></tr></table></figure><h3 id="读者互动"><a href="#读者互动" class="headerlink" title="读者互动"></a>读者互动</h3><p><strong>评论管理</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? 及时回复读者评论</span><br><span class="line">? 鼓励讨论和提问</span><br><span class="line">? 感谢读者的反馈</span><br><span class="line">? 修正文章中的错误</span><br><span class="line">? 避免争论和负面情绪</span><br></pre></td></tr></table></figure><p><strong>社群建设</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">? 邮件订阅：定期发送技术周报</span><br><span class="line">? 微信群：建立读者交流群</span><br><span class="line">? Discord：实时技术讨论</span><br><span class="line">? QQ群：国内用户交流平台</span><br></pre></td></tr></table></figure><h2 id="数据分析和改进"><a href="#数据分析和改进" class="headerlink" title="? 数据分析和改进"></a>? 数据分析和改进</h2><h3 id="关键指标监控"><a href="#关键指标监控" class="headerlink" title="关键指标监控"></a>关键指标监控</h3><p><strong>流量指标</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? 页面浏览量（PV）</span><br><span class="line">? 独立访客数（UV）</span><br><span class="line">?? 平均停留时间</span><br><span class="line">? 跳出率</span><br><span class="line">? 回访率</span><br></pre></td></tr></table></figure><p><strong>内容指标</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? 点赞数和分享数</span><br><span class="line">? 评论数和互动率</span><br><span class="line">? 外部链接数</span><br><span class="line">? 搜索排名</span><br><span class="line">? 订阅用户数</span><br></pre></td></tr></table></figure><h3 id="持续改进策略"><a href="#持续改进策略" class="headerlink" title="持续改进策略"></a>持续改进策略</h3><p><strong>内容优化</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 分析热门文章特点</span><br><span class="line">2. 更新过时的技术内容</span><br><span class="line">3. 补充读者关心的话题</span><br><span class="line">4. 优化文章结构和排版</span><br><span class="line">5. 增加实用的代码示例</span><br></pre></td></tr></table></figure><p><strong>用户体验优化</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? 页面加载速度优化</span><br><span class="line">? 移动端适配改进</span><br><span class="line">? 搜索功能完善</span><br><span class="line">? 界面设计优化</span><br><span class="line">? 可访问性提升</span><br></pre></td></tr></table></figure><h2 id="写作进阶技巧"><a href="#写作进阶技巧" class="headerlink" title="? 写作进阶技巧"></a>? 写作进阶技巧</h2><h3 id="建立写作习惯"><a href="#建立写作习惯" class="headerlink" title="建立写作习惯"></a>建立写作习惯</h3><p><strong>时间管理</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? 制定写作计划</span><br><span class="line">? 固定写作时间</span><br><span class="line">? 设定写作目标</span><br><span class="line">? 建立素材库</span><br><span class="line">? 定期回顾总结</span><br></pre></td></tr></table></figure><p><strong>灵感管理</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? 随时记录想法</span><br><span class="line">? 使用笔记应用</span><br><span class="line">? 收藏优质文章</span><br><span class="line">? 建立知识体系</span><br><span class="line">? 定期思考总结</span><br></pre></td></tr></table></figure><h3 id="写作工具推荐"><a href="#写作工具推荐" class="headerlink" title="写作工具推荐"></a>写作工具推荐</h3><p><strong>编辑器</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">? Typora：所见即所得Markdown编辑器</span><br><span class="line">? VSCode：强大的代码编辑器，支持Markdown</span><br><span class="line">? Notion：全能笔记工具</span><br><span class="line">?? 语雀：在线文档协作平台</span><br></pre></td></tr></table></figure><p><strong>辅助工具</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">? Draw.io：流程图制作</span><br><span class="line">? Excalidraw：手绘风格图表</span><br><span class="line">?? Carbon：代码截图美化</span><br><span class="line">? Snipaste：截图工具</span><br><span class="line">? Grammarly：英文语法检查</span><br></pre></td></tr></table></figure><h2 id="成功案例分析"><a href="#成功案例分析" class="headerlink" title="? 成功案例分析"></a>? 成功案例分析</h2><h3 id="优秀技术博客特点"><a href="#优秀技术博客特点" class="headerlink" title="优秀技术博客特点"></a>优秀技术博客特点</h3><p><strong>阮一峰的网络日志</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">? 内容通俗易懂</span><br><span class="line">? 定期更新周报</span><br><span class="line">? 涵盖面广泛</span><br><span class="line">? 有独特见解</span><br></pre></td></tr></table></figure><p><strong>美团技术团队</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">? 实战经验丰富</span><br><span class="line">? 技术深度足够</span><br><span class="line">? 解决实际问题</span><br><span class="line">? 团队协作产出</span><br></pre></td></tr></table></figure><p><strong>掘金技术社区</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">特点：</span><br><span class="line">? 用户参与度高</span><br><span class="line">? 内容质量把控</span><br><span class="line">? 激励机制完善</span><br><span class="line">? 技术氛围浓厚</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="? 总结"></a>? 总结</h2><p>技术博客写作是一个长期的过程，需要持续的投入和改进。成功的关键在于：</p><h3 id="内容为王"><a href="#内容为王" class="headerlink" title="内容为王"></a>内容为王</h3><ul><li><strong>价值导向</strong>：写对读者有价值的内容</li><li><strong>质量优先</strong>：宁缺毋滥，保证文章质量</li><li><strong>持续更新</strong>：保持稳定的更新频率</li><li><strong>深度思考</strong>：不只是知识搬运，要有自己的见解</li></ul><h3 id="技术精进"><a href="#技术精进" class="headerlink" title="技术精进"></a>技术精进</h3><ul><li><strong>扎实基础</strong>：确保技术内容的准确性</li><li><strong>实践验证</strong>：所有代码都要经过测试</li><li><strong>与时俱进</strong>：跟上技术发展趋势</li><li><strong>广度深度</strong>：既要有专业深度，也要有知识广度</li></ul><h3 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h3><ul><li><strong>读者思维</strong>：站在读者角度思考问题</li><li><strong>清晰表达</strong>：用简洁明了的语言表达复杂概念</li><li><strong>互动交流</strong>：积极回应读者反馈</li><li><strong>持续改进</strong>：根据数据和反馈优化内容</li></ul><h3 id="个人品牌"><a href="#个人品牌" class="headerlink" title="个人品牌"></a>个人品牌</h3><ul><li><strong>一致性</strong>：保持写作风格和价值观的一致</li><li><strong>专业性</strong>：展现专业的技术能力和态度</li><li><strong>影响力</strong>：通过优质内容建立技术影响力</li><li><strong>长期主义</strong>：把博客写作当作长期投资</li></ul><p>记住，每一篇优质的技术文章都是对技术社区的贡献，也是个人成长的见证。开始写作吧，用文字记录你的技术成长之路！</p><hr><blockquote><p>? <strong>写作金句</strong>: “最好的学习方式是教授他人，最好的教授方式是写作分享。”</p></blockquote><p><strong>相关文章推荐</strong>:</p><ul><li><a href="/2024/08/06/markdown-guide/">Markdown语法完全指南</a></li><li><a href="/2024/08/06/hexo-setup/">Hexo博客搭建教程</a></li><li><a href="/2024/08/06/writing-tools/">技术写作工具推荐</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客写作 </category>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Markdown </tag>
            
            <tag> 博客写作 </tag>
            
            <tag> 技术分享 </tag>
            
            <tag> 内容创作 </tag>
            
            <tag> SEO优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git版本控制完全指南 - 从入门到精通</title>
      <link href="/2024/08/06/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2024/08/06/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="? 前言"></a>? 前言</h2><p>Git是现代软件开发中不可或缺的版本控制工具。无论你是初学者还是有经验的开发者，掌握Git都是必备技能。本文将带你从零开始，系统学习Git的各种操作和最佳实践。</p><span id="more"></span><h2 id="学习目标"><a href="#学习目标" class="headerlink" title="? 学习目标"></a>? 学习目标</h2><p>通过本文学习，你将掌握：</p><ul><li>Git的基本概念和工作原理</li><li>常用Git命令的使用方法</li><li>分支管理和合并策略</li><li>远程仓库的操作</li><li>解决冲突的技巧</li><li>Git工作流程和最佳实践</li></ul><h2 id="Git基础概念"><a href="#Git基础概念" class="headerlink" title="? Git基础概念"></a>? Git基础概念</h2><h3 id="什么是Git？"><a href="#什么是Git？" class="headerlink" title="什么是Git？"></a>什么是Git？</h3><p>Git是一个分布式版本控制系统，由Linux之父Linus Torvalds创建。它具有以下特点：</p><ul><li><strong>分布式</strong>：每个开发者都有完整的代码历史</li><li><strong>高效</strong>：快速的分支创建和合并</li><li><strong>安全</strong>：使用SHA-1哈希确保数据完整性</li><li><strong>灵活</strong>：支持多种工作流程</li></ul><h3 id="Git的三个区域"><a href="#Git的三个区域" class="headerlink" title="Git的三个区域"></a>Git的三个区域</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">工作区 (Working Directory)</span><br><span class="line">    ↓ git add</span><br><span class="line">暂存区 (Staging Area)</span><br><span class="line">    ↓ git commit</span><br><span class="line">本地仓库 (Local Repository)</span><br><span class="line">    ↓ git push</span><br><span class="line">远程仓库 (Remote Repository)</span><br></pre></td></tr></table></figure><h2 id="Git基础操作"><a href="#Git基础操作" class="headerlink" title="?? Git基础操作"></a>?? Git基础操作</h2><h3 id="1-初始化和配置"><a href="#1-初始化和配置" class="headerlink" title="1. 初始化和配置"></a>1. 初始化和配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化仓库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置用户信息</span></span><br><span class="line">git config --global user.name <span class="string">&quot;你的姓名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你的邮箱&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看配置</span></span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure><h3 id="2-基本文件操作"><a href="#2-基本文件操作" class="headerlink" title="2. 基本文件操作"></a>2. 基本文件操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加文件到暂存区</span></span><br><span class="line">git add filename.txt        <span class="comment"># 添加单个文件</span></span><br><span class="line">git add .                   <span class="comment"># 添加所有文件</span></span><br><span class="line">git add *.js               <span class="comment"># 添加所有js文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交更改</span></span><br><span class="line">git commit -m <span class="string">&quot;提交信息&quot;</span></span><br><span class="line">git commit -am <span class="string">&quot;添加并提交&quot;</span>  <span class="comment"># 跳过暂存区直接提交</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看提交历史</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line">git <span class="built_in">log</span> --oneline          <span class="comment"># 简洁格式</span></span><br><span class="line">git <span class="built_in">log</span> --graph           <span class="comment"># 图形化显示</span></span><br></pre></td></tr></table></figure><h3 id="3-文件状态管理"><a href="#3-文件状态管理" class="headerlink" title="3. 文件状态管理"></a>3. 文件状态管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 撤销工作区修改</span></span><br><span class="line">git checkout -- filename.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销暂存区文件</span></span><br><span class="line">git reset HEAD filename.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销提交</span></span><br><span class="line">git reset --soft HEAD~1    <span class="comment"># 保留修改</span></span><br><span class="line">git reset --hard HEAD~1    <span class="comment"># 丢弃修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件差异</span></span><br><span class="line">git diff                   <span class="comment"># 工作区与暂存区</span></span><br><span class="line">git diff --cached         <span class="comment"># 暂存区与仓库</span></span><br><span class="line">git diff HEAD             <span class="comment"># 工作区与仓库</span></span><br></pre></td></tr></table></figure><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="? 分支管理"></a>? 分支管理</h2><h3 id="分支基础操作"><a href="#分支基础操作" class="headerlink" title="分支基础操作"></a>分支基础操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看分支</span></span><br><span class="line">git branch                 <span class="comment"># 本地分支</span></span><br><span class="line">git branch -r             <span class="comment"># 远程分支</span></span><br><span class="line">git branch -a             <span class="comment"># 所有分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建分支</span></span><br><span class="line">git branch feature-login   <span class="comment"># 创建分支</span></span><br><span class="line">git checkout -b feature-login  <span class="comment"># 创建并切换</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换分支</span></span><br><span class="line">git checkout main</span><br><span class="line">git switch main           <span class="comment"># Git 2.23+新命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并分支</span></span><br><span class="line">git checkout main</span><br><span class="line">git merge feature-login</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git branch -d feature-login    <span class="comment"># 删除已合并分支</span></span><br><span class="line">git branch -D feature-login    <span class="comment"># 强制删除</span></span><br></pre></td></tr></table></figure><h3 id="分支合并策略"><a href="#分支合并策略" class="headerlink" title="分支合并策略"></a>分支合并策略</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Fast-forward合并（默认）</span></span><br><span class="line">git merge feature-branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建合并提交</span></span><br><span class="line">git merge --no-ff feature-branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 变基合并</span></span><br><span class="line">git rebase main</span><br></pre></td></tr></table></figure><h2 id="远程仓库操作"><a href="#远程仓库操作" class="headerlink" title="? 远程仓库操作"></a>? 远程仓库操作</h2><h3 id="远程仓库管理"><a href="#远程仓库管理" class="headerlink" title="远程仓库管理"></a>远程仓库管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加远程仓库</span></span><br><span class="line">git remote add origin https://github.com/username/repo.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看远程仓库</span></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到远程</span></span><br><span class="line">git push origin main</span><br><span class="line">git push -u origin main    <span class="comment"># 设置上游分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从远程拉取</span></span><br><span class="line">git pull origin main       <span class="comment"># 拉取并合并</span></span><br><span class="line">git fetch origin          <span class="comment"># 只拉取不合并</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/username/repo.git</span><br></pre></td></tr></table></figure><h3 id="远程分支操作"><a href="#远程分支操作" class="headerlink" title="远程分支操作"></a>远程分支操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推送新分支</span></span><br><span class="line">git push origin feature-branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">git push origin --delete feature-branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跟踪远程分支</span></span><br><span class="line">git checkout -b local-branch origin/remote-branch</span><br></pre></td></tr></table></figure><h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="? 高级技巧"></a>? 高级技巧</h2><h3 id="1-储藏-Stash"><a href="#1-储藏-Stash" class="headerlink" title="1. 储藏(Stash)"></a>1. 储藏(Stash)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 储藏当前修改</span></span><br><span class="line">git stash</span><br><span class="line">git stash save <span class="string">&quot;储藏信息&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看储藏列表</span></span><br><span class="line">git stash list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用储藏</span></span><br><span class="line">git stash apply           <span class="comment"># 应用最新储藏</span></span><br><span class="line">git stash apply stash@&#123;1&#125; <span class="comment"># 应用指定储藏</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除储藏</span></span><br><span class="line">git stash drop</span><br><span class="line">git stash clear          <span class="comment"># 清空所有储藏</span></span><br></pre></td></tr></table></figure><h3 id="2-标签管理"><a href="#2-标签管理" class="headerlink" title="2. 标签管理"></a>2. 标签管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建标签</span></span><br><span class="line">git tag v1.0.0</span><br><span class="line">git tag -a v1.0.0 -m <span class="string">&quot;版本1.0.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看标签</span></span><br><span class="line">git tag</span><br><span class="line">git show v1.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送标签</span></span><br><span class="line">git push origin v1.0.0</span><br><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><h3 id="3-子模块"><a href="#3-子模块" class="headerlink" title="3. 子模块"></a>3. 子模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加子模块</span></span><br><span class="line">git submodule add https://github.com/user/repo.git path/to/submodule</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化子模块</span></span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新子模块</span></span><br><span class="line">git submodule update --remote</span><br></pre></td></tr></table></figure><h2 id="冲突解决"><a href="#冲突解决" class="headerlink" title="? 冲突解决"></a>? 冲突解决</h2><h3 id="合并冲突处理"><a href="#合并冲突处理" class="headerlink" title="合并冲突处理"></a>合并冲突处理</h3><p>当出现冲突时，Git会在文件中标记冲突区域：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">当前分支的内容</span><br><span class="line">=======</span><br><span class="line">要合并分支的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature-branch</span><br></pre></td></tr></table></figure><p>解决步骤：</p><ol><li>手动编辑冲突文件</li><li>删除冲突标记</li><li>添加到暂存区：<code>git add filename</code></li><li>提交合并：<code>git commit</code></li></ol><h3 id="常用冲突解决命令"><a href="#常用冲突解决命令" class="headerlink" title="常用冲突解决命令"></a>常用冲突解决命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看冲突文件</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用工具解决冲突</span></span><br><span class="line">git mergetool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中止合并</span></span><br><span class="line">git merge --abort</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中止变基</span></span><br><span class="line">git rebase --abort</span><br></pre></td></tr></table></figure><h2 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="? Git工作流程"></a>? Git工作流程</h2><h3 id="1-Git-Flow"><a href="#1-Git-Flow" class="headerlink" title="1. Git Flow"></a>1. Git Flow</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 功能开发流程</span></span><br><span class="line">git checkout -b feature/new-feature develop</span><br><span class="line"><span class="comment"># 开发功能...</span></span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff feature/new-feature</span><br><span class="line">git branch -d feature/new-feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发布流程</span></span><br><span class="line">git checkout -b release/1.0.0 develop</span><br><span class="line"><span class="comment"># 修复bug...</span></span><br><span class="line">git checkout main</span><br><span class="line">git merge --no-ff release/1.0.0</span><br><span class="line">git tag v1.0.0</span><br><span class="line">git checkout develop</span><br><span class="line">git merge --no-ff release/1.0.0</span><br></pre></td></tr></table></figure><h3 id="2-GitHub-Flow"><a href="#2-GitHub-Flow" class="headerlink" title="2. GitHub Flow"></a>2. GitHub Flow</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简化流程</span></span><br><span class="line">git checkout -b feature-branch</span><br><span class="line"><span class="comment"># 开发功能...</span></span><br><span class="line">git push origin feature-branch</span><br><span class="line"><span class="comment"># 创建Pull Request</span></span><br><span class="line"><span class="comment"># 代码审查后合并到main</span></span><br></pre></td></tr></table></figure><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="? 最佳实践"></a>? 最佳实践</h2><h3 id="提交信息规范"><a href="#提交信息规范" class="headerlink" title="提交信息规范"></a>提交信息规范</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 好的提交信息格式</span></span><br><span class="line">feat: 添加用户登录功能</span><br><span class="line">fix: 修复密码验证bug</span><br><span class="line">docs: 更新API文档</span><br><span class="line">style: 格式化代码</span><br><span class="line">refactor: 重构用户模块</span><br><span class="line"><span class="built_in">test</span>: 添加单元测试</span><br><span class="line">chore: 更新依赖包</span><br></pre></td></tr></table></figure><h3 id="分支命名规范"><a href="#分支命名规范" class="headerlink" title="分支命名规范"></a>分支命名规范</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">feature/user-authentication    <span class="comment"># 功能分支</span></span><br><span class="line">bugfix/login-error            <span class="comment"># 修复分支</span></span><br><span class="line">hotfix/security-patch         <span class="comment"># 热修复分支</span></span><br><span class="line">release/v1.2.0               <span class="comment"># 发布分支</span></span><br></pre></td></tr></table></figure><h3 id="gitignore配置"><a href="#gitignore配置" class="headerlink" title=".gitignore配置"></a>.gitignore配置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 依赖目录</span><br><span class="line">node_modules/</span><br><span class="line">vendor/</span><br><span class="line"></span><br><span class="line"># 构建输出</span><br><span class="line">dist/</span><br><span class="line">build/</span><br><span class="line">*.min.js</span><br><span class="line"></span><br><span class="line"># 日志文件</span><br><span class="line">*.log</span><br><span class="line">logs/</span><br><span class="line"></span><br><span class="line"># 环境配置</span><br><span class="line">.env</span><br><span class="line">.env.local</span><br><span class="line"></span><br><span class="line"># IDE文件</span><br><span class="line">.vscode/</span><br><span class="line">.idea/</span><br><span class="line">*.swp</span><br><span class="line"></span><br><span class="line"># 系统文件</span><br><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br></pre></td></tr></table></figure><h2 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="? 常见问题解决"></a>? 常见问题解决</h2><h3 id="1-撤销操作"><a href="#1-撤销操作" class="headerlink" title="1. 撤销操作"></a>1. 撤销操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 撤销最后一次提交但保留修改</span></span><br><span class="line">git reset --soft HEAD~1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改最后一次提交信息</span></span><br><span class="line">git commit --amend -m <span class="string">&quot;新的提交信息&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销文件修改</span></span><br><span class="line">git checkout -- filename</span><br></pre></td></tr></table></figure><h3 id="2-清理仓库"><a href="#2-清理仓库" class="headerlink" title="2. 清理仓库"></a>2. 清理仓库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清理未跟踪文件</span></span><br><span class="line">git clean -f        <span class="comment"># 删除文件</span></span><br><span class="line">git clean -fd       <span class="comment"># 删除文件和目录</span></span><br><span class="line">git clean -n        <span class="comment"># 预览要删除的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 垃圾回收</span></span><br><span class="line">git gc</span><br></pre></td></tr></table></figure><h3 id="3-查看历史"><a href="#3-查看历史" class="headerlink" title="3. 查看历史"></a>3. 查看历史</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看文件修改历史</span></span><br><span class="line">git <span class="built_in">log</span> -p filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某行代码的修改历史</span></span><br><span class="line">git blame filename</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找提交</span></span><br><span class="line">git <span class="built_in">log</span> --grep=<span class="string">&quot;关键词&quot;</span></span><br><span class="line">git <span class="built_in">log</span> --author=<span class="string">&quot;作者名&quot;</span></span><br></pre></td></tr></table></figure><h2 id="Git安全"><a href="#Git安全" class="headerlink" title="?? Git安全"></a>?? Git安全</h2><h3 id="1-签名提交"><a href="#1-签名提交" class="headerlink" title="1. 签名提交"></a>1. 签名提交</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置GPG签名</span></span><br><span class="line">git config --global user.signingkey YOUR_GPG_KEY</span><br><span class="line">git config --global commit.gpgsign <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 签名提交</span></span><br><span class="line">git commit -S -m <span class="string">&quot;签名提交&quot;</span></span><br></pre></td></tr></table></figure><h3 id="2-敏感信息处理"><a href="#2-敏感信息处理" class="headerlink" title="2. 敏感信息处理"></a>2. 敏感信息处理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从历史中删除敏感文件</span></span><br><span class="line">git filter-branch --force --index-filter \</span><br><span class="line"><span class="string">&#x27;git rm --cached --ignore-unmatch secrets.txt&#x27;</span> \</span><br><span class="line">--prune-empty --tag-name-filter <span class="built_in">cat</span> -- --all</span><br></pre></td></tr></table></figure><h2 id="学习资源"><a href="#学习资源" class="headerlink" title="? 学习资源"></a>? 学习资源</h2><h3 id="推荐资源"><a href="#推荐资源" class="headerlink" title="推荐资源"></a>推荐资源</h3><ul><li><a href="https://git-scm.com/book">Pro Git 书籍</a></li><li><a href="https://git-scm.com/docs">Git官方文档</a></li><li><a href="https://learngitbranching.js.org/">Learn Git Branching</a></li><li><a href="https://guides.github.com/">GitHub Git手册</a></li></ul><h3 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h3><ul><li><strong>GUI工具</strong>: GitKraken, SourceTree, GitHub Desktop</li><li><strong>命令行增强</strong>: Oh My Zsh, Git别名</li><li><strong>在线练习</strong>: Katacoda Git课程</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="? 总结"></a>? 总结</h2><p>Git是现代开发不可或缺的工具，掌握它需要理论学习和实践相结合。从基础的add、commit、push开始，逐步学习分支管理、冲突解决等高级功能。</p><p>记住这些要点：</p><ul><li>频繁提交，保持提交粒度适中</li><li>写清晰的提交信息</li><li>合理使用分支进行功能开发</li><li>定期同步远程仓库</li><li>遇到问题不要慌，Git几乎所有操作都可以撤销</li></ul><p>继续练习，你会发现Git不仅是版本控制工具，更是提高开发效率的利器！</p><hr><blockquote><p>? <strong>小贴士</strong>: 建议在学习过程中创建一个练习仓库，亲手操作每个命令，这样能更好地理解Git的工作原理。</p></blockquote><p><strong>相关文章推荐</strong>:</p><ul><li><a href="/2024/08/06/github-guide/">GitHub使用指南</a></li><li><a href="/2024/08/06/code-collaboration/">代码协作最佳实践</a></li><li><a href="/2024/08/06/dev-tools-setup/">开发工具配置指南</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
          <category> 版本控制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 版本控制 </tag>
            
            <tag> 开发工具 </tag>
            
            <tag> 协作开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux驱动模型详解</title>
      <link href="/2024/06/06/test/Linux%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/06/06/test/Linux%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><strong>让所有很久很久以前都走到幸福结局的时刻</strong></p><h2 id="1-Linux-驱动模型"><a href="#1-Linux-驱动模型" class="headerlink" title="1.Linux 驱动模型"></a>1.Linux 驱动模型</h2><p>本节内容，重在理解。面试时，面试官很大可能会让你挑一个你熟悉的驱动讲讲，如何编写的？能回答出大概的驱动框架就可以。</p><h3 id="1-1-字符设备驱动模型"><a href="#1-1-字符设备驱动模型" class="headerlink" title="1.1 字符设备驱动模型"></a>1.1 字符设备驱动模型</h3><p>驱动初始化中涉及到一个设备描述结构的概念。在任何一种驱动模型中，设备都会用内核中的一种结构来描述，这种结构成为<strong>设备描述结构</strong>。字符设备在内核中使用<code>struct cdev</code>这种结构来描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span> <span class="comment">//设备操作集</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">dev_t</span> dev; <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count; <span class="comment">//设备数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>count表明该类型设备的数目，如有两个串口，则count的值为2。</p></li><li><p>dev是设备号，包含有主设备号和次设备号的信息。主设备号用于区分设备的类型，次设备号用于标记相同类型的设备的不同个体。如串口1和串口2使用同一驱动程序，则其主设备号相同，但次设备号不同。Linux内核中使用<code>dev_t</code>类型来定义设备号，<code>dev_t</code>这种类型其实质为32位的<code>unsigned int</code>，其中高12位为主设备号，低20位为次设备号。</p><ol><li>知道主设备号与次设备号，可通过<code>dev_t dev = MKDEV(主设备号，次设备号)</code> 获得设备号；</li><li>从设备号分解出主设备号：主设备号 &#x3D; <code>MAJOR(dev_t dev)</code></li><li>从设备号分解出次设备号：次设备号 &#x3D; <code>MINOR(dev_t dev)</code></li></ol></li><li><p>主设备号是一个重要的资源，可以通过静态申请和动态分配为设备分配一个主设备号：</p><ol><li>静态申请：开发者自己选择一个数字作为主设备号，然后通过函数<code>register_chrdev_region</code>向内核申请使用。这种方法的缺点是如果申请使用的设备号已经被内核中的其它驱动使用了，则申请失败。</li><li>动态分配：使用<code>alloc_chrdev_region</code>由内核分配一个可用的主设备号。因为内核知道哪些号已经被使用了，所以不会导致分配到已经被使用的号。既然设备号是一种资源，则设备驱动在退出后都应该释放该资源。使用<code>unregister_chrdev_region</code>函数释放这些设备号。</li></ol></li><li><p>ops是操作函数集。<code>file_operations</code>是一个很重要的结构，该结构的成员基本都是函数指针，并且是一些文件操作的函数的指针。</p></li><li><pre><code class="c">struct file_operations &#123;  struct module *owner;  loff_t(*llseek) (struct file *, loff_t, int);  ssize_t(*read) (struct file *, char __user *, size_t, loff_t *);  ssize_t(*aio_read) (struct kiocb *, char __user *, size_t, loff_t);  ssize_t(*write) (struct file *, const char __user *, size_t, loff_t *);  ssize_t(*aio_write) (struct kiocb *, const char __user *, size_t, loff_t);  int (*readdir) (struct file *, void *, filldir_t);  unsigned int (*poll) (struct file *, struct poll_table_struct *);  int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);  int (*mmap) (struct file *, struct vm_area_struct *);  int (*open) (struct inode *, struct file *);  int (*flush) (struct file *);  int (*release) (struct inode *, struct file *);  int (*fsync) (struct file *, struct dentry *, int datasync);  int (*aio_fsync) (struct kiocb *, int datasync);  int (*fasync) (int, struct file *, int);  int (*lock) (struct file *, int, struct file_lock *);  ssize_t(*readv) (struct file *, const struct iovec *, unsigned long, loff_t *);  ssize_t(*writev) (struct file *, const struct iovec *, unsigned long, loff_t *);  ssize_t(*sendfile) (struct file *, loff_t *, size_t, read_actor_t, void __user *);  ssize_t(*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);  unsigned long (*get_unmapped_area) (struct file *, unsigned long,unsigned long, unsigned long,unsigned long);&#125;;    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`struct file_operations`是一个函数指针的集合，定义能在设备上进行的操作。结构中的函数指针指向驱动中的函数，这些函数实现一个针对设备的操作, 对于不支持的操作则设置函数指针为 NULL。例如：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">struct file_operations dev_fops = &#123;</span><br><span class="line">    .llseek = NULL,</span><br><span class="line">    .read = dev_read,</span><br><span class="line">    .write = dev_write,</span><br><span class="line">    .ioctl = dev_ioctl,</span><br><span class="line">    .open = dev_open,</span><br><span class="line">    .release = dev_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>- 该结构体表示应用程序能够对设备文件使用函数`read()`, `write()`等，但不能使用函数`llseek()`。当执行到`read()`函数时，内核根据该结构体转移到驱动程序中的`dev_read`函数去执行。- 驱动初始化有四大步骤：  1.**分配**  - cdev变量的定义可以采用静态和动态两种办法：  - 静态分配：`struct cdev mdev`；  - 动态分配：`struct cdev *pdev = cdev_alloc()`；  2.**初始化**  - `struct cdev`的初始化使用`cdev_init`函数来完成。  - 原型：`cdev_init(struct cdev *cdev, const struct file_operations *fops)`  - 参数：    - `cdev`：待初始化的cdev结构    - `fops`：设备对应的操作函数集  3.注册  - 字符设备的注册使用`cdev_add`函数来完成。  - 原型：`cdev_add(struct cdev *p, dev_t dev, unsigned count)`  - 参数：    - `p`：待添加到内核的字符设备结构    - `dev`：设备号    - `count`：该类设备的设备个数  4.**硬件初始化**  - 根据相应硬件的数据手册完成初始化。</code></pre></li></ul><h3 id="1-2-实现设备操作"><a href="#1-2-实现设备操作" class="headerlink" title="1.2 实现设备操作"></a>1.2 实现设备操作</h3><p>由struct file_operations可以看出，要实现的操作并不少，这里只介绍一些重要的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*open)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *) <span class="comment">//打开设备，响应open系统调用</span></span><br><span class="line"><span class="type">int</span> (*release)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);<span class="comment">//关闭设备，响应close系统调用</span></span><br><span class="line"><span class="type">loff_t</span> (*llseek)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>) <span class="comment">//重定位读写指针，响应lseek系统调用</span></span><br><span class="line"><span class="type">ssize_t</span> (*read)(<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *) <span class="comment">//从设备读取数据，响应read系统调用</span></span><br><span class="line"><span class="type">ssize_t</span> (*write)(<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *) <span class="comment">//向设备写入数据，响应write系统调用</span></span><br></pre></td></tr></table></figure><ul><li><p>以上几个函数涉及到了<code>struct inode</code>和<code>struct file</code>这两种结构体。</p></li><li><p>在Linux系统中，每一个<strong>打开的文件</strong>，在内核中都会关联一个<code>struct file</code>结构体，它由内核在打开文件时创建，在文件关闭后释放。该结构体的重要成员有：</p></li><li><pre><code class="c">loff_t f_pos /*文件读写指针*/struct file_operations *f_op /*该文件所对应的操作*/<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">每一个存在于文件系统里面的文件都会关联一个`inode` 结构，该结构主要用来**记录文件物理上的信息**。因此，它和代表打开文件的file结构是不同的。一个文件**没有被打开时不会关联file结构，但是却会关联一个inode结构**。该结构体重要的成员有：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">dev_t i_rdev /*设备号*/</span><br></pre></td></tr></table></figure>- 一个设备支持的函数操作又称为设备方法。- `open`设备方法是驱动程序用来为以后的操作完成**初始化**准备工作的。在大部分驱动程序中，open完成如下工作：**标明次设备号、启动设备**。- `release`设备方法的作用与open相反，这个设备方法有时也称为close，它完成的工作是**关闭设备**。- `read`设备方法通常完成两件事情：从设备中**读取数据**(属于硬件访问类操作)，将读取到的数据**返回给应用程序**。- ```c  ssize_t (*read)(struct file *filp,char __user *buff,size_t count,loff_t *offp)  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 参数说明：</span><br><span class="line"></span><br><span class="line">  1. `filp`：与字符设备文件关联的file结构指针，由内核创建。</span><br><span class="line">  2. `buff`：从设备读取到的数据，需要**保存到的位置**。由read系统调用提供该参数。</span><br><span class="line">  3. `count`：请求传输的**数据量**，由read系统调用提供该参数。</span><br><span class="line">  4. `offp`：文件的**读写位置**，由内核从file结构中取出后(相当于读取指针)，传递进来。</span><br><span class="line"></span><br><span class="line">- 要注意的是，`buff`参数是来源于用户空间的指针，这类指针都**不能被内核代码直接引用**，必须使用专门的函数：</span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">  int copy_to_user(void __user *to, const void *from, int n)// 内核态-&gt;用户态</span><br><span class="line">  int copy_from_user(void *to, const void __user *from, int n)// 用户态-&gt;内核态</span><br></pre></td></tr></table></figure>    - 其中`copy_to_user()`用于将内核数据传送给用户空间；`copy_from_user()`用于将用户空间的数据传送给内核空间。    - `write`设备方法通常完成两件事情：**从应用程序提供的地址中取出数据，将数据写入设备**(属于硬件访问类操作)    - 函数原型：`ssize_t (*write)(struct file *, const char __user *, size_t, loff_t *)`    - 驱动注销：当我们从内核中卸载驱动程序的时候，需要使用`cdev_del`函数来完成字符设备的注销。    - 一个驱动程序范例：    - ```c      #include &lt;linux/module.h&gt;      #include &lt;linux/types.h&gt;      #include &lt;linux/fs.h&gt;      #include &lt;linux/errno.h&gt;      #include &lt;linux/init.h&gt;      #include &lt;linux/cdev.h&gt;      #include &lt;asm/uaccess.h&gt;      #include &lt;linux/slab.h&gt;             int dev1_registers[5];      int dev2_registers[5];             struct cdev cdev; // 字符驱动设备      dev_t devno;// 设备号             /*文件打开函数*/      int mem_open(struct inode *inode, struct file *filp)      &#123;          /*获取次设备号*/          int num = MINOR(inode-&gt;i_rdev);                 if (num==0)              filp-&gt;private_data = dev1_registers;          else if(num == 1)              filp-&gt;private_data = dev2_registers;          else              return -ENODEV;  //无效的次设备号                 return 0;       &#125;             /*文件释放函数*/      int mem_release(struct inode *inode, struct file *filp)      &#123;        return 0;      &#125;             /*读函数 返回读取了多少个数据*/      static ssize_t mem_read(struct file *filp, char __user *buf, size_t size, loff_t *ppos)      &#123;        unsigned long p =  *ppos;        unsigned int count = size;        int ret = 0;        int *register_addr = filp-&gt;private_data; /*获取设备的寄存器基地址*/               /*判断读位置是否有效*/        if (p &gt;= 5*sizeof(int))          return 0;        if (count &gt; 5*sizeof(int) - p)          count = 5*sizeof(int) - p;               /*读数据到用户空间 从基地址偏移p个(p为开始读的位置 即ppos描述的相对位置)*/        if (copy_to_user(buf, register_addr+p, count))        &#123;          ret = -EFAULT;        &#125;        else        &#123;          *ppos += count;          ret = count;        &#125;               return ret;      &#125;             /*写函数*/      static ssize_t mem_write(struct file *filp, const char __user *buf, size_t size, loff_t *ppos)      &#123;        unsigned long p =  *ppos;        unsigned int count = size;        int ret = 0;        int *register_addr = filp-&gt;private_data; /*获取设备的寄存器地址*/               /*分析和获取有效的写长度*/        if (p &gt;= 5*sizeof(int))          return 0;        if (count &gt; 5*sizeof(int) - p)          count = 5*sizeof(int) - p;               /*从用户空间写入数据*/        if (copy_from_user(register_addr + p, buf, count))          ret = -EFAULT;        else        &#123;          *ppos += count;          ret = count;        &#125;               return ret;      &#125;             /* seek文件定位函数 */      static loff_t mem_llseek(struct file *filp, loff_t offset, int whence)      &#123;           loff_t newpos;                 switch(whence) &#123;            case SEEK_SET:               newpos = offset;              break;                   case SEEK_CUR:               newpos = filp-&gt;f_pos + offset;              break;                   case SEEK_END:               newpos = 5*sizeof(int)-1 + offset;              break;                   default:               return -EINVAL;          &#125;          if ((newpos&lt;0) || (newpos&gt;5*sizeof(int)))              return -EINVAL;                 filp-&gt;f_pos = newpos;          return newpos;             &#125;             /*文件操作结构体*/      static const struct file_operations mem_fops =      &#123;        .llseek = mem_llseek,        .read = mem_read,        .write = mem_write,        .open = mem_open,        .release = mem_release,      &#125;;             /*设备驱动模块加载函数*/      static int memdev_init(void)      &#123;        /*初始化cdev结构*/        cdev_init(&amp;cdev, &amp;mem_fops);               /* 注册字符设备 */        alloc_chrdev_region(&amp;devno, 0, 2, &quot;memdev&quot;);        cdev_add(&amp;cdev, devno, 2);      &#125;             /*模块卸载函数*/      static void memdev_exit(void)      &#123;        cdev_del(&amp;cdev);   /*注销设备*/        unregister_chrdev_region(devno, 2); /*释放设备号*/      &#125;             MODULE_LICENSE(&quot;GPL&quot;);             module_init(memdev_init);      module_exit(memdev_exit);      <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">### 1.3 总线设备驱动模型</span><br><span class="line"></span><br><span class="line">- 自内核2.6版本开始，需要关注的是**总线、设备和驱动**这3个实体，总线将设备和驱动绑定。在Linux内核系统中注册一个设备的时候，会寻找与之对应驱动进行匹配；相反地，系统中注册一个驱动的时候，会去寻找一个对应的设备进行匹配。**匹配的的工作由总线来完成**。</span><br><span class="line"></span><br><span class="line">- **在Linux设备中有的是没有对应的物理总线的，但为了适配Linux的总线模型，内核针对这种没有物理总线的设备开发了一种虚拟总线——platform总线**。将设备和驱动独立开，驱动尽可能写的通用，当来了一个类似的设备后也可以使用这个驱动，让驱动程序可以重用。这体现了Linux驱动的软件架构设计的思想。</span><br><span class="line"></span><br><span class="line">- 按照这个思路，Linux中的设备和驱动都需要挂接在一种总线上，比如i2c总线上的eeprom，eeprom作为设备，**eeprom的驱动都挂接在i2c驱动上**。但是在嵌入式系统中，**soc系统一般都会集成独立的i2c控制器，控制器也是需要驱动的，但是再按照设备-总线-驱动模型进行设计，就会发现无法找到一个合适总线去挂接控制器设备和控制器驱动了（i2c控制器是挂接在CPU内部的总线上，而不是i2c总线）**，所以Linux发明了一种虚拟总线，称为platform总线，相应的设备称为**platform_device（控制器设备），对应的驱动为platform_driver（控制器驱动），用platform总线来承载这些相对特殊的系统**。</span><br><span class="line"></span><br><span class="line">- 注意：**所谓的platform_device并不是与字符设备、块设备和网络设备并列的概念，而是Linux系统提供的一种附加手段**。例如，在 S3C6410处理器中，把内部集成的I2C、RTC、SPI、LCD、看门狗等控制器都归纳为platform_device，而它们本身就是字符设备。我们要记住，platform 驱动只是在**字符设备驱动外套一层platform_driver 的外壳**。引入platform模型符合Linux 设备模型 —— 总线、设备、驱动，设备模型中配套的sysfs节点都可以用，方便我们的开发；**当然你也可以选择不用，不过就失去了一些platform带来的便利**。</span><br><span class="line"></span><br><span class="line">- 设备驱动中引入platform 概念，隔离BSP和驱动。在BSP中定义platform设备和设备使用的资源、设备的具体匹配信息，而在驱动中，只需要通过API去获取资源和数据，做到了板相关代码和驱动代码的分离，使得驱动具有更好的可扩展性和跨平台性。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  - **下面分析下总线设备驱动模型的匹配过程**</span><br><span class="line">    1. 一边的`device`结构体和另一边的`较稳定的 driver 代码`的联系：`device_add()`除将`device`结构放到 bus 的`dev 链表`之外，还会从另一边的`drv`链表中取表元即某个`driver`结构，用总线里的一个`（.match）`函数来作比较，看另一边的`driver`是否支持一边的`device`。若是能够支持，则接着调用软件驱动部分的`.probe`函数。`driver_register()`会将`bus_drv_dev`模型中的较稳定代码`driver`结构体放到虚拟总线的某个链表（drv 链表）中。从另一边的`dev`链表中取出每一个`device`结构用 bus 中的`.match`函数来作比较。</span><br><span class="line">    2. 若支持则调用`.probe`函数。左右两个注册就建立起来的一种机制。在`.probe`函数中做的事件由自已决定，打印一句话，或注册一个字符设备，再或注册一个`input_dev`结构体等等都是由自已决定。强制的把一个驱动程序分为左右两边这种机制而已，可以把这套东西放在任何地方，这里的`driver`只是个结构体不要被这个名字迷惑，`device`也只是个结构体，里面放什么内容都是由自已决定的。</span><br><span class="line"></span><br><span class="line">### 1.4 输入子系统模型</span><br><span class="line"></span><br><span class="line">每个硬件都有一个`input_dev`结构体，每个软件都有一个`input_handler`结构体。`input_dev`和`input_handler`分别通过`input_register_device()`，`input_register_handler()`向核心层注册硬件和软件。</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul><p>int input_register_device(struct input_dev *dev)   &#x2F;&#x2F;*dev:要注册的驱动设备<br>{<br> … …<br>       list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);   &#x2F;&#x2F;(1)放入链表中<br> … …<br>       list_for_each_entry(handler, &amp;input_handler_list, node)  &#x2F;&#x2F;(2)<br>       input_attach_handler(dev, handler);<br> … …<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 从`input_dev`方向分析：`input`设备在增加到`input_dev_list`链表上之后，会查找 `input_handler_list`事件处理链表上的`handler`进行匹配，这里的匹配方式与总线设备驱动模型的`device`和`driver`匹配过程很相似，所有的`input_device`都挂在`input_dev_list`上，所有类型的事件都挂在`input_handler_list`上，进行“匹配相亲”。如果匹配上了，就调用`input_handler`的`connect`函数进行连接。设备就是在此时注册的。</span><br><span class="line">- 从`input_handler`方向分析：将`handler`挂到链表`input_handler_list`下，然后遍历`input_dev_list`链表,查找并匹配输入设备对应的事件处理层，如果匹配上了，就调用`connect`函数进行连接，并创建`input_handle`结构。</span><br><span class="line">- 所以，不管新添加`input_dev`还是`input_handler`，都会进入`input_attach_handler()`判断两者id是否有支持, 若两者支持便进行连接。</span><br><span class="line"></span><br><span class="line">### 1.5 platform总线的匹配规则是什么？在具体应用上要不要先注册驱动再注册设备？有先后顺序没？</span><br><span class="line"></span><br><span class="line">- 匹配规则就是当有一个新的设备挂起时，总线被唤醒，`match`函数被调用，用`device`名字去跟本总线下的所有驱动名字去比较。相反就是用驱动的名字去`device`链表中和所有`device`的名字比较。如果匹配上，才会调用驱动中的`probe`函数，否则不调用。至于先后顺序，鉴于个人理解，**不会有影响**，不管谁先谁后，bus都会完成匹配工作。</span><br><span class="line">- 设备驱动模型的出现主要有三个好处：</span><br><span class="line">  1. 设备与驱动分离，驱动**可移植性增强**；</span><br><span class="line">  2. 设备驱动抽象结构以总线结构表示看起来更加**清晰明了**，谁是属于哪一条bus的；</span><br><span class="line">  3. 设备与驱动分离，很好的奠定了**热插拔**机制。</span><br><span class="line"></span><br><span class="line">## 2.Linux内核</span><br><span class="line"></span><br><span class="line">### 2.1 内核镜像格式有几种？分别有什么区别？</span><br><span class="line"></span><br><span class="line">1. uboot经过编译直接生成的elf格式的可执行程序是u-boot，这个程序类似于windows下的exe格式，在操作系统下是**可以直接执行**的。但是这种格式**不能用来烧录下载**。我们用来烧录下载的是u-boot.bin，这个东西是由u-boot使用arm-linux-objcopy工具进行加工（主要目的是去掉一些无用的东西）得到的。这个u-boot.bin就叫镜像（image），镜像就是用来烧录到iNand中执行的。</span><br><span class="line">2. linux内核经过编译后也会生成一个elf格式的可执行程序，叫**vmlinux或vmlinuz**，这个就是**原始的未经任何处理加工的原版内核elf文件**；嵌入式系统部署时烧录的一般不是这个vmlinuz/vmlinux，而是要用objcopy工具去制作成烧录镜像格式（就是u-boot.bin这种，但是内核没有.bin后缀），经过制作加工成烧录镜像的文件就叫**Image**（制作把78M大的精简成了7.5M，因此这个制作烧录镜像主要目的就是缩减大小，节省磁盘）。</span><br><span class="line">3. 原则上Image就可以直接被烧录到Flash上进行启动执行（类似于u-boot.bin），但是实际上并不是这么简单。实际上linux的作者们觉得Image还是太大了所以对Image进行了压缩，并且在image压缩后的文件的**前端附加了一部分解压缩代码**。构成了一**个压缩格式的镜像就叫zImage**。（因为当年Image大小刚好比一张软盘（软盘有2种，1.2M的和1.44MB两种）大，为了节省1张软盘的钱于是乎设计了这种压缩Image成zImage的技术）。</span><br><span class="line">4. uboot为了启动linux内核，还发明了一种内核格式叫uImage。**uImage是由zImage加工得到的**，uboot中有一个工具，可以将zImage加工生成uImage。注意：uImage不关linux内核的事，linux内核只管生成zImage即可，然后uboot中的mkimage工具再去由zImage加工生成uImage来给uboot启动。这个加工过程其实就是**在zImage前面加上64字节的uImage的头信息即可**。</span><br><span class="line">5. 原则上uboot启动时应该给他uImage格式的内核镜像，但是实际上uboot中也可以支持zImage，是否支持就看x210_sd.h中是否定义了LINUX_ZIMAGE_MAGIC这个宏。所以大家可以看出：有些uboot是支持zImage启动的，有些则不支持。但是**所有的uboot肯定都支持uImage启动**。</span><br><span class="line">6. 如果直接在kernel底下去`make uImage`会提供`mkimage command not found`。解决方案是去`uboot/tools`下`cp mkimage /usr/local/bin/`，复制mkimage工具到系统目录下。再去`make uImage`即可。</span><br><span class="line"></span><br><span class="line">&gt; 通过上面的介绍我们了解了内核镜像的各种格式，如果通过uboot启动内核，Linux必须为**uImage**格式。</span><br><span class="line"></span><br><span class="line">### 2.2 内核中申请内存有哪几个函数？有什么区别？</span><br><span class="line"></span><br><span class="line">1. **kmalloc**</span><br><span class="line"></span><br><span class="line">   ```c</span><br><span class="line">   void *kmalloc(size_t size, gfp_t flags)</span><br></pre></td></tr></table></figure><p>   <code>kmalloc</code>是内核中最常用的一种内存分配方式，它通过调用<code>kmem_cache_alloc</code>函数来实现。<code>kmalloc</code>一次最多能申请的内存大小由<code>include/linux/Kmalloc_size.h</code>的内容来决定，在默认的2.6.18内核版本中，kmalloc一次最多能申请大小为131702B也就是<strong>128KB</strong>字节的连续物理内存。测试结果表明，如果试图用kmalloc函数分配大于128KB的内存，编译不能通过。</p><ol start="2"><li><p><strong>vmalloc</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">vmalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br></pre></td></tr></table></figure><p>前面几种内存分配方式都是物理连续的，能保证较低的平均访问时间。但是在某些场合中，对内存区的请求不是很频繁，较高的内存访问时间也可以接受，这是就可以分配一段<strong>线性连续，物理不连续</strong>的地址，带来的好处是一次可以<strong>分配较大块的内存</strong>。图3-1表示的是<code>vmalloc</code>分配的内存使用的地址范围。<code>vmalloc</code>对一次能分配的内存大小没有明确限制。出于性能考虑，应谨慎使用<code>vmalloc</code>函数。在测试过程中，<strong>最大能一次分配1GB的空间</strong>。</p></li><li><p><strong>dma_alloc_coherent</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">dma_alloc_coherent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> size,<span class="type">ma_addr_t</span> </span></span><br><span class="line"><span class="params">*dma_handle, <span class="type">gfp_t</span> gfp)</span></span><br></pre></td></tr></table></figure><p>DMA(直接内存访问 Direct Memory Access)是一种硬件机制，允许外围设备和主存之间直接传输IO数据，而不需要CPU的参与，使用DMA机制能<strong>大幅提高与设备通信的吞吐量</strong>。DMA操作中，涉及到CPU<strong>高速缓存和对应的内存数据一致性</strong>的问题，必须保证两者的数据一致，在x86_64体系结构中，硬件已经很好的解决了这个问题，<code>dma_alloc_coherentget_free_pages</code>函数实现差别不大，前者实际是调用<code>alloc_pages</code>函数来分配内存，因此一次分配内存的大小限制和后者一样。<code>__get_free_pages</code>分配的内存同样可以用于DMA操作。测试结果证明，<code>dma_alloc_coherent</code>函数一次能分配的最大内存也为<strong>4M</strong>。</p></li><li><p><strong>ioremap</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">ioremap</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> offset, <span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br></pre></td></tr></table></figure><p><code>ioremap</code>是一种更直接的内存“分配”方式，使用时直接<strong>指定物理起始地址和需要分配内存</strong>的大小，然后将该段<strong>物理地址映射到内核地址空间</strong>。<code>ioremap</code>用到的物理地址空间都是事先确定的，和上面的几种内存分配方式并不太一样，并不是分配一段新的物理内存。<code>ioremap</code>多用于<strong>设备驱动</strong>，可以让CPU直接访问外部设备的IO空间。<code>ioremap</code>能映射的内存由原有的物理内存空间决定，所以没有进行测试。</p></li></ol><h3 id="2-3-什么是内核空间，用户空间？"><a href="#2-3-什么是内核空间，用户空间？" class="headerlink" title="2.3 什么是内核空间，用户空间？"></a>2.3 什么是内核空间，用户空间？</h3><ul><li>对 32 位操作系统而言，它的寻址空间（虚拟地址空间，或叫线性地址空间）为 4G（2的32次方）。也就是说一个进程的最大地址空间为 4G。</li><li>操作系统的核心是内核(kernel)，它独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证内核的安全，现在的操作系统一般都强制<strong>用户进程不能直接操作内核</strong>。具体的实现方式基本都是由<strong>操作系统将虚拟地址空间划分为两部分</strong>，一部分为内核空间，另一部分为用户空间。针对 Linux 操作系统而言，<strong>最高的 1G 字节</strong>(从虚拟地址 <code>0xC0000000</code> 到 <code>0xFFFFFFFF</code>)由内核使用，称为<strong>内核空间</strong>。而<strong>较低的 3G 字节</strong>(从虚拟地址 <code>0x00000000</code> 到 <code>0xBFFFFFFF</code>)由各个进程使用，称为用户空间。</li><li>对上面这段内容我们也可以这样理解：<br>每个进程的 4G 地址空间中，最高 1G 都是一样的，即内核空间。只有剩余的 3G 才归进程自己使用。换句话说就是，<strong>最高 1G 的内核空间是被所有进程共享的</strong>！</li><li>下图描述了每个进程 4G 地址空间的分配情况：</li></ul><h3 id="2-4-为什么需要区分内核空间与用户空间？"><a href="#2-4-为什么需要区分内核空间与用户空间？" class="headerlink" title="2.4 为什么需要区分内核空间与用户空间？"></a>2.4 为什么需要区分内核空间与用户空间？</h3><ul><li>在 CPU 的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，比如<strong>清内存、设置时钟</strong>等。如果允许所有的程序都可以使用这些指令，那么系统<strong>崩溃的概率将大大增加</strong>。</li><li>所以，CPU 将指令分为<strong>特权指令</strong>和<strong>非特权指令</strong>，对于那些危险的指令，只允许操作系统及其相关模块使用，普通应用程序只能使用那些不会造成灾难的指令。比如 Intel 的 CPU 将特权等级分为 4 个级别：Ring0~Ring3。</li><li>其实 Linux 系统只使用了 Ring0 和 Ring3 两个运行级别(Windows 系统也是一样的)。当进程运行在 Ring3 级别时被称为运行在用户态，而运行在 Ring0 级别时被称为运行在内核态。</li></ul><h3 id="2-5-什么是内核态和用户态？"><a href="#2-5-什么是内核态和用户态？" class="headerlink" title="2.5 什么是内核态和用户态？"></a>2.5 什么是内核态和用户态？</h3><ul><li><p>当进程<strong>运行在内核空间时</strong>就处于内核态，而进程<strong>运行在用户空间</strong>时则处于用户态。</p></li><li><p>在内核态下，进程运行在内核地址空间中，此时 CPU 可以执行任何指令。运行的代码也不受任何的限制，可以自由地访问任何有效地址，也可以直接进行端口的访问。</p></li><li><p>在用户态下，进程运行在用户地址空间中，被执行的代码要受到 CPU 的诸多检查，它们只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址，且只能对任务状态段(TSS)中 I&#x2F;O 许可位图(I&#x2F;O Permission Bitmap)中规定的可访问端口进行直接访问。</p></li><li><p>对于以前的 DOS 操作系统来说，是没有内核空间、用户空间以及内核态、用户态这些概念的。可以认为所有的代码都是运行在内核态的，因而，用户编写的应用程序代码可以很容易的让操作系统崩溃掉。</p></li><li><p>对于 Linux 来说，通过区分内核空间和用户空间的设计，<strong>隔离了操作系统代码</strong>(操作系统的代码要比应用程序的代码健壮很多)<strong>与应用程序代码</strong>。即便是单个应用程序出现错误，也不会影响到操作系统的稳定性，这样其它的程序还可以正常的运行(Linux 可是个多任务系统啊！)。所以，<strong>区分内核空间和用户空间本质上是要提高操作系统的稳定性及可用性</strong>。</p></li><li><h3 id="2-6-用户空间与内核通信方式有哪些？"><a href="#2-6-用户空间与内核通信方式有哪些？" class="headerlink" title="2.6 用户空间与内核通信方式有哪些？"></a>2.6 用户空间与内核通信方式有哪些？</h3></li></ul><ol><li><p><strong>使用API</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_user(x，ptr) <span class="comment">//在内核中被调用，获取用户空间指定地址的数值并保存到内核变量x中。</span></span><br><span class="line">put_user(x，ptr) <span class="comment">//在内核中被调用，将内核空间的变量x的数值保存到到用户空间指定地址处。</span></span><br><span class="line">copy_from_user()/copy_to_user() <span class="comment">//主要应用于设备驱动读写函数中，通过系统调用触发。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用proc文件系统</strong><br>和<code>sysfs</code>文件系统类似，也可以作为内核空间和用户空间交互的手段。<code>/proc</code> 文件系统是一种虚拟文件系统，通过他可以作为一种linux内核空间和用户空间的桥梁。与普通文件不同，这里的虚拟文件的内容都是动态创建的。使用<code>/proc</code>文件系统的方式很简单。调用<code>create_proc_entry</code>，返回一个<code>proc_dir_entry</code>指针，然后去填充这个指针指向的结构就好了。(相当于proc为用户空间的进程开了个口访问内核空间)</p></li><li><p><strong>使用sysfs文件系统+kobject</strong><br>每个在内核中注册的<code>kobject</code>都对应着<code>sysfs</code>系统中的一个目录。可以通过读取根目录下的<code>sys</code>目录中的文件来获得相应的信息。除了<code>sysfs</code>文件系统和<code>proc</code>文件系统之外，一些其他的虚拟文件系统也能同样达到这个效果。</p></li><li><p><strong>netlink</strong><br><code>netlink socket</code>提供了一组类似于BSD风格的API，用于用户态和内核态的IPC。相比于其他的用户态和内核态IPC机制，netlink有几个好处：1.使用自定义一种协议完成数据交换，不需要添加一个文件等。2.可以支持多点传送。3.支持内核先发起会话。4.异步通信，支持缓存机制。</p></li><li><p><strong>文件</strong><br>应该说这是一种比较笨拙的做法，不过确实可以这样用。当处于内核空间的时候，直接操作文件，将想要传递的信息写入文件，然后用户空间可以读取这个文件便可以得到想要的数据了。下面是一个简单的测试程序，在内核态中，程序会向<code>/home/melody/str_from_kernel</code>文件中写入一条字符串，然后我们在用户态读取这个文件，就可以得到内核态传输过来的数据了。</p></li><li><p><strong>使用mmap系统调用</strong><br>可以将内核空间的地址映射到用户空间。在以前做嵌入式的时候用到几次。一方面可以在<code>driver</code>中修改<code>Struct file_operations</code>结构中的<code>mmap</code>函数指针来重新实现一个文件对应的映射操作。另一方面，也可以直接打开<code>/dev/mem</code>文件，把物理内存中的某一页映射到进程空间中的地址上。其实，除了重写<code>Struct file_operations</code>中<code>mmap</code>函数，我们还可以重写其他的方法如<code>ioctl</code>等，来达到驱动内核空间和用户空间通信的方式。</p></li><li><p><strong>信号</strong><br>从内核空间向进程发送信号。这个倒是经常遇到，用户程序出现重大错误，内核发送信号杀死相应进程。</p></li></ol><h3 id="2-7-内核链表为什么具有通用性？"><a href="#2-7-内核链表为什么具有通用性？" class="headerlink" title="2.7 内核链表为什么具有通用性？"></a>2.7 内核链表为什么具有通用性？</h3><p>内核中由于要管理大量的设备，但是各种设备各不相同，必须将他们统一起来管理，于是内核设计者就想到了使用通用链表来处理，通用链表看似神秘，实际上就是<strong>双向循环链表</strong>，这个链表的每个节点都是只有指针域，没有任何数据域。</p><ul><li>使用通用链表的好处是：<ol><li>通用链表中每个节点中<strong>没有数据域</strong>，也就是说无论数据结构有多复杂在链表中只有前后级指针。</li><li>如果一个数据结构（即是描述设备的设备结构体）想要用通用链表管理，只需要在结构体中包含<strong>节点的字段</strong>即可。</li><li>双向链表可以从任意一个节点的前后遍历整个链表，<strong>遍历非常方便</strong>。</li><li>使用循环链表使得可以不断地循环遍历管理节点，像进程的调度：操作系统会把<strong>就绪的进程</strong>放在一个管理进程的就绪队列的通用链表中管理起来，循环不断地，为他们<strong>分配时间片</strong>，获得cpu进行周而复始的进程调度。</li></ol></li></ul><h3 id="2-8-应用程序中open-在linux中执行过程中是如何从用户空间到内核空间？"><a href="#2-8-应用程序中open-在linux中执行过程中是如何从用户空间到内核空间？" class="headerlink" title="2.8 应用程序中open()在linux中执行过程中是如何从用户空间到内核空间？"></a>2.8 应用程序中open()在linux中执行过程中是如何从用户空间到内核空间？</h3><ol><li>应用层调用<code>open</code>函数，在VFS层中找到<code>struct inode</code>结构体，判断是字符设备还是块设备，根据设备号，可以找到对应的驱动程序。</li><li>在驱动层中，每个字符设备都有一个<code>struct cdev</code>结构体，这个结构体通过<code>struct inode</code>结构体中的<code>i_cdev</code>把连接起VFS层和驱动层，<code>struct cdev</code>结构体描述了字符设备所有信息，其中最重要的一项就是字符设备的操作函数接口，即<code>const struct file_operations *ops</code></li><li><code>struct cdev</code>结构体中的<code>struct file</code>结构体记录了操作字符设备的一些函数，比如<code>open read write</code>函数等。<code>struct file</code>结构体其实是在VFS层的，通过<code>struct file</code>结构体指针指向驱动层的<code>struct file</code>结构体将驱动层函数和VFS层链接起来</li><li>任务完成，VFS层会给应用返回一个<strong>文件描述符（fd）</strong>。这个fd是和<code>struct file</code>结构体对应的。</li></ol><h2 id="3-设备驱动"><a href="#3-设备驱动" class="headerlink" title="3.设备驱动"></a>3.设备驱动</h2><h3 id="3-1-请简述主设备号和次设备号的用途"><a href="#3-1-请简述主设备号和次设备号的用途" class="headerlink" title="3.1 请简述主设备号和次设备号的用途"></a>3.1 请简述主设备号和次设备号的用途</h3><ul><li><strong>主设备号：主设备号标识设备对应的特定的驱动程序</strong>。虽然现代的linux内核允许多个驱动程序共享主设备号，但我们看待的大多数设备仍然按照“一个主设备对应一个驱动程序”的原则组织</li><li><strong>次设备号：次设备号由内核使用，用于确定由主设备号对应驱动程序中的各个设备</strong>。依赖于驱动程序的编写方式，我们可以通过次设备号获得一个指向内核设备的直接指针，也可将此设备号当作设备本地数组的索引。</li></ul><h3 id="3-2-字符型驱动设备怎么创建设备文件？"><a href="#3-2-字符型驱动设备怎么创建设备文件？" class="headerlink" title="3.2 字符型驱动设备怎么创建设备文件？"></a>3.2 字符型驱动设备怎么创建设备文件？</h3><ol><li>手动创建<br><code>mknod /dev/led c 250 0</code> ，其中<code>dev/led</code>为设备节点 ,<code>c</code> 代表字符设备, <code>250</code>代表主设备号, <code>0</code>代表次设备号。</li><li>自动创建<br><code>UDEV/MDEV</code>是运行在用户态的程序，可以动态管理设备文件，包括创建和删除设备文件，运行在用户态意味着系统要运行之后，在 <code>/etc/init.d/rcS</code> 脚本文件中会执行 <code>mdev -s</code> 自动创建设备节点。</li></ol><h3 id="3-3-设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义"><a href="#3-3-设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义" class="headerlink" title="3.3 设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义"></a>3.3 设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义</h3><ul><li><p>注册一个字符设备驱动有两种方法：</p><ol><li><code>void cdev_init(struct cdev *cdev, struct file_operations *fops)</code> 该注册函数可以将<code>cdev</code>结构嵌入到自己的设备特定的结构中。<code>cdev</code>是一个指向结构体<code>cdev</code>的指针，而<code>fops</code>是指向一个类似于 <code>file_operations</code>结构（可以是<code>file_operations</code>结构，但不限于该结构）的指针。</li><li><code>int register_chrdev(unsigned int major, const char *name, struct file operations *fops)</code>；该注册函数是早期的注册函数，<code>major</code>是设备的主设备号，<code>name</code>是驱动程序的名称，而<code>fops</code>是默认的<code>file_operations</code>结构（这是只限于<code>file_operations</code>结构）。对于<code>register_chrdev</code>的调用将为给定的主设备号注册0－255作为次设备号，并为每个设备建立一个对应的默认<code>cdev</code>结构。</li></ol><h3 id="3-4-dev-下面的设备文件是怎么创建出来的？"><a href="#3-4-dev-下面的设备文件是怎么创建出来的？" class="headerlink" title="3.4 &#x2F;dev&#x2F;下面的设备文件是怎么创建出来的？"></a>3.4 &#x2F;dev&#x2F;下面的设备文件是怎么创建出来的？</h3></li><li><p>普遍说法有三种方式，<strong>devfs机制</strong>，<strong>udev机制</strong>，再有一个就是<strong>手动创建</strong>设备节点。谈谈个人见解：</p></li></ul><ol><li><code>devfs</code>机制从来没用过，应该是2.6以前的内核使用的；</li><li><code>udev</code>：其实就是现在常用的<code>device_create()</code>、<code>class_create()</code>这一套接口，所谓<code>udev</code>是上层用户空间程序，是基于驱动中创建使用了这两个接口而起作用的，但是<code>udev</code>在日常开发中几乎接触不到，我们只需在驱动中调用创建节点的这两个API就ok了，剩下的工作就交给<code>udev</code>去做了，有想深究它具体实现原理的那就自己去研究吧，我觉得会用就行了；</li><li><code>mknod</code>：新手最常用的一种创建设备节点方法，但并非入门后就再没有用途，在某些情境下，或许有人不想使用<code>udev</code>机制，于是把节点创建工作写在脚本里，这样也是无可厚非的。</li></ol><h3 id="3-5-Linux设备中字符设备和块设备有什么主要区别？分别举例。"><a href="#3-5-Linux设备中字符设备和块设备有什么主要区别？分别举例。" class="headerlink" title="3.5 Linux设备中字符设备和块设备有什么主要区别？分别举例。"></a>3.5 Linux设备中字符设备和块设备有什么主要区别？分别举例。</h3><ul><li>Linux中I&#x2F;O设备分为两类：块设备和字符设备。两种设备本身没有严格限制，但是，基于不同的功能进行了分类。</li><li><strong>字符设备</strong>：提供<strong>连续</strong>的数据流，应用程序可以顺序读取，通常不支持随机存取。相反，此类设备支持<strong>按字节&#x2F;字符</strong>来读写数据。字符终端、串口、鼠标、键盘、摄像头、声卡和显卡等就是典型的字符设备。</li><li><strong>块设备</strong>：应用程序可以<strong>随机访问</strong>设备数据，程序可自行确定读取数据的位置。硬盘是典型的块设备，应用程序可以寻址磁盘上的<strong>任何位置</strong>，并由此读取数据。此外，数据的读写只能以块(通常是512B)的倍数进行。与字符设备不同，块设备并不支持基于字符的寻址。如：u盘，SD卡，磁盘等。</li></ul><h3 id="3-6-驱动中操作物理绝对地址为什么要先ioremap？"><a href="#3-6-驱动中操作物理绝对地址为什么要先ioremap？" class="headerlink" title="3.6 驱动中操作物理绝对地址为什么要先ioremap？"></a>3.6 驱动中操作物理绝对地址为什么要先ioremap？</h3><ul><li><code>ioremp</code>是内核中用来将外设寄存器物理地址映射到主存上去的接口，即将io地址空间映射到虚拟地址空间上去，便于操作。为什么非要映射呢，因为<strong>保护模式下的cpu只认虚拟地址，不认物理地址</strong>，给它物理地址它并不帮你做事，所以你要操作外设上的寄存器必须先映射到虚拟内存空间，拿着虚拟地址去跟cpu对接，从而操作寄存器。</li></ul><h3 id="3-7-insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？"><a href="#3-7-insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？" class="headerlink" title="3.7 insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？"></a>3.7 insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？</h3><ul><li>分别会执行<code>module_init()</code>和<code>module_exit()</code>指定的<code>init</code>函数和<code>exit</code>函数。要注意的就是，尽量使在<code>init</code>函数中出现的资源申请及使用，都要有对应的释放操作在<code>exit</code>中，即<code>init</code>申请，<code>eixt</code>释放。</li></ul><h3 id="3-8-NAND驱动的probe流程"><a href="#3-8-NAND驱动的probe流程" class="headerlink" title="3.8 NAND驱动的probe流程"></a>3.8 NAND驱动的probe流程</h3><ul><li><code>probe</code> 函数就会与NAND芯片进行，主要做的事情主要包括这几个方面：读取NAND芯片的ID ，然后查表得到这片NAND芯片的如厂商，page size，erase size以及chip size等信息，接着根据<code>struct nand_chip</code> 中<code>options</code>的值的不同，或者在NAND 芯片中的特定位置查找<code>bad block table</code>，或者scan整个NAND 芯片，并在内存中建立<code>bad block table</code>。说起来复杂，但其实所有的这些动作，都可以在MTD提供的一个叫做<code>nand_scan</code>的函数中完成。</li></ul><h3 id="3-9-Linux驱动开发中，常用的调试方法有哪些？"><a href="#3-9-Linux驱动开发中，常用的调试方法有哪些？" class="headerlink" title="3.9 Linux驱动开发中，常用的调试方法有哪些？"></a>3.9 Linux驱动开发中，常用的调试方法有哪些？</h3><ul><li><p>利用<code>printk</code>，查看OOP消息，利用<code>strace</code>，利用内核内置的<code>hacking</code>选项，利用<code>ioctl</code>方法，利用<code>/proc</code> 文件系统，使用<code>kgdb</code>。</p></li><li><p><code>strace</code> 是一个可用于诊断、调试和教学的 Linux 用户空间跟踪器，监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。</p></li><li><p><code>ioctl</code> 是设备驱动程序中设备控制接口函数，一个字符设备驱动通常会实现设备打开、关闭、读、写等功能，在一些需要细分的情境下，如果需要扩展新的功能，通常以增设<code>ioctl()</code>命令的方式实现。</p><blockquote><p>建议大家，亲手动手调试下。面试中，很大可能会问你，在写驱动过程中遇到了什么问题的，如何解决的？如果你能讲出以上几种调试方法中的一两种，一定会让面试官刮目相看！</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
            <tag> 内核编程 </tag>
            
            <tag> Linux系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2024/06/06/test/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/06/06/test/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="写嵌入式用的到数据结构吗？"><a href="#写嵌入式用的到数据结构吗？" class="headerlink" title="写嵌入式用的到数据结构吗？"></a>写嵌入式用的到数据结构吗？</h1><p>看下linux内核就知道了，一堆数据结构，不学习数据结构，linux内核就看不懂了</p><p>使用数据结构是为了使代码结构更清晰，更容易把握代码结构、逻辑。</p><p>几个应用场景</p><ol><li><p>“数组”。你肯定用过吧，属于数据结构“线性表”的一种形式。</p><p><img src="/2024/06/06/test/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241112202136552.png" alt="image-20241112202136552" style="zoom:50%;"><img src="/2024/06/06/test/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241112202215843.png" alt="image-20241112202215843" style="zoom:50%;"></p></li><li></li><li><p>“结构体”。学习过lwip可以知道从以太网上接收一堆数据后，把数据头的地址幅值给以太网包的数据结构定义的指针，可以直接使用此指针-&gt;成员变量的方式，使用接收到的数据。比使用一堆变量来利用接收到的数据方便太多了。</p></li><li><p>“队列”。热敏电阻测温，单片机用ADC测量电阻分压电压，然后对测量值用平滑均值滤波算法滤波，此时会用到“队列”，或用“环形队列”；</p></li><li><p>“树”。项目中经常会使用液晶屏作为显示，其中文本菜单有时用的比较多的一种方式，其中文本菜单常用“树”结构来实现。</p></li><li><p>“栈”。就不用说了，你已经用过了，不过不是你主动用的，它隐藏在你每次函数调用、中断调用中，可能你没有意识到。</p></li></ol><p>简单几个例子，说明了数据结构非常常见，这个是必须要学的，不过有些不常用，比如图。</p><h3 id="1-【简答题】请写出至少两种野指针的成因"><a href="#1-【简答题】请写出至少两种野指针的成因" class="headerlink" title="1.   【简答题】请写出至少两种野指针的成因"></a>1.   【简答题】请写出至少两种野指针的成因</h3><p>【答案】</p><p>（1）指针使用前未初始化</p><p>（2）指针越界访问</p><p>（3）指针指针已经释放的空间</p><h3 id="2-【简答题】非静态局部变量、全局变量、malloc-动态分配的内存分别存储在内存的什么区域。"><a href="#2-【简答题】非静态局部变量、全局变量、malloc-动态分配的内存分别存储在内存的什么区域。" class="headerlink" title="2.   【简答题】非静态局部变量、全局变量、malloc()动态分配的内存分别存储在内存的什么区域。"></a>2.   【简答题】非静态局部变量、全局变量、malloc()动态分配的内存分别存储在内存的什么区域。</h3><p>【答案】</p><p>（1）非静态局部变量存储在内存的栈区域。</p><p>（1）全局变量存储在内存的全局静态区。</p><p>（2）malloc()动态分配的内存存储在内存的堆区域。</p><h1 id="一、数据结构与算法的层次要求："><a href="#一、数据结构与算法的层次要求：" class="headerlink" title="一、数据结构与算法的层次要求："></a>一、数据结构与算法的层次要求：</h1><p>层次1：熟悉各种不同的数据结构：顺序表（一维数组）、链表、栈、队列；森林、树、二叉树；图等<br>      了解不同的数据结构的特点、如何存储、优缺点等</p><p>层次2：如何编写相关的代码，实现对应的数据结构。（需要考虑对应的增、删、改、查、长度、遍历等）</p><p>层次3：算法层面的训练。 —&gt; leetcode （力扣app）、牛客网等。 300+道打底</p><img src="https://s1.vika.cn/space/2024/11/12/bb5ee404f183423782032597b88580fc" alt="image-20241112200556715"><h1 id="二、针对于层次1："><a href="#二、针对于层次1：" class="headerlink" title="二、针对于层次1："></a>二、针对于层次1：</h1><ol><li><p>什么是数据结构？   datastructure   (D-&gt;S)</p><blockquote><p>数据 +  结构<br>数据：多个相同类型的数据或变量<br>结构：即关系<br>目的：为了更高效的访问数据</p></blockquote></li><li><p>数据结构中有哪些内容？即问研究方向？<br>研究方向1：数据之间的逻辑关系</p><blockquote><p>线性关系:（一对一的关系）。比如：顺序表、链表、栈、队列、数组、字符串、广义表等<br>非线性关系：集合关系、树形关系（一对多的关系）、图形关系（多对多的关系）</p></blockquote></li></ol><p>研究方向2：数据的存储结构（或物理结构）<br>    &gt; 基本的两种：顺序存储结构、链式存储结构<br>    &gt; 拓展的两种：索引存储结构、哈希存储结构(散列存储结构)<br>研究方向3：数据之间的运算：增、删、改、查(CRUD)</p><h1 id="三、具体的不同的数据结构的实现（对应着层次2）"><a href="#三、具体的不同的数据结构的实现（对应着层次2）" class="headerlink" title="三、具体的不同的数据结构的实现（对应着层次2）"></a>三、具体的不同的数据结构的实现（对应着层次2）</h1><ol><li><p>数组的实现和相关算法的封装。</p></li><li><p>链表的实现和相关算法的封装。</p><p>   ​                 优点                                      缺点</p><blockquote><p>数组 通过索引查找、修改效率高：O(1)  插入、删除的效率差：O(n)</p><p>​同样大小的内存，数组可以存储更多的数据  当数据存满时，需要考虑扩容</p></blockquote><blockquote><p>链表   插入、删除效率高：O(1) 通过索引查找、修改效率低：O(n)  </p><p>​ 不需要考虑扩容问题   同样大小的内存，链表存储的数据较数组少</p></blockquote></li></ol><h2 id="如何理解数据结构"><a href="#如何理解数据结构" class="headerlink" title="如何理解数据结构"></a>如何理解数据结构</h2><h4 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h4><p>1.数据结构定义：研究多个变量之间的结构，即数据与数据之间的关系。</p><p> 2.研究目的：高效地进行数据的操作，如增删改查。</p><h4 id="数据结构的主要内容"><a href="#数据结构的主要内容" class="headerlink" title="数据结构的主要内容"></a>数据结构的主要内容</h4><p>1.逻辑结构：研究数据之间的逻辑关系，分为集合关系、线性关系、树形关系和网状关系。 </p><p>2.存储结构：研究数据在实际编程语言中的存储方式，分为顺序存储和链式存储。 </p><p>3.运算：基于存储结构，研究数据的增删改查等操作。</p><h4 id="线性结构和非线性结构"><a href="#线性结构和非线性结构" class="headerlink" title="线性结构和非线性结构"></a>线性结构和非线性结构</h4><p>1.线性结构：如顺序表、链表、栈、队列、数组、广义表等。</p><p> 2.非线性结构：如集合、树、图等。</p><h4 id="存储结构的两种基本形式"><a href="#存储结构的两种基本形式" class="headerlink" title="存储结构的两种基本形式"></a>存储结构的两种基本形式</h4><p>1.顺序存储：将数据元素依次排列，通过数组等方式实现。 </p><p>2.链式存储：通过链表方式，每个元素包含指向下一个元素的指针。</p><p> 3.索引存储结构和哈希存储结构：基于顺序存储和链式存储的组合。</p><img src="https://s1.vika.cn/space/2024/11/12/ad74377b36704d109dd9765a42b58faa" alt="image-20241112202757865" style="zoom:50%;"><img src="/2024/06/06/test/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241112202851334.png" alt="image-20241112202851334" style="zoom:50%;"><h1 id="线性结构之数组"><a href="#线性结构之数组" class="headerlink" title="线性结构之数组"></a>线性结构之数组</h1><p><strong>优</strong> <strong>点</strong></p><p>Ø 查找容易（通过下标），时间复杂度为O(1)。不需要额外申请或删除空间。</p><p>Ø 使用下标位置索引(index)十分高效的访问任意元素，修改快</p><p><img src="https://s1.vika.cn/space/2024/11/12/48ec67a0d691481bab93fce23ca5fb1f" alt="image-20241105203354020"></p><p><strong>缺</strong> <strong>点</strong></p><p>Ø 插入、删除元素难，效率低。（需要移动大量元素以使元素空间连续）。</p><p>Ø 插入操作平均需要移动n&#x2F;2个元素。</p><p>Ø 删除操作平均需要移动(n-1)&#x2F;2个元素。</p><p>​                             <img src="https://s1.vika.cn/space/2024/11/12/4dcfedcbb1a2444397856fa27a77c364" alt="image-20241105203403567">     </p><p>Ø 扩展相对繁琐。一方面需要确保能提供更大区域的连续内存空间，另一方面需要将原有数据复制到新的顺序表中。</p><p>1.1.1 功能定义</p><p>前文提到过数组这一数据结构的一个局限性是长度固定，本节我们来实现一个增强版的数组——可变长的动态数组，需要实现以下函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//初始化动态数组</span><br><span class="line">void initDynamicArray(DynamicArray *array, size_t initialCapacity)</span><br><span class="line">//释放动态数组内存</span><br><span class="line">void destroyDynamicArray(DynamicArray *array)</span><br><span class="line">//调整动态数组内存大小</span><br><span class="line">void resizeDynamicArray(DynamicArray *array, size_t newCapacity)</span><br><span class="line">//获取动态数组长度（元素个数）</span><br><span class="line">size_t getLength(const DynamicArray *array)</span><br><span class="line">//在指定位置插入新元素</span><br><span class="line">void insertAt(DynamicArray *array, size_t index, int element)</span><br><span class="line">//在末尾插入新元素</span><br><span class="line">void insertEnd(DynamicArray *array, int element)</span><br><span class="line">//删除指定位置的元素并返回被删除的元素</span><br><span class="line">int deleteAt(DynamicArray *array, size_t index)</span><br><span class="line">//删除末尾的元素并返回被删除的元素</span><br><span class="line">int deleteEnd(DynamicArray *array)</span><br><span class="line">//遍历所有的元素</span><br><span class="line">void print(DynamicArray *array)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-1-1-实现原理"><a href="#1-1-1-实现原理" class="headerlink" title="1.1.1 实现原理"></a>1.1.1 实现原理</h2><p>可变长的动态数组是一种数据结构，它允许在运行时根据需要动态地调整数组的大小，而不需要提前指定固定的大小。这种动态数组通常被称为动态数组、动态分配数组、动态增长数组或动态内存数组。int arr[10];  </p><p>C语言中是通过使用指针和内存分配函数来实现动态数组，常见的内存分配函数是<code>malloc</code>、<code>realloc</code>和<code>free</code>。下面是一些相关的概念和操作：</p><p>（1）<strong>分配内存（malloc）：</strong> 在C语言中，可以使用<code>malloc</code>函数来分配一块指定大小的内存。例如，<code>int *arr = (int *)malloc(n * sizeof(int));</code> 将分配能够存储<code>n</code>个整数的内存空间。</p><p>（2）<strong>重新分配内存（realloc）：</strong> 如果需要改变动态数组的大小，可以使用<code>realloc</code>函数来重新分配内存。这允许你在保留原有数据的情况下扩展或缩小数组的大小。</p><p>（3）<strong>释放内存（free</strong>）： 当不再需要动态数组时，应使用<code>free</code>函数释放之前分配的内存，以避免内存泄露。à 内存溢出</p><p>代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">// 动态数组结构体</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int *data;       // 指向动态数组的指针</span><br><span class="line">    size_t size;     // 当前数组中的元素个数</span><br><span class="line">    size_t capacity; // 当前数组的容量（可以容纳的最大元素个数）</span><br><span class="line">&#125; DynamicArray;</span><br><span class="line"></span><br><span class="line">// 初始化动态数组</span><br><span class="line">void initDynamicArray(DynamicArray *array, size_t initialCapacity)</span><br><span class="line">&#123;     //分配内存（malloc）</span><br><span class="line">    array-&gt;data = (int *)malloc(initialCapacity * sizeof(int)); // 分配初始内存</span><br><span class="line">    array-&gt;size = 0;       // 初始化元素个数为0</span><br><span class="line">    array-&gt;capacity = initialCapacity;     // 设置初始容量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放动态数组内存</span><br><span class="line">void destroyDynamicArray(DynamicArray *array)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    //释放内存（free）</span><br><span class="line">    free(array-&gt;data);   // 释放动态数组内存</span><br><span class="line">    array-&gt;size = 0;     // 重置元素个数为0</span><br><span class="line">    array-&gt;capacity = 0; // 重置容量为0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调整动态数组内存大小</span><br><span class="line">void resizeDynamicArray(DynamicArray *array, size_t newCapacity)</span><br><span class="line">&#123; //重新分配内存（realloc）</span><br><span class="line">    array-&gt;data = (int *)realloc(array-&gt;data, newCapacity * sizeof(int)); // 调整数组内存大小  </span><br><span class="line">    array-&gt;capacity = newCapacity;       // 更新容量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取动态数组长度（元素个数）</span><br><span class="line">size_t getLength(const DynamicArray *array)</span><br><span class="line">&#123;</span><br><span class="line">    return array-&gt;size; // 返回数组中的元素个数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在指定位置插入新元素</span><br><span class="line">void insertAt(DynamicArray *array, size_t index, int element)</span><br><span class="line">&#123;</span><br><span class="line">    if (index &gt; array-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        return; // 忽略无效的插入位置</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (array-&gt;size &gt;= array-&gt;capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t newCapacity = array-&gt;capacity * 2; // 如果容量不足，扩大容量</span><br><span class="line">        resizeDynamicArray(array, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (size_t i = array-&gt;size; i &gt; index; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        array-&gt;data[i] = array-&gt;data[i - 1]; // 后移元素以腾出插入位置</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array-&gt;data[index] = element; // 在指定位置插入新元素</span><br><span class="line">    array-&gt;size++;                // 更新元素个数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在末尾插入新元素</span><br><span class="line">void insertEnd(DynamicArray *array, int element)</span><br><span class="line">&#123;</span><br><span class="line">    insertAt(array, array-&gt;size, element); // 在末尾插入新元素</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除指定位置的元素并返回被删除的元素</span><br><span class="line">int deleteAt(DynamicArray *array, size_t index)</span><br><span class="line">&#123;</span><br><span class="line">    if (index &gt;= array-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        return -1; // 忽略无效的删除位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    int deletedElement = array-&gt;data[index]; // 获取被删除的元素</span><br><span class="line"></span><br><span class="line">    for (size_t i = index; i &lt; array-&gt;size - 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        array-&gt;data[i] = array-&gt;data[i + 1]; // 前移元素以填补删除位置</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array-&gt;size--; // 更新元素个数</span><br><span class="line"></span><br><span class="line">    return deletedElement; // 返回被删除的元素</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除末尾的元素并返回被删除的元素</span><br><span class="line">int deleteEnd(DynamicArray *array)</span><br><span class="line">&#123;</span><br><span class="line">    return deleteAt(array, array-&gt;size - 1); // 删除末尾的元素</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历所有的元素</span><br><span class="line">void print(DynamicArray *array)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; array-&gt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;, array-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    DynamicArray myArray; // 声明动态数组</span><br><span class="line"></span><br><span class="line">    // 初始化动态数组</span><br><span class="line">    initDynamicArray(&amp;myArray, 2);</span><br><span class="line">    printf(&quot;初始化动态数组,初始容量为2\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 向动态数组尾部插入元素</span><br><span class="line">    insertEnd(&amp;myArray, 1);</span><br><span class="line">    insertEnd(&amp;myArray, 2);</span><br><span class="line">    printf(&quot;向动态数组尾部插入了2个元素\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 打印动态数组当前长度</span><br><span class="line"> printf(&quot;动态数组当前长度:%zu\n&quot;, getLength(&amp;myArray));</span><br><span class="line"></span><br><span class="line">    // 在索引1的位置插入元素3</span><br><span class="line">    insertAt(&amp;myArray, 1, 3);</span><br><span class="line">    printf(&quot;在索引1的位置插入元素3\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 再次打印动态数组当前长度</span><br><span class="line">    printf(&quot;动态数组当前长度:%zu\n&quot;, getLength(&amp;myArray));</span><br><span class="line"></span><br><span class="line">    // 删除索引1的元素</span><br><span class="line">    printf(&quot;删除索引1的元素,该元素是%d\n&quot;, deleteAt(&amp;myArray, 1));</span><br><span class="line"></span><br><span class="line">    // 删除动态数组末尾元素</span><br><span class="line">    printf(&quot;删除动态数组末尾元素,该元素是%d\n&quot;, deleteEnd(&amp;myArray));</span><br><span class="line"></span><br><span class="line">    // 释放动态数组内存</span><br><span class="line">    destroyDynamicArray(&amp;myArray);</span><br><span class="line">    printf(&quot;动态数组内存释放完成\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="1-1-线性结构之链表"><a href="#1-1-线性结构之链表" class="headerlink" title="1.1 线性结构之链表"></a>1.1 线性结构之链表</h1><p>1.1.1 链表是什么</p><p>链表的主要特点包括：</p><ol><li><strong>动态大小</strong>：链表可以根据需要动态调整大小，不需要预先分配固定的内存空间。</li><li><strong>插入和删除效率高</strong>：在已知位置插入或删除元素时，链表不需要移动其他元素，只需调整指针即可。</li><li><strong>顺序访问</strong>：链表不支持随机访问，要访问链表中的某个元素，必须从头节点开始逐个遍历。</li></ol><p>链表有几种常见的类型：</p><ul><li><strong>单向链表</strong>：每个节点只指向下一个节点。</li><li><strong>双向链表</strong>：每个节点有两个指针，分别指向前一个节点和后一个节点。</li><li><strong>循环链表</strong>：链表的最后一个节点指向第一个节点，形成一个环。</li></ul><p><img src="https://s1.vika.cn/space/2024/11/12/65ec27aa9d2548efbe0342f9a53b9878" alt="image-20241108184735610"></p><p><strong>相关概念</strong></p><p>n个结点离散分配，彼此通过指针相连，每个结点只有一个前驱结点，每个结点只有一个后续结点，头结点没有前驱结点，尾结点没有后续结点。确定一个链表我们只需要头指针，通过头指针就可以把整个链表都能推出来。</p><p>1）优点</p><p>（1）插入和删除操作效率高。</p><p>（2）动态扩展性能更好，链表不需要像数组那样预先指定固定的大小，而是可以随时动态的增长或缩小。链表是真正的动态数据结构，不需要处理固定容量的问题。</p><p>2）缺点</p><p>（1）查找慢。由于链表中的结点不是连续存储的，无法像数组一样根据索引直接计算出每个结点的地址。必须从头结点开始遍历链表，直到找到目标结点，这导致了链表的随机访问效率较低。</p><p>（2）额外的存储空间。链表的每个结点都需要存储指向下一个结点的指针，这会占用额外的存储空间。所以，相比于数组，链表需要更多的内存空间来存储相同数量的数据元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">初始化链表</span><br><span class="line">void initLinkedList(LinkedList *list)</span><br><span class="line">返回链表的长度</span><br><span class="line">size_t getLength(const LinkedList *list)</span><br><span class="line">在指定位置插入元素</span><br><span class="line">void insertAt(LinkedList *list, size_t index, int element)</span><br><span class="line">在末尾插入元素</span><br><span class="line">void insertEnd(LinkedList *list, int element)</span><br><span class="line">删除指定位置的元素并返回被删除的元素</span><br><span class="line">int deleteAt(LinkedList *list, size_t index)</span><br><span class="line">删除末尾元素</span><br><span class="line">int deleteEnd(LinkedList *list)</span><br><span class="line">获取指定位置的元素</span><br><span class="line">int getElementAt(const LinkedList *list, size_t index)</span><br><span class="line">修改指定位置的元素</span><br><span class="line">void modifyAt(LinkedList *list, size_t index, int newValue)</span><br><span class="line">释放链表内存</span><br><span class="line">void destroyLinkedList(LinkedList *list)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">自定义链表结构</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 定义存储数据的结构体</span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int data;          // 存储的数据</span><br><span class="line">    struct Node *next; // 指向下个元素的指针</span><br><span class="line"></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">// 定义虚拟头结点的结构体</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int size;   // 记录单链表中存储的数据的个数</span><br><span class="line">    Node *next; // 指向保存数据的首元素</span><br><span class="line">&#125; LinkedList;</span><br><span class="line"></span><br><span class="line">// 明确：在包含虚拟头结点的情况下，首个保存数据的结点的索引为0！</span><br><span class="line"></span><br><span class="line">// 初始化链表</span><br><span class="line">void initLinkedList(LinkedList *list)</span><br><span class="line">&#123;</span><br><span class="line">    // 初始化LinkedList内部的成员</span><br><span class="line">    list-&gt;size = 0;</span><br><span class="line">    list-&gt;next = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回链表的长度</span><br><span class="line">size_t getLength(const LinkedList *list)</span><br><span class="line">&#123;</span><br><span class="line">    return list-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在指定位置插入元素</span><br><span class="line">void insertAt(LinkedList *list, size_t index, int element)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (index &lt; 0 || index &gt; list-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;输入的index数据非法\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 插入数据的过程</span><br><span class="line">    // 1. 将数据封装到Node结构体的变量中</span><br><span class="line">    Node *node = (Node *)malloc(1 * sizeof(Node));</span><br><span class="line">    node-&gt;data = element;</span><br><span class="line"></span><br><span class="line">    // 2. 找到index的位置进行插入操作</span><br><span class="line">    if (index == 0)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        node-&gt;next = list-&gt;next;</span><br><span class="line">        list-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Node *currentNode = list-&gt;next; // 指向有数据的首元素</span><br><span class="line">        for (int i = 0; i &lt; index - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            currentNode = currentNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node-&gt;next = currentNode-&gt;next;</span><br><span class="line">        currentNode-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在末尾插入元素</span><br><span class="line">void insertEnd(LinkedList *list, int element)</span><br><span class="line">&#123;</span><br><span class="line">    insertAt(list, list-&gt;size, element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除指定位置的元素并返回被删除的元素</span><br><span class="line">int deleteAt(LinkedList *list, size_t index)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (index &lt; 0 || index &gt;= list-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;输入的index不合法\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int deleteElement;</span><br><span class="line">    Node *deleteNode;</span><br><span class="line">    if (index == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        deleteNode = list-&gt;next;</span><br><span class="line"></span><br><span class="line">        list-&gt;next = deleteNode-&gt;next;</span><br><span class="line"></span><br><span class="line">        // 获取要删除的node的数据</span><br><span class="line">        deleteElement = deleteNode-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Node *currentNode = list-&gt;next; // 指向有数据的首元素</span><br><span class="line">        for (int i = 0; i &lt; index - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            currentNode = currentNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deleteNode = currentNode-&gt;next;</span><br><span class="line">        currentNode-&gt;next = deleteNode-&gt;next;</span><br><span class="line"></span><br><span class="line">        deleteElement = deleteNode-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    free(deleteNode); // 释放node的内存空间</span><br><span class="line"></span><br><span class="line">    list-&gt;size--;</span><br><span class="line"></span><br><span class="line">    return deleteElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除末尾元素</span><br><span class="line">int deleteEnd(LinkedList *list) &#123;</span><br><span class="line">    deleteAt(list,list-&gt;size - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取指定位置的元素</span><br><span class="line">int getElementAt(const LinkedList *list, size_t index) &#123;</span><br><span class="line"></span><br><span class="line">    if(index &lt; 0 || index &gt;= list-&gt;size)&#123;</span><br><span class="line">        printf(&quot;输入的index不合法\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node * currentNode = list-&gt;next;</span><br><span class="line">    for(int i = 0;i &lt; index ;i++)&#123;</span><br><span class="line">        currentNode = currentNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return currentNode-&gt;data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改指定位置的元素</span><br><span class="line">void modifyAt(LinkedList *list, size_t index, int newValue) &#123;</span><br><span class="line"></span><br><span class="line">    if(index &lt; 0 || index &gt;= list-&gt;size)&#123;</span><br><span class="line">        printf(&quot;输入的index不合法\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node * currentNode = list-&gt;next;</span><br><span class="line">    for(int i = 0;i &lt; index ;i++)&#123;</span><br><span class="line">        currentNode = currentNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentNode-&gt;data = newValue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放链表内存</span><br><span class="line">void destroyLinkedList(LinkedList *list) &#123;</span><br><span class="line"></span><br><span class="line">    Node *currentNode = list-&gt;next;  //找到有数据的第1个结点</span><br><span class="line"></span><br><span class="line">    for(int i = 0;i &lt; list-&gt;size;i++)&#123;</span><br><span class="line"></span><br><span class="line">        Node *tempNode = currentNode;</span><br><span class="line">        currentNode = currentNode-&gt;next;</span><br><span class="line"></span><br><span class="line">        free(tempNode);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //辅助操作</span><br><span class="line">    list-&gt;next = NULL;</span><br><span class="line">    list-&gt;size = 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    LinkedList list;</span><br><span class="line">    initLinkedList(&amp;list);</span><br><span class="line"></span><br><span class="line">    insertAt(&amp;list,0,10);</span><br><span class="line">    insertAt(&amp;list,0,20);</span><br><span class="line">    insertAt(&amp;list,0,30);</span><br><span class="line"></span><br><span class="line">    size_t count = getLength(&amp;list);</span><br><span class="line">    printf(&quot;%d\n&quot;,count);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    getchar();  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放链表内存-有什么用"><a href="#释放链表内存-有什么用" class="headerlink" title="释放链表内存 有什么用"></a>释放链表内存 有什么用</h3><p>释放链表内存”的主要用途在于管理动态分配的内存，确保程序运行期间不会造成内存泄漏。下面是这一过程的重要性和作用：</p><ol><li><strong>防止内存泄漏</strong>：在程序中动态申请的内存（例如，通过 <code>malloc</code>）需要在不再使用时及时释放。如果在不再需要链表时不释放内存，程序会占用不必要的内存资源，从而导致内存泄漏。</li><li><strong>优化内存使用</strong>：及时释放内存可以确保系统资源的有效使用，特别是在运行长时间的程序或需要频繁创建和销毁对象的情况下。</li><li><strong>防止悬挂指针</strong>：在释放链表内存的同时，设置指向链表的指针（如头指针）为 <code>NULL</code> 坏境，可以避免访问已释放内存的风险。这有助于防止程序在试图访问无效内存时造成的未定义行为。</li><li><strong>提高程序稳定性</strong>：良好的内存管理使得程序更加稳定和健壮，降低了崩溃的概率。</li></ol><h1 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h1><p>特点：<code>后进先出</code> (LIFO，Last In First Out)或<code>先进后出</code> (FILO，First In Last Out)的线性表。</p><p> 栈顶(Top)：允许进行插入、删除操作的一端，又称为<code>表尾</code>。栈顶由一个称为栈顶指针的位置指示器（其实就是一个变量）来指示，它是动态变化的。</p><p>- 栈底(Bottom)：是固定不变的，不允许进行插入和删除的一端，又称为<code>表头</code>。</p><p>- 空栈：不含任何元素的空表。</p><p>- 设栈S&#x3D;(a1,a2,…,an )，则a1称为栈底元素，an为栈顶元素，栈中元素按a1,a2,…,a_n的次序进栈(压栈、push)，出栈(弹栈，pop)的第一个元素应为栈顶元素，出栈顺序为：an,…,a2,a1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">初始化栈</span><br><span class="line">void initStack(Stack *stack, size_t capacity)</span><br><span class="line">返回栈内元素个数</span><br><span class="line">size_t getSize(const Stack *stack)</span><br><span class="line">添加新元素</span><br><span class="line">void push(Stack *stack, int element)</span><br><span class="line">在末尾插入元素</span><br><span class="line">void insertEnd(LinkedList *list, int element)</span><br><span class="line">栈顶元素出栈并返回</span><br><span class="line">int pop(Stack *stack)</span><br><span class="line">释放栈内存</span><br><span class="line">void destroyStack(Stack *stack)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"></span><br><span class="line">  自定义实现栈结构：使用顺序存储结构实现--&gt; 顺序栈</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line"></span><br><span class="line">    //存储数据的指针</span><br><span class="line">    int *data;</span><br><span class="line">    //指明存储容器的容量</span><br><span class="line">    size_t capacity;</span><br><span class="line">    //指明存储容器中实际存储的数据量</span><br><span class="line">    size_t size;</span><br><span class="line"></span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 初始化栈</span><br><span class="line">void initStack(Stack *stack, size_t capacity)</span><br><span class="line">&#123;</span><br><span class="line">    stack-&gt;data = (int *)malloc(capacity *sizeof(int));//动态内存分配</span><br><span class="line">    if(stack-&gt;data == NULL)&#123;</span><br><span class="line">        printf(&quot;内存分配失败\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack-&gt;capacity = capacity;         </span><br><span class="line">    stack-&gt;size = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回栈内元素个数</span><br><span class="line">size_t getSize(const Stack *stack)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    return stack-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加新元素</span><br><span class="line">void push(Stack *stack, int element)</span><br><span class="line">&#123;</span><br><span class="line">    //考虑是否存满了</span><br><span class="line">    if(stack-&gt;size == stack-&gt;capacity)&#123;</span><br><span class="line">        //扩容</span><br><span class="line">        resizeCapacity(stack,stack-&gt;capacity + stack-&gt;capacity &gt;&gt; 1); //扩容为原来的1.5倍</span><br><span class="line">        printf(&quot;容量已满，进行扩容操作\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack-&gt;data[stack-&gt;size] = element;</span><br><span class="line">    stack-&gt;size++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void resizeCapacity(Stack *stack,int newCapacity)&#123;</span><br><span class="line"></span><br><span class="line">    stack-&gt;data = (int *)realloc(stack-&gt;data,newCapacity * sizeof(int)); //扩容操作</span><br><span class="line">    stack-&gt;capacity = newCapacity; //指明新的容量值</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 栈顶元素出栈并返回</span><br><span class="line">int pop(Stack *stack)</span><br><span class="line">&#123;</span><br><span class="line">    //判断是否为空</span><br><span class="line">    if(stack-&gt;size == 0)&#123;</span><br><span class="line">        printf(&quot;当前栈为空,弹栈失败\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // int popElement = stack-&gt;data[stack-&gt;size-1];</span><br><span class="line">    // stack-&gt;size--;</span><br><span class="line"></span><br><span class="line">    // return popElement;</span><br><span class="line"></span><br><span class="line">    return stack-&gt;data[--stack-&gt;size];//</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//这是一个前缀自减操作。它的作用是将 stack-&gt;size 的值减一，然后返回这个新的值。</span><br><span class="line">//例如，如果 stack-&gt;size 原本是 3，经过 --stack-&gt;size 处理后，</span><br><span class="line">//stack-&gt;size 会变为 2。这意味着我们将要弹出栈中索引为 2 的元素（即第三个元素，因为索引从 0 开始）。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放栈内存</span><br><span class="line">void destroyStack(Stack *stack)</span><br><span class="line">&#123;</span><br><span class="line">    free(stack-&gt;data);</span><br><span class="line">    stack-&gt;data = NULL;</span><br><span class="line">    stack-&gt;capacity = 0;</span><br><span class="line">    stack-&gt;size = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//遍历栈中的元素</span><br><span class="line">void print(Stack *stack)&#123;</span><br><span class="line">    for(int i = 0;i &lt; stack-&gt;size;i++)&#123;</span><br><span class="line">        printf(&quot;%d  &quot;,stack-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //声明结构体变量</span><br><span class="line">    Stack myStack;</span><br><span class="line"></span><br><span class="line">    initStack(&amp;myStack,3);</span><br><span class="line"></span><br><span class="line">    push(&amp;myStack,1);</span><br><span class="line">    push(&amp;myStack,2);</span><br><span class="line">    push(&amp;myStack,3);</span><br><span class="line">    push(&amp;myStack,4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    printf(&quot;栈中元素的个数为：%d\n&quot;,getSize(&amp;myStack));</span><br><span class="line"></span><br><span class="line">    print(&amp;myStack);</span><br><span class="line"></span><br><span class="line">    printf(&quot;弹栈，弹出的数据是：%d\n&quot;,pop(&amp;myStack));</span><br><span class="line">    printf(&quot;弹栈，弹出的数据是：%d\n&quot;,pop(&amp;myStack));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print(&amp;myStack);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线性结构之队列"><a href="#线性结构之队列" class="headerlink" title="线性结构之队列"></a>线性结构之队列</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>队列(Queue)：也是操作受限的线性表，限制为仅允许在表的一端进行插入(入队或进队），在表的另一端进行删除(出队或离队)操作。</p><p>- 队首(front) ：允许进行删除的一端称为队首。</p><p>- 队尾(rear)： 允许进行插入的一端称为队尾。</p><p>在空队列中依次加入元素a1,a2, …, an之后，a1是队首元素，an是队尾元素。显然退出队列的次序也只能是a1,a2, …, an。队列，是一种先进先出(First In First Out ，简称FIFO)的线性结构。类似于生活中的排队行为。</p><p><img src="https://s1.vika.cn/space/2024/11/12/b4e17e3fbd7d4f78815a4f01eb85cb5f" alt="image-20241111205010221"></p><p>队列中没有元素时，称为空队列。</p><h3 id="队列的存储结构"><a href="#队列的存储结构" class="headerlink" title="队列的存储结构"></a>队列的存储结构</h3><p>可用顺序表(数组)和链表来存储队列，队列按存储结构可分为顺序队列和链式队列两种。</p><h3 id="功能定义"><a href="#功能定义" class="headerlink" title="功能定义"></a>功能定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">初始化队列</span><br><span class="line">void initQueue(Queue *queue, size_t capacity)</span><br><span class="line">返回队列内元素个数</span><br><span class="line">size_t getSize(const Queue *queue)</span><br><span class="line">添加新元素</span><br><span class="line">void enqueue(Queue *queue, int element)</span><br><span class="line">元素出队列</span><br><span class="line">int dequeue(Queue *queue)</span><br><span class="line">释放队列内存</span><br><span class="line">void destroyQueue(Queue *queue)</span><br><span class="line">遍历队列</span><br><span class="line">void printQueue(Queue *queue)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">/* </span><br><span class="line">    自定义结构实现队列：使用循环队列</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//声明队列对应的结构体</span><br><span class="line">typedef struct&#123;</span><br><span class="line"></span><br><span class="line">    int *data;</span><br><span class="line">    int capacity; //记录存储的最大容量</span><br><span class="line">    int size ; //记录存储的元素的个数</span><br><span class="line">    int front ;  //记录要出队的索引位置</span><br><span class="line">    int rear;  //记录入队后的索引位置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 初始化队列</span><br><span class="line">void initQueue(Queue *queue, size_t capacity)</span><br><span class="line">&#123;</span><br><span class="line">    queue-&gt;data = (int *)malloc(capacity * sizeof(int));</span><br><span class="line">    queue-&gt;capacity = capacity;</span><br><span class="line">    queue-&gt;size = 0;</span><br><span class="line">    queue-&gt;front = 0;</span><br><span class="line">    queue-&gt;rear = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回队列内元素个数</span><br><span class="line">size_t getSize(const Queue *queue)</span><br><span class="line">&#123;</span><br><span class="line">    return queue-&gt;size;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加新元素</span><br><span class="line">void enqueue(Queue *queue, int element)</span><br><span class="line">&#123;</span><br><span class="line">    if(queue-&gt;size == queue-&gt;capacity)&#123;</span><br><span class="line">        //容量已满</span><br><span class="line">        printf(&quot;队列已满，入队失败\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue-&gt;data[queue-&gt;rear] = element;</span><br><span class="line">    queue-&gt;size++;</span><br><span class="line">    //queue-&gt;rear++; //存在问题，需要使用下面的方式替换</span><br><span class="line"></span><br><span class="line">    queue-&gt;rear = (queue-&gt;rear + 1) % queue-&gt;capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 元素出队列</span><br><span class="line">int dequeue(Queue *queue)</span><br><span class="line">&#123;</span><br><span class="line">    // if(queue-&gt;front == queue-&gt;rear);//此语句满足的情况：① 队列为空 ② 队列已满</span><br><span class="line">    if(queue-&gt;size == 0)&#123;</span><br><span class="line">        printf(&quot;队列为空，出队失败\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int dequeueData = queue-&gt;data[queue-&gt;front];</span><br><span class="line">    queue-&gt;size--;</span><br><span class="line"></span><br><span class="line">    queue-&gt;front = (queue-&gt;front + 1) % queue-&gt;capacity;</span><br><span class="line"></span><br><span class="line">    return dequeueData;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放队列内存</span><br><span class="line">void destroyQueue(Queue *queue)</span><br><span class="line">&#123;</span><br><span class="line">    free(queue-&gt;data);</span><br><span class="line">    queue-&gt;data = NULL;</span><br><span class="line">    queue-&gt;capacity = 0;</span><br><span class="line">    queue-&gt;size = 0;</span><br><span class="line">    queue-&gt;front = 0;</span><br><span class="line">    queue-&gt;rear = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//遍历队列</span><br><span class="line">void printQueue(Queue *queue)&#123;</span><br><span class="line">    </span><br><span class="line">    for(int i = queue-&gt;front,j = 0;j &lt; queue-&gt;size;i++,j++)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        printf(&quot;%d  &quot;,queue-&gt;data[i % queue-&gt;capacity]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Queue myQueue;</span><br><span class="line"></span><br><span class="line">    initQueue(&amp;myQueue,3);</span><br><span class="line"></span><br><span class="line">    enqueue(&amp;myQueue,1);</span><br><span class="line">    enqueue(&amp;myQueue,2);</span><br><span class="line">    enqueue(&amp;myQueue,3);</span><br><span class="line">    enqueue(&amp;myQueue,4); //已满，未入队</span><br><span class="line"></span><br><span class="line">    printQueue(&amp;myQueue);</span><br><span class="line"></span><br><span class="line">    printf(&quot;出队，元素是：%d\n&quot;,dequeue(&amp;myQueue));</span><br><span class="line">    printf(&quot;出队，元素是：%d\n&quot;,dequeue(&amp;myQueue));</span><br><span class="line"></span><br><span class="line">    printQueue(&amp;myQueue);</span><br><span class="line"></span><br><span class="line">    enqueue(&amp;myQueue,5);</span><br><span class="line">    enqueue(&amp;myQueue,6);</span><br><span class="line"></span><br><span class="line">    printQueue(&amp;myQueue);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p><img src="https://s1.vika.cn/space/2024/11/12/72fe34dc1658472cbf5d14212e1506e3" alt="image-20241112175354551"></p><p>假设一个 int 变量占 4个字节，则所需内存空间 &#x3D; 4 + 4 &#x3D; 8，则S(n) &#x3D; O(1)。</p><p><img src="https://s1.vika.cn/space/2024/11/12/4c26e3b872e54932aeac50b4e0cfc5b9" alt="image-20241112175523230"></p><p>假设一个 int 变量占 4个字节，则所需内存空间 &#x3D; 4 + 4n + 4 &#x3D; 4n + 8，则S(n) &#x3D; O(n)。</p><p><img src="https://s1.vika.cn/space/2024/11/12/18bb9907b97d432b83b835a8f999c8d4" alt="image-20241112175532793"></p><p><img src="https://s1.vika.cn/space/2024/11/12/2cb283d076a04171acfea6e1c3b8b96d" alt="image-20241112175538936"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找:"></a>顺序查找:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 顺序查找:</span><br><span class="line">int sequenceSearch(int arr[], int size, int target)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    for(int i = 0;i &lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(arr[i] == target)</span><br><span class="line">        &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return -1; //表示没有找到指定的元素 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int arr[] = &#123;23,45,76,44,22,88,9,12,22,5,80&#125;;</span><br><span class="line"></span><br><span class="line">    int size = sizeof(arr) / sizeof(int);</span><br><span class="line"></span><br><span class="line">    int target = 9;</span><br><span class="line"></span><br><span class="line">    int targetIndex = sequenceSearch(arr,size,target);</span><br><span class="line">    if(targetIndex == -1)&#123;</span><br><span class="line">        printf(&quot;未找到\n&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;找到了%d，对应的索引为%d\n&quot;,target,targetIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sizeof是运算符，返回 unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。<br>它的功能是：获得保证能容纳实现所建立的最大对象的字节大小</p><p>sizeof(ary) &#x2F; sizeof(int) &lt;&#x3D;&#x3D;&gt; sizeof(ary) &#x2F; sizeof(ary[0]) ; 得到 ary 内的元素的个数</p><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>二分查找（Binary Search）是一种高效的搜索算法，通常用于有序数据集中查找目标元素。其原理是通过将数据集划分为两半并与目标进行比较，以确定目标在哪一半中，从而逐步缩小搜索范围，直到找到目标元素或确定不存在。基本原理如下：</p><p>（1）<strong>选择中间元素：</strong> 在有序数据集中，选择数组的中间元素。</p><p>（1）<strong>比较目标：</strong> 将中间元素与目标元素进行比较。</p><p>（2）<strong>查找成功：</strong> 如果中间元素等于目标元素，则查找成功，返回中间元素的索引。</p><p>（3）<strong>缩小搜索范围：</strong> 对于一个升序的数据集，如果中间元素大于目标元素，说明目标可能在左半部分；如果中间元素小于目标元素，说明目标可能在右半部分。根据比较结果，将搜索范围缩小到一半，继续查找。</p><p>（4）<strong>重复步骤：</strong> 重复上述步骤，不断将搜索范围缩小，直到找到目标元素或搜索范围为空。</p><p>​                                   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"></span><br><span class="line">    使用二分查找法，查找数组中的元素</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int binarySearch(int arr[],int size,int target)&#123;</span><br><span class="line"></span><br><span class="line">    int low = 0;</span><br><span class="line">    int high = size - 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    while(low &lt;= high)&#123;</span><br><span class="line"></span><br><span class="line">        int middle = (low + high) / 2;</span><br><span class="line">        if(arr[middle] == target)&#123;</span><br><span class="line">            return middle;</span><br><span class="line">        &#125;else if(arr[middle] &gt; target)&#123;</span><br><span class="line">            high = middle - 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            low = middle + 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //表示未找到</span><br><span class="line">    return -1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int arr[] = &#123;4,7,9,12,16,19,22,28,34,57,69,78,90&#125;;</span><br><span class="line">    int target = 12;</span><br><span class="line">    target = 91;</span><br><span class="line">    int size = sizeof(arr) / sizeof(int);</span><br><span class="line"></span><br><span class="line">    int targetIndex = binarySearch(arr,size,target);</span><br><span class="line">    if(targetIndex == -1)&#123;</span><br><span class="line">        printf(&quot;未找到\n&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;找到了%d，对应的索引为%d\n&quot;,target,targetIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"></span><br><span class="line">    冒泡排序:实现从小到大排序</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">void bubbleSort(int arr[],int size)&#123;</span><br><span class="line"></span><br><span class="line">    //外层循环：控制轮数</span><br><span class="line">    for(int i = 0;i &lt; size - 1;i++)&#123;</span><br><span class="line"></span><br><span class="line">        //内层循环：依次比较相邻的两个元素的大小</span><br><span class="line">        for(int j = 0;j &lt; size - 1 - i;j++)&#123;</span><br><span class="line">            </span><br><span class="line">            if(arr[j] &gt; arr[j + 1])&#123;</span><br><span class="line">                //交互j 和 j+1索引位置的元素</span><br><span class="line">                int temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int arr[] = &#123;23,45,2,46,77,2,99,-9,-32,0,66&#125;;</span><br><span class="line"></span><br><span class="line">    int size = sizeof(arr) / sizeof(int);</span><br><span class="line">    //遍历</span><br><span class="line">    for(int i = 0;i &lt; size;i++)&#123;</span><br><span class="line">        printf(&quot;%d  &quot;,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    //排序</span><br><span class="line">    bubbleSort(arr,size);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //遍历</span><br><span class="line">    for(int i = 0;i &lt; size;i++)&#123;</span><br><span class="line">        printf(&quot;%d  &quot;,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">    快速排序:实现从小到大排序</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">void quickSort(int arr[], int size)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    subSort(arr, 0, size - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void subSort(int arr[], int start, int end)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (start &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        int base = arr[start];</span><br><span class="line">        int low = start;</span><br><span class="line">        int high = end + 1;</span><br><span class="line"></span><br><span class="line">        while (1)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            while (low &lt; end &amp;&amp; arr[++low] &lt;= base)</span><br><span class="line">                ; // 找到从前往后第1个比base大的元素</span><br><span class="line">            while (high &gt; start &amp;&amp; arr[--high] &gt;= base)</span><br><span class="line">                ; // 找到从后往前第1个比base小的元素</span><br><span class="line"></span><br><span class="line">            if (low &lt; high)</span><br><span class="line">            &#123;</span><br><span class="line">                // 交换low和high位置的元素</span><br><span class="line">                int temp = arr[low];</span><br><span class="line">                arr[low] = arr[high];</span><br><span class="line">                arr[high] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 交换start和high索引位置上的元素</span><br><span class="line">        int temp1 = arr[start];</span><br><span class="line">        arr[start] = arr[high];</span><br><span class="line">        arr[high] = temp1;</span><br><span class="line"></span><br><span class="line">        // 递归调用</span><br><span class="line">        subSort(arr, start, high - 1); // 前半段继续排序</span><br><span class="line">        subSort(arr, high + 1, end);   // 后半段继续排序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int arr[] = &#123;23, 45, 2, 46, 77, 2, 99, -9, -32, 0, 66&#125;;</span><br><span class="line"></span><br><span class="line">    int size = sizeof(arr) / sizeof(int);</span><br><span class="line">    // 遍历</span><br><span class="line">    for (int i = 0; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 排序</span><br><span class="line">    quickSort(arr, size);</span><br><span class="line"></span><br><span class="line">    // 遍历</span><br><span class="line">    for (int i = 0; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>车载基础知识</title>
      <link href="/2024/06/06/test/%E8%BD%A6%E8%BD%BD%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/06/06/test/%E8%BD%A6%E8%BD%BD%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/image-20250506131349931.png" alt="image-20250506150752230"></p><p><img src="/images/image-20250506131321041.png" alt="image-20250506150752230"></p><p><img src="/images/image-20250506132441378.png" alt="image-20250506150752230"></p><p><img src="/images/image-20250506132455224.png" alt="image-20250506150752230"></p><p><img src="/images/image-20250506133501197.png" alt="image-20250506150752230"></p><p><img src="/images/image-20250506133535453.png" alt="image-20250506150752230"></p><p><img src="/images/image-20250506143413334.png" alt="image-20250506150752230"></p><p>车载技术基础<br><img src="/images/image-20250506143948308.png" alt="image-20250506150752230"></p><p>更偏向软件方面</p><ol><li><strong>自动驾驶</strong>：这个领域涉及到开发和集成自动驾驶技术，包括传感器融合、决策算法、控制策略等，以实现车辆的自主导航和操作。</li><li><strong>智能座舱</strong>：智能座舱是指车辆内部的智能化系统，包括信息娱乐系统、驾驶员监控系统、乘客交互界面等，旨在提升驾驶体验和安全性。</li><li><strong>SOA和软总线</strong>：SOA（面向服务的架构）是一种软件设计模式，软总线则可能指的是软件定义的通信总线，这些技术有助于实现车辆内部不同系统之间的高效通信和集成。</li><li><strong>网络产品</strong>：这可能涉及到车辆的网络连接解决方案，包括车联网（V2X）、车载信息娱乐系统的网络服务等，以实现车辆与外部世界的连接。</li><li><strong>视觉产品</strong>：这个领域可能包括车载摄像头系统、图像处理算法等，用于车辆的环境感知、驾驶员监控、乘客识别等功能。</li><li><strong>车身控制</strong>：车身控制涉及到车辆的各种电子控制单元（ECU），如车窗控制、车内照明、车门锁定等，以实现车辆的智能化管理。<br><img src="/images/image-20250506144424064.png" alt="image-20250506150752230"></li></ol><p>汽车业务市场情况可以分为以下三个势力：</p><ol><li><strong>传统车企</strong>：<ul><li>这些是基于原有的燃油车智能化以及转型生产电动车的车企。它们通常拥有悠久的历史和深厚的技术积累，正在逐步向智能化和电动化转型。图片中列举了包括通用汽车（GM）、奥迪（Audi）、宝马（BMW）、奔驰（Mercedes-Benz）、大众（Volkswagen）、丰田（Toyota）等在内的多家知名传统汽车制造商。</li></ul></li><li><strong>新兴造车企业</strong>：<ul><li>这些是从特斯拉（Tesla）出现后，特别是国内近几年产生的全新造车企业。它们通常以电动车为主要产品，已经量产了多个车型并且拥有一定的技术积累。图片中提到的新兴造车企业包括特斯拉（Tesla）、Rivian、Lucid、蔚来（NIO）、理想（Li Auto）、小鹏汽车（XPeng Motors）、零跑汽车（Leapmotor）、威马汽车（WM Motor）等。</li></ul></li><li><strong>高技术企业</strong>：<ul><li>这些是新进入局以及较大可能进入汽车行业的高技术企业。它们可能原本并非汽车制造商，但凭借在高科技领域的技术优势，有潜力进入汽车行业。图片中提到的可能进入汽车行业的高技术企业包括苹果（Apple）、索尼（Sony）、富士康（Foxconn）、小米（Xiaomi）、华为（Huawei）等。</li></ul></li></ol><p> </p><p><img src="/images/image-20250506144652829.png" alt="image-20250506150752230"></p><ul><li><strong>主机厂，OEM，车厂</strong>：这些词都指的是那些生产和销售汽车的大公司。它们有完整的生产线，可以自己采购各种零部件，然后组装成一辆完整的汽车。就像是汽车界的“大厨”，负责把各种“食材”（零部件）做成一道“大餐”（整车）。比如北京奔驰、上汽乘用车厂、小米汽车这些。</li><li><strong>Tier1（一级供应商）</strong>：这些公司是直接给主机厂提供零部件或服务的。就像是给“大厨”提供“食材”的供应商。比如安徽智途公司可能会把他们生产的电子控制单元（ECU）卖给江淮乘用车厂，智途就是Tier1供应商；中科创达为通用汽车（GM）开发软件，中科创达也是Tier1供应商。</li><li><strong>Tier2（二级供应商）</strong>：这些公司是给Tier1供应商提供商品或服务的。就像是给“食材”供应商提供原材料的公司。比如创达南京分公司可能会为安徽智途开发软件，创达就是Tier2供应商。</li><li><strong>ECU（电子控制单元）</strong>：ECU就像是汽车的“大脑”，负责控制汽车的各种功能。它通过接收各种传感器的数据，来判断汽车的状态，然后指挥汽车的各个部分工作。比如控制发动机的运转、刹车系统的工作等等。</li></ul><p><img src="/images/image.png" alt="img"></p><p>EE架构，全称是电子电气（Electrical&#x2F;Electronic）架构，是汽车中所有电子和电气系统的框架设计。它定义了车辆内部各个电子控制单元（ECU）的布局、通信方式、功能分配以及它们如何相互作用。EE架构是汽车电子系统的核心，它直接影响到车辆的性能、安全性、舒适性和燃油效率。</p><p>随着汽车技术的发展，EE架构也在不断演进，以适应新的功能和需求，比如增加的电子设备、更复杂的传感器系统、车载信息娱乐系统、自动驾驶技术等。EE架构的演进大致可以分为以下几个阶段：</p><ol><li><strong>分布式架构</strong>：<ul><li>在这个阶段，汽车的每个功能都有自己的电子控制单元（ECU）。这些ECU是独立的，通过CAN（控制器局域网）或LIN（局域互联网络）总线通信。</li><li>每个ECU都有自己的传感器和算法，它们之间的通信不多。</li><li>这种架构的缺点是布线复杂，需要大量的内部通信，导致成本增加。</li></ul></li><li><strong>域集中式架构</strong>：<ul><li>这个阶段将汽车的电子部件功能划分为几个域，如动力域、底盘域、座舱域、驾驶域和车身控制域。</li><li>每个域都有自己的域控制器，域控制器通过CAN或以太网（Ethernet）网络将分散的ECU集中到一起。</li><li>这种架构的优点是更容易实现OTA（空中下载）升级，提高运算能力，支持更灵活的通信网络，同时对信息安全和功能安全的要求更高。</li></ul></li><li><strong>中央集中式架构</strong>：<ul><li>在这个阶段，主控制器的运算能力进一步提高，出现了超级电脑的设计。</li><li>整个系统中复杂的运算功能都集中到一个设备上，这个设备配置有强大的CPU和运算加速器，可以更有效地利用硬件性能。</li><li>这种架构的优点是简化了布线设计，降低了成本，同时支持软件功能的迭代与扩展。</li></ul></li></ol><p><img src="/images/image-20250506145833055.png" alt="image-20250506145833055"></p><p><img src="/images/image-20250506150752230.png" alt="image-20250506150752230"></p><ol><li><strong>SOP</strong>：Start of Production的缩写，指的是芯片开始量产的时间。</li></ol><p><img src="/images/image-20250506153008648.png" alt="image-20250506153008648"></p><ol><li><strong>处理器</strong>：<ul><li>包括CPU（中央处理器）、GPU（图形处理器）、NPU（神经网络加速器）等，就像是电脑的大脑，负责思考和处理各种信息。</li><li>处理视频、音频等，就像是电脑处理图片和声音一样。</li><li>有各种接口，可以连接摄像头、麦克风等设备，就像是电脑的USB接口可以连接鼠标、键盘。</li></ul></li><li><strong>存储器</strong>：<ul><li>RAM（随机访问存储器）：就像是电脑的内存，用来临时存放正在处理的数据，断电后数据会消失。</li><li>ROM（只读存储器）：包括SSD、Flash、SD卡、硬盘等，用来长期存放数据，断电后数据不会消失。</li></ul></li><li><strong>安全和控制系统</strong>：<ul><li>就像是电脑的安全软件，负责保护系统安全，防止未经授权的访问。</li><li>控制电源管理，就像是电脑的电源管理功能，控制电源的开关和分配。</li></ul></li><li><strong>通信部分</strong>：<ul><li>板子内部通信接口：就像是电脑内部的连接线，用来连接不同的部件。</li><li>外部通信接口：包括LVDS、USB、CAN、以太网等，用来连接显示屏、摄像头和其他电子控制单元（ECU），就像是电脑连接显示器、打印机等设备。</li><li>座舱平台需要处理大量的音视频数据，所以接口的带宽（数据传输速度）很高。</li></ul></li></ol><p><img src="/images/image-20250506153500766.png" alt="image-20250506153500766"></p><p><img src="/images/image-1746517001188-3.png" alt="img"></p><p>音频系统</p><ol><li><strong>通过板载音频DSP和功放</strong>：<ul><li>板载音频DSP（数字信号处理器）就像是音频系统的大脑，负责处理音频信号，比如调整音量、平衡、音效等。</li><li>功放（功率放大器）则负责将音频信号放大，以便能够驱动扬声器发出声音。</li><li>在这种连接方式中，音频DSP和功放都集成在同一个电路板上，通过I2S&#x2F;TDM（一种音频数据传输协议）与SoC（系统级芯片）通信。</li></ul></li><li><strong>通过外部音频DSP和功放</strong>：<ul><li>在这种方式中，音频DSP和功放是分开的，位于不同的电路板上。</li><li>SoC通过I2S&#x2F;TDM与外部DSP通信，DSP再通过I2C（一种简单的串行通信协议）与功放通信。</li><li>这种方式提供了更大的灵活性，因为DSP和功放可以独立选择和更换。</li></ul></li><li><strong>通过芯片内部的DSP处理音效</strong>：<ul><li>在这种方式中，SoC内部集成了DSP，可以直接处理音频信号。</li><li>音频信号通过I2S&#x2F;TDM传输到SoC内部的DSP进行处理，然后通过I2C与音频DAC&#x2F;ADC（数字模拟转换器&#x2F;模拟数字转换器）通信，最后通过内部功放输出到扬声器。</li><li>这种方式简化了系统设计，因为所有功能都集成在SoC内部。</li></ul></li></ol><p>自动驾驶</p><p><img src="/images/image-20250506154033968.png" alt="image-20250506154033968"></p><p>要认真对待 </p><p><img src="/images/image-20250506160335715.png" alt="image-20250506160335715"></p><p><img src="/images/image-20250506160819356.png" alt="image-20250506160819356"></p><h1 id="故障分析"><a href="#故障分析" class="headerlink" title="故障分析"></a>故障分析</h1><p><img src="/images/image-20250513140813946.png" alt="image-20250513140813946"></p><p><img src="/images/image-20250513141619558.png" alt="image-20250513141619558"></p><p><img src="/images/image-20250513143344174.png" alt="image-20250513143344174"></p><p><img src="/images/image-20250513143428524.png" alt="image-20250513143428524"></p><p>​</p><p><img src="/images/image-20250513143815538.png" alt="image-20250513143815538"></p><p><img src="/images/image-20250513144051469.png" alt="image-20250513144051469"></p><p>根本原因分析（RCA）是一种结构化的问题解决方法，旨在通过识别、分析和解决根本原因来防止问题再次发生。该方法具有三个主要优点：能够明确问题定义，清晰地识别和说明问题的因果关系，以及有效定位问题的真正根源。实施RCA的基本步骤包括：首先把握现状，识别和澄清问题；其次进行原因调查，探究为何问题未被及时发现；然后进行问题纠正，采取措施处理导致问题的根本原因；最后是再发防止，通过改进措施确保问题不会重复发生。此外，该方法还包括对问题发生的不同层面进行分析，从直接原因到根本原因，以及制定相应的对策来防止问题再次流出。</p><h1 id="开发环境之——git与repo的使用＜1＞"><a href="#开发环境之——git与repo的使用＜1＞" class="headerlink" title="开发环境之——git与repo的使用＜1＞"></a>开发环境之——git与repo的使用＜1＞</h1><p><img src="/images/image-20250513144831104.png" alt="image-20250513144831104"></p><p>版本控制系统是一种用于记录文件内容变化并帮助实现版本控制的系统，它可以让用户在未来查阅特定版本的修订情况。根据其架构和工作方式，版本控制系统可以分为三种类型：本地版本控制系统（RCS），集中式版本控制系统（如CVS、SVN、Perforce），以及分布式版本控制系统（如Git、Mercurial、Bazaar、Darcs、BitKeeper）。这些系统帮助团队有效地管理代码和文档的变更历史，确保项目的协作和版本追踪。</p><p><img src="/images/image-20250513150040756.png" alt="image-20250513150040756"></p><p>分布式版本控制系统是一种允许每个用户计算机上都保存有完整的版本历史记录的系统，它不依赖于中央服务器来存储所有的版本信息。在这种系统中，每个用户的计算机（如Computer A和Computer B）都可以独立地保存文件的所有版本，包括版本1、版本2和版本3。这样的设计提高了系统的灵活性和容错性，因为即使中央服务器出现问题，各个用户的计算机上仍然可以访问到完整的版本历史。此外，这种系统还支持用户在没有网络连接的情况下工作，并且可以在任何时候与其他用户的版本进行合并和同步，从而促进了协作和版本控制的效率。</p><p><img src="/images/image-20250513150658075.png" alt="image-20250513150658075"></p><p>Git是一个由Linus Torvalds在2005年开发的分布式版本控制系统，旨在支持Linux kernel项目。它允许用户在本地计算机上建立一个空目录，并从远程服务器同步一个或多个项目的内容，每个工作目录都是项目的完整拷贝，包含全部的版本历史信息。使用Git时，用户可以在不需要联网的情况下查看文件的变化和进行提交操作，这使得Git非常适合分布式协作和版本控制。</p><p>git不需要联网</p><p>Git 作为一个分布式版本控制系统，其设计允许用户在本地进行大部分的操作，这意味着在很多情况下，确实不需要联网。用户可以在本地仓库中进行文件的版本控制操作，如提交（commit）、查看历史记录（log）、分支（branch）和合并（merge）等，这些操作都不需要网络连接。</p><p>然而，Git 的强大之处也在于它支持远程仓库的管理。当你需要与他人协作或者将你的代码推送（push）到远程仓库（如GitHub、GitLab等），或者从远程仓库拉取（pull）最新的代码时，就需要联网。此外，一些Git命令，如克隆（clone）一个远程仓库，或者与远程仓库进行交互的命令（如fetch、pull、push），也需要网络连接。</p><p><img src="/images/image-20250513150908742.png" alt="image-20250513150908742"></p><p><img src="/images/image-20250513150957026.png" alt="image-20250513150957026"></p><p><img src="/images/image-20250513151131934.png" alt="image-20250513151131934"></p><h4 id="为什么使用git"><a href="#为什么使用git" class="headerlink" title="为什么使用git"></a>为什么使用git</h4><p>Git是一个高效且设计简单的分布式版本控制系统，它能够支持大规模项目如Linux内核的开发，允许上千个并行开发的分支。Git的一个显著特点是它直接快照文件系统的状态，而不是比较文件差异，这样可以更高效地管理版本。几乎所有的操作都可以在本地执行，不需要联网，这使得Git在本地磁盘上保存着所有有关当前项目的历史更新。Git还通过计算内容的校验和（checksum）来保持数据的完整性，确保数据的唯一标识和索引。此外，Git的多数操作仅涉及将数据添加到数据库，这进一步增强了其性能和可靠性。这些特性使得Git成为现代软件开发中不可或缺的工具。</p><p><img src="/images/image-20250513151304914.png" alt="image-20250513151304914"></p><p>git的三种状态、3个工作区域</p><p>Git通过三种状态和三个工作区域来管理文件和项目版本。三种状态包括：已提交（committed），表示文件已经被安全地保存在本地数据库中；已修改（modified），表示文件自上次提交后已经发生了变化，但还没有保存到数据库；已暂存（staged），表示文件的当前修改已被标记，准备在下一次提交时保存到数据库。</p><p>三个工作区域分别是：本地数据目录，即项目的完整历史记录；工作目录，即项目文件的当前工作副本；暂存区域，即索引文件，用于暂存下次提交要保存的文件列表。</p><p>Git的工作流程通常包括以下步骤：首先从本地数据目录检出项目到工作目录，然后在工作目录中对文件进行修改，接着将修改后的文件暂存，最后将暂存的文件提交到本地数据目录，完成一次版本更新。这个过程确保了文件的变更被有序地管理和记录，便于后续的版本控制和协作开发。</p><p><img src="/images/image-20250513151429998.png" alt="image-20250513151429998"></p><p>在Git中，分支是指项目的不同开发版本，它们共享一个共同的历史记录，但每个分支可以独立地发展自己的历史。分支的创建总是从某个已有的提交（通常是主分支）开始，然后从那个点分叉出去，形成新的发展路径。这种机制允许开发者在不影响主分支的情况下进行实验性开发或修复bug。图中展示了项目的原始开发线（Original line of development），以及从这条线上分出的三个分支（1st branch、2nd branch、3rd branch），每个分支都代表了项目的一个不同发展方向。通过这种方式，Git支持并行开发和灵活的项目管理。</p><p><img src="/images/image-20250513152442097.png" alt="image-20250513152442097"><img src="/images/image-20250513152502889.png" alt="image-20250513152502889"></p><p>Git中的分支机制允许开发者从项目的任何提交点创建新的分支，每个分支都代表项目的一个独立开发路径。分支的创建和销毁成本非常低，这使得它们非常适合用于实验性开发、特性开发或修复bug等任务。</p><p>在Git中，每个提交（commit）都可以建立分支，这意味着开发者可以从项目的任何历史点分叉出新的开发线。分支的创建是通过指向提交的可变指针来实现的，这些指针可以移动到不同的提交，从而形成不同的开发路径。每个分支都有自己的历史，但它们可以共享共同的提交历史。</p><p>图中展示了Git分支的工作原理：</p><ol><li>第一张图展示了一个项目的提交历史，其中包含了多个分支（如master、testing、1st branch、2nd branch、3rd branch）。每个分支都从某个提交点开始，然后发展自己的历史。</li><li>第二张图展示了从master分支创建新分支的过程。每个提交（如f30ab、34ac2、98ca9）都可以作为新分支的起点，新分支可以独立地进行开发，而不会影响其他分支。</li></ol><p><img src="/images/image-20250513152626995.png" alt="image-20250513152626995"></p><p>使用例子</p><p>在Git中，分支的使用允许开发者在不影响主分支的情况下处理不同的开发任务。例如，在正常开发过程中，如果需要解决一个特定的问题（如问题#53），但又不能干扰主分支，可以创建一个新的分支专门用于这个问题的修复。在这个新分支上，开发者可以提交修复代码，而主分支则可以继续其正常的开发流程。</p><p>当紧急修复完成时，可以通过合并操作将这个分支的更改整合回主分支。这种策略不仅提高了开发效率，还确保了主分支的稳定性。通过这种方式，Git的分支机制支持并行开发和灵活的问题处理，使得项目管理更加高效和有序。</p><h4 id="GIT分支合并及冲突解决"><a href="#GIT分支合并及冲突解决" class="headerlink" title="GIT分支合并及冲突解决"></a>GIT分支合并及冲突解决</h4><h3 id="Git分支合并"><a href="#Git分支合并" class="headerlink" title="Git分支合并"></a>Git分支合并</h3><p>分支合并是Git中一个非常常见的操作，它允许开发者将一个分支的更改整合到另一个分支中。这通常发生在开发新功能或修复问题时，开发者会在一个单独的分支上进行工作，然后将这些更改合并回主分支（如<code>main</code>或<code>master</code>）。</p><h4 id="使用git-merge命令"><a href="#使用git-merge命令" class="headerlink" title="使用git merge命令"></a>使用<code>git merge</code>命令</h4><p>最直接的分支合并方式是使用<code>git merge</code>命令。假设你有两个分支：<code>main</code>和<code>feature</code>，你在<code>feature</code>分支上开发了一些新功能，现在想要将这些更改合并到<code>main</code>分支。首先，你需要切换到<code>main</code>分支，使用命令<code>git checkout main</code>。然后，执行<code>git merge feature</code>，Git会尝试将<code>feature</code>分支的更改合并到<code>main</code>分支。如果合并过程中没有冲突，Git会自动完成合并，并创建一个新的合并提交。这个合并提交会记录两个分支的合并历史，使得代码的变更过程更加清晰。</p><h4 id="使用git-rebase命令"><a href="#使用git-rebase命令" class="headerlink" title="使用git rebase命令"></a>使用<code>git rebase</code>命令</h4><p>除了<code>git merge</code>，<code>git rebase</code>也是一种常用的分支合并方式。<code>git rebase</code>的作用是将当前分支的更改重新应用到另一个分支的顶部。例如，如果你希望让<code>feature</code>分支的更改基于<code>main</code>分支的最新状态，可以执行<code>git rebase main</code>。这样，<code>feature</code>分支的提交会重新应用到<code>main</code>分支的最新提交之后。这种方式可以使<code>feature</code>分支的提交历史更加清晰，避免了复杂的合并提交。在完成<code>rebase</code>之后，你可以使用<code>git merge</code>将<code>feature</code>分支合并到<code>main</code>分支，或者直接将<code>feature</code>分支的更改推送到远程仓库（如果<code>feature</code>分支已经推送到远程仓库）。</p><hr><h3 id="Git冲突解决"><a href="#Git冲突解决" class="headerlink" title="Git冲突解决"></a>Git冲突解决</h3><p>尽管Git在合并分支时会尽量自动处理更改，但当多个分支对同一部分代码进行了不同的更改时，合并过程中可能会出现冲突。冲突需要手动解决，以下是解决冲突的详细步骤：</p><h4 id="查看冲突"><a href="#查看冲突" class="headerlink" title="查看冲突"></a>查看冲突</h4><p>当合并分支时，如果出现冲突，Git会在冲突的文件中标记冲突的内容。冲突的文件中会包含如下标记：<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>表示当前分支的更改，<code>=======</code>是分隔符，表示冲突的分界点，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>表示另一个分支的更改。例如，冲突的代码可能看起来像这样：</p><p>plaintext</p><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">当前分支的代码</span><br><span class="line">=======</span><br><span class="line">另一个分支的代码</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature</span><br></pre></td></tr></table></figure><p>你可以使用<code>git status</code>命令查看哪些文件存在冲突。Git会明确指出哪些文件需要解决冲突。</p><h4 id="手动解决冲突"><a href="#手动解决冲突" class="headerlink" title="手动解决冲突"></a>手动解决冲突</h4><p>解决冲突通常需要手动编辑冲突的文件。打开冲突的文件，根据实际情况选择保留、修改或删除冲突的内容。例如，如果决定保留当前分支的更改，则删除<code>=======</code>和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>之间的内容，以及<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>和<code>=======</code>之间的标记。如果决定采用另一个分支的更改，则删除<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>和<code>=======</code>之间的内容，以及<code>=======</code>和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>之间的标记。当然，也可以根据需要对代码进行修改，以整合两个分支的更改。</p><h4 id="标记冲突解决"><a href="#标记冲突解决" class="headerlink" title="标记冲突解决"></a>标记冲突解决</h4><p>在解决冲突后，需要使用<code>git add &lt;file&gt;</code>命令将冲突的文件标记为已解决。这一步非常重要，因为Git需要知道冲突已经被处理。之后，执行<code>git commit</code>命令完成合并提交。如果你使用的是<code>git rebase</code>，在解决冲突后，还需要执行<code>git rebase --continue</code>继续<code>rebase</code>过程。</p><h4 id="使用工具辅助解决冲突"><a href="#使用工具辅助解决冲突" class="headerlink" title="使用工具辅助解决冲突"></a>使用工具辅助解决冲突</h4><p>Git支持使用图形化工具来解决冲突，这可以大大简化冲突解决的过程。例如，你可以使用<code>git mergetool</code>命令，Git会自动启动配置的合并工具（如<code>meld</code>、<code>kdiff3</code>等）。在工具中，你可以直观地比较和选择保留或修改冲突的内容。工具会自动将解决后的文件标记为已解决，从而避免了手动编辑文件和标记解决的繁琐过程。</p><hr><p>通过以上方法，你可以有效地进行Git分支合并和冲突解决，从而更好地管理代码版本。分支合并和冲突解决是团队协作开发中不可或缺的部分，掌握这些技能可以帮助你更高效地进行代码管理和协作</p><p><img src="/images/image-20250513210431768.png" alt="image-20250513210431768"></p><p>Repo工具确实是专门为Android操作系统设计的，用于管理多个Git仓库。以下是Repo工具的一些关键信息和用途：</p><ol><li><strong>多仓库管理</strong>：Repo是一个基于Python的脚本工具，它封装了多条Git命令，帮助开发者管理Android源码中的多个Git仓库。这对于大型项目和团队协作尤为重要。</li><li><strong>初始化和同步</strong>：使用<code>repo init</code>命令初始化项目，该命令会读取一个叫做<code>manifest</code>的XML配置文件，定义了项目中需要的Git仓库和版本。<code>repo sync</code>命令用于同步代码，克隆或更新项目中所有Git仓库。</li><li><strong>分支操作</strong>：<code>repo start &lt;branch_name&gt; --all</code>命令用于在所有仓库中创建新的本地分支，便于跨模块开发。</li><li><strong>代码审查</strong>：<code>repo upload</code>命令将本地提交推送到代码审核平台（如Gerrit），自动关联多个子仓库的变更，确保依赖关系正确。</li><li><strong>清单文件（Manifest）</strong>：Repo使用清单文件定义所有子仓库的版本、分支和依赖关系，简化了开发者的代码同步、提交和代码审核流程。</li><li><strong>与Gerrit集成</strong>：Repo与Gerrit代码审核系统集成，简化了代码审核和合并流程。</li><li><strong>解决冲突</strong>：Repo工具提供了解决冲突的场景，如本地代码过期、跨仓库依赖冲突等。</li><li><strong>下载和安装</strong>：Repo工具可以从官方的Git仓库下载，并且可以通过简单的命令添加到系统的PATH变量中，以便在终端中使用。</li></ol><p>git常用命令</p><p><img src="/images/image-20250513210758616.png" alt="image-20250513210758616"></p><p>克隆远程现有仓库：<br>repository_ur是远程仓库地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repository_url&gt; </span><br></pre></td></tr></table></figure><p><img src="/images/5a1381440c5449d486613ab1d72dd8b0.png" alt="在这里插入图片描述"></p><p>Jenkins、Opengrok、JIRA的使用</p><h3 id="1-JIRA"><a href="#1-JIRA" class="headerlink" title="1. JIRA"></a>1. <strong>JIRA</strong></h3><ul><li><strong>功能</strong>：项目管理和问题跟踪工具。</li><li><strong>嵌入式开发中的作用</strong>：<ul><li>管理需求、任务和缺陷。</li><li>跟踪硬件和软件开发进度。</li><li>支持敏捷开发流程。</li></ul></li></ul><h3 id="2-Jenkins"><a href="#2-Jenkins" class="headerlink" title="2. Jenkins"></a>2. <strong>Jenkins</strong></h3><ul><li><strong>功能</strong>：持续集成（CI）和持续部署（CD）工具。</li><li><strong>嵌入式开发中的作用</strong>：<ul><li>自动化构建和测试嵌入式软件。</li><li>确保代码更新后符合质量标准。</li><li>提高开发效率和交付速度。</li></ul></li></ul><h3 id="3-OpenGrok"><a href="#3-OpenGrok" class="headerlink" title="3. OpenGrok"></a>3. <strong>OpenGrok</strong></h3><ul><li><strong>功能</strong>：代码搜索和交叉引用工具。</li><li><strong>嵌入式开发中的作用</strong>：<ul><li>快速查找和理解复杂代码。</li><li>提供代码版本历史信息。</li><li>帮助开发人员定位问题。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>JIRA</strong> 用于项目管理和问题跟踪。</li><li><strong>Jenkins</strong> 用于自动化构建和测试。</li><li><strong>OpenGrok</strong> 用于代码搜索和理解。 这三种工具在嵌入式开发中可以相互配合，提升开发效率和产品质量。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 车载基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 车载基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2024/06/06/test/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/06/06/test/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="写嵌入式用的到数据结构吗？"><a href="#写嵌入式用的到数据结构吗？" class="headerlink" title="写嵌入式用的到数据结构吗？"></a>写嵌入式用的到数据结构吗？</h1><p>看下linux内核就知道了，一堆数据结构，不学习数据结构，linux内核就看不懂了</p><p>使用数据结构是为了使代码结构更清晰，更容易把握代码结构、逻辑。</p><p>几个应用场景</p><ol><li><p>“数组”。你肯定用过吧，属于数据结构“线性表”的一种形式。</p><p><img src="/2024/06/06/test/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241112202136552.png" alt="image-20241112202136552" style="zoom:50%;"><img src="/2024/06/06/test/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241112202215843.png" alt="image-20241112202215843" style="zoom:50%;"></p></li><li></li><li><p>“结构体”。学习过lwip可以知道从以太网上接收一堆数据后，把数据头的地址幅值给以太网包的数据结构定义的指针，可以直接使用此指针-&gt;成员变量的方式，使用接收到的数据。比使用一堆变量来利用接收到的数据方便太多了。</p></li><li><p>“队列”。热敏电阻测温，单片机用ADC测量电阻分压电压，然后对测量值用平滑均值滤波算法滤波，此时会用到“队列”，或用“环形队列”；</p></li><li><p>“树”。项目中经常会使用液晶屏作为显示，其中文本菜单有时用的比较多的一种方式，其中文本菜单常用“树”结构来实现。</p></li><li><p>“栈”。就不用说了，你已经用过了，不过不是你主动用的，它隐藏在你每次函数调用、中断调用中，可能你没有意识到。</p></li></ol><p>简单几个例子，说明了数据结构非常常见，这个是必须要学的，不过有些不常用，比如图。</p><h3 id="1-【简答题】请写出至少两种野指针的成因"><a href="#1-【简答题】请写出至少两种野指针的成因" class="headerlink" title="1.   【简答题】请写出至少两种野指针的成因"></a>1.   【简答题】请写出至少两种野指针的成因</h3><p>【答案】</p><p>（1）指针使用前未初始化</p><p>（2）指针越界访问</p><p>（3）指针指针已经释放的空间</p><h3 id="2-【简答题】非静态局部变量、全局变量、malloc-动态分配的内存分别存储在内存的什么区域。"><a href="#2-【简答题】非静态局部变量、全局变量、malloc-动态分配的内存分别存储在内存的什么区域。" class="headerlink" title="2.   【简答题】非静态局部变量、全局变量、malloc()动态分配的内存分别存储在内存的什么区域。"></a>2.   【简答题】非静态局部变量、全局变量、malloc()动态分配的内存分别存储在内存的什么区域。</h3><p>【答案】</p><p>（1）非静态局部变量存储在内存的栈区域。</p><p>（1）全局变量存储在内存的全局静态区。</p><p>（2）malloc()动态分配的内存存储在内存的堆区域。</p><h1 id="一、数据结构与算法的层次要求："><a href="#一、数据结构与算法的层次要求：" class="headerlink" title="一、数据结构与算法的层次要求："></a>一、数据结构与算法的层次要求：</h1><p>层次1：熟悉各种不同的数据结构：顺序表（一维数组）、链表、栈、队列；森林、树、二叉树；图等<br>      了解不同的数据结构的特点、如何存储、优缺点等</p><p>层次2：如何编写相关的代码，实现对应的数据结构。（需要考虑对应的增、删、改、查、长度、遍历等）</p><p>层次3：算法层面的训练。 —&gt; leetcode （力扣app）、牛客网等。 300+道打底</p><img src="https://s1.vika.cn/space/2024/11/12/bb5ee404f183423782032597b88580fc" alt="image-20241112200556715"><h1 id="二、针对于层次1："><a href="#二、针对于层次1：" class="headerlink" title="二、针对于层次1："></a>二、针对于层次1：</h1><ol><li><p>什么是数据结构？   datastructure   (D-&gt;S)</p><blockquote><p>数据 +  结构<br>数据：多个相同类型的数据或变量<br>结构：即关系<br>目的：为了更高效的访问数据</p></blockquote></li><li><p>数据结构中有哪些内容？即问研究方向？<br>研究方向1：数据之间的逻辑关系</p><blockquote><p>线性关系:（一对一的关系）。比如：顺序表、链表、栈、队列、数组、字符串、广义表等<br>非线性关系：集合关系、树形关系（一对多的关系）、图形关系（多对多的关系）</p></blockquote></li></ol><p>研究方向2：数据的存储结构（或物理结构）<br>    &gt; 基本的两种：顺序存储结构、链式存储结构<br>    &gt; 拓展的两种：索引存储结构、哈希存储结构(散列存储结构)<br>研究方向3：数据之间的运算：增、删、改、查(CRUD)</p><h1 id="三、具体的不同的数据结构的实现（对应着层次2）"><a href="#三、具体的不同的数据结构的实现（对应着层次2）" class="headerlink" title="三、具体的不同的数据结构的实现（对应着层次2）"></a>三、具体的不同的数据结构的实现（对应着层次2）</h1><ol><li><p>数组的实现和相关算法的封装。</p></li><li><p>链表的实现和相关算法的封装。</p><p>   ​                 优点                                      缺点</p><blockquote><p>数组 通过索引查找、修改效率高：O(1)  插入、删除的效率差：O(n)</p><p>​同样大小的内存，数组可以存储更多的数据  当数据存满时，需要考虑扩容</p></blockquote><blockquote><p>链表   插入、删除效率高：O(1) 通过索引查找、修改效率低：O(n)  </p><p>​ 不需要考虑扩容问题   同样大小的内存，链表存储的数据较数组少</p></blockquote></li></ol><h2 id="如何理解数据结构"><a href="#如何理解数据结构" class="headerlink" title="如何理解数据结构"></a>如何理解数据结构</h2><h4 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h4><p>1.数据结构定义：研究多个变量之间的结构，即数据与数据之间的关系。</p><p> 2.研究目的：高效地进行数据的操作，如增删改查。</p><h4 id="数据结构的主要内容"><a href="#数据结构的主要内容" class="headerlink" title="数据结构的主要内容"></a>数据结构的主要内容</h4><p>1.逻辑结构：研究数据之间的逻辑关系，分为集合关系、线性关系、树形关系和网状关系。 </p><p>2.存储结构：研究数据在实际编程语言中的存储方式，分为顺序存储和链式存储。 </p><p>3.运算：基于存储结构，研究数据的增删改查等操作。</p><h4 id="线性结构和非线性结构"><a href="#线性结构和非线性结构" class="headerlink" title="线性结构和非线性结构"></a>线性结构和非线性结构</h4><p>1.线性结构：如顺序表、链表、栈、队列、数组、广义表等。</p><p> 2.非线性结构：如集合、树、图等。</p><h4 id="存储结构的两种基本形式"><a href="#存储结构的两种基本形式" class="headerlink" title="存储结构的两种基本形式"></a>存储结构的两种基本形式</h4><p>1.顺序存储：将数据元素依次排列，通过数组等方式实现。 </p><p>2.链式存储：通过链表方式，每个元素包含指向下一个元素的指针。</p><p> 3.索引存储结构和哈希存储结构：基于顺序存储和链式存储的组合。</p><img src="https://s1.vika.cn/space/2024/11/12/ad74377b36704d109dd9765a42b58faa" alt="image-20241112202757865" style="zoom:50%;"><img src="/2024/06/06/test/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241112202851334.png" alt="image-20241112202851334" style="zoom:50%;"><h1 id="线性结构之数组"><a href="#线性结构之数组" class="headerlink" title="线性结构之数组"></a>线性结构之数组</h1><p><strong>优</strong> <strong>点</strong></p><p>Ø 查找容易（通过下标），时间复杂度为O(1)。不需要额外申请或删除空间。</p><p>Ø 使用下标位置索引(index)十分高效的访问任意元素，修改快</p><p><img src="https://s1.vika.cn/space/2024/11/12/48ec67a0d691481bab93fce23ca5fb1f" alt="image-20241105203354020"></p><p><strong>缺</strong> <strong>点</strong></p><p>Ø 插入、删除元素难，效率低。（需要移动大量元素以使元素空间连续）。</p><p>Ø 插入操作平均需要移动n&#x2F;2个元素。</p><p>Ø 删除操作平均需要移动(n-1)&#x2F;2个元素。</p><p>​                             <img src="https://s1.vika.cn/space/2024/11/12/4dcfedcbb1a2444397856fa27a77c364" alt="image-20241105203403567">     </p><p>Ø 扩展相对繁琐。一方面需要确保能提供更大区域的连续内存空间，另一方面需要将原有数据复制到新的顺序表中。</p><p>1.1.1 功能定义</p><p>前文提到过数组这一数据结构的一个局限性是长度固定，本节我们来实现一个增强版的数组——可变长的动态数组，需要实现以下函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//初始化动态数组</span><br><span class="line">void initDynamicArray(DynamicArray *array, size_t initialCapacity)</span><br><span class="line">//释放动态数组内存</span><br><span class="line">void destroyDynamicArray(DynamicArray *array)</span><br><span class="line">//调整动态数组内存大小</span><br><span class="line">void resizeDynamicArray(DynamicArray *array, size_t newCapacity)</span><br><span class="line">//获取动态数组长度（元素个数）</span><br><span class="line">size_t getLength(const DynamicArray *array)</span><br><span class="line">//在指定位置插入新元素</span><br><span class="line">void insertAt(DynamicArray *array, size_t index, int element)</span><br><span class="line">//在末尾插入新元素</span><br><span class="line">void insertEnd(DynamicArray *array, int element)</span><br><span class="line">//删除指定位置的元素并返回被删除的元素</span><br><span class="line">int deleteAt(DynamicArray *array, size_t index)</span><br><span class="line">//删除末尾的元素并返回被删除的元素</span><br><span class="line">int deleteEnd(DynamicArray *array)</span><br><span class="line">//遍历所有的元素</span><br><span class="line">void print(DynamicArray *array)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-1-1-实现原理"><a href="#1-1-1-实现原理" class="headerlink" title="1.1.1 实现原理"></a>1.1.1 实现原理</h2><p>可变长的动态数组是一种数据结构，它允许在运行时根据需要动态地调整数组的大小，而不需要提前指定固定的大小。这种动态数组通常被称为动态数组、动态分配数组、动态增长数组或动态内存数组。int arr[10];  </p><p>C语言中是通过使用指针和内存分配函数来实现动态数组，常见的内存分配函数是<code>malloc</code>、<code>realloc</code>和<code>free</code>。下面是一些相关的概念和操作：</p><p>（1）<strong>分配内存（malloc）：</strong> 在C语言中，可以使用<code>malloc</code>函数来分配一块指定大小的内存。例如，<code>int *arr = (int *)malloc(n * sizeof(int));</code> 将分配能够存储<code>n</code>个整数的内存空间。</p><p>（2）<strong>重新分配内存（realloc）：</strong> 如果需要改变动态数组的大小，可以使用<code>realloc</code>函数来重新分配内存。这允许你在保留原有数据的情况下扩展或缩小数组的大小。</p><p>（3）<strong>释放内存（free</strong>）： 当不再需要动态数组时，应使用<code>free</code>函数释放之前分配的内存，以避免内存泄露。à 内存溢出</p><p>代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">// 动态数组结构体</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int *data;       // 指向动态数组的指针</span><br><span class="line">    size_t size;     // 当前数组中的元素个数</span><br><span class="line">    size_t capacity; // 当前数组的容量（可以容纳的最大元素个数）</span><br><span class="line">&#125; DynamicArray;</span><br><span class="line"></span><br><span class="line">// 初始化动态数组</span><br><span class="line">void initDynamicArray(DynamicArray *array, size_t initialCapacity)</span><br><span class="line">&#123;     //分配内存（malloc）</span><br><span class="line">    array-&gt;data = (int *)malloc(initialCapacity * sizeof(int)); // 分配初始内存</span><br><span class="line">    array-&gt;size = 0;       // 初始化元素个数为0</span><br><span class="line">    array-&gt;capacity = initialCapacity;     // 设置初始容量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放动态数组内存</span><br><span class="line">void destroyDynamicArray(DynamicArray *array)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    //释放内存（free）</span><br><span class="line">    free(array-&gt;data);   // 释放动态数组内存</span><br><span class="line">    array-&gt;size = 0;     // 重置元素个数为0</span><br><span class="line">    array-&gt;capacity = 0; // 重置容量为0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调整动态数组内存大小</span><br><span class="line">void resizeDynamicArray(DynamicArray *array, size_t newCapacity)</span><br><span class="line">&#123; //重新分配内存（realloc）</span><br><span class="line">    array-&gt;data = (int *)realloc(array-&gt;data, newCapacity * sizeof(int)); // 调整数组内存大小  </span><br><span class="line">    array-&gt;capacity = newCapacity;       // 更新容量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取动态数组长度（元素个数）</span><br><span class="line">size_t getLength(const DynamicArray *array)</span><br><span class="line">&#123;</span><br><span class="line">    return array-&gt;size; // 返回数组中的元素个数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在指定位置插入新元素</span><br><span class="line">void insertAt(DynamicArray *array, size_t index, int element)</span><br><span class="line">&#123;</span><br><span class="line">    if (index &gt; array-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        return; // 忽略无效的插入位置</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (array-&gt;size &gt;= array-&gt;capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t newCapacity = array-&gt;capacity * 2; // 如果容量不足，扩大容量</span><br><span class="line">        resizeDynamicArray(array, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (size_t i = array-&gt;size; i &gt; index; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        array-&gt;data[i] = array-&gt;data[i - 1]; // 后移元素以腾出插入位置</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array-&gt;data[index] = element; // 在指定位置插入新元素</span><br><span class="line">    array-&gt;size++;                // 更新元素个数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在末尾插入新元素</span><br><span class="line">void insertEnd(DynamicArray *array, int element)</span><br><span class="line">&#123;</span><br><span class="line">    insertAt(array, array-&gt;size, element); // 在末尾插入新元素</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除指定位置的元素并返回被删除的元素</span><br><span class="line">int deleteAt(DynamicArray *array, size_t index)</span><br><span class="line">&#123;</span><br><span class="line">    if (index &gt;= array-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        return -1; // 忽略无效的删除位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    int deletedElement = array-&gt;data[index]; // 获取被删除的元素</span><br><span class="line"></span><br><span class="line">    for (size_t i = index; i &lt; array-&gt;size - 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        array-&gt;data[i] = array-&gt;data[i + 1]; // 前移元素以填补删除位置</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array-&gt;size--; // 更新元素个数</span><br><span class="line"></span><br><span class="line">    return deletedElement; // 返回被删除的元素</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除末尾的元素并返回被删除的元素</span><br><span class="line">int deleteEnd(DynamicArray *array)</span><br><span class="line">&#123;</span><br><span class="line">    return deleteAt(array, array-&gt;size - 1); // 删除末尾的元素</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历所有的元素</span><br><span class="line">void print(DynamicArray *array)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; array-&gt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;, array-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    DynamicArray myArray; // 声明动态数组</span><br><span class="line"></span><br><span class="line">    // 初始化动态数组</span><br><span class="line">    initDynamicArray(&amp;myArray, 2);</span><br><span class="line">    printf(&quot;初始化动态数组,初始容量为2\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 向动态数组尾部插入元素</span><br><span class="line">    insertEnd(&amp;myArray, 1);</span><br><span class="line">    insertEnd(&amp;myArray, 2);</span><br><span class="line">    printf(&quot;向动态数组尾部插入了2个元素\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 打印动态数组当前长度</span><br><span class="line"> printf(&quot;动态数组当前长度:%zu\n&quot;, getLength(&amp;myArray));</span><br><span class="line"></span><br><span class="line">    // 在索引1的位置插入元素3</span><br><span class="line">    insertAt(&amp;myArray, 1, 3);</span><br><span class="line">    printf(&quot;在索引1的位置插入元素3\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 再次打印动态数组当前长度</span><br><span class="line">    printf(&quot;动态数组当前长度:%zu\n&quot;, getLength(&amp;myArray));</span><br><span class="line"></span><br><span class="line">    // 删除索引1的元素</span><br><span class="line">    printf(&quot;删除索引1的元素,该元素是%d\n&quot;, deleteAt(&amp;myArray, 1));</span><br><span class="line"></span><br><span class="line">    // 删除动态数组末尾元素</span><br><span class="line">    printf(&quot;删除动态数组末尾元素,该元素是%d\n&quot;, deleteEnd(&amp;myArray));</span><br><span class="line"></span><br><span class="line">    // 释放动态数组内存</span><br><span class="line">    destroyDynamicArray(&amp;myArray);</span><br><span class="line">    printf(&quot;动态数组内存释放完成\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="1-1-线性结构之链表"><a href="#1-1-线性结构之链表" class="headerlink" title="1.1 线性结构之链表"></a>1.1 线性结构之链表</h1><p>1.1.1 链表是什么</p><p>链表的主要特点包括：</p><ol><li><strong>动态大小</strong>：链表可以根据需要动态调整大小，不需要预先分配固定的内存空间。</li><li><strong>插入和删除效率高</strong>：在已知位置插入或删除元素时，链表不需要移动其他元素，只需调整指针即可。</li><li><strong>顺序访问</strong>：链表不支持随机访问，要访问链表中的某个元素，必须从头节点开始逐个遍历。</li></ol><p>链表有几种常见的类型：</p><ul><li><strong>单向链表</strong>：每个节点只指向下一个节点。</li><li><strong>双向链表</strong>：每个节点有两个指针，分别指向前一个节点和后一个节点。</li><li><strong>循环链表</strong>：链表的最后一个节点指向第一个节点，形成一个环。</li></ul><p><img src="https://s1.vika.cn/space/2024/11/12/65ec27aa9d2548efbe0342f9a53b9878" alt="image-20241108184735610"></p><p><strong>相关概念</strong></p><p>n个结点离散分配，彼此通过指针相连，每个结点只有一个前驱结点，每个结点只有一个后续结点，头结点没有前驱结点，尾结点没有后续结点。确定一个链表我们只需要头指针，通过头指针就可以把整个链表都能推出来。</p><p>1）优点</p><p>（1）插入和删除操作效率高。</p><p>（2）动态扩展性能更好，链表不需要像数组那样预先指定固定的大小，而是可以随时动态的增长或缩小。链表是真正的动态数据结构，不需要处理固定容量的问题。</p><p>2）缺点</p><p>（1）查找慢。由于链表中的结点不是连续存储的，无法像数组一样根据索引直接计算出每个结点的地址。必须从头结点开始遍历链表，直到找到目标结点，这导致了链表的随机访问效率较低。</p><p>（2）额外的存储空间。链表的每个结点都需要存储指向下一个结点的指针，这会占用额外的存储空间。所以，相比于数组，链表需要更多的内存空间来存储相同数量的数据元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">初始化链表</span><br><span class="line">void initLinkedList(LinkedList *list)</span><br><span class="line">返回链表的长度</span><br><span class="line">size_t getLength(const LinkedList *list)</span><br><span class="line">在指定位置插入元素</span><br><span class="line">void insertAt(LinkedList *list, size_t index, int element)</span><br><span class="line">在末尾插入元素</span><br><span class="line">void insertEnd(LinkedList *list, int element)</span><br><span class="line">删除指定位置的元素并返回被删除的元素</span><br><span class="line">int deleteAt(LinkedList *list, size_t index)</span><br><span class="line">删除末尾元素</span><br><span class="line">int deleteEnd(LinkedList *list)</span><br><span class="line">获取指定位置的元素</span><br><span class="line">int getElementAt(const LinkedList *list, size_t index)</span><br><span class="line">修改指定位置的元素</span><br><span class="line">void modifyAt(LinkedList *list, size_t index, int newValue)</span><br><span class="line">释放链表内存</span><br><span class="line">void destroyLinkedList(LinkedList *list)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">自定义链表结构</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 定义存储数据的结构体</span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int data;          // 存储的数据</span><br><span class="line">    struct Node *next; // 指向下个元素的指针</span><br><span class="line"></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">// 定义虚拟头结点的结构体</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int size;   // 记录单链表中存储的数据的个数</span><br><span class="line">    Node *next; // 指向保存数据的首元素</span><br><span class="line">&#125; LinkedList;</span><br><span class="line"></span><br><span class="line">// 明确：在包含虚拟头结点的情况下，首个保存数据的结点的索引为0！</span><br><span class="line"></span><br><span class="line">// 初始化链表</span><br><span class="line">void initLinkedList(LinkedList *list)</span><br><span class="line">&#123;</span><br><span class="line">    // 初始化LinkedList内部的成员</span><br><span class="line">    list-&gt;size = 0;</span><br><span class="line">    list-&gt;next = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回链表的长度</span><br><span class="line">size_t getLength(const LinkedList *list)</span><br><span class="line">&#123;</span><br><span class="line">    return list-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在指定位置插入元素</span><br><span class="line">void insertAt(LinkedList *list, size_t index, int element)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (index &lt; 0 || index &gt; list-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;输入的index数据非法\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 插入数据的过程</span><br><span class="line">    // 1. 将数据封装到Node结构体的变量中</span><br><span class="line">    Node *node = (Node *)malloc(1 * sizeof(Node));</span><br><span class="line">    node-&gt;data = element;</span><br><span class="line"></span><br><span class="line">    // 2. 找到index的位置进行插入操作</span><br><span class="line">    if (index == 0)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        node-&gt;next = list-&gt;next;</span><br><span class="line">        list-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Node *currentNode = list-&gt;next; // 指向有数据的首元素</span><br><span class="line">        for (int i = 0; i &lt; index - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            currentNode = currentNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node-&gt;next = currentNode-&gt;next;</span><br><span class="line">        currentNode-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在末尾插入元素</span><br><span class="line">void insertEnd(LinkedList *list, int element)</span><br><span class="line">&#123;</span><br><span class="line">    insertAt(list, list-&gt;size, element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除指定位置的元素并返回被删除的元素</span><br><span class="line">int deleteAt(LinkedList *list, size_t index)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (index &lt; 0 || index &gt;= list-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;输入的index不合法\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int deleteElement;</span><br><span class="line">    Node *deleteNode;</span><br><span class="line">    if (index == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        deleteNode = list-&gt;next;</span><br><span class="line"></span><br><span class="line">        list-&gt;next = deleteNode-&gt;next;</span><br><span class="line"></span><br><span class="line">        // 获取要删除的node的数据</span><br><span class="line">        deleteElement = deleteNode-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Node *currentNode = list-&gt;next; // 指向有数据的首元素</span><br><span class="line">        for (int i = 0; i &lt; index - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            currentNode = currentNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deleteNode = currentNode-&gt;next;</span><br><span class="line">        currentNode-&gt;next = deleteNode-&gt;next;</span><br><span class="line"></span><br><span class="line">        deleteElement = deleteNode-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    free(deleteNode); // 释放node的内存空间</span><br><span class="line"></span><br><span class="line">    list-&gt;size--;</span><br><span class="line"></span><br><span class="line">    return deleteElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除末尾元素</span><br><span class="line">int deleteEnd(LinkedList *list) &#123;</span><br><span class="line">    deleteAt(list,list-&gt;size - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取指定位置的元素</span><br><span class="line">int getElementAt(const LinkedList *list, size_t index) &#123;</span><br><span class="line"></span><br><span class="line">    if(index &lt; 0 || index &gt;= list-&gt;size)&#123;</span><br><span class="line">        printf(&quot;输入的index不合法\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node * currentNode = list-&gt;next;</span><br><span class="line">    for(int i = 0;i &lt; index ;i++)&#123;</span><br><span class="line">        currentNode = currentNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return currentNode-&gt;data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改指定位置的元素</span><br><span class="line">void modifyAt(LinkedList *list, size_t index, int newValue) &#123;</span><br><span class="line"></span><br><span class="line">    if(index &lt; 0 || index &gt;= list-&gt;size)&#123;</span><br><span class="line">        printf(&quot;输入的index不合法\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node * currentNode = list-&gt;next;</span><br><span class="line">    for(int i = 0;i &lt; index ;i++)&#123;</span><br><span class="line">        currentNode = currentNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentNode-&gt;data = newValue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放链表内存</span><br><span class="line">void destroyLinkedList(LinkedList *list) &#123;</span><br><span class="line"></span><br><span class="line">    Node *currentNode = list-&gt;next;  //找到有数据的第1个结点</span><br><span class="line"></span><br><span class="line">    for(int i = 0;i &lt; list-&gt;size;i++)&#123;</span><br><span class="line"></span><br><span class="line">        Node *tempNode = currentNode;</span><br><span class="line">        currentNode = currentNode-&gt;next;</span><br><span class="line"></span><br><span class="line">        free(tempNode);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //辅助操作</span><br><span class="line">    list-&gt;next = NULL;</span><br><span class="line">    list-&gt;size = 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    LinkedList list;</span><br><span class="line">    initLinkedList(&amp;list);</span><br><span class="line"></span><br><span class="line">    insertAt(&amp;list,0,10);</span><br><span class="line">    insertAt(&amp;list,0,20);</span><br><span class="line">    insertAt(&amp;list,0,30);</span><br><span class="line"></span><br><span class="line">    size_t count = getLength(&amp;list);</span><br><span class="line">    printf(&quot;%d\n&quot;,count);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    getchar();  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放链表内存-有什么用"><a href="#释放链表内存-有什么用" class="headerlink" title="释放链表内存 有什么用"></a>释放链表内存 有什么用</h3><p>释放链表内存”的主要用途在于管理动态分配的内存，确保程序运行期间不会造成内存泄漏。下面是这一过程的重要性和作用：</p><ol><li><strong>防止内存泄漏</strong>：在程序中动态申请的内存（例如，通过 <code>malloc</code>）需要在不再使用时及时释放。如果在不再需要链表时不释放内存，程序会占用不必要的内存资源，从而导致内存泄漏。</li><li><strong>优化内存使用</strong>：及时释放内存可以确保系统资源的有效使用，特别是在运行长时间的程序或需要频繁创建和销毁对象的情况下。</li><li><strong>防止悬挂指针</strong>：在释放链表内存的同时，设置指向链表的指针（如头指针）为 <code>NULL</code> 坏境，可以避免访问已释放内存的风险。这有助于防止程序在试图访问无效内存时造成的未定义行为。</li><li><strong>提高程序稳定性</strong>：良好的内存管理使得程序更加稳定和健壮，降低了崩溃的概率。</li></ol><h1 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h1><p>特点：<code>后进先出</code> (LIFO，Last In First Out)或<code>先进后出</code> (FILO，First In Last Out)的线性表。</p><p> 栈顶(Top)：允许进行插入、删除操作的一端，又称为<code>表尾</code>。栈顶由一个称为栈顶指针的位置指示器（其实就是一个变量）来指示，它是动态变化的。</p><p>- 栈底(Bottom)：是固定不变的，不允许进行插入和删除的一端，又称为<code>表头</code>。</p><p>- 空栈：不含任何元素的空表。</p><p>- 设栈S&#x3D;(a1,a2,…,an )，则a1称为栈底元素，an为栈顶元素，栈中元素按a1,a2,…,a_n的次序进栈(压栈、push)，出栈(弹栈，pop)的第一个元素应为栈顶元素，出栈顺序为：an,…,a2,a1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">初始化栈</span><br><span class="line">void initStack(Stack *stack, size_t capacity)</span><br><span class="line">返回栈内元素个数</span><br><span class="line">size_t getSize(const Stack *stack)</span><br><span class="line">添加新元素</span><br><span class="line">void push(Stack *stack, int element)</span><br><span class="line">在末尾插入元素</span><br><span class="line">void insertEnd(LinkedList *list, int element)</span><br><span class="line">栈顶元素出栈并返回</span><br><span class="line">int pop(Stack *stack)</span><br><span class="line">释放栈内存</span><br><span class="line">void destroyStack(Stack *stack)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"></span><br><span class="line">  自定义实现栈结构：使用顺序存储结构实现--&gt; 顺序栈</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line"></span><br><span class="line">    //存储数据的指针</span><br><span class="line">    int *data;</span><br><span class="line">    //指明存储容器的容量</span><br><span class="line">    size_t capacity;</span><br><span class="line">    //指明存储容器中实际存储的数据量</span><br><span class="line">    size_t size;</span><br><span class="line"></span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 初始化栈</span><br><span class="line">void initStack(Stack *stack, size_t capacity)</span><br><span class="line">&#123;</span><br><span class="line">    stack-&gt;data = (int *)malloc(capacity *sizeof(int));//动态内存分配</span><br><span class="line">    if(stack-&gt;data == NULL)&#123;</span><br><span class="line">        printf(&quot;内存分配失败\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack-&gt;capacity = capacity;         </span><br><span class="line">    stack-&gt;size = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回栈内元素个数</span><br><span class="line">size_t getSize(const Stack *stack)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    return stack-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加新元素</span><br><span class="line">void push(Stack *stack, int element)</span><br><span class="line">&#123;</span><br><span class="line">    //考虑是否存满了</span><br><span class="line">    if(stack-&gt;size == stack-&gt;capacity)&#123;</span><br><span class="line">        //扩容</span><br><span class="line">        resizeCapacity(stack,stack-&gt;capacity + stack-&gt;capacity &gt;&gt; 1); //扩容为原来的1.5倍</span><br><span class="line">        printf(&quot;容量已满，进行扩容操作\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack-&gt;data[stack-&gt;size] = element;</span><br><span class="line">    stack-&gt;size++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void resizeCapacity(Stack *stack,int newCapacity)&#123;</span><br><span class="line"></span><br><span class="line">    stack-&gt;data = (int *)realloc(stack-&gt;data,newCapacity * sizeof(int)); //扩容操作</span><br><span class="line">    stack-&gt;capacity = newCapacity; //指明新的容量值</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 栈顶元素出栈并返回</span><br><span class="line">int pop(Stack *stack)</span><br><span class="line">&#123;</span><br><span class="line">    //判断是否为空</span><br><span class="line">    if(stack-&gt;size == 0)&#123;</span><br><span class="line">        printf(&quot;当前栈为空,弹栈失败\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // int popElement = stack-&gt;data[stack-&gt;size-1];</span><br><span class="line">    // stack-&gt;size--;</span><br><span class="line"></span><br><span class="line">    // return popElement;</span><br><span class="line"></span><br><span class="line">    return stack-&gt;data[--stack-&gt;size];//</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//这是一个前缀自减操作。它的作用是将 stack-&gt;size 的值减一，然后返回这个新的值。</span><br><span class="line">//例如，如果 stack-&gt;size 原本是 3，经过 --stack-&gt;size 处理后，</span><br><span class="line">//stack-&gt;size 会变为 2。这意味着我们将要弹出栈中索引为 2 的元素（即第三个元素，因为索引从 0 开始）。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放栈内存</span><br><span class="line">void destroyStack(Stack *stack)</span><br><span class="line">&#123;</span><br><span class="line">    free(stack-&gt;data);</span><br><span class="line">    stack-&gt;data = NULL;</span><br><span class="line">    stack-&gt;capacity = 0;</span><br><span class="line">    stack-&gt;size = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//遍历栈中的元素</span><br><span class="line">void print(Stack *stack)&#123;</span><br><span class="line">    for(int i = 0;i &lt; stack-&gt;size;i++)&#123;</span><br><span class="line">        printf(&quot;%d  &quot;,stack-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //声明结构体变量</span><br><span class="line">    Stack myStack;</span><br><span class="line"></span><br><span class="line">    initStack(&amp;myStack,3);</span><br><span class="line"></span><br><span class="line">    push(&amp;myStack,1);</span><br><span class="line">    push(&amp;myStack,2);</span><br><span class="line">    push(&amp;myStack,3);</span><br><span class="line">    push(&amp;myStack,4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    printf(&quot;栈中元素的个数为：%d\n&quot;,getSize(&amp;myStack));</span><br><span class="line"></span><br><span class="line">    print(&amp;myStack);</span><br><span class="line"></span><br><span class="line">    printf(&quot;弹栈，弹出的数据是：%d\n&quot;,pop(&amp;myStack));</span><br><span class="line">    printf(&quot;弹栈，弹出的数据是：%d\n&quot;,pop(&amp;myStack));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print(&amp;myStack);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线性结构之队列"><a href="#线性结构之队列" class="headerlink" title="线性结构之队列"></a>线性结构之队列</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>队列(Queue)：也是操作受限的线性表，限制为仅允许在表的一端进行插入(入队或进队），在表的另一端进行删除(出队或离队)操作。</p><p>- 队首(front) ：允许进行删除的一端称为队首。</p><p>- 队尾(rear)： 允许进行插入的一端称为队尾。</p><p>在空队列中依次加入元素a1,a2, …, an之后，a1是队首元素，an是队尾元素。显然退出队列的次序也只能是a1,a2, …, an。队列，是一种先进先出(First In First Out ，简称FIFO)的线性结构。类似于生活中的排队行为。</p><p><img src="https://s1.vika.cn/space/2024/11/12/b4e17e3fbd7d4f78815a4f01eb85cb5f" alt="image-20241111205010221"></p><p>队列中没有元素时，称为空队列。</p><h3 id="队列的存储结构"><a href="#队列的存储结构" class="headerlink" title="队列的存储结构"></a>队列的存储结构</h3><p>可用顺序表(数组)和链表来存储队列，队列按存储结构可分为顺序队列和链式队列两种。</p><h3 id="功能定义"><a href="#功能定义" class="headerlink" title="功能定义"></a>功能定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">初始化队列</span><br><span class="line">void initQueue(Queue *queue, size_t capacity)</span><br><span class="line">返回队列内元素个数</span><br><span class="line">size_t getSize(const Queue *queue)</span><br><span class="line">添加新元素</span><br><span class="line">void enqueue(Queue *queue, int element)</span><br><span class="line">元素出队列</span><br><span class="line">int dequeue(Queue *queue)</span><br><span class="line">释放队列内存</span><br><span class="line">void destroyQueue(Queue *queue)</span><br><span class="line">遍历队列</span><br><span class="line">void printQueue(Queue *queue)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">/* </span><br><span class="line">    自定义结构实现队列：使用循环队列</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//声明队列对应的结构体</span><br><span class="line">typedef struct&#123;</span><br><span class="line"></span><br><span class="line">    int *data;</span><br><span class="line">    int capacity; //记录存储的最大容量</span><br><span class="line">    int size ; //记录存储的元素的个数</span><br><span class="line">    int front ;  //记录要出队的索引位置</span><br><span class="line">    int rear;  //记录入队后的索引位置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 初始化队列</span><br><span class="line">void initQueue(Queue *queue, size_t capacity)</span><br><span class="line">&#123;</span><br><span class="line">    queue-&gt;data = (int *)malloc(capacity * sizeof(int));</span><br><span class="line">    queue-&gt;capacity = capacity;</span><br><span class="line">    queue-&gt;size = 0;</span><br><span class="line">    queue-&gt;front = 0;</span><br><span class="line">    queue-&gt;rear = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回队列内元素个数</span><br><span class="line">size_t getSize(const Queue *queue)</span><br><span class="line">&#123;</span><br><span class="line">    return queue-&gt;size;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加新元素</span><br><span class="line">void enqueue(Queue *queue, int element)</span><br><span class="line">&#123;</span><br><span class="line">    if(queue-&gt;size == queue-&gt;capacity)&#123;</span><br><span class="line">        //容量已满</span><br><span class="line">        printf(&quot;队列已满，入队失败\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue-&gt;data[queue-&gt;rear] = element;</span><br><span class="line">    queue-&gt;size++;</span><br><span class="line">    //queue-&gt;rear++; //存在问题，需要使用下面的方式替换</span><br><span class="line"></span><br><span class="line">    queue-&gt;rear = (queue-&gt;rear + 1) % queue-&gt;capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 元素出队列</span><br><span class="line">int dequeue(Queue *queue)</span><br><span class="line">&#123;</span><br><span class="line">    // if(queue-&gt;front == queue-&gt;rear);//此语句满足的情况：① 队列为空 ② 队列已满</span><br><span class="line">    if(queue-&gt;size == 0)&#123;</span><br><span class="line">        printf(&quot;队列为空，出队失败\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int dequeueData = queue-&gt;data[queue-&gt;front];</span><br><span class="line">    queue-&gt;size--;</span><br><span class="line"></span><br><span class="line">    queue-&gt;front = (queue-&gt;front + 1) % queue-&gt;capacity;</span><br><span class="line"></span><br><span class="line">    return dequeueData;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放队列内存</span><br><span class="line">void destroyQueue(Queue *queue)</span><br><span class="line">&#123;</span><br><span class="line">    free(queue-&gt;data);</span><br><span class="line">    queue-&gt;data = NULL;</span><br><span class="line">    queue-&gt;capacity = 0;</span><br><span class="line">    queue-&gt;size = 0;</span><br><span class="line">    queue-&gt;front = 0;</span><br><span class="line">    queue-&gt;rear = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//遍历队列</span><br><span class="line">void printQueue(Queue *queue)&#123;</span><br><span class="line">    </span><br><span class="line">    for(int i = queue-&gt;front,j = 0;j &lt; queue-&gt;size;i++,j++)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        printf(&quot;%d  &quot;,queue-&gt;data[i % queue-&gt;capacity]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Queue myQueue;</span><br><span class="line"></span><br><span class="line">    initQueue(&amp;myQueue,3);</span><br><span class="line"></span><br><span class="line">    enqueue(&amp;myQueue,1);</span><br><span class="line">    enqueue(&amp;myQueue,2);</span><br><span class="line">    enqueue(&amp;myQueue,3);</span><br><span class="line">    enqueue(&amp;myQueue,4); //已满，未入队</span><br><span class="line"></span><br><span class="line">    printQueue(&amp;myQueue);</span><br><span class="line"></span><br><span class="line">    printf(&quot;出队，元素是：%d\n&quot;,dequeue(&amp;myQueue));</span><br><span class="line">    printf(&quot;出队，元素是：%d\n&quot;,dequeue(&amp;myQueue));</span><br><span class="line"></span><br><span class="line">    printQueue(&amp;myQueue);</span><br><span class="line"></span><br><span class="line">    enqueue(&amp;myQueue,5);</span><br><span class="line">    enqueue(&amp;myQueue,6);</span><br><span class="line"></span><br><span class="line">    printQueue(&amp;myQueue);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p><img src="https://s1.vika.cn/space/2024/11/12/72fe34dc1658472cbf5d14212e1506e3" alt="image-20241112175354551"></p><p>假设一个 int 变量占 4个字节，则所需内存空间 &#x3D; 4 + 4 &#x3D; 8，则S(n) &#x3D; O(1)。</p><p><img src="https://s1.vika.cn/space/2024/11/12/4c26e3b872e54932aeac50b4e0cfc5b9" alt="image-20241112175523230"></p><p>假设一个 int 变量占 4个字节，则所需内存空间 &#x3D; 4 + 4n + 4 &#x3D; 4n + 8，则S(n) &#x3D; O(n)。</p><p><img src="https://s1.vika.cn/space/2024/11/12/18bb9907b97d432b83b835a8f999c8d4" alt="image-20241112175532793"></p><p><img src="https://s1.vika.cn/space/2024/11/12/2cb283d076a04171acfea6e1c3b8b96d" alt="image-20241112175538936"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找:"></a>顺序查找:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 顺序查找:</span><br><span class="line">int sequenceSearch(int arr[], int size, int target)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    for(int i = 0;i &lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(arr[i] == target)</span><br><span class="line">        &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return -1; //表示没有找到指定的元素 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int arr[] = &#123;23,45,76,44,22,88,9,12,22,5,80&#125;;</span><br><span class="line"></span><br><span class="line">    int size = sizeof(arr) / sizeof(int);</span><br><span class="line"></span><br><span class="line">    int target = 9;</span><br><span class="line"></span><br><span class="line">    int targetIndex = sequenceSearch(arr,size,target);</span><br><span class="line">    if(targetIndex == -1)&#123;</span><br><span class="line">        printf(&quot;未找到\n&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;找到了%d，对应的索引为%d\n&quot;,target,targetIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sizeof是运算符，返回 unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。<br>它的功能是：获得保证能容纳实现所建立的最大对象的字节大小</p><p>sizeof(ary) &#x2F; sizeof(int) &lt;&#x3D;&#x3D;&gt; sizeof(ary) &#x2F; sizeof(ary[0]) ; 得到 ary 内的元素的个数</p><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>二分查找（Binary Search）是一种高效的搜索算法，通常用于有序数据集中查找目标元素。其原理是通过将数据集划分为两半并与目标进行比较，以确定目标在哪一半中，从而逐步缩小搜索范围，直到找到目标元素或确定不存在。基本原理如下：</p><p>（1）<strong>选择中间元素：</strong> 在有序数据集中，选择数组的中间元素。</p><p>（1）<strong>比较目标：</strong> 将中间元素与目标元素进行比较。</p><p>（2）<strong>查找成功：</strong> 如果中间元素等于目标元素，则查找成功，返回中间元素的索引。</p><p>（3）<strong>缩小搜索范围：</strong> 对于一个升序的数据集，如果中间元素大于目标元素，说明目标可能在左半部分；如果中间元素小于目标元素，说明目标可能在右半部分。根据比较结果，将搜索范围缩小到一半，继续查找。</p><p>（4）<strong>重复步骤：</strong> 重复上述步骤，不断将搜索范围缩小，直到找到目标元素或搜索范围为空。</p><p>​                                   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"></span><br><span class="line">    使用二分查找法，查找数组中的元素</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int binarySearch(int arr[],int size,int target)&#123;</span><br><span class="line"></span><br><span class="line">    int low = 0;</span><br><span class="line">    int high = size - 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    while(low &lt;= high)&#123;</span><br><span class="line"></span><br><span class="line">        int middle = (low + high) / 2;</span><br><span class="line">        if(arr[middle] == target)&#123;</span><br><span class="line">            return middle;</span><br><span class="line">        &#125;else if(arr[middle] &gt; target)&#123;</span><br><span class="line">            high = middle - 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            low = middle + 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //表示未找到</span><br><span class="line">    return -1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int arr[] = &#123;4,7,9,12,16,19,22,28,34,57,69,78,90&#125;;</span><br><span class="line">    int target = 12;</span><br><span class="line">    target = 91;</span><br><span class="line">    int size = sizeof(arr) / sizeof(int);</span><br><span class="line"></span><br><span class="line">    int targetIndex = binarySearch(arr,size,target);</span><br><span class="line">    if(targetIndex == -1)&#123;</span><br><span class="line">        printf(&quot;未找到\n&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;找到了%d，对应的索引为%d\n&quot;,target,targetIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"></span><br><span class="line">    冒泡排序:实现从小到大排序</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">void bubbleSort(int arr[],int size)&#123;</span><br><span class="line"></span><br><span class="line">    //外层循环：控制轮数</span><br><span class="line">    for(int i = 0;i &lt; size - 1;i++)&#123;</span><br><span class="line"></span><br><span class="line">        //内层循环：依次比较相邻的两个元素的大小</span><br><span class="line">        for(int j = 0;j &lt; size - 1 - i;j++)&#123;</span><br><span class="line">            </span><br><span class="line">            if(arr[j] &gt; arr[j + 1])&#123;</span><br><span class="line">                //交互j 和 j+1索引位置的元素</span><br><span class="line">                int temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int arr[] = &#123;23,45,2,46,77,2,99,-9,-32,0,66&#125;;</span><br><span class="line"></span><br><span class="line">    int size = sizeof(arr) / sizeof(int);</span><br><span class="line">    //遍历</span><br><span class="line">    for(int i = 0;i &lt; size;i++)&#123;</span><br><span class="line">        printf(&quot;%d  &quot;,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    //排序</span><br><span class="line">    bubbleSort(arr,size);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //遍历</span><br><span class="line">    for(int i = 0;i &lt; size;i++)&#123;</span><br><span class="line">        printf(&quot;%d  &quot;,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">    快速排序:实现从小到大排序</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">void quickSort(int arr[], int size)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    subSort(arr, 0, size - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void subSort(int arr[], int start, int end)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (start &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        int base = arr[start];</span><br><span class="line">        int low = start;</span><br><span class="line">        int high = end + 1;</span><br><span class="line"></span><br><span class="line">        while (1)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            while (low &lt; end &amp;&amp; arr[++low] &lt;= base)</span><br><span class="line">                ; // 找到从前往后第1个比base大的元素</span><br><span class="line">            while (high &gt; start &amp;&amp; arr[--high] &gt;= base)</span><br><span class="line">                ; // 找到从后往前第1个比base小的元素</span><br><span class="line"></span><br><span class="line">            if (low &lt; high)</span><br><span class="line">            &#123;</span><br><span class="line">                // 交换low和high位置的元素</span><br><span class="line">                int temp = arr[low];</span><br><span class="line">                arr[low] = arr[high];</span><br><span class="line">                arr[high] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 交换start和high索引位置上的元素</span><br><span class="line">        int temp1 = arr[start];</span><br><span class="line">        arr[start] = arr[high];</span><br><span class="line">        arr[high] = temp1;</span><br><span class="line"></span><br><span class="line">        // 递归调用</span><br><span class="line">        subSort(arr, start, high - 1); // 前半段继续排序</span><br><span class="line">        subSort(arr, high + 1, end);   // 后半段继续排序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int arr[] = &#123;23, 45, 2, 46, 77, 2, 99, -9, -32, 0, 66&#125;;</span><br><span class="line"></span><br><span class="line">    int size = sizeof(arr) / sizeof(int);</span><br><span class="line">    // 遍历</span><br><span class="line">    for (int i = 0; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 排序</span><br><span class="line">    quickSort(arr, size);</span><br><span class="line"></span><br><span class="line">    // 遍历</span><br><span class="line">    for (int i = 0; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux驱动模型详解</title>
      <link href="/2024/06/06/test/liunx%E9%A9%B1%E5%8A%A8/Linux%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/06/06/test/liunx%E9%A9%B1%E5%8A%A8/Linux%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><strong>让所有很久很久以前都走到幸福结局的时刻</strong></p><h2 id="1-Linux-驱动模型"><a href="#1-Linux-驱动模型" class="headerlink" title="1.Linux 驱动模型"></a>1.Linux 驱动模型</h2><p>本节内容，重在理解。面试时，面试官很大可能会让你挑一个你熟悉的驱动讲讲，如何编写的？能回答出大概的驱动框架就可以。</p><h3 id="1-1-字符设备驱动模型"><a href="#1-1-字符设备驱动模型" class="headerlink" title="1.1 字符设备驱动模型"></a>1.1 字符设备驱动模型</h3><p>驱动初始化中涉及到一个设备描述结构的概念。在任何一种驱动模型中，设备都会用内核中的一种结构来描述，这种结构成为<strong>设备描述结构</strong>。字符设备在内核中使用<code>struct cdev</code>这种结构来描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span> <span class="comment">//设备操作集</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">dev_t</span> dev; <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count; <span class="comment">//设备数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>count表明该类型设备的数目，如有两个串口，则count的值为2。</p></li><li><p>dev是设备号，包含有主设备号和次设备号的信息。主设备号用于区分设备的类型，次设备号用于标记相同类型的设备的不同个体。如串口1和串口2使用同一驱动程序，则其主设备号相同，但次设备号不同。Linux内核中使用<code>dev_t</code>类型来定义设备号，<code>dev_t</code>这种类型其实质为32位的<code>unsigned int</code>，其中高12位为主设备号，低20位为次设备号。</p><ol><li>知道主设备号与次设备号，可通过<code>dev_t dev = MKDEV(主设备号，次设备号)</code> 获得设备号；</li><li>从设备号分解出主设备号：主设备号 &#x3D; <code>MAJOR(dev_t dev)</code></li><li>从设备号分解出次设备号：次设备号 &#x3D; <code>MINOR(dev_t dev)</code></li></ol></li><li><p>主设备号是一个重要的资源，可以通过静态申请和动态分配为设备分配一个主设备号：</p><ol><li>静态申请：开发者自己选择一个数字作为主设备号，然后通过函数<code>register_chrdev_region</code>向内核申请使用。这种方法的缺点是如果申请使用的设备号已经被内核中的其它驱动使用了，则申请失败。</li><li>动态分配：使用<code>alloc_chrdev_region</code>由内核分配一个可用的主设备号。因为内核知道哪些号已经被使用了，所以不会导致分配到已经被使用的号。既然设备号是一种资源，则设备驱动在退出后都应该释放该资源。使用<code>unregister_chrdev_region</code>函数释放这些设备号。</li></ol></li><li><p>ops是操作函数集。<code>file_operations</code>是一个很重要的结构，该结构的成员基本都是函数指针，并且是一些文件操作的函数的指针。</p></li><li><pre><code class="c">struct file_operations &#123;  struct module *owner;  loff_t(*llseek) (struct file *, loff_t, int);  ssize_t(*read) (struct file *, char __user *, size_t, loff_t *);  ssize_t(*aio_read) (struct kiocb *, char __user *, size_t, loff_t);  ssize_t(*write) (struct file *, const char __user *, size_t, loff_t *);  ssize_t(*aio_write) (struct kiocb *, const char __user *, size_t, loff_t);  int (*readdir) (struct file *, void *, filldir_t);  unsigned int (*poll) (struct file *, struct poll_table_struct *);  int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);  int (*mmap) (struct file *, struct vm_area_struct *);  int (*open) (struct inode *, struct file *);  int (*flush) (struct file *);  int (*release) (struct inode *, struct file *);  int (*fsync) (struct file *, struct dentry *, int datasync);  int (*aio_fsync) (struct kiocb *, int datasync);  int (*fasync) (int, struct file *, int);  int (*lock) (struct file *, int, struct file_lock *);  ssize_t(*readv) (struct file *, const struct iovec *, unsigned long, loff_t *);  ssize_t(*writev) (struct file *, const struct iovec *, unsigned long, loff_t *);  ssize_t(*sendfile) (struct file *, loff_t *, size_t, read_actor_t, void __user *);  ssize_t(*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);  unsigned long (*get_unmapped_area) (struct file *, unsigned long,unsigned long, unsigned long,unsigned long);&#125;;    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`struct file_operations`是一个函数指针的集合，定义能在设备上进行的操作。结构中的函数指针指向驱动中的函数，这些函数实现一个针对设备的操作, 对于不支持的操作则设置函数指针为 NULL。例如：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">struct file_operations dev_fops = &#123;</span><br><span class="line">    .llseek = NULL,</span><br><span class="line">    .read = dev_read,</span><br><span class="line">    .write = dev_write,</span><br><span class="line">    .ioctl = dev_ioctl,</span><br><span class="line">    .open = dev_open,</span><br><span class="line">    .release = dev_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>- 该结构体表示应用程序能够对设备文件使用函数`read()`, `write()`等，但不能使用函数`llseek()`。当执行到`read()`函数时，内核根据该结构体转移到驱动程序中的`dev_read`函数去执行。- 驱动初始化有四大步骤：  1.**分配**  - cdev变量的定义可以采用静态和动态两种办法：  - 静态分配：`struct cdev mdev`；  - 动态分配：`struct cdev *pdev = cdev_alloc()`；  2.**初始化**  - `struct cdev`的初始化使用`cdev_init`函数来完成。  - 原型：`cdev_init(struct cdev *cdev, const struct file_operations *fops)`  - 参数：    - `cdev`：待初始化的cdev结构    - `fops`：设备对应的操作函数集  3.注册  - 字符设备的注册使用`cdev_add`函数来完成。  - 原型：`cdev_add(struct cdev *p, dev_t dev, unsigned count)`  - 参数：    - `p`：待添加到内核的字符设备结构    - `dev`：设备号    - `count`：该类设备的设备个数  4.**硬件初始化**  - 根据相应硬件的数据手册完成初始化。</code></pre></li></ul><h3 id="1-2-实现设备操作"><a href="#1-2-实现设备操作" class="headerlink" title="1.2 实现设备操作"></a>1.2 实现设备操作</h3><p>由struct file_operations可以看出，要实现的操作并不少，这里只介绍一些重要的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*open)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *) <span class="comment">//打开设备，响应open系统调用</span></span><br><span class="line"><span class="type">int</span> (*release)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);<span class="comment">//关闭设备，响应close系统调用</span></span><br><span class="line"><span class="type">loff_t</span> (*llseek)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>) <span class="comment">//重定位读写指针，响应lseek系统调用</span></span><br><span class="line"><span class="type">ssize_t</span> (*read)(<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *) <span class="comment">//从设备读取数据，响应read系统调用</span></span><br><span class="line"><span class="type">ssize_t</span> (*write)(<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *) <span class="comment">//向设备写入数据，响应write系统调用</span></span><br></pre></td></tr></table></figure><ul><li><p>以上几个函数涉及到了<code>struct inode</code>和<code>struct file</code>这两种结构体。</p></li><li><p>在Linux系统中，每一个<strong>打开的文件</strong>，在内核中都会关联一个<code>struct file</code>结构体，它由内核在打开文件时创建，在文件关闭后释放。该结构体的重要成员有：</p></li><li><pre><code class="c">loff_t f_pos /*文件读写指针*/struct file_operations *f_op /*该文件所对应的操作*/<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">每一个存在于文件系统里面的文件都会关联一个`inode` 结构，该结构主要用来**记录文件物理上的信息**。因此，它和代表打开文件的file结构是不同的。一个文件**没有被打开时不会关联file结构，但是却会关联一个inode结构**。该结构体重要的成员有：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">dev_t i_rdev /*设备号*/</span><br></pre></td></tr></table></figure>- 一个设备支持的函数操作又称为设备方法。- `open`设备方法是驱动程序用来为以后的操作完成**初始化**准备工作的。在大部分驱动程序中，open完成如下工作：**标明次设备号、启动设备**。- `release`设备方法的作用与open相反，这个设备方法有时也称为close，它完成的工作是**关闭设备**。- `read`设备方法通常完成两件事情：从设备中**读取数据**(属于硬件访问类操作)，将读取到的数据**返回给应用程序**。- ```c  ssize_t (*read)(struct file *filp,char __user *buff,size_t count,loff_t *offp)  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 参数说明：</span><br><span class="line"></span><br><span class="line">  1. `filp`：与字符设备文件关联的file结构指针，由内核创建。</span><br><span class="line">  2. `buff`：从设备读取到的数据，需要**保存到的位置**。由read系统调用提供该参数。</span><br><span class="line">  3. `count`：请求传输的**数据量**，由read系统调用提供该参数。</span><br><span class="line">  4. `offp`：文件的**读写位置**，由内核从file结构中取出后(相当于读取指针)，传递进来。</span><br><span class="line"></span><br><span class="line">- 要注意的是，`buff`参数是来源于用户空间的指针，这类指针都**不能被内核代码直接引用**，必须使用专门的函数：</span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">  int copy_to_user(void __user *to, const void *from, int n)// 内核态-&gt;用户态</span><br><span class="line">  int copy_from_user(void *to, const void __user *from, int n)// 用户态-&gt;内核态</span><br></pre></td></tr></table></figure>    - 其中`copy_to_user()`用于将内核数据传送给用户空间；`copy_from_user()`用于将用户空间的数据传送给内核空间。    - `write`设备方法通常完成两件事情：**从应用程序提供的地址中取出数据，将数据写入设备**(属于硬件访问类操作)    - 函数原型：`ssize_t (*write)(struct file *, const char __user *, size_t, loff_t *)`    - 驱动注销：当我们从内核中卸载驱动程序的时候，需要使用`cdev_del`函数来完成字符设备的注销。    - 一个驱动程序范例：    - ```c      #include &lt;linux/module.h&gt;      #include &lt;linux/types.h&gt;      #include &lt;linux/fs.h&gt;      #include &lt;linux/errno.h&gt;      #include &lt;linux/init.h&gt;      #include &lt;linux/cdev.h&gt;      #include &lt;asm/uaccess.h&gt;      #include &lt;linux/slab.h&gt;             int dev1_registers[5];      int dev2_registers[5];             struct cdev cdev; // 字符驱动设备      dev_t devno;// 设备号             /*文件打开函数*/      int mem_open(struct inode *inode, struct file *filp)      &#123;          /*获取次设备号*/          int num = MINOR(inode-&gt;i_rdev);                 if (num==0)              filp-&gt;private_data = dev1_registers;          else if(num == 1)              filp-&gt;private_data = dev2_registers;          else              return -ENODEV;  //无效的次设备号                 return 0;       &#125;             /*文件释放函数*/      int mem_release(struct inode *inode, struct file *filp)      &#123;        return 0;      &#125;             /*读函数 返回读取了多少个数据*/      static ssize_t mem_read(struct file *filp, char __user *buf, size_t size, loff_t *ppos)      &#123;        unsigned long p =  *ppos;        unsigned int count = size;        int ret = 0;        int *register_addr = filp-&gt;private_data; /*获取设备的寄存器基地址*/               /*判断读位置是否有效*/        if (p &gt;= 5*sizeof(int))          return 0;        if (count &gt; 5*sizeof(int) - p)          count = 5*sizeof(int) - p;               /*读数据到用户空间 从基地址偏移p个(p为开始读的位置 即ppos描述的相对位置)*/        if (copy_to_user(buf, register_addr+p, count))        &#123;          ret = -EFAULT;        &#125;        else        &#123;          *ppos += count;          ret = count;        &#125;               return ret;      &#125;             /*写函数*/      static ssize_t mem_write(struct file *filp, const char __user *buf, size_t size, loff_t *ppos)      &#123;        unsigned long p =  *ppos;        unsigned int count = size;        int ret = 0;        int *register_addr = filp-&gt;private_data; /*获取设备的寄存器地址*/               /*分析和获取有效的写长度*/        if (p &gt;= 5*sizeof(int))          return 0;        if (count &gt; 5*sizeof(int) - p)          count = 5*sizeof(int) - p;               /*从用户空间写入数据*/        if (copy_from_user(register_addr + p, buf, count))          ret = -EFAULT;        else        &#123;          *ppos += count;          ret = count;        &#125;               return ret;      &#125;             /* seek文件定位函数 */      static loff_t mem_llseek(struct file *filp, loff_t offset, int whence)      &#123;           loff_t newpos;                 switch(whence) &#123;            case SEEK_SET:               newpos = offset;              break;                   case SEEK_CUR:               newpos = filp-&gt;f_pos + offset;              break;                   case SEEK_END:               newpos = 5*sizeof(int)-1 + offset;              break;                   default:               return -EINVAL;          &#125;          if ((newpos&lt;0) || (newpos&gt;5*sizeof(int)))              return -EINVAL;                 filp-&gt;f_pos = newpos;          return newpos;             &#125;             /*文件操作结构体*/      static const struct file_operations mem_fops =      &#123;        .llseek = mem_llseek,        .read = mem_read,        .write = mem_write,        .open = mem_open,        .release = mem_release,      &#125;;             /*设备驱动模块加载函数*/      static int memdev_init(void)      &#123;        /*初始化cdev结构*/        cdev_init(&amp;cdev, &amp;mem_fops);               /* 注册字符设备 */        alloc_chrdev_region(&amp;devno, 0, 2, &quot;memdev&quot;);        cdev_add(&amp;cdev, devno, 2);      &#125;             /*模块卸载函数*/      static void memdev_exit(void)      &#123;        cdev_del(&amp;cdev);   /*注销设备*/        unregister_chrdev_region(devno, 2); /*释放设备号*/      &#125;             MODULE_LICENSE(&quot;GPL&quot;);             module_init(memdev_init);      module_exit(memdev_exit);      <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">### 1.3 总线设备驱动模型</span><br><span class="line"></span><br><span class="line">- 自内核2.6版本开始，需要关注的是**总线、设备和驱动**这3个实体，总线将设备和驱动绑定。在Linux内核系统中注册一个设备的时候，会寻找与之对应驱动进行匹配；相反地，系统中注册一个驱动的时候，会去寻找一个对应的设备进行匹配。**匹配的的工作由总线来完成**。</span><br><span class="line"></span><br><span class="line">- **在Linux设备中有的是没有对应的物理总线的，但为了适配Linux的总线模型，内核针对这种没有物理总线的设备开发了一种虚拟总线——platform总线**。将设备和驱动独立开，驱动尽可能写的通用，当来了一个类似的设备后也可以使用这个驱动，让驱动程序可以重用。这体现了Linux驱动的软件架构设计的思想。</span><br><span class="line"></span><br><span class="line">- 按照这个思路，Linux中的设备和驱动都需要挂接在一种总线上，比如i2c总线上的eeprom，eeprom作为设备，**eeprom的驱动都挂接在i2c驱动上**。但是在嵌入式系统中，**soc系统一般都会集成独立的i2c控制器，控制器也是需要驱动的，但是再按照设备-总线-驱动模型进行设计，就会发现无法找到一个合适总线去挂接控制器设备和控制器驱动了（i2c控制器是挂接在CPU内部的总线上，而不是i2c总线）**，所以Linux发明了一种虚拟总线，称为platform总线，相应的设备称为**platform_device（控制器设备），对应的驱动为platform_driver（控制器驱动），用platform总线来承载这些相对特殊的系统**。</span><br><span class="line"></span><br><span class="line">- 注意：**所谓的platform_device并不是与字符设备、块设备和网络设备并列的概念，而是Linux系统提供的一种附加手段**。例如，在 S3C6410处理器中，把内部集成的I2C、RTC、SPI、LCD、看门狗等控制器都归纳为platform_device，而它们本身就是字符设备。我们要记住，platform 驱动只是在**字符设备驱动外套一层platform_driver 的外壳**。引入platform模型符合Linux 设备模型 —— 总线、设备、驱动，设备模型中配套的sysfs节点都可以用，方便我们的开发；**当然你也可以选择不用，不过就失去了一些platform带来的便利**。</span><br><span class="line"></span><br><span class="line">- 设备驱动中引入platform 概念，隔离BSP和驱动。在BSP中定义platform设备和设备使用的资源、设备的具体匹配信息，而在驱动中，只需要通过API去获取资源和数据，做到了板相关代码和驱动代码的分离，使得驱动具有更好的可扩展性和跨平台性。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  - **下面分析下总线设备驱动模型的匹配过程**</span><br><span class="line">    1. 一边的`device`结构体和另一边的`较稳定的 driver 代码`的联系：`device_add()`除将`device`结构放到 bus 的`dev 链表`之外，还会从另一边的`drv`链表中取表元即某个`driver`结构，用总线里的一个`（.match）`函数来作比较，看另一边的`driver`是否支持一边的`device`。若是能够支持，则接着调用软件驱动部分的`.probe`函数。`driver_register()`会将`bus_drv_dev`模型中的较稳定代码`driver`结构体放到虚拟总线的某个链表（drv 链表）中。从另一边的`dev`链表中取出每一个`device`结构用 bus 中的`.match`函数来作比较。</span><br><span class="line">    2. 若支持则调用`.probe`函数。左右两个注册就建立起来的一种机制。在`.probe`函数中做的事件由自已决定，打印一句话，或注册一个字符设备，再或注册一个`input_dev`结构体等等都是由自已决定。强制的把一个驱动程序分为左右两边这种机制而已，可以把这套东西放在任何地方，这里的`driver`只是个结构体不要被这个名字迷惑，`device`也只是个结构体，里面放什么内容都是由自已决定的。</span><br><span class="line"></span><br><span class="line">### 1.4 输入子系统模型</span><br><span class="line"></span><br><span class="line">每个硬件都有一个`input_dev`结构体，每个软件都有一个`input_handler`结构体。`input_dev`和`input_handler`分别通过`input_register_device()`，`input_register_handler()`向核心层注册硬件和软件。</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul><p>int input_register_device(struct input_dev *dev)   &#x2F;&#x2F;*dev:要注册的驱动设备<br>{<br> … …<br>       list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);   &#x2F;&#x2F;(1)放入链表中<br> … …<br>       list_for_each_entry(handler, &amp;input_handler_list, node)  &#x2F;&#x2F;(2)<br>       input_attach_handler(dev, handler);<br> … …<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 从`input_dev`方向分析：`input`设备在增加到`input_dev_list`链表上之后，会查找 `input_handler_list`事件处理链表上的`handler`进行匹配，这里的匹配方式与总线设备驱动模型的`device`和`driver`匹配过程很相似，所有的`input_device`都挂在`input_dev_list`上，所有类型的事件都挂在`input_handler_list`上，进行“匹配相亲”。如果匹配上了，就调用`input_handler`的`connect`函数进行连接。设备就是在此时注册的。</span><br><span class="line">- 从`input_handler`方向分析：将`handler`挂到链表`input_handler_list`下，然后遍历`input_dev_list`链表,查找并匹配输入设备对应的事件处理层，如果匹配上了，就调用`connect`函数进行连接，并创建`input_handle`结构。</span><br><span class="line">- 所以，不管新添加`input_dev`还是`input_handler`，都会进入`input_attach_handler()`判断两者id是否有支持, 若两者支持便进行连接。</span><br><span class="line"></span><br><span class="line">### 1.5 platform总线的匹配规则是什么？在具体应用上要不要先注册驱动再注册设备？有先后顺序没？</span><br><span class="line"></span><br><span class="line">- 匹配规则就是当有一个新的设备挂起时，总线被唤醒，`match`函数被调用，用`device`名字去跟本总线下的所有驱动名字去比较。相反就是用驱动的名字去`device`链表中和所有`device`的名字比较。如果匹配上，才会调用驱动中的`probe`函数，否则不调用。至于先后顺序，鉴于个人理解，**不会有影响**，不管谁先谁后，bus都会完成匹配工作。</span><br><span class="line">- 设备驱动模型的出现主要有三个好处：</span><br><span class="line">  1. 设备与驱动分离，驱动**可移植性增强**；</span><br><span class="line">  2. 设备驱动抽象结构以总线结构表示看起来更加**清晰明了**，谁是属于哪一条bus的；</span><br><span class="line">  3. 设备与驱动分离，很好的奠定了**热插拔**机制。</span><br><span class="line"></span><br><span class="line">## 2.Linux内核</span><br><span class="line"></span><br><span class="line">### 2.1 内核镜像格式有几种？分别有什么区别？</span><br><span class="line"></span><br><span class="line">1. uboot经过编译直接生成的elf格式的可执行程序是u-boot，这个程序类似于windows下的exe格式，在操作系统下是**可以直接执行**的。但是这种格式**不能用来烧录下载**。我们用来烧录下载的是u-boot.bin，这个东西是由u-boot使用arm-linux-objcopy工具进行加工（主要目的是去掉一些无用的东西）得到的。这个u-boot.bin就叫镜像（image），镜像就是用来烧录到iNand中执行的。</span><br><span class="line">2. linux内核经过编译后也会生成一个elf格式的可执行程序，叫**vmlinux或vmlinuz**，这个就是**原始的未经任何处理加工的原版内核elf文件**；嵌入式系统部署时烧录的一般不是这个vmlinuz/vmlinux，而是要用objcopy工具去制作成烧录镜像格式（就是u-boot.bin这种，但是内核没有.bin后缀），经过制作加工成烧录镜像的文件就叫**Image**（制作把78M大的精简成了7.5M，因此这个制作烧录镜像主要目的就是缩减大小，节省磁盘）。</span><br><span class="line">3. 原则上Image就可以直接被烧录到Flash上进行启动执行（类似于u-boot.bin），但是实际上并不是这么简单。实际上linux的作者们觉得Image还是太大了所以对Image进行了压缩，并且在image压缩后的文件的**前端附加了一部分解压缩代码**。构成了一**个压缩格式的镜像就叫zImage**。（因为当年Image大小刚好比一张软盘（软盘有2种，1.2M的和1.44MB两种）大，为了节省1张软盘的钱于是乎设计了这种压缩Image成zImage的技术）。</span><br><span class="line">4. uboot为了启动linux内核，还发明了一种内核格式叫uImage。**uImage是由zImage加工得到的**，uboot中有一个工具，可以将zImage加工生成uImage。注意：uImage不关linux内核的事，linux内核只管生成zImage即可，然后uboot中的mkimage工具再去由zImage加工生成uImage来给uboot启动。这个加工过程其实就是**在zImage前面加上64字节的uImage的头信息即可**。</span><br><span class="line">5. 原则上uboot启动时应该给他uImage格式的内核镜像，但是实际上uboot中也可以支持zImage，是否支持就看x210_sd.h中是否定义了LINUX_ZIMAGE_MAGIC这个宏。所以大家可以看出：有些uboot是支持zImage启动的，有些则不支持。但是**所有的uboot肯定都支持uImage启动**。</span><br><span class="line">6. 如果直接在kernel底下去`make uImage`会提供`mkimage command not found`。解决方案是去`uboot/tools`下`cp mkimage /usr/local/bin/`，复制mkimage工具到系统目录下。再去`make uImage`即可。</span><br><span class="line"></span><br><span class="line">&gt; 通过上面的介绍我们了解了内核镜像的各种格式，如果通过uboot启动内核，Linux必须为**uImage**格式。</span><br><span class="line"></span><br><span class="line">### 2.2 内核中申请内存有哪几个函数？有什么区别？</span><br><span class="line"></span><br><span class="line">1. **kmalloc**</span><br><span class="line"></span><br><span class="line">   ```c</span><br><span class="line">   void *kmalloc(size_t size, gfp_t flags)</span><br></pre></td></tr></table></figure><p>   <code>kmalloc</code>是内核中最常用的一种内存分配方式，它通过调用<code>kmem_cache_alloc</code>函数来实现。<code>kmalloc</code>一次最多能申请的内存大小由<code>include/linux/Kmalloc_size.h</code>的内容来决定，在默认的2.6.18内核版本中，kmalloc一次最多能申请大小为131702B也就是<strong>128KB</strong>字节的连续物理内存。测试结果表明，如果试图用kmalloc函数分配大于128KB的内存，编译不能通过。</p><ol start="2"><li><p><strong>vmalloc</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">vmalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br></pre></td></tr></table></figure><p>前面几种内存分配方式都是物理连续的，能保证较低的平均访问时间。但是在某些场合中，对内存区的请求不是很频繁，较高的内存访问时间也可以接受，这是就可以分配一段<strong>线性连续，物理不连续</strong>的地址，带来的好处是一次可以<strong>分配较大块的内存</strong>。图3-1表示的是<code>vmalloc</code>分配的内存使用的地址范围。<code>vmalloc</code>对一次能分配的内存大小没有明确限制。出于性能考虑，应谨慎使用<code>vmalloc</code>函数。在测试过程中，<strong>最大能一次分配1GB的空间</strong>。</p></li><li><p><strong>dma_alloc_coherent</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">dma_alloc_coherent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> size,<span class="type">ma_addr_t</span> </span></span><br><span class="line"><span class="params">*dma_handle, <span class="type">gfp_t</span> gfp)</span></span><br></pre></td></tr></table></figure><p>DMA(直接内存访问 Direct Memory Access)是一种硬件机制，允许外围设备和主存之间直接传输IO数据，而不需要CPU的参与，使用DMA机制能<strong>大幅提高与设备通信的吞吐量</strong>。DMA操作中，涉及到CPU<strong>高速缓存和对应的内存数据一致性</strong>的问题，必须保证两者的数据一致，在x86_64体系结构中，硬件已经很好的解决了这个问题，<code>dma_alloc_coherentget_free_pages</code>函数实现差别不大，前者实际是调用<code>alloc_pages</code>函数来分配内存，因此一次分配内存的大小限制和后者一样。<code>__get_free_pages</code>分配的内存同样可以用于DMA操作。测试结果证明，<code>dma_alloc_coherent</code>函数一次能分配的最大内存也为<strong>4M</strong>。</p></li><li><p><strong>ioremap</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">ioremap</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> offset, <span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br></pre></td></tr></table></figure><p><code>ioremap</code>是一种更直接的内存“分配”方式，使用时直接<strong>指定物理起始地址和需要分配内存</strong>的大小，然后将该段<strong>物理地址映射到内核地址空间</strong>。<code>ioremap</code>用到的物理地址空间都是事先确定的，和上面的几种内存分配方式并不太一样，并不是分配一段新的物理内存。<code>ioremap</code>多用于<strong>设备驱动</strong>，可以让CPU直接访问外部设备的IO空间。<code>ioremap</code>能映射的内存由原有的物理内存空间决定，所以没有进行测试。</p></li></ol><h3 id="2-3-什么是内核空间，用户空间？"><a href="#2-3-什么是内核空间，用户空间？" class="headerlink" title="2.3 什么是内核空间，用户空间？"></a>2.3 什么是内核空间，用户空间？</h3><ul><li>对 32 位操作系统而言，它的寻址空间（虚拟地址空间，或叫线性地址空间）为 4G（2的32次方）。也就是说一个进程的最大地址空间为 4G。</li><li>操作系统的核心是内核(kernel)，它独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证内核的安全，现在的操作系统一般都强制<strong>用户进程不能直接操作内核</strong>。具体的实现方式基本都是由<strong>操作系统将虚拟地址空间划分为两部分</strong>，一部分为内核空间，另一部分为用户空间。针对 Linux 操作系统而言，<strong>最高的 1G 字节</strong>(从虚拟地址 <code>0xC0000000</code> 到 <code>0xFFFFFFFF</code>)由内核使用，称为<strong>内核空间</strong>。而<strong>较低的 3G 字节</strong>(从虚拟地址 <code>0x00000000</code> 到 <code>0xBFFFFFFF</code>)由各个进程使用，称为用户空间。</li><li>对上面这段内容我们也可以这样理解：<br>每个进程的 4G 地址空间中，最高 1G 都是一样的，即内核空间。只有剩余的 3G 才归进程自己使用。换句话说就是，<strong>最高 1G 的内核空间是被所有进程共享的</strong>！</li><li>下图描述了每个进程 4G 地址空间的分配情况：</li></ul><h3 id="2-4-为什么需要区分内核空间与用户空间？"><a href="#2-4-为什么需要区分内核空间与用户空间？" class="headerlink" title="2.4 为什么需要区分内核空间与用户空间？"></a>2.4 为什么需要区分内核空间与用户空间？</h3><ul><li>在 CPU 的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，比如<strong>清内存、设置时钟</strong>等。如果允许所有的程序都可以使用这些指令，那么系统<strong>崩溃的概率将大大增加</strong>。</li><li>所以，CPU 将指令分为<strong>特权指令</strong>和<strong>非特权指令</strong>，对于那些危险的指令，只允许操作系统及其相关模块使用，普通应用程序只能使用那些不会造成灾难的指令。比如 Intel 的 CPU 将特权等级分为 4 个级别：Ring0~Ring3。</li><li>其实 Linux 系统只使用了 Ring0 和 Ring3 两个运行级别(Windows 系统也是一样的)。当进程运行在 Ring3 级别时被称为运行在用户态，而运行在 Ring0 级别时被称为运行在内核态。</li></ul><h3 id="2-5-什么是内核态和用户态？"><a href="#2-5-什么是内核态和用户态？" class="headerlink" title="2.5 什么是内核态和用户态？"></a>2.5 什么是内核态和用户态？</h3><ul><li><p>当进程<strong>运行在内核空间时</strong>就处于内核态，而进程<strong>运行在用户空间</strong>时则处于用户态。</p></li><li><p>在内核态下，进程运行在内核地址空间中，此时 CPU 可以执行任何指令。运行的代码也不受任何的限制，可以自由地访问任何有效地址，也可以直接进行端口的访问。</p></li><li><p>在用户态下，进程运行在用户地址空间中，被执行的代码要受到 CPU 的诸多检查，它们只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址，且只能对任务状态段(TSS)中 I&#x2F;O 许可位图(I&#x2F;O Permission Bitmap)中规定的可访问端口进行直接访问。</p></li><li><p>对于以前的 DOS 操作系统来说，是没有内核空间、用户空间以及内核态、用户态这些概念的。可以认为所有的代码都是运行在内核态的，因而，用户编写的应用程序代码可以很容易的让操作系统崩溃掉。</p></li><li><p>对于 Linux 来说，通过区分内核空间和用户空间的设计，<strong>隔离了操作系统代码</strong>(操作系统的代码要比应用程序的代码健壮很多)<strong>与应用程序代码</strong>。即便是单个应用程序出现错误，也不会影响到操作系统的稳定性，这样其它的程序还可以正常的运行(Linux 可是个多任务系统啊！)。所以，<strong>区分内核空间和用户空间本质上是要提高操作系统的稳定性及可用性</strong>。</p></li><li><h3 id="2-6-用户空间与内核通信方式有哪些？"><a href="#2-6-用户空间与内核通信方式有哪些？" class="headerlink" title="2.6 用户空间与内核通信方式有哪些？"></a>2.6 用户空间与内核通信方式有哪些？</h3></li></ul><ol><li><p><strong>使用API</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_user(x，ptr) <span class="comment">//在内核中被调用，获取用户空间指定地址的数值并保存到内核变量x中。</span></span><br><span class="line">put_user(x，ptr) <span class="comment">//在内核中被调用，将内核空间的变量x的数值保存到到用户空间指定地址处。</span></span><br><span class="line">copy_from_user()/copy_to_user() <span class="comment">//主要应用于设备驱动读写函数中，通过系统调用触发。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用proc文件系统</strong><br>和<code>sysfs</code>文件系统类似，也可以作为内核空间和用户空间交互的手段。<code>/proc</code> 文件系统是一种虚拟文件系统，通过他可以作为一种linux内核空间和用户空间的桥梁。与普通文件不同，这里的虚拟文件的内容都是动态创建的。使用<code>/proc</code>文件系统的方式很简单。调用<code>create_proc_entry</code>，返回一个<code>proc_dir_entry</code>指针，然后去填充这个指针指向的结构就好了。(相当于proc为用户空间的进程开了个口访问内核空间)</p></li><li><p><strong>使用sysfs文件系统+kobject</strong><br>每个在内核中注册的<code>kobject</code>都对应着<code>sysfs</code>系统中的一个目录。可以通过读取根目录下的<code>sys</code>目录中的文件来获得相应的信息。除了<code>sysfs</code>文件系统和<code>proc</code>文件系统之外，一些其他的虚拟文件系统也能同样达到这个效果。</p></li><li><p><strong>netlink</strong><br><code>netlink socket</code>提供了一组类似于BSD风格的API，用于用户态和内核态的IPC。相比于其他的用户态和内核态IPC机制，netlink有几个好处：1.使用自定义一种协议完成数据交换，不需要添加一个文件等。2.可以支持多点传送。3.支持内核先发起会话。4.异步通信，支持缓存机制。</p></li><li><p><strong>文件</strong><br>应该说这是一种比较笨拙的做法，不过确实可以这样用。当处于内核空间的时候，直接操作文件，将想要传递的信息写入文件，然后用户空间可以读取这个文件便可以得到想要的数据了。下面是一个简单的测试程序，在内核态中，程序会向<code>/home/melody/str_from_kernel</code>文件中写入一条字符串，然后我们在用户态读取这个文件，就可以得到内核态传输过来的数据了。</p></li><li><p><strong>使用mmap系统调用</strong><br>可以将内核空间的地址映射到用户空间。在以前做嵌入式的时候用到几次。一方面可以在<code>driver</code>中修改<code>Struct file_operations</code>结构中的<code>mmap</code>函数指针来重新实现一个文件对应的映射操作。另一方面，也可以直接打开<code>/dev/mem</code>文件，把物理内存中的某一页映射到进程空间中的地址上。其实，除了重写<code>Struct file_operations</code>中<code>mmap</code>函数，我们还可以重写其他的方法如<code>ioctl</code>等，来达到驱动内核空间和用户空间通信的方式。</p></li><li><p><strong>信号</strong><br>从内核空间向进程发送信号。这个倒是经常遇到，用户程序出现重大错误，内核发送信号杀死相应进程。</p></li></ol><h3 id="2-7-内核链表为什么具有通用性？"><a href="#2-7-内核链表为什么具有通用性？" class="headerlink" title="2.7 内核链表为什么具有通用性？"></a>2.7 内核链表为什么具有通用性？</h3><p>内核中由于要管理大量的设备，但是各种设备各不相同，必须将他们统一起来管理，于是内核设计者就想到了使用通用链表来处理，通用链表看似神秘，实际上就是<strong>双向循环链表</strong>，这个链表的每个节点都是只有指针域，没有任何数据域。</p><ul><li>使用通用链表的好处是：<ol><li>通用链表中每个节点中<strong>没有数据域</strong>，也就是说无论数据结构有多复杂在链表中只有前后级指针。</li><li>如果一个数据结构（即是描述设备的设备结构体）想要用通用链表管理，只需要在结构体中包含<strong>节点的字段</strong>即可。</li><li>双向链表可以从任意一个节点的前后遍历整个链表，<strong>遍历非常方便</strong>。</li><li>使用循环链表使得可以不断地循环遍历管理节点，像进程的调度：操作系统会把<strong>就绪的进程</strong>放在一个管理进程的就绪队列的通用链表中管理起来，循环不断地，为他们<strong>分配时间片</strong>，获得cpu进行周而复始的进程调度。</li></ol></li></ul><h3 id="2-8-应用程序中open-在linux中执行过程中是如何从用户空间到内核空间？"><a href="#2-8-应用程序中open-在linux中执行过程中是如何从用户空间到内核空间？" class="headerlink" title="2.8 应用程序中open()在linux中执行过程中是如何从用户空间到内核空间？"></a>2.8 应用程序中open()在linux中执行过程中是如何从用户空间到内核空间？</h3><ol><li>应用层调用<code>open</code>函数，在VFS层中找到<code>struct inode</code>结构体，判断是字符设备还是块设备，根据设备号，可以找到对应的驱动程序。</li><li>在驱动层中，每个字符设备都有一个<code>struct cdev</code>结构体，这个结构体通过<code>struct inode</code>结构体中的<code>i_cdev</code>把连接起VFS层和驱动层，<code>struct cdev</code>结构体描述了字符设备所有信息，其中最重要的一项就是字符设备的操作函数接口，即<code>const struct file_operations *ops</code></li><li><code>struct cdev</code>结构体中的<code>struct file</code>结构体记录了操作字符设备的一些函数，比如<code>open read write</code>函数等。<code>struct file</code>结构体其实是在VFS层的，通过<code>struct file</code>结构体指针指向驱动层的<code>struct file</code>结构体将驱动层函数和VFS层链接起来</li><li>任务完成，VFS层会给应用返回一个<strong>文件描述符（fd）</strong>。这个fd是和<code>struct file</code>结构体对应的。</li></ol><h2 id="3-设备驱动"><a href="#3-设备驱动" class="headerlink" title="3.设备驱动"></a>3.设备驱动</h2><h3 id="3-1-请简述主设备号和次设备号的用途"><a href="#3-1-请简述主设备号和次设备号的用途" class="headerlink" title="3.1 请简述主设备号和次设备号的用途"></a>3.1 请简述主设备号和次设备号的用途</h3><ul><li><strong>主设备号：主设备号标识设备对应的特定的驱动程序</strong>。虽然现代的linux内核允许多个驱动程序共享主设备号，但我们看待的大多数设备仍然按照“一个主设备对应一个驱动程序”的原则组织</li><li><strong>次设备号：次设备号由内核使用，用于确定由主设备号对应驱动程序中的各个设备</strong>。依赖于驱动程序的编写方式，我们可以通过次设备号获得一个指向内核设备的直接指针，也可将此设备号当作设备本地数组的索引。</li></ul><h3 id="3-2-字符型驱动设备怎么创建设备文件？"><a href="#3-2-字符型驱动设备怎么创建设备文件？" class="headerlink" title="3.2 字符型驱动设备怎么创建设备文件？"></a>3.2 字符型驱动设备怎么创建设备文件？</h3><ol><li>手动创建<br><code>mknod /dev/led c 250 0</code> ，其中<code>dev/led</code>为设备节点 ,<code>c</code> 代表字符设备, <code>250</code>代表主设备号, <code>0</code>代表次设备号。</li><li>自动创建<br><code>UDEV/MDEV</code>是运行在用户态的程序，可以动态管理设备文件，包括创建和删除设备文件，运行在用户态意味着系统要运行之后，在 <code>/etc/init.d/rcS</code> 脚本文件中会执行 <code>mdev -s</code> 自动创建设备节点。</li></ol><h3 id="3-3-设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义"><a href="#3-3-设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义" class="headerlink" title="3.3 设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义"></a>3.3 设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义</h3><ul><li><p>注册一个字符设备驱动有两种方法：</p><ol><li><code>void cdev_init(struct cdev *cdev, struct file_operations *fops)</code> 该注册函数可以将<code>cdev</code>结构嵌入到自己的设备特定的结构中。<code>cdev</code>是一个指向结构体<code>cdev</code>的指针，而<code>fops</code>是指向一个类似于 <code>file_operations</code>结构（可以是<code>file_operations</code>结构，但不限于该结构）的指针。</li><li><code>int register_chrdev(unsigned int major, const char *name, struct file operations *fops)</code>；该注册函数是早期的注册函数，<code>major</code>是设备的主设备号，<code>name</code>是驱动程序的名称，而<code>fops</code>是默认的<code>file_operations</code>结构（这是只限于<code>file_operations</code>结构）。对于<code>register_chrdev</code>的调用将为给定的主设备号注册0－255作为次设备号，并为每个设备建立一个对应的默认<code>cdev</code>结构。</li></ol><h3 id="3-4-dev-下面的设备文件是怎么创建出来的？"><a href="#3-4-dev-下面的设备文件是怎么创建出来的？" class="headerlink" title="3.4 &#x2F;dev&#x2F;下面的设备文件是怎么创建出来的？"></a>3.4 &#x2F;dev&#x2F;下面的设备文件是怎么创建出来的？</h3></li><li><p>普遍说法有三种方式，<strong>devfs机制</strong>，<strong>udev机制</strong>，再有一个就是<strong>手动创建</strong>设备节点。谈谈个人见解：</p></li></ul><ol><li><code>devfs</code>机制从来没用过，应该是2.6以前的内核使用的；</li><li><code>udev</code>：其实就是现在常用的<code>device_create()</code>、<code>class_create()</code>这一套接口，所谓<code>udev</code>是上层用户空间程序，是基于驱动中创建使用了这两个接口而起作用的，但是<code>udev</code>在日常开发中几乎接触不到，我们只需在驱动中调用创建节点的这两个API就ok了，剩下的工作就交给<code>udev</code>去做了，有想深究它具体实现原理的那就自己去研究吧，我觉得会用就行了；</li><li><code>mknod</code>：新手最常用的一种创建设备节点方法，但并非入门后就再没有用途，在某些情境下，或许有人不想使用<code>udev</code>机制，于是把节点创建工作写在脚本里，这样也是无可厚非的。</li></ol><h3 id="3-5-Linux设备中字符设备和块设备有什么主要区别？分别举例。"><a href="#3-5-Linux设备中字符设备和块设备有什么主要区别？分别举例。" class="headerlink" title="3.5 Linux设备中字符设备和块设备有什么主要区别？分别举例。"></a>3.5 Linux设备中字符设备和块设备有什么主要区别？分别举例。</h3><ul><li>Linux中I&#x2F;O设备分为两类：块设备和字符设备。两种设备本身没有严格限制，但是，基于不同的功能进行了分类。</li><li><strong>字符设备</strong>：提供<strong>连续</strong>的数据流，应用程序可以顺序读取，通常不支持随机存取。相反，此类设备支持<strong>按字节&#x2F;字符</strong>来读写数据。字符终端、串口、鼠标、键盘、摄像头、声卡和显卡等就是典型的字符设备。</li><li><strong>块设备</strong>：应用程序可以<strong>随机访问</strong>设备数据，程序可自行确定读取数据的位置。硬盘是典型的块设备，应用程序可以寻址磁盘上的<strong>任何位置</strong>，并由此读取数据。此外，数据的读写只能以块(通常是512B)的倍数进行。与字符设备不同，块设备并不支持基于字符的寻址。如：u盘，SD卡，磁盘等。</li></ul><h3 id="3-6-驱动中操作物理绝对地址为什么要先ioremap？"><a href="#3-6-驱动中操作物理绝对地址为什么要先ioremap？" class="headerlink" title="3.6 驱动中操作物理绝对地址为什么要先ioremap？"></a>3.6 驱动中操作物理绝对地址为什么要先ioremap？</h3><ul><li><code>ioremp</code>是内核中用来将外设寄存器物理地址映射到主存上去的接口，即将io地址空间映射到虚拟地址空间上去，便于操作。为什么非要映射呢，因为<strong>保护模式下的cpu只认虚拟地址，不认物理地址</strong>，给它物理地址它并不帮你做事，所以你要操作外设上的寄存器必须先映射到虚拟内存空间，拿着虚拟地址去跟cpu对接，从而操作寄存器。</li></ul><h3 id="3-7-insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？"><a href="#3-7-insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？" class="headerlink" title="3.7 insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？"></a>3.7 insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？</h3><ul><li>分别会执行<code>module_init()</code>和<code>module_exit()</code>指定的<code>init</code>函数和<code>exit</code>函数。要注意的就是，尽量使在<code>init</code>函数中出现的资源申请及使用，都要有对应的释放操作在<code>exit</code>中，即<code>init</code>申请，<code>eixt</code>释放。</li></ul><h3 id="3-8-NAND驱动的probe流程"><a href="#3-8-NAND驱动的probe流程" class="headerlink" title="3.8 NAND驱动的probe流程"></a>3.8 NAND驱动的probe流程</h3><ul><li><code>probe</code> 函数就会与NAND芯片进行，主要做的事情主要包括这几个方面：读取NAND芯片的ID ，然后查表得到这片NAND芯片的如厂商，page size，erase size以及chip size等信息，接着根据<code>struct nand_chip</code> 中<code>options</code>的值的不同，或者在NAND 芯片中的特定位置查找<code>bad block table</code>，或者scan整个NAND 芯片，并在内存中建立<code>bad block table</code>。说起来复杂，但其实所有的这些动作，都可以在MTD提供的一个叫做<code>nand_scan</code>的函数中完成。</li></ul><h3 id="3-9-Linux驱动开发中，常用的调试方法有哪些？"><a href="#3-9-Linux驱动开发中，常用的调试方法有哪些？" class="headerlink" title="3.9 Linux驱动开发中，常用的调试方法有哪些？"></a>3.9 Linux驱动开发中，常用的调试方法有哪些？</h3><ul><li><p>利用<code>printk</code>，查看OOP消息，利用<code>strace</code>，利用内核内置的<code>hacking</code>选项，利用<code>ioctl</code>方法，利用<code>/proc</code> 文件系统，使用<code>kgdb</code>。</p></li><li><p><code>strace</code> 是一个可用于诊断、调试和教学的 Linux 用户空间跟踪器，监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。</p></li><li><p><code>ioctl</code> 是设备驱动程序中设备控制接口函数，一个字符设备驱动通常会实现设备打开、关闭、读、写等功能，在一些需要细分的情境下，如果需要扩展新的功能，通常以增设<code>ioctl()</code>命令的方式实现。</p><blockquote><p>建议大家，亲手动手调试下。面试中，很大可能会问你，在写驱动过程中遇到了什么问题的，如何解决的？如果你能讲出以上几种调试方法中的一两种，一定会让面试官刮目相看！</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
            <tag> 内核编程 </tag>
            
            <tag> Linux系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令完全手册 - 嵌入式开发者必备</title>
      <link href="/2024/01/01/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Linux%E5%91%BD%E4%BB%A4%E5%AE%8C%E5%85%A8%E6%89%8B%E5%86%8C/"/>
      <url>/2024/01/01/%E7%BC%96%E7%A8%8B%E6%8A%80%E6%9C%AF/Linux%E5%91%BD%E4%BB%A4%E5%AE%8C%E5%85%A8%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="? 前言"></a>? 前言</h2><p>Linux命令行是嵌入式开发和系统管理的核心工具。本手册整理了最常用、最实用的Linux命令，按功能分类，便于快速查找和学习。</p><span id="more"></span><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="? 使用说明"></a>? 使用说明</h2><ul><li>? <strong>快速查找</strong>: 使用目录快速定位所需命令</li><li>? <strong>实用示例</strong>: 每个命令都配有实际使用示例</li><li>? <strong>效率优先</strong>: 重点介绍高频使用的参数和技巧</li><li>? <strong>嵌入式友好</strong>: 特别标注嵌入式开发中的常用场景</li></ul><h2 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="? 文件和目录操作"></a>? 文件和目录操作</h2><h3 id="基础文件操作"><a href="#基础文件操作" class="headerlink" title="基础文件操作"></a>基础文件操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出文件和目录</span></span><br><span class="line"><span class="built_in">ls</span>                    <span class="comment"># 列出当前目录内容</span></span><br><span class="line"><span class="built_in">ls</span> -la               <span class="comment"># 详细信息，包含隐藏文件</span></span><br><span class="line"><span class="built_in">ls</span> -lh               <span class="comment"># 人性化显示文件大小</span></span><br><span class="line"><span class="built_in">ls</span> -lt               <span class="comment"># 按修改时间排序</span></span><br><span class="line"><span class="built_in">ls</span> -lS               <span class="comment"># 按文件大小排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换目录</span></span><br><span class="line"><span class="built_in">cd</span> /path/to/dir      <span class="comment"># 切换到指定目录</span></span><br><span class="line"><span class="built_in">cd</span> ~                 <span class="comment"># 切换到家目录</span></span><br><span class="line"><span class="built_in">cd</span> -                 <span class="comment"># 切换到上一个目录</span></span><br><span class="line"><span class="built_in">cd</span> ..                <span class="comment"># 切换到上级目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前路径</span></span><br><span class="line"><span class="built_in">pwd</span>                  <span class="comment"># 显示当前工作目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> <span class="built_in">dirname</span>        <span class="comment"># 创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p a/b/c      <span class="comment"># 递归创建多级目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -m 755 <span class="built_in">dirname</span> <span class="comment"># 创建目录并设置权限</span></span><br></pre></td></tr></table></figure><h3 id="文件复制、移动、删除"><a href="#文件复制、移动、删除" class="headerlink" title="文件复制、移动、删除"></a>文件复制、移动、删除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制文件</span></span><br><span class="line"><span class="built_in">cp</span> file1 file2       <span class="comment"># 复制文件</span></span><br><span class="line"><span class="built_in">cp</span> -r dir1 dir2      <span class="comment"># 递归复制目录</span></span><br><span class="line"><span class="built_in">cp</span> -p file1 file2    <span class="comment"># 保持文件属性</span></span><br><span class="line"><span class="built_in">cp</span> -u file1 file2    <span class="comment"># 只在源文件较新时复制</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动/重命名</span></span><br><span class="line"><span class="built_in">mv</span> file1 file2       <span class="comment"># 重命名文件</span></span><br><span class="line"><span class="built_in">mv</span> file1 /path/      <span class="comment"># 移动文件到目录</span></span><br><span class="line"><span class="built_in">mv</span> dir1 dir2         <span class="comment"># 重命名目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line"><span class="built_in">rm</span> file              <span class="comment"># 删除文件</span></span><br><span class="line"><span class="built_in">rm</span> -f file           <span class="comment"># 强制删除</span></span><br><span class="line"><span class="built_in">rm</span> -r <span class="built_in">dir</span>            <span class="comment"># 递归删除目录</span></span><br><span class="line"><span class="built_in">rm</span> -rf <span class="built_in">dir</span>           <span class="comment"># 强制递归删除（危险操作！）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建链接</span></span><br><span class="line"><span class="built_in">ln</span> file <span class="built_in">link</span>         <span class="comment"># 创建硬链接</span></span><br><span class="line"><span class="built_in">ln</span> -s file <span class="built_in">link</span>      <span class="comment"># 创建软链接（符号链接）</span></span><br></pre></td></tr></table></figure><h3 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># find命令 - 强大的文件查找工具</span></span><br><span class="line">find /path -name <span class="string">&quot;*.c&quot;</span>           <span class="comment"># 按名称查找</span></span><br><span class="line">find /path -<span class="built_in">type</span> f               <span class="comment"># 查找文件</span></span><br><span class="line">find /path -<span class="built_in">type</span> d               <span class="comment"># 查找目录</span></span><br><span class="line">find /path -size +100M           <span class="comment"># 查找大于100M的文件</span></span><br><span class="line">find /path -mtime -7             <span class="comment"># 查找7天内修改的文件</span></span><br><span class="line">find /path -user username        <span class="comment"># 查找指定用户的文件</span></span><br><span class="line">find /path -perm 755             <span class="comment"># 查找指定权限的文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># locate命令 - 快速查找（需要updatedb）</span></span><br><span class="line">locate filename      <span class="comment"># 快速查找文件</span></span><br><span class="line">updatedb            <span class="comment"># 更新文件数据库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># which和whereis</span></span><br><span class="line"><span class="built_in">which</span> <span class="built_in">command</span>        <span class="comment"># 查找命令的路径</span></span><br><span class="line">whereis <span class="built_in">command</span>      <span class="comment"># 查找命令、源码、手册的路径</span></span><br></pre></td></tr></table></figure><h2 id="文件内容操作"><a href="#文件内容操作" class="headerlink" title="? 文件内容操作"></a>? 文件内容操作</h2><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看文件内容</span></span><br><span class="line"><span class="built_in">cat</span> file             <span class="comment"># 显示整个文件内容</span></span><br><span class="line"><span class="built_in">cat</span> -n file          <span class="comment"># 显示行号</span></span><br><span class="line"><span class="built_in">cat</span> -A file          <span class="comment"># 显示所有字符（包括控制字符）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分页查看</span></span><br><span class="line">less file            <span class="comment"># 分页查看（推荐）</span></span><br><span class="line">more file            <span class="comment"># 分页查看</span></span><br><span class="line"><span class="built_in">head</span> file            <span class="comment"># 显示文件前10行</span></span><br><span class="line"><span class="built_in">head</span> -n 20 file      <span class="comment"># 显示前20行</span></span><br><span class="line"><span class="built_in">tail</span> file            <span class="comment"># 显示文件后10行</span></span><br><span class="line"><span class="built_in">tail</span> -n 20 file      <span class="comment"># 显示后20行</span></span><br><span class="line"><span class="built_in">tail</span> -f file         <span class="comment"># 实时监控文件变化（常用于日志）</span></span><br></pre></td></tr></table></figure><h3 id="文本搜索和处理"><a href="#文本搜索和处理" class="headerlink" title="文本搜索和处理"></a>文本搜索和处理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># grep - 文本搜索</span></span><br><span class="line">grep <span class="string">&quot;pattern&quot;</span> file              <span class="comment"># 搜索模式</span></span><br><span class="line">grep -i <span class="string">&quot;pattern&quot;</span> file           <span class="comment"># 忽略大小写</span></span><br><span class="line">grep -r <span class="string">&quot;pattern&quot;</span> <span class="built_in">dir</span>            <span class="comment"># 递归搜索目录</span></span><br><span class="line">grep -n <span class="string">&quot;pattern&quot;</span> file           <span class="comment"># 显示行号</span></span><br><span class="line">grep -v <span class="string">&quot;pattern&quot;</span> file           <span class="comment"># 反向匹配（不包含模式的行）</span></span><br><span class="line">grep -E <span class="string">&quot;pattern1|pattern2&quot;</span> file <span class="comment"># 扩展正则表达式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sed - 流编辑器</span></span><br><span class="line">sed <span class="string">&#x27;s/old/new/g&#x27;</span> file          <span class="comment"># 替换文本</span></span><br><span class="line">sed -i <span class="string">&#x27;s/old/new/g&#x27;</span> file       <span class="comment"># 直接修改文件</span></span><br><span class="line">sed -n <span class="string">&#x27;1,10p&#x27;</span> file             <span class="comment"># 显示1-10行</span></span><br><span class="line">sed <span class="string">&#x27;5d&#x27;</span> file                   <span class="comment"># 删除第5行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># awk - 文本处理工具</span></span><br><span class="line">awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> file           <span class="comment"># 打印第一列</span></span><br><span class="line">awk -F: <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> /etc/passwd <span class="comment"># 指定分隔符</span></span><br><span class="line">awk <span class="string">&#x27;NR==5&#x27;</span> file                <span class="comment"># 打印第5行</span></span><br><span class="line">awk <span class="string">&#x27;length &gt; 80&#x27;</span> file          <span class="comment"># 打印长度超过80的行</span></span><br></pre></td></tr></table></figure><h3 id="文件比较和排序"><a href="#文件比较和排序" class="headerlink" title="文件比较和排序"></a>文件比较和排序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件比较</span></span><br><span class="line">diff file1 file2     <span class="comment"># 比较两个文件</span></span><br><span class="line">diff -u file1 file2  <span class="comment"># 统一格式显示差异</span></span><br><span class="line">cmp file1 file2      <span class="comment"># 字节级比较</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序和去重</span></span><br><span class="line"><span class="built_in">sort</span> file            <span class="comment"># 排序文件内容</span></span><br><span class="line"><span class="built_in">sort</span> -n file         <span class="comment"># 数字排序</span></span><br><span class="line"><span class="built_in">sort</span> -r file         <span class="comment"># 逆序排序</span></span><br><span class="line"><span class="built_in">sort</span> -u file         <span class="comment"># 排序并去重</span></span><br><span class="line"><span class="built_in">uniq</span> file            <span class="comment"># 去除相邻重复行</span></span><br><span class="line"><span class="built_in">uniq</span> -c file         <span class="comment"># 统计重复次数</span></span><br></pre></td></tr></table></figure><h2 id="系统信息和监控"><a href="#系统信息和监控" class="headerlink" title="? 系统信息和监控"></a>? 系统信息和监控</h2><h3 id="系统基本信息"><a href="#系统基本信息" class="headerlink" title="系统基本信息"></a>系统基本信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 系统信息</span></span><br><span class="line"><span class="built_in">uname</span> -a             <span class="comment"># 显示所有系统信息</span></span><br><span class="line"><span class="built_in">uname</span> -r             <span class="comment"># 显示内核版本</span></span><br><span class="line">hostname             <span class="comment"># 显示主机名</span></span><br><span class="line"><span class="built_in">uptime</span>               <span class="comment"># 显示系统运行时间和负载</span></span><br><span class="line"><span class="built_in">whoami</span>               <span class="comment"># 显示当前用户</span></span><br><span class="line"><span class="built_in">id</span>                   <span class="comment"># 显示用户和组ID</span></span><br><span class="line"><span class="built_in">date</span>                 <span class="comment"># 显示当前日期时间</span></span><br><span class="line">cal                  <span class="comment"># 显示日历</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 硬件信息</span></span><br><span class="line">lscpu                <span class="comment"># 显示CPU信息</span></span><br><span class="line">lsblk                <span class="comment"># 显示块设备信息</span></span><br><span class="line">lsusb                <span class="comment"># 显示USB设备</span></span><br><span class="line">lspci                <span class="comment"># 显示PCI设备</span></span><br><span class="line">dmidecode            <span class="comment"># 显示硬件详细信息（需要root权限）</span></span><br></pre></td></tr></table></figure><h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看进程</span></span><br><span class="line">ps aux               <span class="comment"># 显示所有进程</span></span><br><span class="line">ps -ef               <span class="comment"># 另一种格式显示进程</span></span><br><span class="line">pstree               <span class="comment"># 树形显示进程</span></span><br><span class="line">top                  <span class="comment"># 实时显示进程（交互式）</span></span><br><span class="line">htop                 <span class="comment"># 增强版top（需要安装）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程控制</span></span><br><span class="line"><span class="built_in">kill</span> PID             <span class="comment"># 终止进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 PID          <span class="comment"># 强制终止进程</span></span><br><span class="line">killall process_name <span class="comment"># 按名称终止进程</span></span><br><span class="line">pkill pattern        <span class="comment"># 按模式终止进程</span></span><br><span class="line"><span class="built_in">nohup</span> <span class="built_in">command</span> &amp;      <span class="comment"># 后台运行命令，忽略挂起信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务管理</span></span><br><span class="line"><span class="built_in">jobs</span>                 <span class="comment"># 显示当前任务</span></span><br><span class="line"><span class="built_in">bg</span> %1                <span class="comment"># 将任务1放到后台</span></span><br><span class="line"><span class="built_in">fg</span> %1                <span class="comment"># 将任务1调到前台</span></span><br><span class="line">Ctrl+Z               <span class="comment"># 暂停当前任务</span></span><br><span class="line">Ctrl+C               <span class="comment"># 终止当前任务</span></span><br></pre></td></tr></table></figure><h3 id="内存和磁盘"><a href="#内存和磁盘" class="headerlink" title="内存和磁盘"></a>内存和磁盘</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内存信息</span></span><br><span class="line">free -h              <span class="comment"># 显示内存使用情况（人性化格式）</span></span><br><span class="line"><span class="built_in">cat</span> /proc/meminfo    <span class="comment"># 详细内存信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 磁盘使用</span></span><br><span class="line"><span class="built_in">df</span> -h                <span class="comment"># 显示磁盘使用情况</span></span><br><span class="line"><span class="built_in">du</span> -h <span class="built_in">dir</span>            <span class="comment"># 显示目录大小</span></span><br><span class="line"><span class="built_in">du</span> -sh *             <span class="comment"># 显示当前目录下各项大小</span></span><br><span class="line"><span class="built_in">du</span> -h --max-depth=1  <span class="comment"># 限制显示深度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 磁盘I/O</span></span><br><span class="line">iostat               <span class="comment"># 显示I/O统计信息</span></span><br><span class="line">iotop                <span class="comment"># 实时显示I/O使用情况</span></span><br></pre></td></tr></table></figure><h2 id="网络工具"><a href="#网络工具" class="headerlink" title="? 网络工具"></a>? 网络工具</h2><h3 id="网络配置和状态"><a href="#网络配置和状态" class="headerlink" title="网络配置和状态"></a>网络配置和状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网络接口</span></span><br><span class="line">ifconfig             <span class="comment"># 显示网络接口信息（传统命令）</span></span><br><span class="line">ip addr show         <span class="comment"># 显示IP地址（现代命令）</span></span><br><span class="line">ip route show        <span class="comment"># 显示路由表</span></span><br><span class="line">ip <span class="built_in">link</span> show         <span class="comment"># 显示网络接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网络连接</span></span><br><span class="line">netstat -tuln        <span class="comment"># 显示监听端口</span></span><br><span class="line">netstat -an          <span class="comment"># 显示所有连接</span></span><br><span class="line">ss -tuln             <span class="comment"># 现代版netstat</span></span><br><span class="line">lsof -i :80          <span class="comment"># 显示使用80端口的进程</span></span><br></pre></td></tr></table></figure><h3 id="网络测试"><a href="#网络测试" class="headerlink" title="网络测试"></a>网络测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连通性测试</span></span><br><span class="line">ping host            <span class="comment"># 测试连通性</span></span><br><span class="line">ping -c 4 host       <span class="comment"># 发送4个包</span></span><br><span class="line">traceroute host      <span class="comment"># 跟踪路由路径</span></span><br><span class="line">mtr host             <span class="comment"># 结合ping和traceroute</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DNS查询</span></span><br><span class="line">nslookup domain      <span class="comment"># DNS查询</span></span><br><span class="line">dig domain           <span class="comment"># 详细DNS查询</span></span><br><span class="line">host domain          <span class="comment"># 简单DNS查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网络传输</span></span><br><span class="line">wget url             <span class="comment"># 下载文件</span></span><br><span class="line">curl url             <span class="comment"># 获取网页内容</span></span><br><span class="line">curl -O url          <span class="comment"># 下载文件</span></span><br><span class="line">scp file user@host:path  <span class="comment"># 安全复制文件</span></span><br><span class="line">rsync -av src dest   <span class="comment"># 同步文件/目录</span></span><br></pre></td></tr></table></figure><h2 id="权限和用户管理"><a href="#权限和用户管理" class="headerlink" title="? 权限和用户管理"></a>? 权限和用户管理</h2><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看权限</span></span><br><span class="line"><span class="built_in">ls</span> -l file           <span class="comment"># 查看文件权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改权限</span></span><br><span class="line"><span class="built_in">chmod</span> 755 file       <span class="comment"># 数字方式设置权限</span></span><br><span class="line"><span class="built_in">chmod</span> u+x file       <span class="comment"># 给所有者添加执行权限</span></span><br><span class="line"><span class="built_in">chmod</span> g-w file       <span class="comment"># 移除组写权限</span></span><br><span class="line"><span class="built_in">chmod</span> o=r file       <span class="comment"># 设置其他用户只读权限</span></span><br><span class="line"><span class="built_in">chmod</span> -R 644 <span class="built_in">dir</span>     <span class="comment"># 递归设置目录权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改所有者</span></span><br><span class="line"><span class="built_in">chown</span> user file      <span class="comment"># 改变文件所有者</span></span><br><span class="line"><span class="built_in">chown</span> user:group file <span class="comment"># 改变所有者和组</span></span><br><span class="line"><span class="built_in">chgrp</span> group file     <span class="comment"># 改变文件组</span></span><br></pre></td></tr></table></figure><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户信息</span></span><br><span class="line"><span class="built_in">who</span>                  <span class="comment"># 显示当前登录用户</span></span><br><span class="line">w                    <span class="comment"># 显示用户活动</span></span><br><span class="line">last                 <span class="comment"># 显示登录历史</span></span><br><span class="line">finger user          <span class="comment"># 显示用户信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换用户</span></span><br><span class="line">su user              <span class="comment"># 切换用户</span></span><br><span class="line">su -                 <span class="comment"># 切换到root并加载环境</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">command</span>         <span class="comment"># 以管理员权限执行命令</span></span><br><span class="line"><span class="built_in">sudo</span> -u user <span class="built_in">command</span> <span class="comment"># 以指定用户身份执行命令</span></span><br></pre></td></tr></table></figure><h2 id="软件包管理"><a href="#软件包管理" class="headerlink" title="? 软件包管理"></a>? 软件包管理</h2><h3 id="APT-Debian-Ubuntu"><a href="#APT-Debian-Ubuntu" class="headerlink" title="APT (Debian&#x2F;Ubuntu)"></a>APT (Debian&#x2F;Ubuntu)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 包管理</span></span><br><span class="line">apt update           <span class="comment"># 更新包列表</span></span><br><span class="line">apt upgrade          <span class="comment"># 升级所有包</span></span><br><span class="line">apt install package  <span class="comment"># 安装包</span></span><br><span class="line">apt remove package   <span class="comment"># 删除包</span></span><br><span class="line">apt purge package    <span class="comment"># 完全删除包（包括配置）</span></span><br><span class="line">apt autoremove       <span class="comment"># 删除不需要的依赖</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索和信息</span></span><br><span class="line">apt search keyword   <span class="comment"># 搜索包</span></span><br><span class="line">apt show package     <span class="comment"># 显示包信息</span></span><br><span class="line">apt list --installed <span class="comment"># 列出已安装包</span></span><br></pre></td></tr></table></figure><h3 id="YUM-DNF-RedHat-CentOS-Fedora"><a href="#YUM-DNF-RedHat-CentOS-Fedora" class="headerlink" title="YUM&#x2F;DNF (RedHat&#x2F;CentOS&#x2F;Fedora)"></a>YUM&#x2F;DNF (RedHat&#x2F;CentOS&#x2F;Fedora)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># YUM命令</span></span><br><span class="line">yum update           <span class="comment"># 更新系统</span></span><br><span class="line">yum install package  <span class="comment"># 安装包</span></span><br><span class="line">yum remove package   <span class="comment"># 删除包</span></span><br><span class="line">yum search keyword   <span class="comment"># 搜索包</span></span><br><span class="line">yum info package     <span class="comment"># 显示包信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># DNF命令（Fedora新版本）</span></span><br><span class="line">dnf update           <span class="comment"># 更新系统</span></span><br><span class="line">dnf install package  <span class="comment"># 安装包</span></span><br><span class="line">dnf remove package   <span class="comment"># 删除包</span></span><br></pre></td></tr></table></figure><h2 id="系统服务管理"><a href="#系统服务管理" class="headerlink" title="? 系统服务管理"></a>? 系统服务管理</h2><h3 id="Systemd-现代Linux发行版"><a href="#Systemd-现代Linux发行版" class="headerlink" title="Systemd (现代Linux发行版)"></a>Systemd (现代Linux发行版)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务控制</span></span><br><span class="line">systemctl start service     <span class="comment"># 启动服务</span></span><br><span class="line">systemctl stop service      <span class="comment"># 停止服务</span></span><br><span class="line">systemctl restart service   <span class="comment"># 重启服务</span></span><br><span class="line">systemctl reload service    <span class="comment"># 重新加载配置</span></span><br><span class="line">systemctl <span class="built_in">enable</span> service    <span class="comment"># 开机自启</span></span><br><span class="line">systemctl <span class="built_in">disable</span> service   <span class="comment"># 禁用自启</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务状态</span></span><br><span class="line">systemctl status service    <span class="comment"># 查看服务状态</span></span><br><span class="line">systemctl is-active service <span class="comment"># 检查服务是否运行</span></span><br><span class="line">systemctl list-units        <span class="comment"># 列出所有单元</span></span><br><span class="line">systemctl list-unit-files   <span class="comment"># 列出所有单元文件</span></span><br></pre></td></tr></table></figure><h2 id="压缩和归档"><a href="#压缩和归档" class="headerlink" title="?? 压缩和归档"></a>?? 压缩和归档</h2><h3 id="tar归档"><a href="#tar归档" class="headerlink" title="tar归档"></a>tar归档</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建归档</span></span><br><span class="line">tar -cvf archive.tar files     <span class="comment"># 创建tar归档</span></span><br><span class="line">tar -czvf archive.tar.gz files <span class="comment"># 创建gzip压缩归档</span></span><br><span class="line">tar -cjvf archive.tar.bz2 files <span class="comment"># 创建bzip2压缩归档</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压归档</span></span><br><span class="line">tar -xvf archive.tar           <span class="comment"># 解压tar归档</span></span><br><span class="line">tar -xzvf archive.tar.gz       <span class="comment"># 解压gzip归档</span></span><br><span class="line">tar -xjvf archive.tar.bz2      <span class="comment"># 解压bzip2归档</span></span><br><span class="line">tar -tf archive.tar            <span class="comment"># 列出归档内容</span></span><br></pre></td></tr></table></figure><h3 id="其他压缩工具"><a href="#其他压缩工具" class="headerlink" title="其他压缩工具"></a>其他压缩工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># zip/unzip</span></span><br><span class="line">zip -r archive.zip files       <span class="comment"># 创建zip归档</span></span><br><span class="line">unzip archive.zip              <span class="comment"># 解压zip归档</span></span><br><span class="line">unzip -l archive.zip           <span class="comment"># 列出zip内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gzip/gunzip</span></span><br><span class="line">gzip file                      <span class="comment"># 压缩文件</span></span><br><span class="line">gunzip file.gz                 <span class="comment"># 解压文件</span></span><br><span class="line">zcat file.gz                   <span class="comment"># 查看压缩文件内容</span></span><br></pre></td></tr></table></figure><h2 id="系统监控和调试"><a href="#系统监控和调试" class="headerlink" title="? 系统监控和调试"></a>? 系统监控和调试</h2><h3 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 系统负载</span></span><br><span class="line">top                  <span class="comment"># 实时系统监控</span></span><br><span class="line">htop                 <span class="comment"># 增强版top</span></span><br><span class="line">atop                 <span class="comment"># 高级系统监控</span></span><br><span class="line">vmstat 1             <span class="comment"># 虚拟内存统计</span></span><br><span class="line">iostat 1             <span class="comment"># I/O统计</span></span><br><span class="line">sar -u 1 10          <span class="comment"># CPU使用率统计</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 网络监控</span></span><br><span class="line">iftop                <span class="comment"># 网络流量监控</span></span><br><span class="line">nethogs              <span class="comment"># 按进程显示网络使用</span></span><br><span class="line">tcpdump              <span class="comment"># 网络包捕获</span></span><br><span class="line">wireshark            <span class="comment"># 图形化网络分析工具</span></span><br></pre></td></tr></table></figure><h3 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 系统日志</span></span><br><span class="line">journalctl           <span class="comment"># 查看systemd日志</span></span><br><span class="line">journalctl -u service <span class="comment"># 查看特定服务日志</span></span><br><span class="line">journalctl -f        <span class="comment"># 实时跟踪日志</span></span><br><span class="line">journalctl --since <span class="string">&quot;1 hour ago&quot;</span> <span class="comment"># 查看最近1小时日志</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 传统日志</span></span><br><span class="line"><span class="built_in">tail</span> -f /var/log/syslog        <span class="comment"># 实时查看系统日志</span></span><br><span class="line"><span class="built_in">tail</span> -f /var/log/messages      <span class="comment"># 实时查看消息日志</span></span><br><span class="line">grep ERROR /var/log/syslog     <span class="comment"># 搜索错误信息</span></span><br></pre></td></tr></table></figure><h2 id="嵌入式开发专用"><a href="#嵌入式开发专用" class="headerlink" title="?? 嵌入式开发专用"></a>?? 嵌入式开发专用</h2><h3 id="交叉编译环境"><a href="#交叉编译环境" class="headerlink" title="交叉编译环境"></a>交叉编译环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 环境变量设置</span></span><br><span class="line"><span class="built_in">export</span> CROSS_COMPILE=arm-linux-gnueabihf-</span><br><span class="line"><span class="built_in">export</span> ARCH=arm</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/opt/toolchain/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译内核</span></span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j4</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- modules</span><br><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- dtbs</span><br></pre></td></tr></table></figure><h3 id="设备调试"><a href="#设备调试" class="headerlink" title="设备调试"></a>设备调试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 串口通信</span></span><br><span class="line">minicom -D /dev/ttyUSB0        <span class="comment"># 串口终端</span></span><br><span class="line">screen /dev/ttyUSB0 115200     <span class="comment"># 使用screen连接串口</span></span><br><span class="line">picocom -b 115200 /dev/ttyUSB0 <span class="comment"># 使用picocom</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设备信息</span></span><br><span class="line">lsmod                <span class="comment"># 列出加载的内核模块</span></span><br><span class="line">modinfo module_name  <span class="comment"># 显示模块信息</span></span><br><span class="line">dmesg               <span class="comment"># 显示内核消息</span></span><br><span class="line">dmesg | <span class="built_in">tail</span>        <span class="comment"># 显示最新内核消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># GPIO和硬件</span></span><br><span class="line"><span class="built_in">cat</span> /proc/cpuinfo   <span class="comment"># CPU信息</span></span><br><span class="line"><span class="built_in">cat</span> /proc/meminfo   <span class="comment"># 内存信息</span></span><br><span class="line"><span class="built_in">cat</span> /proc/version   <span class="comment"># 内核版本</span></span><br><span class="line"><span class="built_in">ls</span> /sys/class/gpio  <span class="comment"># GPIO信息</span></span><br></pre></td></tr></table></figure><h3 id="文件系统操作"><a href="#文件系统操作" class="headerlink" title="文件系统操作"></a>文件系统操作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 挂载文件系统</span></span><br><span class="line">mount /dev/sdb1 /mnt           <span class="comment"># 挂载设备</span></span><br><span class="line">umount /mnt                    <span class="comment"># 卸载</span></span><br><span class="line">mount -t nfs server:/path /mnt <span class="comment"># NFS挂载</span></span><br><span class="line">mount -o loop image.img /mnt   <span class="comment"># 挂载镜像文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件系统检查</span></span><br><span class="line">fsck /dev/sdb1      <span class="comment"># 检查文件系统</span></span><br><span class="line">fsck -f /dev/sdb1   <span class="comment"># 强制检查</span></span><br><span class="line"><span class="built_in">df</span> -h               <span class="comment"># 显示文件系统使用情况</span></span><br></pre></td></tr></table></figure><h2 id="实用技巧和快捷键"><a href="#实用技巧和快捷键" class="headerlink" title="? 实用技巧和快捷键"></a>? 实用技巧和快捷键</h2><h3 id="命令行快捷键"><a href="#命令行快捷键" class="headerlink" title="命令行快捷键"></a>命令行快捷键</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 光标移动</span></span><br><span class="line">Ctrl+A              <span class="comment"># 移动到行首</span></span><br><span class="line">Ctrl+E              <span class="comment"># 移动到行尾</span></span><br><span class="line">Ctrl+F              <span class="comment"># 向前移动一个字符</span></span><br><span class="line">Ctrl+B              <span class="comment"># 向后移动一个字符</span></span><br><span class="line">Alt+F               <span class="comment"># 向前移动一个单词</span></span><br><span class="line">Alt+B               <span class="comment"># 向后移动一个单词</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑</span></span><br><span class="line">Ctrl+U              <span class="comment"># 删除光标前的内容</span></span><br><span class="line">Ctrl+K              <span class="comment"># 删除光标后的内容</span></span><br><span class="line">Ctrl+W              <span class="comment"># 删除光标前的单词</span></span><br><span class="line">Ctrl+Y              <span class="comment"># 粘贴删除的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 历史命令</span></span><br><span class="line">Ctrl+R              <span class="comment"># 搜索历史命令</span></span><br><span class="line">Ctrl+P              <span class="comment"># 上一个命令</span></span><br><span class="line">Ctrl+N              <span class="comment"># 下一个命令</span></span><br><span class="line">!!                  <span class="comment"># 执行上一个命令</span></span><br><span class="line">!n                  <span class="comment"># 执行历史中第n个命令</span></span><br></pre></td></tr></table></figure><h3 id="管道和重定向"><a href="#管道和重定向" class="headerlink" title="管道和重定向"></a>管道和重定向</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重定向</span></span><br><span class="line"><span class="built_in">command</span> &gt; file      <span class="comment"># 重定向输出到文件</span></span><br><span class="line"><span class="built_in">command</span> &gt;&gt; file     <span class="comment"># 追加输出到文件</span></span><br><span class="line"><span class="built_in">command</span> &lt; file      <span class="comment"># 从文件读取输入</span></span><br><span class="line"><span class="built_in">command</span> 2&gt; file     <span class="comment"># 重定向错误输出</span></span><br><span class="line"><span class="built_in">command</span> &amp;&gt; file     <span class="comment"># 重定向所有输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 管道</span></span><br><span class="line">command1 | command2 <span class="comment"># 将command1的输出作为command2的输入</span></span><br><span class="line"><span class="built_in">command</span> | <span class="built_in">tee</span> file  <span class="comment"># 同时输出到屏幕和文件</span></span><br><span class="line"><span class="built_in">command</span> | xargs     <span class="comment"># 将输入转换为命令参数</span></span><br></pre></td></tr></table></figure><h3 id="别名和函数"><a href="#别名和函数" class="headerlink" title="别名和函数"></a>别名和函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建别名</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -la&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> grep=<span class="string">&#x27;grep --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ..=<span class="string">&#x27;cd ..&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">mkcd</span></span>() &#123;</span><br><span class="line">    <span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$1</span>&quot;</span> &amp;&amp; <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看别名</span></span><br><span class="line"><span class="built_in">alias</span>               <span class="comment"># 显示所有别名</span></span><br></pre></td></tr></table></figure><h2 id="安全和备份"><a href="#安全和备份" class="headerlink" title="? 安全和备份"></a>? 安全和备份</h2><h3 id="系统安全"><a href="#系统安全" class="headerlink" title="系统安全"></a>系统安全</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 防火墙</span></span><br><span class="line">ufw <span class="built_in">enable</span>          <span class="comment"># 启用防火墙</span></span><br><span class="line">ufw status          <span class="comment"># 查看防火墙状态</span></span><br><span class="line">ufw allow 22        <span class="comment"># 允许SSH端口</span></span><br><span class="line">ufw deny 80         <span class="comment"># 拒绝HTTP端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件权限安全</span></span><br><span class="line">find / -perm -4000  <span class="comment"># 查找SUID文件</span></span><br><span class="line">find / -perm -2000  <span class="comment"># 查找SGID文件</span></span><br><span class="line">find / -<span class="built_in">type</span> f -perm 777 <span class="comment"># 查找所有人可写的文件</span></span><br></pre></td></tr></table></figure><h3 id="备份和同步"><a href="#备份和同步" class="headerlink" title="备份和同步"></a>备份和同步</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rsync备份</span></span><br><span class="line">rsync -av <span class="built_in">source</span>/ dest/              <span class="comment"># 本地同步</span></span><br><span class="line">rsync -av <span class="built_in">source</span>/ user@host:dest/    <span class="comment"># 远程同步</span></span><br><span class="line">rsync -av --delete <span class="built_in">source</span>/ dest/     <span class="comment"># 同步并删除目标多余文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tar备份</span></span><br><span class="line">tar -czf backup.tar.gz /important/data</span><br><span class="line">tar -czf backup-$(<span class="built_in">date</span> +%Y%m%d).tar.gz /data</span><br></pre></td></tr></table></figure><h2 id="学习资源"><a href="#学习资源" class="headerlink" title="? 学习资源"></a>? 学习资源</h2><h3 id="手册和帮助"><a href="#手册和帮助" class="headerlink" title="手册和帮助"></a>手册和帮助</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">man <span class="built_in">command</span>         <span class="comment"># 查看命令手册</span></span><br><span class="line">info <span class="built_in">command</span>        <span class="comment"># 查看info文档</span></span><br><span class="line"><span class="built_in">command</span> --<span class="built_in">help</span>      <span class="comment"># 查看命令帮助</span></span><br><span class="line"><span class="built_in">which</span> <span class="built_in">command</span>       <span class="comment"># 查找命令位置</span></span><br><span class="line"><span class="built_in">type</span> <span class="built_in">command</span>        <span class="comment"># 显示命令类型</span></span><br></pre></td></tr></table></figure><h3 id="推荐学习资源"><a href="#推荐学习资源" class="headerlink" title="推荐学习资源"></a>推荐学习资源</h3><ul><li><strong>在线手册</strong>: <a href="https://www.linuxcool.com/">Linux命令大全</a></li><li><strong>交互式学习</strong>: <a href="https://linuxjourney.com/">Linux Journey</a></li><li><strong>实践环境</strong>: <a href="https://overthewire.org/wargames/">OverTheWire</a></li><li><strong>书籍推荐</strong>: 《鸟哥的Linux私房菜》、《Linux命令行与shell脚本编程大全》</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="? 总结"></a>? 总结</h2><p>这份Linux命令手册涵盖了日常开发和系统管理中最常用的命令。建议：</p><ol><li><strong>循序渐进</strong>: 从基础命令开始，逐步掌握高级功能</li><li><strong>多加练习</strong>: 在安全环境中多实践，熟能生巧</li><li><strong>善用手册</strong>: 遇到问题时多查看man手册</li><li><strong>自定义环境</strong>: 根据需要设置别名和函数</li><li><strong>安全意识</strong>: 特别是在生产环境中，谨慎使用危险命令</li></ol><p>掌握这些命令，你将能够高效地进行Linux系统管理和嵌入式开发工作！</p><hr><blockquote><p>? <strong>提示</strong>: 建议将常用命令制作成速查卡片，放在工作台旁边，方便随时查阅。</p></blockquote><p><strong>相关文章推荐</strong>:</p><ul><li><a href="/2024/08/07/shell-programming/">Shell脚本编程指南</a></li><li><a href="/2024/08/07/embedded-linux-setup/">嵌入式Linux开发环境搭建</a></li><li><a href="/2024/08/07/linux-optimization/">Linux系统调优实践</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
          <category> Linux系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 命令行 </tag>
            
            <tag> 系统管理 </tag>
            
            <tag> 嵌入式开发 </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 常用命令自查手册</title>
      <link href="/2024/01/01/test/linux%E5%9F%BA%E7%A1%80/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%87%AA%E6%9F%A5%E6%89%8B%E5%86%8C/"/>
      <url>/2024/01/01/test/linux%E5%9F%BA%E7%A1%80/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%87%AA%E6%9F%A5%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-常用命令自查手册"><a href="#Linux-常用命令自查手册" class="headerlink" title="Linux 常用命令自查手册"></a><strong>Linux 常用命令自查手册</strong></h1><h2 id="APT软件工具"><a href="#APT软件工具" class="headerlink" title="APT软件工具"></a>APT软件工具</h2><p><img src="/././images/image-20250530183119170.png" alt="image-20250530183119170"></p><h2 id="关机-重启-注销"><a href="#关机-重启-注销" class="headerlink" title="关机&#x2F;重启&#x2F;注销"></a>关机&#x2F;重启&#x2F;注销</h2><p><img src="/././images/image-20250530183259481.png" alt="image-20250530183259481"></p><h2 id="系统信息和性能查看"><a href="#系统信息和性能查看" class="headerlink" title="系统信息和性能查看"></a>系统信息和性能查看</h2><p><img src="/././images/2.jpg" alt="2"></p><h2 id="磁盘和分区"><a href="#磁盘和分区" class="headerlink" title="磁盘和分区"></a>磁盘和分区</h2><p><img src="/././images/3.jpg" alt="3"></p><h2 id="用户和用户名"><a href="#用户和用户名" class="headerlink" title="用户和用户名"></a>用户和用户名</h2><p><img src="/././images/4.jpg" alt="4"></p><h2 id="网络和进程管理"><a href="#网络和进程管理" class="headerlink" title="网络和进程管理"></a>网络和进程管理</h2><p><img src="/././images/5.jpg" alt="5"></p><h2 id="常见系统服务命令"><a href="#常见系统服务命令" class="headerlink" title="常见系统服务命令"></a>常见系统服务命令</h2><p><img src="/././images/6.jpg" alt="6"></p><h2 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h2><p><img src="/././images/7.jpg" alt="7"></p><h2 id="文件查看和处理"><a href="#文件查看和处理" class="headerlink" title="文件查看和处理"></a>文件查看和处理</h2><p><img src="/././images/8.jpg" alt="8"></p><h2 id="打包和解压"><a href="#打包和解压" class="headerlink" title="打包和解压"></a>打包和解压</h2><p><img src="/././images/9.jpg" alt="9"></p><h2 id="RPM包管理命令"><a href="#RPM包管理命令" class="headerlink" title="RPM包管理命令"></a>RPM包管理命令</h2><p><img src="/././images/10.jpg" alt="10"></p><h2 id="YUM包管理命令"><a href="#YUM包管理命令" class="headerlink" title="YUM包管理命令"></a>YUM包管理命令</h2><p><img src="/././images/11.jpg" alt="11"></p><h2 id="DPKG包管理命令"><a href="#DPKG包管理命令" class="headerlink" title="DPKG包管理命令"></a>DPKG包管理命令</h2><p><img src="/././images/12.jpg" alt="12"></p><p><img src="/././images/image-20250530184153540.png" alt="image-20250530184153540"></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4MjEzNTMzNw==&mid=2653228392&idx=1&sn=15269ce188ed77c239c92639d9612b8f">deb和rpm有什么区别？——Linux软件包格式详解</a></p><p>RPM、YUM和DPKG是Linux系统中用于管理软件包的三种不同工具：</p><ol><li><strong>RPM（Red Hat Package Manager）</strong>：是Red Hat系列Linux发行版（如Red Hat Enterprise Linux、CentOS、Fedora）中用于安装、卸载、升级和管理软件包的工具。它处理<code>.rpm</code>格式的包，但不自动处理依赖关系。</li><li><strong>YUM（Yellowdog Updater Modified）</strong>：基于RPM，用于自动处理软件包的依赖关系。它简化了软件包管理，允许自动下载和安装依赖的包。YUM在CentOS 8及更高版本中被DNF取代。</li><li><strong>DPKG（Debian Package）</strong>：是Debian系列Linux发行版（如Debian、Ubuntu）中用于管理软件包的工具。它处理<code>.deb</code>格式的包，并可以自动处理依赖关系。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux开发 </tag>
            
            <tag> 嵌入式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言第1-4章内容</title>
      <link href="/2023/09/20/test/c%E5%92%8Cc++/C%E8%AF%AD%E8%A8%80(1-4%E7%AB%A0)/"/>
      <url>/2023/09/20/test/c%E5%92%8Cc++/C%E8%AF%AD%E8%A8%80(1-4%E7%AB%A0)/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-计算机内部结构"><a href="#第一章-计算机内部结构" class="headerlink" title="第一章 计算机内部结构"></a><strong>第一章 计算机内部结构</strong></h1><p><strong>1.1 计算机内部结构（存储器、CPU、输入输出设备）</strong><br><strong>1.2 C语言的起源和发展</strong><br><strong>1.3 C语言的特点和优缺点</strong><br><strong>1.4 C语言的应用领域</strong><br><strong>1.5 C语言中的八进制、十进制、十六进制数和计算机二进制</strong><br><strong>1.6 C语言的第一个hello world程序</strong></p><p><img src="H:/Hexo-Blog/blog-demo/source/images/1694402772337-c1eff0d2-cb85-47f3-9b8f-10a0fea49e61-1748589409790-9.jpeg" alt="img"></p><h2 id="一、计算机内部结构"><a href="#一、计算机内部结构" class="headerlink" title="一、计算机内部结构"></a>一、计算机内部结构</h2><h3 id="1-1-冯·诺伊曼架构"><a href="#1-1-冯·诺伊曼架构" class="headerlink" title="1.1 冯·诺伊曼架构"></a>1.1 冯·诺伊曼架构</h3><h4 id="1-1-1-冯·诺伊曼"><a href="#1-1-1-冯·诺伊曼" class="headerlink" title="1.1.1 冯·诺伊曼"></a>1.1.1 冯·诺伊曼</h4><p><img src="H:/Hexo-Blog/blog-demo/source/images/image-20250530151730082.png" alt="image-20250530151730082"></p><p>基本信息：约翰·冯·诺伊曼，1903-1957，匈牙利裔美国数学家和理论物理学家。<br>重要贡献：开创了存储程序的计算机设计概念，即冯·诺伊曼架构。</p><h4 id="冯诺伊曼架构"><a href="#冯诺伊曼架构" class="headerlink" title="冯诺伊曼架构"></a>冯诺伊曼架构</h4><p><img src="H:/Hexo-Blog/blog-demo/source/images/image-20250530151754770.png" alt="image-20250530151754770"></p><p><strong>定义</strong>：冯·诺伊曼模型，也称冯·诺伊曼架构，是现代计算机的基础，分为输入设备，输出设备，存储器，处理器和总线五部分。<br><strong>输入设备</strong>：让用户向计算机输入数据，如键盘，鼠标等。<br><strong>输出设备</strong>：让计算机将处理过的数据展示给用户，如显示器，打印机等。<br><strong>存储器</strong>：用于存储数据和指令，在冯·诺伊曼模型中，数据和指令存储在同一内存中。</p><ul><li>硬盘 ： 外部存储设备</li><li>内存 ： 存储程序运行数据</li><li>缓存 ： 集成在CPU内部</li></ul><p><strong>处理器</strong>：负责执行指令和处理数据，由算术逻辑单元和控制单元组成。总线：连接各个部分，负责数据传输。</p><h2 id="二、C语言的起源和发展"><a href="#二、C语言的起源和发展" class="headerlink" title="二、C语言的起源和发展"></a>二、C语言的起源和发展</h2><p>C 语言于 20 世纪 70 年代诞生于美国的贝尔实验室。在此之前，人们编写系统软件主要使用汇编语言，汇编语言编写的程序依赖于计算机硬件，其可读性和可移植性都比较差。而高级语言的可读性和可移植性虽然较汇编语言好，但一般又不具备低级语言的能够直观地对硬件实现控制和操作而且执行速度快等特点。</p><p>（1）C语言最初由美国贝尔实验室的D.M. Ritchie在B语言的基础上设计，主要为描述和实现UNIX操作系统。那时，C语言仅在贝尔实验室内部使用。<br>（2）然后到了1975年，UNIX的第6版发布后，C语言因其突出的优点引起了广泛关注。随后，到1977年出现了可移植的C语言。<br>（3）1978年，UNIX的第7版发布，其中使用的C语言被视为后来广泛使用的C语言版本的基础，也被称为标准C语言。<br>（4）1983年，美国国家标准学会（ANSI）对C语言进行了发展和扩充，并制定了新的标准，称为ANSI C。<br>（5）最后到了1990年，国际标准化组织（ISO）制定了ISO C标准，至今流行的C语言编译系统都是以此为标准。</p><h2 id="三、C语言的特点和优缺点"><a href="#三、C语言的特点和优缺点" class="headerlink" title="三、C语言的特点和优缺点"></a>三、C语言的特点和优缺点</h2><h3 id="3-1-C语言的特点："><a href="#3-1-C语言的特点：" class="headerlink" title="3.1 C语言的特点："></a>3.1 C语言的特点：</h3><p><strong>简洁和高效</strong>：C语言的语法简洁，而且执行速度快。它允许程序员直接操作硬件，因此经常用于系统编程。<br><strong>过程式</strong>：C语言是一种过程式语言，这意味着它侧重于过程和函数。<br><strong>低级功能</strong>：C语言提供了对内存的直接访问和操作，这对于开发底层应用程序和系统非常有用。<br><strong>可移植性</strong>：C语言编写的程序可以在多种不同的硬件平台上运行，只要有适当的编译器。<br><strong>丰富的库支持</strong>：C语言有一个广泛的标准库，提供了许多内置的函数。<br><strong>扩展性</strong>：C语言允许程序员轻松地扩展其功能通过使用外部库。</p><h3 id="3-2-C语言的优点："><a href="#3-2-C语言的优点：" class="headerlink" title="3.2 C语言的优点："></a>3.2 C语言的优点：</h3><p><strong>性能：</strong>C语言编写的程序通常具有很高的执行速度和优化的内存使用。<br><strong>控制：</strong>提供了对硬件资源的底层访问和控制。<br><strong>广泛应用：</strong>C语言用于开发各种类型的应用程序，包括操作系统、数据库系统、图形包和游戏等。</p><h3 id="3-3-C语言的缺点："><a href="#3-3-C语言的缺点：" class="headerlink" title="3.3 C语言的缺点："></a>3.3 C语言的缺点：</h3><p><strong>安全性：</strong>C语言中的内存管理是手动的，并且它允许直接操作内存地址，这可能导致安全问题，如缓冲区溢出。<br><strong>复杂性：</strong>尽管C语言的语法相对简单，但它的低级特性使得编写复杂程序变得困难。<br><strong>缺乏现代特性：</strong>与一些现代语言相比，C语言缺少一些高级特性，如垃圾收集、异常处理和面向对象编程。<br><strong>调试和维护：</strong>由于C语言的低级性质，调试和维护C语言程序可能会比使用高级语言更加困难。</p><h2 id="四、C语言的应用领域"><a href="#四、C语言的应用领域" class="headerlink" title="四、C语言的应用领域"></a>四、C语言的应用领域</h2><p><strong>操作系统：</strong>许多现代操作系统，包括Linux，Windows以及大部分Unix和Unix-like系统，都是用C语言编写的。这是因为C语言可以提供底层硬件访问和高效的内存管理。<br><strong>嵌入式系统：</strong>由于C语言的执行效率高且占用资源少，因此非常适合于嵌入式系统和实时系统的开发。<br><strong>硬件驱动：</strong>硬件驱动程序通常需要直接与特定硬件设备交互，而C语言提供了直接访问物理地址和硬件的能力。<br><strong>系统软件：</strong>除了操作系统外，很多系统级的软件，如数据库、网络服务器等，也是用C语言开发的。<br><strong>编译器和解释器：</strong>很多现代编程语言的编译器和解释器都是用C或C编写的。例如，Python的解释器CPython和Java的虚拟机JVM等。<br><strong>图形和游戏编程：</strong>C语言也在图形和游戏编程中被广泛使用，尤其是在需要对性能要求很高的场合。<br><strong>科学计算：</strong>很多科学计算软件和库，例如MATLAB等，底层都是用C或C编写的，以保证计算效率。</p><h2 id="五、八进制、十进制、十六进制数和计算机二进制"><a href="#五、八进制、十进制、十六进制数和计算机二进制" class="headerlink" title="五、八进制、十进制、十六进制数和计算机二进制"></a>五、<strong>八进制、十进制、十六进制数和计算机二进制</strong></h2><p><strong>十进制： 遇十进一 10个基础数</strong><br><strong>八进制： 遇十进一 8个基础数</strong><br><strong>十六进制： 遇十进一 16个基础数 0x</strong><br><strong>二进制： 遇十进一 2个基础数</strong></p><h2 id="六-C语言的第一个hello-world程序"><a href="#六-C语言的第一个hello-world程序" class="headerlink" title="六 C语言的第一个hello world程序"></a><strong>六 C语言的第一个hello world程序</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//  标准输入输出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello hqyj\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="H:/Hexo-Blog/blog-demo/source/images/1694401532597-5a388e94-d5d5-4b76-aa56-537f6d476394.jpeg" alt="img"></p><p><strong>#include &lt;stdio.h&gt;</strong><br><strong>&#x2F;&#x2F; 标准输入输出</strong><br><strong>定义头文件</strong></p><p><strong>主函数</strong><br>**int main(int argc, char const <em>argv[])</em></p><p><strong>打印并输出到终端（屏幕）</strong><br><strong>printf(“hello hqyj\n”);</strong></p><p><strong>1、返回一个值</strong><br><strong>2、退出函数</strong><br><strong>return n;</strong></p><p><strong>n的类型，和你的函数类型一致</strong><br><strong>如果函数是void 空类型 直接 return；</strong></p><h1 id="第二章-C语言基础"><a href="#第二章-C语言基础" class="headerlink" title="第二章 C语言基础"></a><strong>第二章 C语言基础</strong></h1><p>@[toc]<strong>目标</strong></p><ul><li>1、C语言程序的基本结构</li><li>2、C语言关键字和标识符</li><li>3、C语言的数据类型和变量的以及存储类型</li><li>4、C语言中的标准输入输出函数</li><li>5、C语言中的常量</li><li>6、C语言中的运算符</li><li>7、C语言中的表达式式</li></ul><h2 id="一、C语言程序的基本结构"><a href="#一、C语言程序的基本结构" class="headerlink" title="一、C语言程序的基本结构"></a>一、C语言程序的基本结构</h2><h3 id="1-1-基本结构"><a href="#1-1-基本结构" class="headerlink" title="1.1 基本结构"></a>1.1 基本结构</h3><p>C语言程序的基本结构包括以下几个部分：<br><strong>1.预处理指令</strong>：这些编译器指令，通常放在程序的开头，#include &lt;stdio.h&gt; 。预处理器指令以#字符开始，最常见的#include,用于包含其他的头文件。<strong>2.函数</strong>：C程序中至少包含一个函数，即main()函数。main()函数是程序执行的起点。此外，一个C程序中可以包含其他的函数，这些函数可以自己定义也可以是从库中调用。<br><strong>3.变量</strong>：变量用于存储数据。在C语言中，每个变量都有特有类型。<br><strong>4.语句&amp;表达式</strong>：语句是执行特定任务的语句，如赋值语句、调用函数等，表达式则是计算产生值的计算公式。<br><strong>5.注释</strong>：注释用于解释程序的功能，对代码进行解释和描述。在C语言中，注释可以用&#x2F; <em>注释内容</em> &#x2F;或者&#x2F;&#x2F;注释内容来书写。<img src="https://cdn.nlark.com/yuque/0/2023/png/8368890/1694402052443-c71c85bb-05c5-4dcb-aa9e-c1c70e110bb2.png#averageHue=%23ebebeb&clientId=u1e415e4d-0a0d-4&from=paste&id=u49d8c282&originHeight=892&originWidth=948&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=319759&status=done&style=none&taskId=ua10423ec-bf6b-477f-bd6b-1cb5bb08a1a&title=?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_27%2Ctext_enpo%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" alt="img"></p><p>1、预处理<br>#include<br>2、main<br>主函数 不管在外面写了多少个函数 只能运行main<br>要运行外部函数，则需要通过main直接或间接的调用<br>3、语句<br>需要执行的程序</p><p>实例程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>   <span class="comment">//预处理指令</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这是一个简单的C程序 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>          <span class="comment">//函数开始</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">int</span> a = <span class="number">10</span>;     <span class="comment">//定义变量和赋值语句</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Hello World&quot;</span>);  <span class="comment">//语句：调用printf函数</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">//语句：返回，结束main函数</span></span><br><span class="line"> &#125;                   <span class="comment">//函数结束</span></span><br></pre></td></tr></table></figure><p>在这个程序中：<br>#include &lt;stdio.h&gt;是预处理指令，用于包含stdio.h头文件。<br>main()是函数，程序的入口。<br>int a &#x3D; 10为变量赋值语句。<br>printf是一个函数调用该语句，用于输出字符以及字符串和变量a的值。</p><h3 id="1-2-gcc编译器"><a href="#1-2-gcc编译器" class="headerlink" title="1.2 gcc编译器"></a>1.2 gcc编译器</h3><p><strong>gcc编译器的使用</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gcc [文件名]     编译</span><br><span class="line">./a.out 执行</span><br><span class="line"></span><br><span class="line">gcc [文件名] -o [程序名]    改名执行文件名称</span><br><span class="line"></span><br><span class="line">多文件</span><br><span class="line">gcc *.c -o [程序名]多文件编译    要求这整个文件夹都是同一个工程</span><br></pre></td></tr></table></figure><h4 id="1-2-1-gcc编译流程"><a href="#1-2-1-gcc编译流程" class="headerlink" title="1.2.1 gcc编译流程"></a>1.2.1 gcc编译流程</h4><p>gcc的编译流程分为4个步骤：<br>①预处理 -E .i 展开头文件 替换宏定义 删除注释<br>②编译-S .s 纠错<br>③汇编-c .o<br>④链接a.out<br>支持以下后缀：<br>.cC语言源代码<br>.h程序中所包含的头文件<br>.i已经预处理过的C源代码文件<br>.s汇编语言源代码文件<br>.o汇编后的目标文件<br><img src="H:/Hexo-Blog/blog-demo/source/images/1694412923517-c33863b7-41f0-4096-820b-e77c7c48e39a.jpeg" alt="img"></p><hr><p>接下通过一个实例程序来对gcc进行讲解，实例程序如下，分为两个文件一个hello.c和hello.h：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//hello.c//</span><br><span class="line"> #include &lt;stdio.h&gt;</span><br><span class="line"> #include &quot;hello.h&quot;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">     u8 i;</span><br><span class="line">     printf(&quot;%ld\n&quot;,sizeof(i));</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br><span class="line">#ifndef __HELLO_H_</span><br><span class="line"> #define __HELLO_H_</span><br><span class="line"> </span><br><span class="line"> typedef unsigned int u8;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> #endif</span><br></pre></td></tr></table></figure><hr><p><strong>预处理阶段：</strong><br>gcc的选项”-E”可以使用编译器在预处理结束时就停止编译，选项-o是指定gcc输出结果，<br>gcc -E -o [目标文件] [编译文件] gcc -E -o hello.i hello.c<br><strong>编译阶段：</strong><br>编译器在预处理结束后开始使用，gcc首先要检查代码的规范性、是否还有语法错误等，在检查无误后，就开始把代码翻译成汇编语言。<br>gcc -S -o [目标文件] [编译文件] gcc -S -o hello.s hello.i<br><strong>汇编阶段:</strong><br>汇编的过程就是将.s文件生成生产目标文件，我们在使用-c就可以看到汇编的代码转换成为.o的二进制目标代码了。<br>gcc -c -o [目标文件] [编译文件]gcc -c -o hello.o hello.s<br><strong>链接阶段：</strong><br>成功编译后，就进入到了链接阶段，在这里涉及到一个很重要的概念：函数库。<br>当我们使用一些库文件时，则会</p><h2 id="二、C语言关键字和标识符"><a href="#二、C语言关键字和标识符" class="headerlink" title="二、C语言关键字和标识符"></a>二、C语言关键字和标识符</h2><h3 id="2-1关键字"><a href="#2-1关键字" class="headerlink" title="2.1关键字"></a>2.1关键字</h3><p><strong>关键字</strong>：关键字是C语言中预先定义并保留的特殊单词，每个关键字在C语言中都有特定的含义和用途。我们在编写C程序时不能将关键字作为变量名或者其他标识名。以下是C语言的关键字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>        <span class="type">double</span>      <span class="type">int</span>         <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"><span class="title">break</span>       <span class="title">else</span>        <span class="title">long</span>        <span class="title">switch</span></span></span><br><span class="line"><span class="class"><span class="title">case</span>        <span class="title">enum</span>        <span class="title">register</span>    <span class="title">typedef</span></span></span><br><span class="line"><span class="class"><span class="title">char</span>        <span class="title">extern</span>      <span class="title">return</span>      <span class="title">union</span></span></span><br><span class="line"><span class="class"><span class="title">const</span>       <span class="title">float</span>       <span class="title">short</span>       <span class="title">unsigned</span></span></span><br><span class="line"><span class="class"><span class="title">continue</span>    <span class="title">for</span>         <span class="title">signed</span>      <span class="title">void</span></span></span><br><span class="line"><span class="class"><span class="title">default</span>     <span class="title">goto</span>        <span class="title">sizeof</span>      <span class="title">volatile</span></span></span><br><span class="line"><span class="class"><span class="title">do</span>          <span class="title">if</span>          <span class="title">static</span>      <span class="title">while</span></span></span><br></pre></td></tr></table></figure><h3 id="2-2标识符"><a href="#2-2标识符" class="headerlink" title="2.2标识符"></a>2.2标识符</h3><p><strong>标识符</strong>：是程序编写过程中的变量名、函数名、数组名等元素定义的名称。标识符的命名需要遵循以下规则：<br>1.标识符的第一个字符必须是字母（大写或小写）或者下划线”_”。<br>2.后续的字符可以是字母、数字或下划线。<br>3.关键字不能作为标识符。<br>4.标识符在C语言中是区分大小写的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> myVar;</span><br><span class="line"><span class="type">double</span> _myVar;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> var123;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myFunction</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="type">int</span> <span class="number">123</span>var;    <span class="comment">// 以数字开头</span></span><br><span class="line"><span class="type">double</span> <span class="type">double</span>; <span class="comment">// 使用了关键字</span></span><br></pre></td></tr></table></figure><hr><p>随堂小测：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int score;              // 正确</span><br><span class="line">double _maxValue;       // 正确</span><br><span class="line">char response1;         // 正确</span><br><span class="line">int 7score;             // 错误，名称不能以数字开头</span><br><span class="line">void print_score();     // 正确</span><br><span class="line">double double;          // 错误，不能使用关键字作为名称</span><br><span class="line">char a b;               // 错误，名称中不能有空格</span><br><span class="line">int number of students; // 错误，名称中不能有空格</span><br><span class="line">void PrintScore();      // 正确，但不符合C语言的常见命名习惯，函数名通常全部小写，如print_score</span><br><span class="line">int NumberOfStudents;   // 正确，但不符合C语言的常见命名习惯，更常见的是使用下划线，如number_of_students</span><br></pre></td></tr></table></figure><hr><h2 id="三、C语言的数据类型和变量的以及存储类型"><a href="#三、C语言的数据类型和变量的以及存储类型" class="headerlink" title="三、C语言的数据类型和变量的以及存储类型"></a>三、C语言的数据类型和变量的以及存储类型</h2><h3 id="3-1-计算机数据的表示"><a href="#3-1-计算机数据的表示" class="headerlink" title="3.1 计算机数据的表示"></a>3.1 计算机数据的表示</h3><h4 id="3-1-1-进制"><a href="#3-1-1-进制" class="headerlink" title="3.1.1 进制"></a>3.1.1 进制</h4><p>计算机中数据通常以二进制形式表示，但根据需要，它们可以进一步划分为不同的类型。以下是常见的计算机中数据表示的方式：</p><h5 id="3-1-1-1-数值数据"><a href="#3-1-1-1-数值数据" class="headerlink" title="3.1.1.1 数值数据"></a>3.1.1.1 数值数据</h5><ol><li><strong>二进制</strong>：这是计算机最基础的数据表示方式，所有的信息都可以转换为0和1。这是因为计算机的硬件电路（例如，开关和逻辑门）最适合处理二进制系统。</li><li><strong>十进制</strong>：尽管计算机内部使用二进制，但在显示和输入数据时，通常使用我们更熟悉的十进制系统。计算机内部会将十进制数字转换为二进制，进行计算后再转回十进制。</li><li><strong>十六进制</strong>：十六进制被广泛用于计算机科学和编程，因为它可以更简洁地表示二进制数。每个十六进制数字可以精确地表示四个二进制位，这使得二进制数和十六进制数之间的转换非常直接。</li><li><strong>各进制的前缀和后缀</strong></li></ol><p><img src="H:/Hexo-Blog/blog-demo/source/images/1705913805089-42cec186-671d-4880-9f6f-fb9a0dde9403.png" alt="img"></p><p>6、进制间的转化</p><p>短除法和乘积法</p><h5 id="3-1-1-1-非数值数据"><a href="#3-1-1-1-非数值数据" class="headerlink" title="3.1.1.1 非数值数据"></a>3.1.1.1 非数值数据</h5><ol><li><strong>ASCII</strong>：ASCII是一种将字符（如字母、数字和特殊符号）映射到二进制数的标准。例如，在ASCII中，大写字母A的编码是65，对应的二进制是1000001。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/8368890/1694413927041-f1076166-e505-4a03-a6d3-0da3526c6f8d.png#averageHue=%23d2d2d2&clientId=u87bc8a45-431d-4&from=paste&height=615&id=uf648587b&originHeight=923&originWidth=1434&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=1855008&status=done&style=none&taskId=u69f69612-fbc5-4daa-a5a0-59a75716fc2&title=&width=956?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_41%2Ctext_enpo%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" alt="img"></p><ol><li><strong>浮点数</strong>：计算机使用浮点数表示法来存储和操作实数。IEEE 754标准定义了浮点数的表示方式和操作，这是现代计算机最广泛使用的浮点数标准。</li></ol><h4 id="3-1-2-源码、反码、补码"><a href="#3-1-2-源码、反码、补码" class="headerlink" title="3.1.2 源码、反码、补码"></a>3.1.2 源码、反码、补码</h4><p>原码、反码和补码是用于表示和存储二进制有符号整数的方式。它们都用最高位（通常是左边的位）表示符号，0表示正，1表示负。<br><strong>原码</strong>：原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。比如如果是8位二进制：</p><ul><li>[+1]原 &#x3D; 0000 0001</li><li>[-1]原 &#x3D; 1000 0001</li></ul><p>有符号数的第一位为符号位<br><strong>反码</strong>：正数的反码是其本身，负数的反码是在其原码的基础上, <strong>符号位</strong>不变，其余各位取反。</p><ul><li>[+1]反 &#x3D; 0000 0001</li><li>[-1]反 &#x3D; 1111 1110</li></ul><p><strong>补码</strong>：正数的补码就是其本身，负数的补码是在其原码的基础上，符号位不变，其余各个位取反，然后最后一位加1。</p><ul><li>[+1]补 &#x3D; 0000 0001</li><li>[-1]补 &#x3D; 1111 1111</li></ul><p>原码 本身<br>反码原码取反<br>补码反码 + 1<br><img src="H:/Hexo-Blog/blog-demo/source/images/1694414463919-3a9085cb-c5aa-44c1-9bf2-e9c1db389d41.jpeg" alt="img"></p><h3 id="3-2-数据类型"><a href="#3-2-数据类型" class="headerlink" title="3.2 数据类型"></a>3.2 数据类型</h3><h4 id="数据类型的作用"><a href="#数据类型的作用" class="headerlink" title="数据类型的作用"></a>数据类型的作用</h4><p>在计算机最开始的时候，没有这么大的存储空间，需要一个东西规范存储空间的大小</p><p><img src="H:/Hexo-Blog/blog-demo/source/images/1694414895788-0970ee59-ece2-4e51-8f25-de4805bf240f.jpeg" alt="img"><br>在C语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，以及该位置可以参与的运算。<br>C语言中的数据类型主要可以分为以下几类：</p><h4 id="3-2-1-基本类型：它们是算术类型，包括两种类型：整数类型和浮点类型。"><a href="#3-2-1-基本类型：它们是算术类型，包括两种类型：整数类型和浮点类型。" class="headerlink" title="3.2.1 基本类型：它们是算术类型，包括两种类型：整数类型和浮点类型。"></a>3.2.1 <strong>基本类型</strong>：它们是算术类型，包括两种类型：整数类型和浮点类型。</h4><ul><li>整数类型包括：char、short int、int、long int、long long int。</li><li>浮点类型包括：float、double、long double。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//● 整数类型包括：char、short int、int、long int、long long int。</span></span><br><span class="line"><span class="comment">//● 浮点类型包括：float、double、long double。</span></span><br><span class="line"><span class="comment">//● ascll</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//int               整型</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">    <span class="comment">//char              字符型</span></span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,<span class="keyword">sizeof</span>(ch));</span><br><span class="line">    <span class="comment">//short int         短整型</span></span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> sh_in = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span> , <span class="keyword">sizeof</span>(sh_in));</span><br><span class="line">    <span class="comment">//long int          长整型</span></span><br><span class="line">    <span class="comment">//long long int     长长整型</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> lo_in = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span> , <span class="keyword">sizeof</span>(lo_in));</span><br><span class="line">    <span class="comment">//无符号 整型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> un_in = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span> , <span class="keyword">sizeof</span>(un_in));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//● 浮点类型包括：float、double、long double。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//单精度浮点型          4</span></span><br><span class="line">    <span class="type">float</span> fl = <span class="number">3.14</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span> , <span class="keyword">sizeof</span>(fl));</span><br><span class="line">    <span class="comment">//双精度浮点型          8</span></span><br><span class="line">    <span class="type">double</span> dou = <span class="number">3.14</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span> , <span class="keyword">sizeof</span>(dou));</span><br><span class="line">    <span class="comment">//长双精度浮点型        16</span></span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> dou_1 = <span class="number">3.14</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span> , <span class="keyword">sizeof</span>(dou_1));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、C语言中的标准输入输出函数"><a href="#四、C语言中的标准输入输出函数" class="headerlink" title="四、C语言中的标准输入输出函数"></a>四、C语言中的标准输入输出函数</h2><hr><h3 id="4-2-缓冲区"><a href="#4-2-缓冲区" class="headerlink" title="4.2 缓冲区"></a>4.2 缓冲区</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/8368890/1694402052315-6787a482-0758-47ac-95c2-8cfbf0b92003.png#averageHue=%23eeeeee&clientId=u1e415e4d-0a0d-4&from=paste&id=ubf32db6f&originHeight=746&originWidth=1080&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=270818&status=done&style=none&taskId=u2dbca5a3-476d-4828-9f43-d51e57558dd&title=?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_31%2Ctext_enpo%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" alt="img"></p><ol><li><strong>输入缓冲区：</strong> 当我们在键盘上敲击字符时，这些字符首先被存储在输入缓冲区中。当我们按下回车键或者缓冲区满时，存储在缓冲区的数据才会被送入程序处理。</li><li><strong>输出缓冲区：</strong> 当我们执行一个输出函数(如printf)时，数据首先被放入输出缓冲区，直到缓冲区满或者调用刷新缓冲区函数（如fflush）时，才会真正输出到屏幕上。</li></ol><h3 id="4-2-输入函数："><a href="#4-2-输入函数：" class="headerlink" title="4.2 输入函数："></a>4.2 输入函数：</h3><ol><li>scanf()：此函数用于从标准输入（键盘）读取并转换。它需要一个格式字符串，该字符串确定了如何读取输入。</li><li>getchar()：此函数从标准输入读取并返回一个字符。</li><li>gets()：此函数从指定的流中读取并存储一行字符。该行以空字符终止。</li></ol><h3 id="4-3-输出函数："><a href="#4-3-输出函数：" class="headerlink" title="4.3 输出函数："></a>4.3 输出函数：</h3><ol><li>printf()：此函数用于在标准输出（显示器）上打印格式化的输出。它需要一个格式字符串，该字符串确定了如何打印变量的值。</li><li>putchar()：此函数将一个字符写入标准输出。</li><li>puts()：此函数写一个字符串和一个尾随的换行符到标准输出。</li></ol><h4 id="scanf-printf-格式化输入-输出"><a href="#scanf-printf-格式化输入-输出" class="headerlink" title="scanf printf 格式化输入\输出"></a>scanf printf 格式化输入\输出</h4><p><strong>scanf</strong> </p><p>*<em>函数原型 extern int scanf (const char <em>__restrict <strong>format, …)</strong> wur;</em></em><br><strong>函数参数</strong><br>**const char <em>__restrict __format 输入格式</em><br><strong>…多参数 输入数据</strong><br><strong>返回值</strong><br><strong>函数功能 从标准输入设备(键盘)中获取数据</strong></p><p><strong>printf</strong></p><p>**函数原型 printf (const char <em>__restrict __fmt, …)</em><br><strong>函数参数</strong><br>**const char <em>__restrict __fmt 输出格式</em><br><strong>…多参数 输出数据</strong><br><strong>返回值没有</strong><br><strong>函数功能 向标准输出设备（屏幕 终端）中输出数据</strong></p><h4 id="putchar-getchar-单字符输入-输出"><a href="#putchar-getchar-单字符输入-输出" class="headerlink" title="putchar getchar 单字符输入\输出"></a>putchar getchar 单字符输入\输出</h4><p><strong>putchar</strong></p><p>putchar (int __c)<br>{<br>return *IO_putc (<strong><strong>c, stdout);<br>*</strong><em><strong>}<br>*</strong></em><strong>*函数原型 putchar (int</strong> c)</strong><br><strong>函数参数</strong><br><strong>int c 需要输出的字符</strong><br><strong>返回值没有</strong><br><strong>函数功能 向标准输出设备（屏幕 终端）中输出数据</strong></p><p><strong>getchar</strong></p><p><strong>getchar (void)</strong><br><strong>{</strong><br> <strong>return _IO_getc (stdin);</strong><br><strong>}</strong></p><p><strong>函数原型 getchar (void)</strong><br><strong>函数参数</strong><br><strong>返回值return _IO_getc (stdin); 返回从键盘中读取到的一个字符</strong><br><strong>函数功能 从标准输入设备(键盘)中获取数据</strong></p><h5 id="4-5-3-printf描述符"><a href="#4-5-3-printf描述符" class="headerlink" title="4.5.3 printf描述符"></a>4.5.3 printf描述符</h5><p>格式符号111</p><table><thead><tr><th><strong>格式说明符</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>%d</td><td>以十进制形式输出带符号整数</td></tr><tr><td>%u</td><td>以十进制形式输出无符号整数</td></tr><tr><td>%f</td><td>以小数形式输出单、双精度浮点数</td></tr><tr><td>%e, %E</td><td>以指数形式输出单、双精度浮点数</td></tr><tr><td>%g, %G</td><td>根据值的不同，自动选择%f或%e、%E格式输出单、双精度浮点数</td></tr><tr><td>%c</td><td>输出一个字符</td></tr><tr><td>%s</td><td>输出一个字符串</td></tr><tr><td>%p</td><td>输出一个指针（以十六进制形式输出指针的值）</td></tr><tr><td>%x, %X</td><td>以十六进制形式输出无符号整数</td></tr><tr><td>%o</td><td>以八进制形式输出无符号整数</td></tr><tr><td>%ld</td><td>输出长整型（sizeof的输出常用）</td></tr><tr><td>%lu</td><td>输出无符号长整型</td></tr></tbody></table><p>格式的描述符a1</p><table><thead><tr><th><strong>修饰符</strong></th><th><strong>示例代码</strong></th><th><strong>输出</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>-</td><td>printf(“%-10d”, 123);</td><td>123</td><td>左对齐输出</td></tr><tr><td>+</td><td>printf(“%+d”, 123);</td><td>+123</td><td>在正数前面显示加号</td></tr><tr><td>空格</td><td>printf(“% d”, 123);</td><td>123</td><td>在正数前面显示空格</td></tr><tr><td>#</td><td>printf(“%#o”, 123);</td><td>0173</td><td>以八进制显示数值</td></tr><tr><td>0</td><td>printf(“%010d”, 123);</td><td>0000000123</td><td>左边用0填充</td></tr><tr><td>数字</td><td>printf(“%10d”, 123);</td><td></td><td></td></tr><tr><td>printf(“%-10d”, 123);</td><td>123</td><td>设定字段宽度为10</td><td></td></tr><tr><td>.</td><td>printf(“%.2f”, 123.456);</td><td>123.46</td><td>保留2位小数</td></tr><tr><td>l</td><td>printf(“%ld”, 123456789L);</td><td>123456789</td><td>长整型</td></tr><tr><td>ll</td><td>printf(“%lld”, 123456789012345LL);</td><td>123456789012345</td><td>长长整型</td></tr><tr><td>h</td><td>short s &#x3D; 123; printf(“%hd”, s);</td><td>123</td><td>短整型</td></tr><tr><td>hh</td><td>signed char c &#x3D; 123; printf(“%hhd”, c);</td><td>123</td><td>有符号字符</td></tr><tr><td>L</td><td>printf(“%Lf”, 123456.789L);</td><td>123456.789000</td><td>长双精度浮点数</td></tr></tbody></table><h5 id="4-5-4-scanf描述符"><a href="#4-5-4-scanf描述符" class="headerlink" title="4.5.4 scanf描述符"></a>4.5.4 scanf描述符</h5><p>描述符</p><table><thead><tr><th><strong>描述符</strong></th><th><strong>作用</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>%d</td><td>匹配带符号的十进制整数</td><td>scanf(“%d”, &amp;num);</td></tr><tr><td>%i</td><td>匹配带符号的整数，可以是十进制、八进制、十六进制</td><td>scanf(“%i”, &amp;num);</td></tr><tr><td>%o</td><td>匹配八进制整数</td><td>scanf(“%o”, &amp;num);</td></tr><tr><td>%u</td><td>匹配无符号十进制整数</td><td>scanf(“%u”, &amp;num);</td></tr><tr><td>%x%X</td><td>匹配无符号十六进制整数</td><td>scanf(“%x”, &amp;num);</td></tr><tr><td>%f</td><td>匹配浮点数</td><td>scanf(“%f”, &amp;num);</td></tr><tr><td>%e%E</td><td>匹配浮点数，可以是指数形式</td><td>scanf(“%e”, &amp;num);</td></tr><tr><td>%g%G</td><td>根据数值和精度选择 %f 或 %e (%E)</td><td>scanf(“%g”, &amp;num);</td></tr><tr><td>%c</td><td>匹配一个字符</td><td>scanf(“%c”, &amp;char);</td></tr><tr><td>%s</td><td>匹配字符串，遇到空格、制表符或换行符结束</td><td>scanf(“%s”, str);</td></tr><tr><td>%p</td><td>匹配指针</td><td>scanf(“%p”, &amp;ptr);</td></tr></tbody></table><p><strong>注意：scanf中的 %s 和 printf 中的 %s 的行为是完全不同的。printf 中的 %s 会输出字符串直到遇到空字符 ‘\0’，而 scanf 中的 %s 会读取输入直到遇到一个空格、制表符或换行符。</strong></p><h4 id="4-6-字符串I-O：puts-和gets"><a href="#4-6-字符串I-O：puts-和gets" class="headerlink" title="4.6 字符串I&#x2F;O：puts()和gets()"></a>4.6 字符串I&#x2F;O：puts()和gets()</h4><h5 id="4-6-1-puts"><a href="#4-6-1-puts" class="headerlink" title="4.6.1 puts"></a>4.6.1 puts</h5><hr><p>函数：<strong>puts()</strong><br>头文件：#include &lt;stdio.h&gt;<br>函数原型：int puts(const char <em>s);<br>功能：将字符串s和一个尾随的换行符写入到标准输出(stdout)。<br>参数：</em>s – 指向一个字符数组的指针，该数组包含了一个空字符(‘\0’)来结束输入的字符串。<br>返回值：如果执行成功，返回非负值，如果发生错误则返回EOF。</p><hr><h5 id="4-6-1-gets"><a href="#4-6-1-gets" class="headerlink" title="4.6.1 gets"></a>4.6.1 gets</h5><hr><p>函数：<strong>gets()</strong><br>头文件：#include &lt;stdio.h&gt;<br>函数原型：char <em>gets(char</em> s);<br>功能：从标准输入(stdin)读取一行，并把它保存到str所指向的字符数组，它会在读取的行尾自动加上null字符，但它不会保留换行符。<br>参数：*s – 一个数组，该数组用来存储读取的字符串，直到一个换行符(‘\n’)或EOF。<br>返回值：如果执行成功，返回str。如果发生错误或读到文件的末尾且未读到任何字符，返回NULL。<br>注意：C11已经从库函数中删除了gets()，使用该函数可能会存在安全风险，比如缓冲区溢出等问题，通常建议使用fgets()替代。</p><hr><h3 id="五、C语言中的常量"><a href="#五、C语言中的常量" class="headerlink" title="五、C语言中的常量"></a>五、C语言中的常量</h3><hr><p>#define LENGTH 10 const int WIDTH &#x3D; 5;</p><hr><p>比较</p><ul><li>#define是预处理器宏，而const是语言自身的一部分。</li><li>const可以用于更复杂的类型，比如对象，而#define只能用于基本类型。</li><li>#define不分配存储空间，而const通常分配存储空间（例如在RAM中）。</li><li>const常量的类型和大小都是固定的，但#define预处理器宏没有固定的类型或大小。</li></ul><h2 id="六、C语言中的运算符"><a href="#六、C语言中的运算符" class="headerlink" title="六、C语言中的运算符"></a>六、C语言中的运算符</h2><table><thead><tr><th><strong>运算符类别</strong></th><th><strong>运算符</strong></th></tr></thead><tbody><tr><td>算术运算符</td><td>+，-，*，&#x2F;，%</td></tr><tr><td>赋值运算符</td><td>&#x3D;，+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;，%&#x3D;</td></tr><tr><td>关系运算符</td><td>&#x3D;&#x3D;，!&#x3D;，&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;</td></tr><tr><td>逻辑运算符</td><td>&amp;&amp;，|| ，！</td></tr><tr><td>位运算符</td><td>&amp;，|，^，~，&lt;&lt;，&gt;&gt;</td></tr><tr><td>条件运算符</td><td>? :</td></tr><tr><td>自增自减运算符</td><td>++，– 前置和后置得一个关系</td></tr><tr><td>逗号运算符</td><td>,</td></tr><tr><td>指针运算符</td><td>*，&amp;</td></tr><tr><td>sizeof运算符</td><td>sizeof （单目）</td></tr></tbody></table><h3 id="6-1-算术运算符"><a href="#6-1-算术运算符" class="headerlink" title="6.1 算术运算符"></a>6.1 算术运算符</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d\n&quot;</span>, a + b);  <span class="comment">// 30</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a - b = %d\n&quot;</span>, a - b);  <span class="comment">// -10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a * b = %d\n&quot;</span>, a * b);  <span class="comment">// 200</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b / a = %d\n&quot;</span>, b / a);  <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b %% a = %d\n&quot;</span>, b % a);  <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-赋值运算符"><a href="#6-2-赋值运算符" class="headerlink" title="6.2 赋值运算符"></a>6.2 赋值运算符</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    a += <span class="number">20</span>;  <span class="comment">// a = a + 20</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);  <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line">    a -= <span class="number">5</span>;  <span class="comment">// a = a - 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);  <span class="comment">// 25</span></span><br><span class="line"></span><br><span class="line">    a *= <span class="number">2</span>;  <span class="comment">// a = a * 2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);  <span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line">    a /= <span class="number">10</span>;  <span class="comment">// a = a / 10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);  <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    a %= <span class="number">3</span>;  <span class="comment">// a = a % 3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);  <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-关系运算符"><a href="#6-3-关系运算符" class="headerlink" title="6.3 关系运算符"></a>6.3 关系运算符</h3><p>关系运算符在C语言中用于比较两个值，结果为一个布尔值（0或1）。如果比较的条件成立，那么结果为1，否则为0。以下是C语言中的关系运算符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a &gt; b: %d\n&quot;</span>, a &gt; b);  <span class="comment">// 0 (false)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a &lt; b: %d\n&quot;</span>, a &lt; b);  <span class="comment">// 1 (true)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a &gt;= b: %d\n&quot;</span>, a &gt;= b);  <span class="comment">// 0 (false)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a &lt;= b: %d\n&quot;</span>, a &lt;= b);  <span class="comment">// 1 (true)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a == b: %d\n&quot;</span>, a == b);  <span class="comment">// 0 (false)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a != b: %d\n&quot;</span>, a != b);  <span class="comment">// 1 (true)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-逻辑运算符"><a href="#6-4-逻辑运算符" class="headerlink" title="6.4 逻辑运算符"></a>6.4 逻辑运算符</h3><p>逻辑运算符用于链接和操作布尔值（真或假，即1或0）。C语言中的逻辑运算符包括“与”（&amp;&amp;），“或”（||）和“非”（！）。以下是这些运算符的解释：<br>**1.**逻辑与运算符（&amp;&amp;）：当两边的操作数都为真（非零）时，结果才为真。如果任一操作数为假（即零），结果就为假。<br>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> result = a || b; <span class="comment">// result 的值为 1，因为 a 为非零</span></span><br></pre></td></tr></table></figure><p>**2.**逻辑或运算符（||）：只要两个操作数中的任一操作数为真，结果就为真。只有当两个操作数都为假，结果才为假。<br>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int b = 0;</span><br><span class="line">int result = a || b; // result 的值为 1，因为 a 为非零</span><br></pre></td></tr></table></figure><p>**3.**逻辑非运算符（!）：这是一个单目运算符，对一个布尔值进行取反操作。如果操作数为真，结果为假，反之亦然。<br>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> result = !a; <span class="comment">// result 的值为 0，因为 a 为真（非零）</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a &amp;&amp; b: %d\n&quot;</span>, a &amp;&amp; b);  <span class="comment">// 0 (false)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a || b: %d\n&quot;</span>, a || b);  <span class="comment">// 1 (true)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;!a: %d\n&quot;</span>, !a);  <span class="comment">// 0 (false)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;!b: %d\n&quot;</span>, !b);  <span class="comment">// 1 (true)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-5-位运算符"><a href="#6-5-位运算符" class="headerlink" title="6.5 位运算符"></a>6.5 位运算符</h3><p>位运算符直接对整数在内存中的二进制位进行操作。这些运算符包括：<br>按位与(&amp;) ： 全一得一<br>按位或(|)： 有一得一<br>按位异或(^)： 相同为0 不同为1<br>取反(~)： 取反<br>左移(&lt;&lt;)和右移(&gt;&gt;）：</p><p>下面详细解释每一种：<br>**1.**按位与运算符（&amp;）：如果两个相应的二进制位都为1，则结果为1，否则为0。<br>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">60</span>;  <span class="comment">// 60的二进制是 0011 1100</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">13</span>;  <span class="comment">// 13的二进制是 0000 1101</span></span><br><span class="line"><span class="type">int</span> result = a &amp; b;  <span class="comment">// result 的值为 12，二进制为 0000 1100</span></span><br></pre></td></tr></table></figure><p>**2.**按位或运算符（|）：如果两个相应的二进制位中至少有一个1，则结果为1，否则为0。<br>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">60</span>;  <span class="comment">// 60的二进制是 0011 1100</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">13</span>;  <span class="comment">// 13的二进制是 0000 1101</span></span><br><span class="line"><span class="type">int</span> result = a | b;  <span class="comment">// result 的值为 61，二进制为 0011 1101</span></span><br></pre></td></tr></table></figure><p>**3.**按位异或运算符（^）：如果两个相应的二进制位值相同，则结果为0，否则为1。<br>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">60</span>;  <span class="comment">// 60的二进制是 0011 1100</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">13</span>;  <span class="comment">// 13的二进制是 0000 1101</span></span><br><span class="line"><span class="type">int</span> result = a ^ b;  <span class="comment">// result 的值为 49，二进制为 0011 0001</span></span><br></pre></td></tr></table></figure><p>**4.**取反运算符（~）：对数的每一位取反，0变1，1变0。<br>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">60</span>;  <span class="comment">// 60的二进制是 0011 1100</span></span><br><span class="line"><span class="type">int</span> result = ~a;  <span class="comment">// result 的值为 -61，二进制为 1100 0011</span></span><br></pre></td></tr></table></figure><p>**5.**左移运算符（&lt;&lt;）：把位向左移动指定的位数，右边用0填充。<br>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">15</span>;  <span class="comment">// 15的二进制是 0000 1111</span></span><br><span class="line"><span class="type">int</span> result = a &lt;&lt; <span class="number">2</span>;  <span class="comment">// result 的值为 60，二进制为 0011 1100</span></span><br></pre></td></tr></table></figure><p>**6.**右移运算符（&gt;&gt;）：把位向右移动指定的位数，左边的空位如何填充取决于数字的符号（正数左边填充0，负数左边填充1）。<br>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">15</span>;  <span class="comment">// 15的二进制是 0000 1111</span></span><br><span class="line"><span class="type">int</span> result = a &gt;&gt; <span class="number">2</span>;  <span class="comment">// result 的值为 3，二进制为 0000 0011</span></span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">60</span>; <span class="comment">/* 60 = 0011 1100 */</span></span><br><span class="line">    <span class="type">int</span> b = <span class="number">13</span>; <span class="comment">/* 13 = 0000 1101 */</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">    result = a &amp; b; <span class="comment">/* 12 = 0000 1100 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = a &amp; b: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    result = a | b; <span class="comment">/* 61 = 0011 1101 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = a | b: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    result = a ^ b; <span class="comment">/* 49 = 0011 0001 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = a ^ b: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    result = ~a; <span class="comment">/*-61 = 1100 0011 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = ~a: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    result = a &lt;&lt; <span class="number">2</span>; <span class="comment">/* 240 = 1111 0000 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = a &lt;&lt; 2: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    result = a &gt;&gt; <span class="number">2</span>; <span class="comment">/* 15 = 0000 1111 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = a &gt;&gt; 2: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-6-条件运算符"><a href="#6-6-条件运算符" class="headerlink" title="6.6 条件运算符"></a>6.6 条件运算符</h3><p>条件运算符也称为<strong>三元运算符</strong>，其格式为：<br><strong>条件表达式 ? 表达式1 : 表达式2</strong><br>三元运算符的执行过程是这样的：</p><ul><li>首先，程序会计算条件表达式的值</li><li>如果条件表达式的值为真（非0），那么程序会计算调大是1</li></ul><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = 20;</span><br><span class="line">    int max = a &gt; b ? a : b;</span><br><span class="line">    printf(&quot;最大的数是：%d\n&quot;, max);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = (a == 1) ? 20 : 30;</span><br><span class="line">    printf(&quot;b is %d\n&quot;, b);  // b is 30</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-7-自增自减运算符"><a href="#6-7-自增自减运算符" class="headerlink" title="6.7 自增自减运算符"></a>6.7 自增自减运算符</h3><p>C语言中的自增（++）和自减（–）运算符用于增加或减少变量的值。这些运算符有前缀和后缀两种形式，对应着不同的操作顺序。</p><ul><li>前缀自增&#x2F;自减：先进行自增&#x2F;自减操作，然后再进行其他操作。例如，++a 或 –a。</li><li>后缀自增&#x2F;自减：先进行其他操作，然后再进行自增&#x2F;自减操作。例如，a++ 或 a–。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int b = ++a; // 先增加a的值，然后赋值给b。此时a和b都为11。</span><br><span class="line"></span><br><span class="line">a = 10; // 重置a的值为10</span><br><span class="line">b = a++; // 先将a的值赋给b，然后再增加a的值。此时a为11，b为10。</span><br></pre></td></tr></table></figure><h3 id="6-8-逗号运算符"><a href="#6-8-逗号运算符" class="headerlink" title="6.8 逗号运算符"></a>6.8 逗号运算符</h3><p>逗号运算符在C语言中被用来链接两个或更多的独立的表达式，从而使它们能在一行内执行。逗号运算符有两个主要的特点：</p><ol><li>从左至右的顺序执行：逗号运算符的所有操作数都按从左到右的顺序进行计算。</li><li>返回值：逗号运算符的返回值是最后一个表达式的值。</li></ol><p>让我们看一个简单的例 子来更好地理解这个概念：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line"></span><br><span class="line">    a = (b=<span class="number">4</span>, b+<span class="number">2</span>); </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a 的值是 %d\n&quot;</span>, a );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，逗号运算符将两个表达式b&#x3D;4和b+2链接在一起。首先，b&#x3D;4被执行，然后执行b+2，最后，b+2的结果被赋给变量a。因此，a的最终值为6。<br>请注意，虽然逗号运算符可以将多个表达式链接在一起，但过度使用可能会使代码难以理解和维护。在编程时，最好尽可能地保持代码的清晰和简洁。</p><h3 id="6-9-指针运算符"><a href="#6-9-指针运算符" class="headerlink" title="6.9 指针运算符"></a>6.9 指针运算符</h3><p>在C语言中，我们主要有4个指针运算符，它们是：</p><ol><li><em>（解引用运算符）：这个运算符返回指针所指向的值。例如，如果p是一个指向整数的指针，并且该整数的值是10，那么</em>p将返回10。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int *p = &amp;a;</span><br><span class="line">printf(&quot;%d\n&quot;, *p);  // 输出: 10</span><br></pre></td></tr></table></figure><ol><li>&amp;（取地址运算符）：这个运算符返回变量的内存地址。例如，如果a是一个整数，那么&amp;a将返回这个整数在内存中的地址。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">printf(&quot;%p\n&quot;, &amp;a);  // 输出: a在内存中的地址</span><br></pre></td></tr></table></figure><ol><li>和–（自增和自减运算符）：这些运算符用于改变指针的值，使其指向下一个或上一个内存位置。如果p是一个指向整数的指针，并且整数占用4个字节，那么p将使p指向内存中的下一个整数，而p–将使p指向内存中的上一个整数。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int arr[] = &#123;10, 20, 30&#125;;</span><br><span class="line">int *p = arr;</span><br><span class="line">printf(&quot;%d\n&quot;, *p);  // 输出: 10</span><br><span class="line">p++;</span><br><span class="line">printf(&quot;%d\n&quot;, *p);  // 输出: 20</span><br></pre></td></tr></table></figure><ol><li>指针比较运算符：这些包括 &#x3D;&#x3D;、!&#x3D;、&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;。它们可以用来比较两个指针的值（即它们所指向的内存地址）。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a = 10, b = 20;</span><br><span class="line">int *p1 = &amp;a, *p2 = &amp;b;</span><br><span class="line"></span><br><span class="line">if (p1 != p2) &#123;</span><br><span class="line">    printf(&quot;p1 and p2 point to different locations.\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是C语言中关于指针的主要运算符。</p><h3 id="6-10-sizeof运算符"><a href="#6-10-sizeof运算符" class="headerlink" title="6.10 sizeof运算符"></a>6.10 sizeof运算符</h3><p>sizeof运算符是C语言中的一种单目运算符，用于获取一个特定类型或特定对象的大小（以字节为单位）。其可以应用于任何数据类型，包括基本类型（如int、char、double等）、派生类型（如数组、指针等）和自定义类型（如结构体、联合等）。<br>以下是sizeof运算符的一些使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    double b;</span><br><span class="line">    char c[10];</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Size of int: %lu\n&quot;, sizeof(a));  // 输出: Size of int: 4</span><br><span class="line">    printf(&quot;Size of double: %lu\n&quot;, sizeof(b));  // 输出: Size of double: 8</span><br><span class="line">    printf(&quot;Size of char[10]: %lu\n&quot;, sizeof(c));  // 输出: Size of char[10]: 10</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，sizeof(a)返回变量a的大小（以字节为单位），sizeof(b)返回变量b的大小，sizeof(c)返回数组c的大小。<br>需要注意的是，sizeof运算符返回的是size_t类型的值，这是一种无符号整型数据类型，所以在printf函数中应该使用%lu（代表长无符号整型）来格式化输出。<br>另外，你也可以使用sizeof运算符来获取一个类型的大小，而不仅仅是变量的大小。例如，sizeof(int)将返回int类型的大小，sizeof(double)将返回double类型的大小。</p><h1 id="第三章-流程控制语句和循环结构"><a href="#第三章-流程控制语句和循环结构" class="headerlink" title="第三章 流程控制语句和循环结构"></a><strong>第三章 流程控制语句和循环结构</strong></h1><h2 id="3-1-C语言中的分支语句-if-else语句、switch语句"><a href="#3-1-C语言中的分支语句-if-else语句、switch语句" class="headerlink" title="3.1 C语言中的分支语句: if-else语句、switch语句"></a>3.1 C语言中的分支语句: if-else语句、switch语句</h2><h3 id="3-1-1-if-else语句"><a href="#3-1-1-if-else语句" class="headerlink" title="3.1.1 if-else语句"></a>3.1.1 if-else语句</h3><p>在C语言中，if-else结构是一种条件控制语句，<br>在C语言（以及其他许多编程语言中），if-else结构是一种条件控制语句，它用于基于特定条件执行不同的代码块。下面是if-else语句的基本结构和用法说明：</p><ol><li><strong>if 语句</strong>：如果给定条件为真（即条件评估为非零值），则执行if块中的语句。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">     // 代码块 1: 当条件为真时执行这里的代码</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol><li><strong>if-else 语句</strong>：如果if中的条件为真，则执行if块中的语句；否则，执行else块中的语句。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">     // 代码块 1: 当条件为真时执行这里的代码</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">     // 代码块 2: 当条件为假时执行这里的代码</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol><li><strong>if-else if-else 语句</strong>：可以使用多个else if来检查多个条件，如果前面的条件都不满足，则执行最后的else块中的语句。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (condition1) &#123;</span><br><span class="line">     // 代码块 1: 当条件1为真时执行这里的代码</span><br><span class="line"> &#125; else if (condition2) &#123;</span><br><span class="line">     // 代码块 2: 当条件1为假而条件2为真时执行这里的代码</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">     // 代码块 3: 当条件1和条件2都为假时执行这里的代码</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h3><p>下面是一个简单的示例，说明了if-else语句的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line"> int main() &#123;</span><br><span class="line">     int x = 10;</span><br><span class="line"> </span><br><span class="line">     if (x &gt; 10) &#123;</span><br><span class="line">         printf(&quot;x大于10\n&quot;);</span><br><span class="line">     &#125; else if (x == 10) &#123;</span><br><span class="line">         printf(&quot;x等于10\n&quot;);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         printf(&quot;x小于10\n&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，输出将是：<br>x等于10<br>因为x等于10，所以else if中的条件为真，执行了与该条件相关联的代码块。</p><h3 id="3-1-2-switch语句"><a href="#3-1-2-switch语句" class="headerlink" title="3.1.2 switch语句"></a>3.1.2 switch语句</h3><p>switch语句是另一种条件控制语句，它允许你根据一个变量或表达式的值来执行多个不同的代码块。这里是它的基本结构和作用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> constant1:</span><br><span class="line">        <span class="comment">// 代码块 1: 如果表达式的值等于constant1，执行这里的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> constant2:</span><br><span class="line">        <span class="comment">// 代码块 2: 如果表达式的值等于constant2，执行这里的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... (更多的case分支)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 默认代码块: 如果表达式的值不匹配任何case常量，执行这里的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件说明"><a href="#组件说明" class="headerlink" title="组件说明"></a>组件说明</h3><ol><li><strong>switch (expression)</strong>: 以某个表达式或变量为基础启动一个新的switch语句。</li><li><strong>case constantN</strong>: 定义一个新的case分支，其中constantN是一个常量表达式，表示该分支的匹配值。</li><li><strong>break</strong>: 用于退出switch语句并继续执行switch块之后的代码。</li><li><strong>default</strong>: 如果没有任何case分支与表达式的值匹配，将执行default块中的代码。</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面是一个简单的示例，说明了switch语句的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;x等于1\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;x等于2\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;x等于3\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;x不等于1、2或3\n&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，输出将是：<br>x等于2<br>因为x等于2，所以匹配了case 2分支，执行了与该分支相关联的代码块。注意，break语句用于防止代码从一个case块“跌落”到下一个case块（称为fallthrough），这是一个常见的程序错误来源。</p><h2 id="3-2-C语言中的循环语句-while循环、do-while循环、for循环"><a href="#3-2-C语言中的循环语句-while循环、do-while循环、for循环" class="headerlink" title="3.2 C语言中的循环语句: while循环、do-while循环、for循环"></a>3.2 C语言中的循环语句: while循环、do-while循环、for循环</h2><h3 id="3-2-1-while循环"><a href="#3-2-1-while循环" class="headerlink" title="3.2.1 while循环"></a>3.2.1 while循环</h3><h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 代码块：只要条件为真，就会重复执行这里的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件说明-1"><a href="#组件说明-1" class="headerlink" title="组件说明"></a>组件说明</h3><ol><li><strong>while (condition)</strong>: 在这里，“condition”是一个布尔表达式，用于决定是否执行循环体。如果条件为真（即结果为非零值），则会执行循环体。在每次循环迭代结束时，此条件将被重新评估。</li><li><strong>代码块</strong>: 这是需要多次执行的代码段。它可以包含各种语句和控制流结构。</li></ol><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>下面是一个更加详细的示例，其中我们将使用while循环来找出一个整数范围内的所有偶数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> upperLimit = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;1到10之间的偶数有：\n&quot;</span>);</span><br><span class="line">     <span class="keyword">while</span> (i &lt;= upperLimit) &#123;</span><br><span class="line">         <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">         &#125;</span><br><span class="line">         i++;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\n循环结束\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，输出将是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>到<span class="number">10</span>之间的偶数有：</span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span> </span><br><span class="line">    循环结束</span><br></pre></td></tr></table></figure><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><ol><li><strong>初始化变量</strong>: 在循环开始之前，我们首先初始化了两个变量：i（用作循环计数器）和upperLimit（用作循环的上限）。</li><li><strong>循环条件</strong>: while (i &lt;&#x3D; upperLimit)是循环的条件。只要i的值小于或等于upperLimit的值，循环将继续。</li><li><strong>循环体</strong>: 循环体中有一个if语句，用于检查当前i的值是否为偶数。如果是，则将其打印到控制台。</li><li><strong>迭代步进</strong>: 在循环体的末尾，我们增加了i的值，这样可以逐渐接近循环的终止条件，避免无限循环。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>确保循环有一个可达到的终止条件，以避免无限循环。</li><li>可以使用break语句提前退出循环，或使用continue语句来跳过当前迭代的剩余部分，并立即开始下一次迭代。</li><li>在while循环内，你可以嵌套其他控制流结构，如if-else语句或甚至其他while循环，以创建更复杂的逻辑和控制流。</li><li>通过合理的代码注释和良好的代码组织来保持循环的清晰和可读性。</li></ul><h3 id="3-2-2-do-while循环"><a href="#3-2-2-do-while循环" class="headerlink" title="3.2.2 do-while循环"></a>3.2.2 do-while循环</h3><h3 id="do-while-循环的说明"><a href="#do-while-循环的说明" class="headerlink" title="do-while 循环的说明"></a>do-while 循环的说明</h3><ul><li>do-while循环是C语言中的另一种循环结构，它至少执行一次循环体，然后根据给定的条件来决定是否继续执行循环。以下是它的基本结构和作用：</li></ul><h4 id="语法结构-1"><a href="#语法结构-1" class="headerlink" title="语法结构"></a>语法结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">     // 循环体：先执行这里的代码</span><br><span class="line"> &#125; while (condition);</span><br></pre></td></tr></table></figure><h4 id="组件说明-2"><a href="#组件说明-2" class="headerlink" title="组件说明"></a>组件说明</h4><ol><li><strong>do { … }</strong>: 此部分包含你想要循环执行的代码块。无论条件是否满足，此代码块都将执行至少一次。</li><li><strong>while (condition)</strong>: 此处的“condition”是一个布尔表达式。在执行了do代码块一次后，它将被评估。如果条件为真（非零值），则再次执行do代码块。这将继续，直到条件变为假（零值）。</li></ol><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>下面是一个实例，其中我们使用do-while循环来打印1到5之间的所有整数：在这个示例中，输出将是：</p><h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><ol><li><strong>初始化变量</strong>: 在循环开始之前，我们首先初始化了一个变量i，它将用作循环计数器。</li><li><strong>循环体</strong>: 循环体内有一个printf语句，用于打印当前i的值。</li><li><strong>迭代步进</strong>: 在循环体内，我们增加了i的值，这样可以逐渐接近循环的终止条件，避免无限循环。</li><li><strong>循环条件</strong>: 在do代码块执行后，通过while(i &lt;&#x3D; 5)来检查条件。只要条件为真，循环将继续。当i大于5时，循环将停止。</li></ol><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>确保在循环体内有一个能够满足的终止条件，以避免无限循环。</li><li>do-while循环是先执行循环体，然后才检查条件，这意味着循环体将至少执行一次。</li><li>与while循环类似，你可以使用break和continue语句来控制循环的流程。</li><li>你可以在do-while循环内嵌套其他控制流结构，以创建更复杂的逻辑和控制流。</li></ol><h3 id="3-2-3-for循环"><a href="#3-2-3-for循环" class="headerlink" title="3.2.3 for循环"></a>3.2.3 for循环</h3><h3 id="for-循环的说明"><a href="#for-循环的说明" class="headerlink" title="for 循环的说明"></a>for 循环的说明</h3><p>for循环是一个很强大的循环结构，允许你在一行中初始化变量，定义循环条件和增加迭代步进。以下是它的基本结构和解释：</p><h4 id="语法结构-2"><a href="#语法结构-2" class="headerlink" title="语法结构"></a>语法结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (条件1; 条件2; 条件3) &#123;</span><br><span class="line">     // 循环体：只要条件为真，就会重复执行这里的代码</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="组件说明-3"><a href="#组件说明-3" class="headerlink" title="组件说明"></a>组件说明</h4><ol><li><strong>条件1</strong>: 在这个部分，你可以初始化循环控制变量。它在循环开始前仅执行一次。</li><li><strong>条件2</strong>: 这是一个布尔表达式，用于每次循环迭代前检查条件。如果条件为真（非零值），则执行循环体。</li><li><strong>条件3</strong>: 这里你可以更新循环控制变量的值。它在每次循环迭代后被执行。</li><li><strong>循环体</strong>: 这是需要多次执行的代码段。它可以包含各种语句和控制流结构。</li></ol><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;当前的i是：%d\n&quot;</span>, i);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当前的i是：1</span><br><span class="line"> 当前的i是：2</span><br><span class="line"> 当前的i是：3</span><br><span class="line"> 当前的i是：4</span><br><span class="line"> 当前的i是：5</span><br></pre></td></tr></table></figure><h4 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h4><ol><li><strong>初始化</strong>: 循环开始前，i被初始化为1。</li><li><strong>条件检查</strong>: 在每次循环开始时，检查i是否小于或等于5。如果是，则进入循环体。</li><li><strong>循环体</strong>: 循环体内有一个printf语句，用于打印当前i的值。</li><li><strong>迭代</strong>: 在循环体的末尾，i的值增加1，然后返回第二步进行条件检查。</li></ol><h3 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h3><ol><li><strong>逆序打印</strong>: 编写一个程序，使用for循环从10逆序打印到1。</li><li><strong>阶乘计算</strong>: 编写一个程序，使用for循环计算给定数字的阶乘。</li><li><strong>斐波那契序列</strong>: 编写一个程序，使用for循环生成一个长度为n的斐波那契序列。</li><li><strong>奇数和偶数之和</strong>: 编写一个程序，使用for循环计算1到n之间所有奇数和偶数的和。</li><li><strong>质数检查</strong>: 编写一个程序，使用for循环检查一个给定的数字是否是质数。</li><li><strong>矩阵乘法</strong>: 编写一个程序，使用嵌套for循环进行两个矩阵的乘法。</li></ol><h3 id="阶乘的定义"><a href="#阶乘的定义" class="headerlink" title="阶乘的定义"></a>阶乘的定义</h3><p>阶乘是一种数学运算，通常表示为n!，定义为从1乘到n的所有正整数的乘积。数学上，它可以定义为：<br>n! &#x3D; n  <em>(n-1)</em>  (n-2)  <em>…</em>  1</p><h3 id="程序步骤"><a href="#程序步骤" class="headerlink" title="程序步骤"></a>程序步骤</h3><ol><li>从主函数中获取用户输入的数字，存储在变量n中。</li><li>初始化一个变量，例如factorial，为1。因为1是乘法的单位元素。</li><li>使用for循环从1迭代到n，在每次迭代中将当前迭代的数乘以factorial。</li></ol><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>以下是一个简单的C程序，实现上述步骤：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> n;</span><br><span class="line">     <span class="type">long</span> <span class="type">long</span> factorial = <span class="number">1</span>;  <span class="comment">// 使用长整型来防止溢出</span></span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数: &quot;</span>);</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;负数没有阶乘!\n&quot;</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">             factorial *= i;  <span class="comment">// 等价于 factorial = factorial * i;</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d的阶乘是: %lld\n&quot;</span>, n, factorial);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><ol><li><strong>用户输入</strong>: 首先，我们让用户输入一个整数n，我们要计算这个数的阶乘。</li><li><strong>错误检查</strong>: 如果输入的数字是负数，我们打印一个错误消息，因为负数没有阶乘。</li><li><strong>初始化阶乘变量</strong>: 我们初始化一个变量factorial为1。</li><li><strong>for循环</strong>: 使用for循环从1迭代到n，并在每次迭代中将factorial乘以当前的迭代数。</li><li><strong>输出结果</strong>: 在循环结束后，我们得到n的阶乘，并将其打印到控制台。</li></ol><p>这样你就得到了一个简单但有效的阶乘计算程序！</p><h2 id="3-3-C语言中的转移语句-goto语句（禁用）、break语句、continue语句"><a href="#3-3-C语言中的转移语句-goto语句（禁用）、break语句、continue语句" class="headerlink" title="3.3 C语言中的转移语句: goto语句（禁用）、break语句、continue语句"></a>3.3 C语言中的转移语句: goto语句（禁用）、break语句、continue语句</h2><h3 id="break-跳出循环"><a href="#break-跳出循环" class="headerlink" title="break 跳出循环"></a>break 跳出循环</h3><h3 id="continue-跳出循环一次"><a href="#continue-跳出循环一次" class="headerlink" title="continue 跳出循环一次"></a>continue 跳出循环一次</h3><h1 id="第四章-数组和字符串"><a href="#第四章-数组和字符串" class="headerlink" title="第四章 数组和字符串"></a><strong>第四章 数组和字符串</strong></h1><p><strong>目标</strong></p><ul><li>1、C语言中数组的概念和使用</li><li>2、C语言中的多维数组</li><li>3、C语言中字符串的概念和使用</li><li>4、C语言中字符串处理函数（复制、连接）</li><li>5、C语言中字符串处理函数（比较、长度）</li><li>6、C语言中字符串处理函数（转换）</li></ul><h2 id="1、C语言中数组的概念和使用"><a href="#1、C语言中数组的概念和使用" class="headerlink" title="1、C语言中数组的概念和使用"></a>1、C语言中数组的概念和使用</h2><p>在C语言中，数组是一种复合数据类型，可以存储固定大小的同类型元素的序列。数组可以是一维的（即线性数组），也可以是多维的（例如二维的网格数组或者三维的立方体数组等）。<br>数组的使用在C语言编程中非常常见，无论是存储一系列的数值，还是字符串（字符数组），甚至更复杂的数据结构，如结构体数组等。</p><h3 id="1-1-定义和初始化数组"><a href="#1-1-定义和初始化数组" class="headerlink" title="1.1 定义和初始化数组"></a>1.1 定义和初始化数组</h3><p>在C语言中，我们可以定义一个数组，如下所示：<br>int arr[10]; &#x2F;&#x2F; 定义一个可以存放10个整数的数组<br>在定义数组的时候，可以对它进行初始化：<br>int arr[5] &#x3D; {1, 2, 3, 4, 5}; &#x2F;&#x2F; 定义并初始化一个数组<br>如果在初始化的时候没有给出数组的大小，编译器会根据初始化的元素数量自动确定：<br>int arr[] &#x3D; {1, 2, 3, 4, 5}; &#x2F;&#x2F; 定义并初始化一个数组，大小为5</p><p>第一种 定义数组时 内部变量写完整<br>int arr[3] &#x3D; {1，2，3};<br>第二种 定时数组时 内部变量不完整<br>int arr[5] &#x3D; {1，2，3}; -&gt; {1，2，3 , 0 , 0 };<br>第三种 定义数组时 只填写一个0<br>int arr[10] &#x3D; {0}； -&gt; {0,0,0,0,0,0,0,0};<br>第四种 定义数组时 []内不填写<br>int arr[] &#x3D; {1，2，3}; -&gt; int arr[3] &#x3D; {1，2，3};</p><h3 id="1-2-访问数组元素"><a href="#1-2-访问数组元素" class="headerlink" title="1.2 访问数组元素"></a>1.2 访问数组元素</h3><p>通过下标的方式访问 arr[n] 此时n就是该数组的下标索引</p><p>可以通过索引来访问数组元素，索引从0开始，即第一个元素的索引为0，第二个元素的索引为1，以此类推。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr[<span class="number">0</span>]); <span class="comment">// 输出第一个元素，结果为1</span></span><br></pre></td></tr></table></figure><h3 id="1-3-数组遍历"><a href="#1-3-数组遍历" class="headerlink" title="1.3 数组遍历"></a>1.3 数组遍历</h3><p>一般情况下，可以通过循环来遍历数组中的所有元素。例如，如果要输出数组中的所有元素，可以使用如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr[i]); <span class="comment">// 输出每个元素</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，访问数组时必须确保索引不超过数组的大小，否则会产生未定义行为。</p><h2 id="2、C语言中的多维数组"><a href="#2、C语言中的多维数组" class="headerlink" title="2、C语言中的多维数组"></a>2、C语言中的多维数组</h2><p>在C语言中，除了一维数组外，还可以定义多维数组。最常见的就是二维数组，常常被用来表示表格或者矩阵。多维数组的定义和使用方式基本上和一维数组类似，但是在索引元素的时候需要指定更多的索引。</p><p>在逻辑上，我们认为二维数组第一个下标是表示他的行，第二个下标是表示他的列<br>但是在实际存储上，他还是一个顺序存储</p><h3 id="2-1-定义和初始化多维数组"><a href="#2-1-定义和初始化多维数组" class="headerlink" title="2.1 定义和初始化多维数组"></a>2.1 定义和初始化多维数组</h3><p>在 C 语言中，可以使用多种方式来定义多维数组。在下面的例子中，我将演示如何使用不同的方式来定义一个二维数组：<br><strong>标准定义方式</strong>：直接在声明时指定数组的大小。<br>int array[2][3]; &#x2F;&#x2F; 定义了一个 2 行 3 列的二维整数数组<br><strong>初始化时定义</strong>：在定义时直接初始化数组。<br>int array[2][3] &#x3D; { {1, 2, 3}, {4, 5, 6} }; &#x2F;&#x2F; 定义并初始化二维数组<br><strong>部分初始化定义</strong>：定义时只初始化部分元素，其余元素默认为0。<br>int array[2][3] &#x3D; { {1, 2}, {4} }; &#x2F;&#x2F; 未初始化的元素值为0<br><strong>省略行大小定义</strong>：在初始化时可以省略行的大小。<br>int array[][3] &#x3D; { {1, 2, 3}, {4, 5, 6} }; &#x2F;&#x2F; 行的大小通过初始化元素的个数决定<br>请注意，在 C 语言中，多维数组的行和列的大小必须是一个已知的常量，不能是变量。如果你需要一个行或列大小可以改变的数组，那么你可能需要使用到动态内存分配（比如使用 malloc 或 calloc 函数）或者使用一维数组的数组（数组的指针）来模拟多维数组。</p><h3 id="二维数组赋值时，可以省略行但是不能省略列"><a href="#二维数组赋值时，可以省略行但是不能省略列" class="headerlink" title="二维数组赋值时，可以省略行但是不能省略列"></a>二维数组赋值时，可以省略行但是不能省略列</h3><p>1、二维数组看成是一维数组的集合</p><p>2、编译时需要确定每个数组的空间</p><p>3、可以根据数组下标的偏移量来找到数组元素</p><p>以上三点说明可以省略行数但是不能省略列数。</p><h3 id="2-2-访问多维数组元素"><a href="#2-2-访问多维数组元素" class="headerlink" title="2.2 访问多维数组元素"></a>2.2 访问多维数组元素</h3><p>访问多维数组元素时，需要为每一维指定索引：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> matrix[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, matrix[<span class="number">0</span>][<span class="number">2</span>]); <span class="comment">// 输出第一行第三列的元素，结果为3</span></span><br></pre></td></tr></table></figure><h3 id="2-3-多维数组的遍历"><a href="#2-3-多维数组的遍历" class="headerlink" title="2.3 多维数组的遍历"></a>2.3 多维数组的遍历</h3><p>遍历多维数组一般需要使用嵌套循环。例如，打印出二维数组中的所有元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> matrix[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matrix[i][j]); <span class="comment">// 输出每个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">// 每一行结束后换行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码将会输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>注意：和一维数组一样，访问多维数组时必须确保所有的索引都不超过数组的大小，否则会产生未定义行为。</p><h2 id="3、C语言中字符串的概念和使用"><a href="#3、C语言中字符串的概念和使用" class="headerlink" title="3、C语言中字符串的概念和使用"></a>3、C语言中字符串的概念和使用</h2><p>在 C 语言中，字符串被视为字符数组的特殊情况。C 语言中没有专门的字符串类型，而是使用字符数组来表示和操作字符串。下面来具体说明一下。</p><h3 id="3-1-字符串的概念"><a href="#3-1-字符串的概念" class="headerlink" title="3.1 字符串的概念"></a>3.1 字符串的概念</h3><p>在 C 语言中，字符串是由多个字符组成的一系列字符序列，以空字符**(‘\0’)<strong>作为结束标志。字符串通常被存储在</strong>字符数组**中，数组的最后一位存放这个空字符。例如，字符串 “Hello” 在 C 中被表示为字符数组 {‘H’, ‘e’, ‘l’, ‘l’, ‘o’, ‘\0’}。</p><h3 id="字符串的使用"><a href="#字符串的使用" class="headerlink" title="字符串的使用"></a>字符串的使用</h3><p><strong>定义和初始化字符串</strong><br>定义和初始化字符串有多种方式。最常见的是直接使用字符串字面量进行初始化：<br>char str[] &#x3D; “Hello”;<br>上述代码定义了一个名为 str 的字符数组，并用字符串 “Hello” 对其进行初始化。数组的长度自动设置为6，其中包括5个字符和一个结尾的空字符。<br><strong>字符串的输入和输出</strong><br>可以使用 printf 和 scanf 函数来进行字符串的输出和输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char str[50];</span><br><span class="line">printf(&quot;Enter a string: &quot;);</span><br><span class="line">scanf(&quot;%s&quot;, str);  // 输入字符串</span><br><span class="line">printf(&quot;You entered: %s&quot;, str);  // 输出字符串</span><br></pre></td></tr></table></figure><p>注意，当使用 scanf 函数输入字符串时，它会在遇到空白字符（如空格、制表符或换行符）时停止读取。如果要读取一行（包含空格的字符串），需要使用 fgets 函数。<br><strong>字符串函数</strong><br>C 标准库 &lt;string.h&gt; 提供了一系列操作字符串的函数，如 strlen（获取字符串长度）、strcpy（复制字符串）、strcat（连接字符串）、strcmp（比较字符串）等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">char str1[10] = &quot;Hello&quot;;</span><br><span class="line">char str2[10];</span><br><span class="line">int len = strlen(str1);  // 获取字符串长度</span><br><span class="line">strcpy(str2, str1);  // 复制字符串</span><br><span class="line">strcat(str1, str2);  // 连接字符串</span><br><span class="line">int cmp = strcmp(str1, str2);  // 比较字符串</span><br></pre></td></tr></table></figure><h2 id="4、C语言中字符串处理函数（复制、连接）"><a href="#4、C语言中字符串处理函数（复制、连接）" class="headerlink" title="4、C语言中字符串处理函数（复制、连接）"></a>4、C语言中字符串处理函数（复制、连接）</h2><h3 id="4-1strcpy"><a href="#4-1strcpy" class="headerlink" title="4.1strcpy"></a>4.1strcpy</h3><ul><li><p><strong>头文件</strong>：#include &lt;string.h&gt;</p></li><li><p><strong>函数原型</strong>：char <em>strcpy(char</em> dest, const char *src);</p></li><li><p><strong>功能</strong>：该函数用于将字符串 src（包括 ‘\0’ 终止字符）复制到 dest 中。</p></li><li><p><strong>参数</strong>： </p></li><li><p>dest：目标字符串，即复制到的地方。</p></li><li><p>src：源字符串，即需要复制的字符串。</p></li><li><p><strong>返回值</strong>：函数返回 dest，即目标字符串。</p></li></ul><p><strong>示例程序</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char src[40];</span><br><span class="line">    char dest[100];</span><br><span class="line"></span><br><span class="line">    memset(dest, &#x27;\0&#x27;, sizeof(dest));</span><br><span class="line">    strcpy(src, &quot;This is example&quot;);</span><br><span class="line">    strcpy(dest, src);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Final copied string : %s\n&quot;, dest);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例程序中，src 字符串 “This is example” 被复制到 dest 字符串中。然后，打印 dest 字符串，输出 “Final copied string : This is example”。</p><h3 id="4-2strcat-函数"><a href="#4-2strcat-函数" class="headerlink" title="4.2strcat 函数"></a>4.2strcat 函数</h3><ul><li><p><strong>头文件</strong>：#include &lt;string.h&gt;</p></li><li><p><strong>函数原型</strong>：char <em>strcat(char</em> dest, const char *src);</p></li><li><p><strong>功能</strong>：该函数用于将 src 字符串（包括 ‘\0’ 终止字符）连接到 dest 的末尾。</p></li><li><p><strong>参数</strong>： </p></li><li><p>dest：目标字符串，即要被添加内容的字符串。</p></li><li><p>src：源字符串，即要添加的字符串。</p></li><li><p><strong>返回值</strong>：函数返回 dest，即目标字符串。</p></li></ul><p><strong>例程</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char dest[30] = &quot;Hello&quot;;</span><br><span class="line">    char src[] = &quot;, World!&quot;;</span><br><span class="line"></span><br><span class="line">    strcat(dest, src);</span><br><span class="line"></span><br><span class="line">    printf(&quot;源字符串： %s\n&quot;, src);</span><br><span class="line">    printf(&quot;目标字符串： %s\n&quot;, dest);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例程中，源字符串 “, World!” 被连接到目标字符串 “Hello” 的末尾。然后，打印源字符串和目标字符串。输出结果将是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">源字符串： , World!</span><br><span class="line">目标字符串： Hello, World!</span><br></pre></td></tr></table></figure><h3 id="3-strlen"><a href="#3-strlen" class="headerlink" title="3. strlen"></a>3. strlen</h3><ul><li><strong>头文件</strong>： #include &lt;string.h&gt;</li><li><strong>函数原型</strong>： size_t strlen(const char *str);</li><li><strong>功能</strong>： 此函数用于获取字符串的长度，也就是从字符串的开始到遇到第一个空字符(‘\0’)的字符数。注意，这个长度不包括空字符(‘\0’)本身。</li><li><strong>参数</strong>：</li><li>str：指向要获取长度的字符串的指针。</li><li><strong>返回值</strong>： 此函数返回字符串的长度（不包括结束字符’\0’）。返回值的类型是 size_t，这是无符号整数类型，用于表示对象的大小。</li></ul><p>例程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char str[] = &quot;Hello, World!&quot;;</span><br><span class="line">    size_t length = strlen(str);</span><br><span class="line"></span><br><span class="line">    printf(&quot;The length of the string &#x27;%s&#x27; is: %zu\n&quot;, str, length);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此程序中，我们使用 strlen 函数获取字符串 “Hello, World!” 的长度，并将其打印出来。注意，%zu 是 size_t 类型的 printf 格式说明符。</p><h3 id="4-strcmp"><a href="#4-strcmp" class="headerlink" title="4. strcmp"></a>4. strcmp</h3><ul><li><p><strong>头文件</strong>： #include &lt;string.h&gt;</p></li><li><p><strong>函数原型</strong>： int strcmp(const char <em>str1, const char</em> str2);</p></li><li><p><strong>功能</strong>： 此函数用于比较两个字符串。比较是基于字符的ASCII值进行的。</p></li><li><p><strong>参数</strong>： </p></li><li><p>str1：指向第一个要比较的字符串的指针。</p></li><li><p>str2：指向第二个要比较的字符串的指针。</p></li><li><p><strong>返回值</strong>： </p></li><li><p>如果 str1 和 str2 相等，则返回0。</p></li><li><p>如果 str1 大于 str2，则返回大于0的数。</p></li><li><p>如果 str1 小于 str2，则返回小于0的数。</p></li></ul><p><strong>例程</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char str1[] = &quot;Hello, World!&quot;;</span><br><span class="line">    char str2[] = &quot;Hello, OpenAI!&quot;;</span><br><span class="line">    </span><br><span class="line">    int result = strcmp(str1, str2);</span><br><span class="line">    </span><br><span class="line">    if(result &gt; 0) &#123;</span><br><span class="line">        printf(&quot;&#x27;%s&#x27; is greater than &#x27;%s&#x27;\n&quot;, str1, str2);</span><br><span class="line">    &#125; else if(result &lt; 0) &#123;</span><br><span class="line">        printf(&quot;&#x27;%s&#x27; is less than &#x27;%s&#x27;\n&quot;, str1, str2);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;&#x27;%s&#x27; is equal to &#x27;%s&#x27;\n&quot;, str1, str2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此程序中，我们使用 strcmp 函数比较两个字符串 “Hello, World!” 和 “Hello, OpenAI!” 并打印结果。</p><h3 id="5-strchr-搜索"><a href="#5-strchr-搜索" class="headerlink" title="5. strchr 搜索"></a>5. strchr 搜索</h3><ul><li><p>strchr函数</p></li><li><p><strong>头文件</strong>： #include &lt;string.h&gt;</p></li><li><p><strong>函数原型</strong>： char <em>strchr(const char</em> str, int c);</p></li><li><p><strong>功能</strong>： 此函数在字符串 str 中查找第一次出现字符 c 的位置。</p></li><li><p><strong>参数</strong>： </p></li><li><p>str：指向要被搜索的字符串的指针。</p></li><li><p>c：要搜索的字符。</p></li><li><p><strong>返回值</strong>： </p></li><li><p>如果字符 c 在字符串 str 中找到，则返回一个指向该位置的指针。</p></li><li><p>如果字符 c 在字符串 str 中没有找到，则返回 NULL。</p></li><li><p><strong>例程</strong>：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char str[] = &quot;Hello, World!&quot;;</span><br><span class="line">    char c = &#x27;o&#x27;;</span><br><span class="line">    </span><br><span class="line">    char *result = strchr(str, c);</span><br><span class="line">    </span><br><span class="line">    if(result != NULL) &#123;</span><br><span class="line">        printf(&quot;First occurrence of &#x27;%c&#x27; in &#x27;%s&#x27; is at position: %ld\n&quot;, c, str, result - str);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;Character &#x27;%c&#x27; not found in &#x27;%s&#x27;\n&quot;, c, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此程序中，我们使用 strchr 函数在字符串 “Hello, World!” 中查找字符 ‘o’ 的第一次出现的位置，并打印结果。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言第5-8章内容</title>
      <link href="/2023/09/20/test/c%E5%92%8Cc++/C%E8%AF%AD%E8%A8%80(5-8%E7%AB%A0)%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%B1%E7%94%A8%E4%BD%93%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%20%E9%AB%98%E7%BA%A7C%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"/>
      <url>/2023/09/20/test/c%E5%92%8Cc++/C%E8%AF%AD%E8%A8%80(5-8%E7%AB%A0)%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%B1%E7%94%A8%E4%BD%93%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%20%E9%AB%98%E7%BA%A7C%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-函数和指针"><a href="#第五章-函数和指针" class="headerlink" title="第五章 函数和指针"></a><strong>第五章 函数和指针</strong></h1><h2 id="一、C语言中函数的定义和调用"><a href="#一、C语言中函数的定义和调用" class="headerlink" title="一、C语言中函数的定义和调用"></a>一、C语言中函数的定义和调用</h2><p>在C语言中，函数是一组可重复使用的代码，用于执行特定任务。函数的优势在于它可以随需求调用，减少代码的冗余性，并增强代码的可读性。<br>函数的基本组成包括：<strong>返回（函数）类型</strong> ， <strong>函数名</strong> ， <strong>参数列表和函数体</strong>。</p><ul><li><strong>返回类型</strong> ： 函数可以返回一个值。返回类型是函数返回值的数据类型。如果函数不反悔任何值，则其返回值为void。</li><li><strong>函数名</strong>：这是表示函数的唯一名称，函数名和参数列表一起构成了函数的签名。、</li><li><strong>参数列表</strong>：参数是传递给函数的值。参数列表包括参数的类型、类型、参数的数量，参数是可选的，也就是说，函数可以不包含参数</li><li><strong>函数体</strong>：函数体包含了定义函数行为的一组语句。</li></ul><h3 id="1-1-函数的定义"><a href="#1-1-函数的定义" class="headerlink" title="1.1 函数的定义"></a>1.1 函数的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  返回类型是 int ，函数名为add 参数列表是两个int类型的参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1 , <span class="type">int</span> num2)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">int</span> sum = num1 + num;</span><br><span class="line">     <span class="keyword">return</span> sum;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>一旦我们定义了函数，就可以在其他地方调用它。要调用函数，我们只需要编写函数名和在括号中传递适当的参数。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = add(<span class="number">5</span> , <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;两数之和等于 %d\n&quot;</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，add(5, 10)是函数调用，5和10是传递给add函数的参数，add函数返回15，我们将这个返回值赋值给result变量，然后打印出来。</p><h2 id="二、C语言中函数参数的传递"><a href="#二、C语言中函数参数的传递" class="headerlink" title="二、C语言中函数参数的传递"></a>二、C语言中函数参数的传递</h2><p>C语言中函数参数传递基本上有两种方式：值传递和引用传递。</p><ul><li><strong>值传递</strong>：在值传递方式中，被调函数的<strong>形式参数</strong>作为被调用函数的局部变量处理，即在栈中开辟了内存空间，以存放主调函数传递过来的实参值，这个空间值只在函数调用的过程中有效，也就是说，值传递的方式，函数接收的是参数的副本，函数内部对参数的任何改变，都不会影响到实际参数的值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">     x = <span class="number">20</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Inside change() x=%d\n&quot;</span>, x);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">     change(x);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Outside change() x=%d\n&quot;</span>, x);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，即使在change函数中修改了x的值，但在main函数中打印x时，其值还是原来的值10，这就是值传递。</p><ul><li><strong>引用传递（Pass by Reference）</strong>： 在引用传递方式中，被调函数的形式参数虽然也作为局部变量在堆栈中开辟了内存空间，但是这次存放的是主调函数放进来实参的变量地址。被调函数对形参的任何操作都被处理成间接寻址，即对实参操作。</li></ul><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> *x)</span> &#123;</span><br><span class="line">     *x = <span class="number">20</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Inside change() x=%d\n&quot;</span>, *x);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">     change(&amp;x);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Outside change() x=%d\n&quot;</span>, x);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们传递了x的地址给change函数，然后在change函数中修改了x的值。在main函数中，我们看到x的值已经被修改为20，这就是引用传递。</p><ul><li><strong>形式参数</strong> : 形式参数也成为形参，是函数定义时声明的参数。形参只在函数定义时有意义，在函数内部形参作为局部变量使用。</li><li><strong>实际参数</strong>：实际参数也成为实参，实在函数调用时实际传给函数的参数。实参可以是常量、变量或者是表达式，无论实参是任何形式的量，在进行函数调用时，他们都必须有确定的值，以便把这些值传给形参。</li></ul><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void myFunction(int x) &#123;    // 这里的int x就是形式参数</span><br><span class="line">     printf(&quot;%d&quot;, x);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> int main() &#123;</span><br><span class="line">     int y = 10;</span><br><span class="line">     myFunction(y);   // 这里的y就是实际参数</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，myFunction的定义中int x就是形式参数，当我们在main函数中调用myFunction(y)时，y就是实际参数。<br>函数在被调用时，实际参数的值会被复制给形式参数。如果形式参数在函数体内发生改变，并不会影响实际参数的值。但如果你使用了指针作为形式参数，那么你可以在函数体内改变实际参数的值，这是因为你传递的是实际参数的地址，而不是实际参数的值。</p><h2 id="三、C语言中函数的返回值"><a href="#三、C语言中函数的返回值" class="headerlink" title="三、C语言中函数的返回值"></a>三、C语言中函数的返回值</h2><p>C语言中的函数可以返回一个值给调用他的函数或者是主程序。返回值可以是任何基本类型，也可以是街头提或者枚举类型。当然，函数也可以设定为不返回任何值，这种类型的函数被声明为”void”<br>函数的返回值</p><h2 id="四、C语言中全局变量和局部变量"><a href="#四、C语言中全局变量和局部变量" class="headerlink" title="四、C语言中全局变量和局部变量"></a>四、C语言中全局变量和局部变量</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><ul><li><strong>定义</strong>：全局变量是在函数之外定义的变量，它在程序的任何地方都可以访问（除了在它定义之前）。</li><li><strong>作用范围</strong>：全局变量在整个程序中都是可见的，从它被定义开始，直到程序结束。</li><li><strong>生命周期</strong>：全局变量的生命周期是整个程序运行期间，它们在程序开始时分配内存，在程序结束时释放。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int globalVar = 10; // 定义一个全局变量</span><br><span class="line"></span><br><span class="line">void func() &#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, globalVar); // 可以访问全局变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><ul><li><p><strong>定义</strong>：局部变量是在函数内部定义的变量，它只在定义它的函数内部可见。</p></li><li><p><strong>作用范围</strong>：局部变量只在定义它的函数内部有效，函数外部无法访问。</p></li><li><p><strong>生命周期</strong>：局部变量的生命周期仅限于函数执行期间，当函数执行完毕后，局部变量的内存会被释放。</p></li><li><p><strong>例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">20</span>; <span class="comment">// 定义一个局部变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, localVar); <span class="comment">// 可以访问局部变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// int localVar = 20; // 错误：无法访问func函数内的局部变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="五、C语言中指针的概念和使用"><a href="#五、C语言中指针的概念和使用" class="headerlink" title="五、C语言中指针的概念和使用"></a>五、C语言中指针的概念和使用</h2><h3 id="6-1-指针中的一些基础概念知识"><a href="#6-1-指针中的一些基础概念知识" class="headerlink" title="6.1 指针中的一些基础概念知识"></a>6.1 指针中的一些基础概念知识</h3><h4 id="6-1-1-指针的作用"><a href="#6-1-1-指针的作用" class="headerlink" title="6.1.1 指针的作用"></a>6.1.1 指针的作用</h4><ul><li><strong>使程序简洁、高效</strong>：指针可以直接访问内存，提高性能，减少内存使用。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;a; <span class="comment">// ptr是指向a的指针，它存储着a的内存地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *ptr); <span class="comment">// 输出a的值，即10</span></span><br></pre></td></tr></table></figure><ul><li><strong>表示复杂数据结构</strong>：指针是实现链表、树等复杂数据结构的关键。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>; <span class="comment">// 链表的头指针，开始时为空</span></span><br><span class="line"><span class="comment">// 可以继续添加节点到链表中</span></span><br></pre></td></tr></table></figure><ul><li><strong>动态内存分配</strong>：运行时需要动态分配或释放内存时，必须使用指针。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配一个int大小的内存，并让ptr指向它</span></span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    *ptr = <span class="number">20</span>; <span class="comment">// 通过指针修改内存中的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *ptr); <span class="comment">// 输出20</span></span><br><span class="line">    <span class="built_in">free</span>(ptr); <span class="comment">// 使用完后释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>返回多个函数值</strong>：通过传递指针给函数，函数可以修改并返回多个结果。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    swap(&amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x: %d, y: %d\n&quot;</span>, x, y); <span class="comment">// 输出x: 10, y: 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-1-2-指针、内存、地址的概念"><a href="#6-1-2-指针、内存、地址的概念" class="headerlink" title="6.1.2 指针、内存、地址的概念"></a>6.1.2 指针、内存、地址的概念</h4><ul><li><strong>内存</strong>：内存是计算机存储空间中，每个变量都占用的一定内存空间。</li><li><strong>地址</strong>：内存中每个字节都拥有唯一的地址，这个地址是内存空间的标识符</li><li><strong>指针</strong>：指针是一个特殊的变量，他存储了内存的地址，通过这个地址，我们可以直接访问内存中的数据</li></ul><p>指针就是链接内存和地址的桥梁，通过指针我们可以直接的操作内存中的数据，这是C语言中非常重要和强大的特性<br>其关系如图所示，其实指针也只是一个变量，这个变量存储的类型有一点点特殊，存储的是我们其他变量的地址。我们只需要知道一个变量是由地址和数据组成，而我们的指针变量所能做的就是存储你这个普通变量的地址并能进行操作。<img src="https://cdn.nlark.com/yuque/0/2023/png/8368890/1694678675709-6891934b-7d53-4e48-a6b8-ab0498a6ba13.png#averageHue=%23f3f3f3&clientId=ufdda5353-03bf-4&from=paste&id=u1b89d7e7&originHeight=865&originWidth=1710&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=89081&status=done&style=none&taskId=u93bf1897-7638-4b49-aec6-dc61622deef&title=" alt="img"></p><h3 id="6-2-指针的概念"><a href="#6-2-指针的概念" class="headerlink" title="6.2 指针的概念"></a>6.2 指针的概念</h3><p>在C语言中，指针就是一个变量，<strong>其值为另一个变量的内存地址</strong>，也就是它指向该地址的变量。指针允许以直接和间接的方式通过引用内存地址来访问和操作内存中存储数据。</p><h4 id="6-2-1-指针变量说明"><a href="#6-2-1-指针变量说明" class="headerlink" title="6.2.1 指针变量说明"></a>6.2.1 指针变量说明</h4><p>指针变量的一般形式如下：<br>type * v &#x3D; NULL;<br>在这里，</p><ul><li>type：表示指针变量所指向的变量的数据类型。它可以是任何的数据类型，例如 int, char, double, float 等。</li><li>*：表示这是一个指针变量。</li><li>v：是指针变量的名称。</li></ul><h3 id="6-3-指针的使用"><a href="#6-3-指针的使用" class="headerlink" title="6.3 指针的使用"></a>6.3 指针的使用</h3><p>在C语言中要使用指针，我们首先需要声明一个指针，然后可以通过地址操作符（&amp;）来获取变量的地址并将其存储在指针中，然后通过解引用操作符(*)来获取存储该地址中的值<br>以下是指针的基本步骤：</p><h4 id="6-3-1-指针使用的基本步骤"><a href="#6-3-1-指针使用的基本步骤" class="headerlink" title="6.3.1 指针使用的基本步骤"></a>6.3.1 指针使用的基本步骤</h4><hr><p><strong>步骤如下</strong>：</p><ul><li>声明指针</li><li>为指针分配地址</li><li>使用访问变量值</li><li>修改指针指向的变量的值</li></ul><p><strong>声明指针</strong>：在C语言中，使用星号（*）来声明一个指针。<br>int * p;<br><strong>为指针分配地址</strong>：我们可以使用“&amp;”来获取一个变量的地址，然后将该地址分配给指针。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> * p;</span><br><span class="line">p = &amp;i;    <span class="comment">//存地址</span></span><br></pre></td></tr></table></figure><p><strong>使用指针访问变量值</strong>：使用星号(<em>)前缀可以访问变量的值。这称为*<em>解引用</em></em><br>printf(“%d”,*p); &#x2F;&#x2F;去数据<br><strong>修改指针指向的变量的值</strong>：你也可以使用指针来修改它所指向的变量的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> * p;</span><br><span class="line">p = &amp;i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p);</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> * p = &amp;a;</span><br><span class="line"></span><br><span class="line">    *p = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印地址： p = %p a = %p&quot;</span> , p , &amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印数据： p = %d a = %d&quot;</span> , *p, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="六、C语言中指针运算"><a href="#六、C语言中指针运算" class="headerlink" title="六、C语言中指针运算"></a>六、C语言中指针运算</h2><p>指针的运算就是以指针变量中所存放的值（地址量）作为运算量而进行运算。指针运算的知识就是地址的计算。<br>指针运算的种类是有限制的，只能进行<strong>算术运算</strong>、<strong>关系运算</strong>，以及我们前面所讲过的赋值，这里称为赋值运算。<br>如下表：</p><h3 id="6-1-算术运算"><a href="#6-1-算术运算" class="headerlink" title="6.1 算术运算"></a>6.1 算术运算</h3><p>不同类型的两个指针实行加减是无意义的：<br>px+n 表示实际内存单元的地址量是:(px)+sizeof(px的类型)*n;<br>px+n 表示实际内存单元的地址量是:(px)-sizeof(px的类型)*n;<br><strong>指针算术运算：</strong></p><table><thead><tr><th><strong>运算符</strong></th><th><strong>用法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>+</td><td>p + n</td><td>指针p向前（向高地址）移动n个同类型元素的位置</td></tr><tr><td>-</td><td>p - n</td><td>指针p向后（向低地址）移动n个同类型元素的位置</td></tr><tr><td>-</td><td>p - q</td><td>计算两个指针p和q之间相差多少个同类型元素的位置</td></tr></tbody></table><p><strong>指针的自增与自减运算：</strong></p><table><thead><tr><th><strong>运算符</strong></th><th><strong>用法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>++</td><td>p 或 p</td><td>指针p向前（向高地址）移动一个同类型元素的位置</td></tr><tr><td>–</td><td>–p 或 p–</td><td>指针p向后（向低地址）移动一个同类型元素的位置</td></tr></tbody></table><p><strong>注意</strong>：这些运算符直接改变指针本身的值。具体来说，p或–p首先改变指针的值，然后返回新的指针值；p或p–先返回原始的指针值，然后改变指针的值。<br><strong>例程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> * p = arr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印地址: p = %p , arr = %p \n &quot;</span> , &amp;p , arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印数据: p = %d\n&quot;</span>,*p);</span><br><span class="line">    <span class="comment">/*加法运算*/</span></span><br><span class="line">    p = p + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****************加法计算******************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印地址: p = %p , arr = %p \n&quot;</span> , &amp;p , arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印数据: p = %d\n&quot;</span>,*p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*减法运算*/</span></span><br><span class="line">    p = p - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****************加法计算******************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印地址: p = %p , arr = %p \n&quot;</span> , &amp;p , arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印数据: p = %d\n&quot;</span>,*p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*指针差*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****************指针差******************\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> * p_3 = &amp;arr[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> * p_4 = &amp;arr[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> i = p_3 - p_4;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;指针差%d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*自增运算*/</span></span><br><span class="line">    p++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****************加法计算******************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印地址: p = %p , arr = %p \n&quot;</span> , &amp;p , arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印数据: p = %d\n&quot;</span>,*p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*减法运算*/</span></span><br><span class="line">    j</span><br><span class="line">        p--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****************加法计算******************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印地址: p = %p , arr = %p \n&quot;</span> , &amp;p , arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印数据: p = %d\n&quot;</span>,*p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2关系运算"><a href="#6-2关系运算" class="headerlink" title="6.2关系运算"></a>6.2关系运算</h3><p>关于指针的关系运算，需要注意以下几个问题</p><ol><li>指针关系运算应当在同类型和同数据区域的指针间进行。具有不同数据类型的指针之间的关系运算没有意义，指向不同数据区域（例如，一个指针指向堆，另一个指向栈）的两个指针之间，关系运算也没有意义。</li><li>指针与整数之间的关系运算没有意义，不能进行大于、小于等判断，但是可以与0进行等于或不等于的比较，用于判断指针是否为空。这是因为在C语言中，NULL指针通常被定义为0。</li></ol><p><strong>指针关系运算</strong></p><table><thead><tr><th><strong>运算符</strong></th><th><strong>用法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>p &#x3D;&#x3D; q</td><td>如果指针p和q指向同一位置则返回真</td></tr><tr><td>!&#x3D;</td><td>p !&#x3D; q</td><td>如果指针p和q指向不同位置则返回真</td></tr><tr><td>&lt;</td><td>p &lt; q</td><td>如果指针p位于q之前则返回真</td></tr><tr><td>&gt;</td><td>p &gt; q</td><td>如果指针p位于q之后则返回真</td></tr><tr><td>&lt;&#x3D;</td><td>p &lt;&#x3D; q</td><td>如果指针p位于q之前或与q同位置则返回真</td></tr><tr><td>&gt;&#x3D;</td><td>p &gt;&#x3D; q</td><td>如果指针p位于q之后或与q同位置则返回真</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line">    <span class="type">int</span> * p_1 = arr;</span><br><span class="line">    <span class="type">int</span> * p_2 = arr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印数据:p_1 = %d , p_2 = %d , arr = %d\n&quot;</span> , *p_1 , *p_2 ,* arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印地址:p_1 = %p , p_2 = %p , arr = %p\n&quot;</span> , p_1 , p_2 , arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*大于小于判断*/</span></span><br><span class="line">    p_1 = p_1 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p_2 &gt; p_1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打印数据:p_1 = %d , p_2 = %d , arr = %d\n&quot;</span> , *p_1 , *p_2 ,* arr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打印地址:p_1 = %p , p_2 = %p , arr = %p\n&quot;</span> , p_1 , p_2 , arr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p_2 &gt; p_1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//p_1 = p_1 - 1;</span></span><br><span class="line">    <span class="comment">//p_2 = p_2 + 1;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p_2 &lt; p_1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打印数据:p_1 = %d , p_2 = %d , arr = %d\n&quot;</span> , *p_1 , *p_2 ,* arr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打印地址:p_1 = %p , p_2 = %p , arr = %p\n&quot;</span> , p_1 , p_2 , arr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p_2 &gt; p_1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、C语言中指针和数组的关系"><a href="#七、C语言中指针和数组的关系" class="headerlink" title="七、C语言中指针和数组的关系"></a>七、C语言中指针和数组的关系</h2><p>在 C 语言中，指针和数组有着紧密的联系。理解这种联系有助于我们更好地理解如何在 C 程序中使用数组和指针。</p><h4 id="7-1-数组名作为指针"><a href="#7-1-数组名作为指针" class="headerlink" title="7.1 数组名作为指针"></a>7.1 <strong>数组名作为指针</strong></h4><p>在 C 语言中，数组名是一个常量指针，它指向数组的第一个元素。例如，如果你有一个数组 int arr[5]，那么 arr 就是指向 arr[0] 的指针。你可以通过对数组名进行解引用操作来获取第一个元素的值，例如 *arr 就是 arr[0] 的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *arr);  <span class="comment">// 输出: 1</span></span><br></pre></td></tr></table></figure><h4 id="7-2-使用指针访问数组元素"><a href="#7-2-使用指针访问数组元素" class="headerlink" title="7.2 使用指针访问数组元素:"></a>7.2 <strong>使用指针访问数组元素</strong>:</h4><p>你可以使用指针来访问和操作数组的元素。你可以通过对指针进行增减操作来移动指针，并使用解引用操作符来访问指针当前指向的元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = arr;  <span class="comment">// p 指向数组的第一个元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);  <span class="comment">// 输出当前元素的值</span></span><br><span class="line">    p++;  <span class="comment">// 指针向前移动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-数组作为函数参数"><a href="#7-3-数组作为函数参数" class="headerlink" title="7.3 数组作为函数参数"></a>7.3 <strong>数组作为函数参数</strong></h4><p>当数组作为函数参数时，它会被自动地转化为指向数组第一个元素的指针。这意味着函数内部不能直接获取到数组的长度，因为指针不保存数组的长度信息。为了在函数内部处理数组，你通常需要将数组的长度作为另一个参数传入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printArr</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> size)</span>·-</span><br><span class="line">    <span class="title function_">for</span> <span class="params">(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    printArr(arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，理解指针和数组的关系有助于我们编写更高效、更灵活的 C 代码。</p><h2 id="八、C语言中指针当函数参数和返回值"><a href="#八、C语言中指针当函数参数和返回值" class="headerlink" title="八、C语言中指针当函数参数和返回值"></a>八、C语言中指针当函数参数和返回值</h2><p>在 C 语言中，我们可以使用指针作为函数的参数，也可以使用指针作为函数的返回值。这种使用指针的方式可以使我们的代码更加灵活，特别是在处理数组，字符串，动态内存分配等问题时。</p><ol><li><strong>指针作为函数参数</strong>: 通过将指针作为函数参数，我们可以实现在函数内部修改外部变量的值。此外，当我们需要在函数中处理数组，字符串等数据结构时，也通常会使用指针作为参数。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>* p)</span> &#123;    <span class="comment">//引用传递</span></span><br><span class="line">    (*p)++;  <span class="comment">// increment the value of variable pointed by p</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before: %d\n&quot;</span>, a);</span><br><span class="line">    add(&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After: %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，add函数接收一个整数指针作为参数，然后增加该指针所指向的变量的值。</p><ol><li><strong>指针作为函数返回值</strong>: 如果函数需要返回数组，字符串，或者其他的复杂数据类型，那么通常会使用指针作为函数的返回值。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">getArr</span><span class="params">()</span> &#123;     <span class="comment">//指针函数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>* arr = getArr();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，getArr函数返回一个指向整型数组的指针。<br>注意事项：函数返回的指针必须指向静态数据或者动态分配的内存，不能返回指向栈上数据的指针，因为当函数执行完毕后，局部变量（存储在栈上）的生命周期就结束了，其内存区域可能会被其他的数据覆盖。<br>以上，就是在 C 语言中使用指针作为函数参数和返回值的基本用法。</p><h2 id="九、C语言中指针函数和函数指针"><a href="#九、C语言中指针函数和函数指针" class="headerlink" title="九、C语言中指针函数和函数指针"></a>九、C语言中指针函数和函数指针</h2><p>在 C 语言中，指针函数和函数指针是两个不同的概念，它们的含义和用法如下：</p><ol><li>**指针函数 (Pointer Function)**：指针函数其实就是返回指针的函数。在这种情况下，函数的返回类型是一个指针类型。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">getString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span>* str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">    str = getString();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，getString是一个返回char类型指针的函数，也被称为指针函数。</p><ol><li>**函数指针 (Function Pointer)**：函数指针是一个指针，它指向了一个函数。这样我们就可以像使用普通函数一样来使用这个指针。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void hello() &#123;</span><br><span class="line">    printf(&quot;Hello, World!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    void (*funcPtr)();  // declare a function pointer</span><br><span class="line">    funcPtr = hello;  // assign hello function to funcPtr</span><br><span class="line">    funcPtr();  // call the function via the function pointer</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，funcPtr就是一个函数指针，它被用来指向hello函数。然后通过funcPtr()来调用hello函数。<br>这两者虽然名字类似，但其实是两个完全不同的概念。指针函数是一种特殊类型的函数，它的返回值是一个指针。函数指针则是指向函数的指针，它可以被用来调用所指向的函数。</p><h2 id="十、C语言中命令行参数函数"><a href="#十、C语言中命令行参数函数" class="headerlink" title="十、C语言中命令行参数函数"></a>十、C语言中命令行参数函数</h2><p>在 C 语言中，我们可以通过命令行为程序提供参数，这些参数会在 main 函数中以特定的形式被处理。一个处理命令行参数的 main 函数的形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的两个参数分别是：</p><ol><li>argc (参数的数量)：这是一个整型，代表命令行参数的数量。当没有任何参数时，argc 的值为 1，因为程序的名称本身也被视作一个参数。</li><li>argv (参数的值)：这是一个指向字符串的指针数组，其中包含了每个参数的具体值。argv[0] 是程序的名称，argv[1] 是第一个参数，以此类推。</li></ol><p>比如，你有一个程序叫做 program，你通过命令行以这种方式运行它：.&#x2F;program arg1 arg2。在这种情况下，argc 的值为 3，argv[0] 是 .&#x2F;program，argv[1] 是 arg1，argv[2] 是 arg2。<br>这是一个简单的处理命令行参数的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序名称: %s\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;参数 %d: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有提供参数.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序会打印出它自己的名称以及所有的命令行参数。如果没有提供任何参数，它将输出 “没有提供参数.”。<br><strong>应用场景</strong>：<br>命令行参数在许多情况下都非常有用。这是因为它们提供了一种灵活的方式，让你可以在启动程序时向其提供一些信息。这意味着你可以控制程序的行为，而无需修改和重新编译代码。<br>以下是一些具体的使用场景：</p><ol><li><strong>配置选项</strong>：你可以使用命令行参数来控制程序的行为。例如，许多命令行工具都有诸如 -v 或 –verbose 的参数，这些参数可以控制程序显示更多的输出信息。</li><li><strong>输入和输出文件</strong>：你可以使用命令行参数来指定输入和&#x2F;或输出文件的路径。例如，编译器就需要一个源代码文件作为输入，并将生成的机器代码写入到另一个文件中。</li><li><strong>参数化测试</strong>：如果你正在编写一个需要进行大量测试的程序，那么命令行参数可能会派上用场。你可以编写一个脚本来运行你的程序，每次使用不同的参数，这样就可以自动化测试过程。</li><li><strong>环境设置</strong>：例如，你可能需要指定一些环境特定的设置，比如数据库的地址、密码等。</li></ol><p>总的来说，命令行参数提供了一种灵活的方式来影响程序的行为，而无需每次都去改变和重新编译代码。</p><h1 id="第六章-结构体和共用体"><a href="#第六章-结构体和共用体" class="headerlink" title="第六章 结构体和共用体"></a><strong>第六章 结构体和共用体</strong></h1><p><strong>目标</strong></p><ul><li>1、C语言中结构体和概念和使用</li><li>2、C语言中结构体数组和指针</li><li>3、C语言中结构体字节对齐和位域</li><li>4、C语言中共用体的概念和使用</li><li>5、C语言中枚举的概念和使用</li><li>6、C语言中的类型定义和typedef</li></ul><h2 id="一、C语言中结构体和概念和使用"><a href="#一、C语言中结构体和概念和使用" class="headerlink" title="一、C语言中结构体和概念和使用"></a>一、C语言中结构体和概念和使用</h2><h3 id="1-1-结构体的概念和基本定义"><a href="#1-1-结构体的概念和基本定义" class="headerlink" title="1.1 结构体的概念和基本定义"></a>1.1 结构体的概念和基本定义</h3><h4 id="1-1-1-什么是结构体，它的用途和场景"><a href="#1-1-1-什么是结构体，它的用途和场景" class="headerlink" title="1.1.1 什么是结构体，它的用途和场景"></a>1.1.1 什么是结构体，它的用途和场景</h4><p>结构体（Structure）是C语言中一种复合数据类型，它允许开发者将不同类型的数据项组织在一起。结构体中的每个数据项被称为“成员”，这些成员可以具有不同的数据类型，包括基本类型（如int，char，float等）和其他复合类型（包括其他结构体或数组）。结构体提供了一种方法，让开发者能够将相关数据项集中在一起并分配给一个变量。<br>结构体在以下场景中特别有用：</p><ol><li>表示复杂的数据对象：例如，如果要表示一个学生，可以创建一个包含姓名、年龄、成绩等成员的结构体。</li><li>将一组相关的变量组织在一起：如果有一组数据项属于同一实体或概念，那么将它们放在一个结构体中是有意义的。例如，一个结构体可以代表一个日期，其中包含年份、月份和日期这三个成员。</li><li>作为函数的参数或返回类型：在复杂的程序中，可能需要通过函数传递或返回多个数据。在这种情况下，将这些数据封装在一个结构体中会更有效，而且代码更易于阅读和理解。</li><li>实现更复杂的数据结构：在数据结构和算法中，结构体是实现链表、树、图等高级数据结构的基础。</li></ol><p>因此，结构体是C语言中一个非常重要的概念，掌握了结构体，就意味着你已经进入了C语言的一个更高级的阶段。</p><h4 id="1-1-2-结构体的基本语法"><a href="#1-1-2-结构体的基本语法" class="headerlink" title="1.1.2 结构体的基本语法"></a>1.1.2 结构体的基本语法</h4><p>结构体的基本语法在C语言中如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct_name</span> &#123;</span></span><br><span class="line">    data_type member1;</span><br><span class="line">    data_type member2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>struct 是一个关键字，表示这是一个结构体类型的定义。</li><li>struct_name 是你为这个结构体类型取的名字，这个名字在后面声明结构体变量时会用到。</li><li>data_type 是成员的数据类型，它可以是任何有效的C语言数据类型，包括基本数据类型（如int，float，char等）和其他复合类型（如数组，指针，甚至其他的结构体类型）。</li><li>member1，member2 等是成员的名字，你可以根据实际需要定义任意多个成员。</li></ul><p>例如，如果你想定义一个表示“学生”的结构体类型，你可以这么写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构体类型名字叫做 “Student”，它有三个成员：一个是长度为50的字符数组 “name”，用来存储学生的名字；一个是整型 “age”，用来存储学生的年龄；一个是浮点型 “grade”，用来存储学生的成绩。<br>这只是定义了一个结构体类型，如果你想要创建一个具体的学生，你需要声明一个结构体变量，就像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">lile</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就创建了一个 “Student” 类型的变量 “tzp”，你可以通过 “.” 操作符来访问它的成员，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(lile.name, <span class="string">&quot;lile&quot;</span>);</span><br><span class="line">lile.age = <span class="number">20</span>;</span><br><span class="line">lile.grade = <span class="number">90.5</span>;</span><br></pre></td></tr></table></figure><h3 id="1-2-结构体变量的声明和访问"><a href="#1-2-结构体变量的声明和访问" class="headerlink" title="1.2 结构体变量的声明和访问"></a>1.2 结构体变量的声明和访问</h3><h4 id="1-2-1-如何声明结构体变量"><a href="#1-2-1-如何声明结构体变量" class="headerlink" title="1.2.1 如何声明结构体变量"></a>1.2.1 如何声明结构体变量</h4><p>声明结构体变量的方式和声明其他类型的变量类似。首先要写出结构体类型，然后跟上你要声明的变量名。如下面的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student1</span>;</span>  <span class="comment">// 声明了一个类型为struct Student的变量student1</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>此外，你也可以在定义结构体的同时声明变量，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125; student1, student2;  <span class="comment">// 在定义struct Student类型的同时，声明了两个此类型的变量student1和student2</span></span><br></pre></td></tr></table></figure><h4 id="1-2-2-如何访问结构体成员"><a href="#1-2-2-如何访问结构体成员" class="headerlink" title="1.2.2 如何访问结构体成员"></a>1.2.2 如何访问结构体成员</h4><p>访问结构体变量的成员可以使用.运算符。首先写出结构体变量的名字，然后写上.，最后写上你要访问的成员的名字。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125; student1, student2;  <span class="comment">// 在定义struct Student类型的同时，声明了两个此类型的变量student1和student2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">strcpy</span>(student1.name, <span class="string">&quot;lican&quot;</span>);  <span class="comment">// 设置student1的名字为&quot;John Doe&quot;</span></span><br><span class="line">     student1.age = <span class="number">20</span>;  <span class="comment">// 设置student1的年龄为20</span></span><br><span class="line">     student1.grade = <span class="number">90.5</span>;  <span class="comment">// 设置student1的成绩为90.5</span></span><br><span class="line"></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student3</span>;</span></span><br><span class="line">     <span class="built_in">strcpy</span>(student3.name, <span class="string">&quot;lile&quot;</span>);  <span class="comment">// 设置student1的名字为&quot;John Doe&quot;</span></span><br><span class="line">     student3.age = <span class="number">20</span>;  <span class="comment">// 设置student1的年龄为20</span></span><br><span class="line">     student3.grade = <span class="number">90.5</span>;  <span class="comment">// 设置student1的成绩为90.5</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当我们使用指向结构体的指针时，可以使用 -&gt; 运算符来访问结构体的成员。下面是一个使用 -&gt; 运算符访问结构体成员的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">     <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">     <span class="type">int</span> age;</span><br><span class="line">     <span class="type">float</span> grade;</span><br><span class="line"> &#125;student1;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">strcpy</span>(student1.name, <span class="string">&quot;lican&quot;</span>);  <span class="comment">// 设置student1的名字为&quot;John Doe&quot;</span></span><br><span class="line">     student1.age = <span class="number">20</span>;  <span class="comment">// 设置student1的年龄为20</span></span><br><span class="line">     student1.grade = <span class="number">90.5</span>;  <span class="comment">// 设置student1的成绩为90.5</span></span><br><span class="line"></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student3</span>;</span></span><br><span class="line">     <span class="built_in">strcpy</span>(student3.name, <span class="string">&quot;lile&quot;</span>);  <span class="comment">// 设置student1的名字为&quot;John Doe&quot;</span></span><br><span class="line">     student3.age = <span class="number">20</span>;  <span class="comment">// 设置student1的年龄为20</span></span><br><span class="line">     student3.grade = <span class="number">90.5</span>;  <span class="comment">// 设置student1的成绩为90.5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">p</span> =</span> &amp;student1;  <span class="comment">// p是一个指向student1的指针</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用-&gt;运算符访问student1的成员</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p-&gt;name);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;age);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, p-&gt;grade);</span><br><span class="line"></span><br><span class="line">     p = <span class="literal">NULL</span>;</span><br><span class="line">     p = &amp;student3;  <span class="comment">// p是一个指向student1的指针</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用-&gt;运算符访问student3的成员</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p-&gt;name);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;age);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, p-&gt;grade);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，p 是一个指向 student1 的指针，p-&gt;name 就是访问 p 指向的结构体的 name 成员，p-&gt;age 和 p-&gt;grade 同理。所以，-&gt; 运算符是用于通过结构体指针访问结构体成员的。</p><h4 id="1-2-3-如何初始化结构体变量"><a href="#1-2-3-如何初始化结构体变量" class="headerlink" title="1.2.3 如何初始化结构体变量"></a>1.2.3 如何初始化结构体变量</h4><p>初始化结构体变量可以在声明的同时进行。写出结构体类型和变量名，然后在等号右边用花括号包裹起来的值列表来初始化所有的成员。值的顺序应该和成员在结构体定义中的顺序一致。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student1</span> =</span> &#123;<span class="string">&quot;tan&quot;</span>, <span class="number">20</span>, <span class="number">90.5</span>&#125;;  <span class="comment">// 初始化student1的所有成员</span></span><br></pre></td></tr></table></figure><p>在这个例子中，”tan”初始化了name成员，20初始化了age成员，90.5初始化了grade成员。<br>也可以使用指定初始化器的方式来初始化结构体变量，这种方式可以不按照成员顺序进行，而是根据成员的名字来指定值。例如：<br><strong>struct Student student1 &#x3D; {.name &#x3D; “John Doe”, .age &#x3D; 20, .grade &#x3D; 90.5}; &#x2F;&#x2F; 使用指定初始化器初始化student1的所有成员</strong></p><h3 id="1-3-结构体和函数的关系"><a href="#1-3-结构体和函数的关系" class="headerlink" title="1.3 结构体和函数的关系"></a>1.3 结构体和函数的关系</h3><h4 id="1-3-1-如何将结构体作为函数参数"><a href="#1-3-1-如何将结构体作为函数参数" class="headerlink" title="1.3.1 如何将结构体作为函数参数"></a>1.3.1 如何将结构体作为函数参数</h4><p>我们可以将结构体作为函数的参数。在这种情况下，函数会接收结构体的一个<strong>副本</strong>，修改这个副本并不会影响原来的结构体。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_student</span><span class="params">(                                                )</span>    <span class="comment">//参数列表为结构体</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, s.grade);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">john</span> =</span> &#123;<span class="string">&quot;John Doe&quot;</span>, <span class="number">20</span>, <span class="number">90.5</span>&#125;;</span><br><span class="line">print_student(john);  <span class="comment">// 将john作为参数传递给print_student函数</span></span><br></pre></td></tr></table></figure><p>如果要在函数内部修改原来的结构体，需要传递一个指向结构体的指针，然后在函数内部通过这个指针来访问和修改结构体。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">birthday</span><span class="params">(<span class="keyword">struct</span> Student *s)</span> &#123;</span><br><span class="line">    s-&gt;age++;  <span class="comment">// 通过指针访问并修改结构体的成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">birthday(&amp;john);  <span class="comment">// 将指向john的指针作为参数传递给birthday函数</span></span><br></pre></td></tr></table></figure><h4 id="1-3-2-在函数中返回结构体"><a href="#1-3-2-在函数中返回结构体" class="headerlink" title="1.3.2 在函数中返回结构体"></a>1.3.2 在函数中返回结构体</h4><p>函数也可以返回一个结构体。 在这种情况下，函数会返回一个结构体的副本。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student <span class="title function_">make_student</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> age, <span class="type">float</span> grade)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s</span>;</span></span><br><span class="line">    <span class="built_in">strcpy</span>(s.name, name);</span><br><span class="line">    s.age = age;</span><br><span class="line">    s.grade = grade;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">john</span> =</span> make_student(<span class="string">&quot;peng&quot;</span>, <span class="number">20</span>, <span class="number">90.5</span>);  <span class="comment">// 使用make_student函数的返回值来初始化john</span></span><br></pre></td></tr></table></figure><p>需要注意的是，返回一个结构体会涉及到拷贝整个结构体，如果结构体很大，这可能会比较低效。在这种情况下，一种可能的解决方案是返回一个指向结构体的指针。但需要注意的是，不能返回指向局部变量的指针，因为当函数返回后，局部变量就不存在了。你可以返回一个指向动态分配的内存的指针，这个内存可以在函数返回后继续存在。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Student *make_student(char *name, int age, float grade) &#123;</span><br><span class="line">    struct Student *s = malloc(sizeof(struct Student));</span><br><span class="line">    if (s != NULL) &#123;</span><br><span class="line">        strcpy(s-&gt;name, name);</span><br><span class="line">        s-&gt;age = age;</span><br><span class="line">        s-&gt;grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Student *john = make_student(&quot;John Doe&quot;, 20, 90.5);  // john是一个指向动态分配的结构体的指针</span><br></pre></td></tr></table></figure><p>在这个例子中，make_student 函数使用 malloc 函数动态分配了一块内存，并返回了指向这块内存的指针。使用完这块内存后，你需要使用 free 函数来释放它，防止内存泄漏。</p><h2 id="二、C语言中结构体数组和指针"><a href="#二、C语言中结构体数组和指针" class="headerlink" title="二、C语言中结构体数组和指针"></a>二、C语言中结构体数组和指针</h2><h3 id="2-1-结构体数组的定义和使用"><a href="#2-1-结构体数组的定义和使用" class="headerlink" title="2.1 结构体数组的定义和使用"></a>2.1 结构体数组的定义和使用</h3><h4 id="2-1-1-如何定义和初始化结构体数组"><a href="#2-1-1-如何定义和初始化结构体数组" class="headerlink" title="2.1.1 如何定义和初始化结构体数组"></a>2.1.1 如何定义和初始化结构体数组</h4><p>定义和初始化结构体数组的语法与普通数组非常类似。我们首先定义结构体类型，然后声明该类型的数组，并在声明时初始化数组。<br>以下是一个示例，我们定义了一个名为Student的结构体，并声明了该类型的数组students：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并初始化一个结构体数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">students</span>[3] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">20</span>, <span class="number">85.6</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">22</span>, <span class="number">90.8</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">19</span>, <span class="number">88.5</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-如何访问结构体数组的元素"><a href="#2-1-2-如何访问结构体数组的元素" class="headerlink" title="2.1.2 如何访问结构体数组的元素"></a>2.1.2 如何访问结构体数组的元素</h4><p>访问结构体数组的元素非常直观，我们可以通过索引来访问数组的元素，然后使用.运算符来访问结构体的成员。<br>以下是一个示例，我们访问students数组的元素并打印相关信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印第一个学生的姓名</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, students[<span class="number">0</span>].name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印第二个学生的年龄</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Age: %d\n&quot;</span>, students[<span class="number">1</span>].age);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印第三个学生的成绩</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Grade: %.2f\n&quot;</span>, students[<span class="number">2</span>].grade);</span><br></pre></td></tr></table></figure><p>在这个示例中，students[0]、students[1]、students[2]分别表示数组students中的第一个、第二个和第三个元素，这些元素都是Student类型的结构体。我们使用.运算符来访问这些结构体的成员。</p><h3 id="2-2-的定义和使用"><a href="#2-2-的定义和使用" class="headerlink" title="2.2 &lt;结构体指针&gt;的定义和使用"></a>2.2 &lt;结构体指针&gt;的定义和使用</h3><h4 id="2-2-1-如何定义结构体指针"><a href="#2-2-1-如何定义结构体指针" class="headerlink" title="2.2.1 如何定义结构体指针"></a>2.2.1 如何定义结构体指针</h4><p>定义一个指向结构体的指针与定义普通指针类似。首先我们需要指定指针的类型，即指针指向的结构体的类型，然后指定指针的名称。例如，我们可以这样定义一个指向 struct Student 类型的指针 p：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student1</span> =</span> &#123;<span class="string">&quot;John Doe&quot;</span>, <span class="number">20</span>, <span class="number">90.5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">p</span>;</span>  <span class="comment">// 定义一个指向struct Student类型的指针p</span></span><br><span class="line"></span><br><span class="line">p = &amp;student1;  <span class="comment">// 将p指向student1</span></span><br></pre></td></tr></table></figure><p>在上述代码中，我们首先定义了一个 struct Student 类型的变量 student1，然后定义了一个指向 struct Student 类型的指针 p，最后将 p 指向 student1。</p><h4 id="2-2-2-如何访问指向结构体的指针成员"><a href="#2-2-2-如何访问指向结构体的指针成员" class="headerlink" title="2.2.2 如何访问指向结构体的指针成员"></a>2.2.2 如何访问指向结构体的指针成员</h4><p>我们可以通过结构体指针来访问结构体的成员，这时我们需要使用 <strong>-&gt;</strong> 运算符。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p-&gt;name);  <span class="comment">// 使用-&gt;运算符访问p指向的结构体的name成员</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;age);  <span class="comment">// 使用-&gt;运算符访问p指向的结构体的age成员</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, p-&gt;grade);  <span class="comment">// 使用-&gt;运算符访问p指向的结构体的grade成员</span></span><br></pre></td></tr></table></figure><p>在这个例子中，p 是一个指向 student1 的指针，p-&gt;name 就是访问 p 指向的结构体的 name 成员，p-&gt;age 和 p-&gt;grade 同理。所以，-&gt; 运算符是用于通过结构体指针访问结构体成员的。</p><h2 id="三、C语言中结构体字节对齐和位域"><a href="#三、C语言中结构体字节对齐和位域" class="headerlink" title="三、C语言中结构体字节对齐和位域"></a>三、C语言中结构体字节对齐和位域</h2><h3 id="3-1-结构体的字节对齐"><a href="#3-1-结构体的字节对齐" class="headerlink" title="3.1 结构体的字节对齐"></a>3.1 结构体的字节对齐</h3><p>字节对齐（Data Alignment）是计算机硬件为了提高内存读写效率所采取的一种措施。在C语言中，结构体的成员可能不会严格按照代码中的顺序在内存中排列，而会进行字节对齐。</p><h4 id="3-1-1-结构体的字节对齐"><a href="#3-1-1-结构体的字节对齐" class="headerlink" title="3.1.1 结构体的字节对齐"></a>3.1.1 结构体的字节对齐</h4><p>结构体的字节对齐是指编译器在分配内存时，会保证每个成员的存储地址相对于结构体起始地址的偏移量是该成员类型大小的整数倍。例如，如果一个成员的类型为 int，则其偏移量必须是 sizeof(int) 的整数倍。</p><h4 id="3-1-2-结构体的字节对齐规则"><a href="#3-1-2-结构体的字节对齐规则" class="headerlink" title="3.1.2 结构体的字节对齐规则"></a>3.1.2 结构体的字节对齐规则</h4><ul><li>结构体的每个成员根据其类型的自然对齐要求，从起始位置按该类型的整数倍位置开始存放。</li><li>结构体本身，按照所有成员中最大自然对齐值的整数倍来对齐。</li><li>在成员对齐时，如果成员大小小于对齐值，按照成员大小对齐。如果成员大小大于对齐值，按照对齐值对齐。</li></ul><h4 id="3-1-3-如何设置字节对齐"><a href="#3-1-3-如何设置字节对齐" class="headerlink" title="3.1.3 如何设置字节对齐"></a>3.1.3 如何设置字节对齐</h4><p>在C语言中，可以通过编译指令 #pragma pack(n) 来设置字节对齐的规则。n 表示最大对齐字节数，必须是2的非负整数次幂，并且小于或等于平台最大支持的对齐字节数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(2) <span class="comment">// 设定字节对齐规则为2字节对齐</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyData</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack() <span class="comment">// 恢复编译器默认的对齐规则</span></span></span><br></pre></td></tr></table></figure><p>在上面的例子中，使用 #pragma pack(2) 设定了2字节对齐，MyData 结构体的 c 成员和 i 成员之间可能就会有1个字节的填充。然后使用 #pragma pack() 恢复了编译器默认的对齐规则。</p><p>结构体对齐的规则通常包括以下几点：</p><ol><li>基本对齐原则：结构体中的每个成员按照其自身类型的大小进行对齐。例如， int 类型通常按照 4 字节对齐， double 类型通常按照 8 字节对齐。</li><li>填充字节：为了满足对齐要求，可能会在成员之间插入填充字节。例如，如果一个  char 类型（1 字节）后面紧跟着一个  int 类型（4 字节），那么可能会在  char 后面填充 3 个字节，以使  int 从 4 字节的边界开始存储。</li><li>结构体大小：结构体的总大小是其最大成员大小的整数倍。如果结构体的最后一个成员后面还需要填充字节以满足这个规则，也会进行填充。</li><li>嵌套结构体：如果结构体中包含嵌套的结构体，嵌套结构体也会按照上述规则进行对齐，并且整个结构体的对齐要考虑嵌套结构体的对齐情况。</li><li>编译器特定规则：不同的编译器可能对结构体的对齐有一些细微的差别，或者提供特定的编译选项来控制对齐方式。</li></ol><p>下面是一个示例来说明结构体对齐：</p><p>#include &lt;stdio.h&gt;</p><p>struct S1 {</p><p>​    char c;</p><p>​    int i;</p><p>};</p><p>struct S2 {</p><p>​    int i;</p><p>​    char c;</p><p>};</p><p>int main() {</p><p>​    printf(“Size of S1: %zu\n”, sizeof(struct S1));</p><p>​    printf(“Size of S2: %zu\n”, sizeof(struct S2));</p><p>​    return 0;</p><p>}</p><p>在常见的编译器中， struct S1 的大小可能是 8 字节，因为  char 后面会填充 3 个字节以满足  int 的 4 字节对齐要求。而  struct S2 的大小通常也是 8 字节，因为结构体的总大小要为 4 的整数倍，所以在最后可能会填充 3 个字节。</p><h3 id="3-2-结构体的位域"><a href="#3-2-结构体的位域" class="headerlink" title="3.2 结构体的位域"></a>3.2 结构体的位域</h3><h4 id="3-2-1-什么是位域，他的作用"><a href="#3-2-1-什么是位域，他的作用" class="headerlink" title="3.2.1 什么是位域，他的作用"></a>3.2.1 什么是位域，他的作用</h4><p>位域（Bit-field）是C语言中的一种特殊类型，它允许程序员对一个整型变量的位进行操作，从而节省内存空间。位域通常用于处理底层硬件或者协议中的数据，例如，一些硬件的寄存器可能只有几个位有实际意义，或者网络协议中的一些字段可能只有几位。</p><h4 id="3-2-2-如何定义和使用位域"><a href="#3-2-2-如何定义和使用位域" class="headerlink" title="3.2.2 如何定义和使用位域"></a>3.2.2 如何定义和使用位域</h4><p>位域的定义在语法上类似于普通的结构体成员定义，但是需要在类型名和成员名之间加上一个冒号和一个数字，表示该成员的位数。<br>例如，下面的代码定义了一个包含两个位域成员的结构体 BitField：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BitField</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a : <span class="number">3</span>;  <span class="comment">// a是一个3位的无符号整型位域</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b : <span class="number">4</span>;  <span class="comment">// b是一个4位的无符号整型位域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用位域的方式和普通的结构体成员类似，都是使用 . 运算符。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BitField</span> <span class="title">bf</span>;</span></span><br><span class="line">bf.a = <span class="number">5</span>;  <span class="comment">// 设置a为5</span></span><br><span class="line">bf.b = <span class="number">10</span>;  <span class="comment">// 设置b为10</span></span><br></pre></td></tr></table></figure><p>需要注意的是，位域的值不能超过它的位数所能表示的最大值。例如，在上面的代码中，a 最大只能表示到 2^3-1 &#x3D; 7，如果尝试设置一个更大的值，那么只有最低的3位会被保留，高位的值会被丢弃。</p><h4 id="3-2-3-位于在结构体中的内存分布"><a href="#3-2-3-位于在结构体中的内存分布" class="headerlink" title="3.2.3 位于在结构体中的内存分布"></a>3.2.3 位于在结构体中的内存分布</h4><p>位域在内存中的布局取决于具体的编译器和平台。大部分情况下，同一类型的连续位域会被打包在一起。如果一组连续的位域的总位数超过了它们的类型的大小，那么编译器可能会将它们分配到两个或更多的字（word）中。如果位域之间有一个非位域成员，或者两个位域成员的类型不同，那么它们也可能被分配到不同的字中。<br>例如，下面的代码定义了一个包含三个位域成员的结构体 BitField2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BitField2</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a : <span class="number">3</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b : <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> c : <span class="number">6</span>;  <span class="comment">// c可能无法和a、b打包在一起，因为a、b、c的总位数超过了unsigned int的大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，a、b 和 c 可能无法全部打包在一个 unsigned int 中，因为它们的总位数（3+4+6 &#x3D; 13）超过了 unsigned int 的大小（通常为8或16）。这时，c 可能会被分配到另一个 unsigned int 中。但是具体的内存布局取决于编译器和平台，可以通过编译器的文档或者实验来确定。</p><h2 id="四、C语言中共用体的概念和使用-union"><a href="#四、C语言中共用体的概念和使用-union" class="headerlink" title="四、C语言中共用体的概念和使用(union)"></a>四、C语言中共用体的概念和使用(union)</h2><h3 id="4-1-共用体的概念"><a href="#4-1-共用体的概念" class="headerlink" title="4.1 共用体的概念"></a>4.1 共用体的概念</h3><p>共用体（union）是C语言中的一种复合数据类型，类似于结构体。它允许在相同的内存位置存储不同的数据类型。也就是说，共用体的所有成员共享同一块内存空间，它的大小由最大的成员决定。因此，共用体可以被看作是一个可以存储多种数据类型的变量。<br>共用体的主要用途是节省内存，特别是当我们有一些组件会以多种方式使用的时候。但请注意，同一时间只能使用共用体的一个成员，因为所有成员都共享同一块内存。</p><h3 id="4-2-共用体的基本语法"><a href="#4-2-共用体的基本语法" class="headerlink" title="4.2 共用体的基本语法"></a>4.2 共用体的基本语法</h3><p>共用体的定义与结构体类似，使用关键字 union。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">union Data &#123;</span><br><span class="line">   int i;</span><br><span class="line">   float f;</span><br><span class="line">   char str[20];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个名为 Data 的共用体，它有三个成员：一个 int，一个 float 和一个 char 数组。共用体 Data 的大小等于其最大成员的大小，即 char str[20] 的大小。</p><h3 id="4-3-如何使用共用体"><a href="#4-3-如何使用共用体" class="headerlink" title="4.3 如何使用共用体"></a>4.3 如何使用共用体</h3><p>共用体的使用方法和结构体相似。我们可以定义一个共用体类型的变量，然后通过 . 运算符来访问它的成员。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">union Data data;</span><br><span class="line"></span><br><span class="line">data.i = 10;</span><br><span class="line">printf( &quot;%d\n&quot;, data.i);</span><br><span class="line"></span><br><span class="line">data.f = 220.5;</span><br><span class="line">printf( &quot;%f\n&quot;, data.f);</span><br><span class="line"></span><br><span class="line">strcpy( data.str, &quot;C Programming&quot;);</span><br><span class="line">printf( &quot;%s\n&quot;, data.str);</span><br></pre></td></tr></table></figure><p>在上面的代码中，首先定义了一个 Data 类型的变量 data，然后依次将其 int 成员 i，float 成员 f 和 char 数组成员 str 赋值并打印。注意在赋值新的成员之后，之前的成员的值就不再保留了。<br>总结来说，共用体在C语言中是一个非常有用的工具，它可以帮助我们在不同情况下复用内存，但使用时需要注意其成员之间的覆盖关系。</p><h2 id="五、C语言中枚举的概念和使用-enum"><a href="#五、C语言中枚举的概念和使用-enum" class="headerlink" title="五、C语言中枚举的概念和使用(enum)"></a>五、C语言中枚举的概念和使用(enum)</h2><h3 id="5-1-枚举的概念"><a href="#5-1-枚举的概念" class="headerlink" title="5.1 枚举的概念"></a>5.1 枚举的概念</h3><p>枚举（enum）是C语言中的一种数据类型，它由程序员定义一组整数常量，并给这组常量赋予一个名字。枚举类型的变量只能被赋予枚举中的某个值，这样可以使程序更加清晰和易于理解。<br>枚举类型通常被用在需要一组固定值的场景，例如一周的七天、一个月的十二个月、棋盘的颜色（黑色和白色）、交通信号灯的颜色（红、黄、绿）等等。</p><h3 id="5-2-枚举的基本语法"><a href="#5-2-枚举的基本语法" class="headerlink" title="5.2 枚举的基本语法"></a>5.2 枚举的基本语法</h3><p>枚举的定义使用关键字 enum。例如，下面的代码定义了一个名为 Day 的枚举类型，它包含一周的七天：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span> &#123;</span></span><br><span class="line">    SUNDAY,</span><br><span class="line">    MONDAY,</span><br><span class="line">    TUESDAY,</span><br><span class="line">    WEDNESDAY,</span><br><span class="line">    THURSDAY,</span><br><span class="line">    FRIDAY,</span><br><span class="line">    SATURDAY</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，SUNDAY、MONDAY 等被称为枚举常量，它们默认对应的整数值从0开始，逐个加1。也就是说，SUNDAY 对应0，MONDAY 对应1，以此类推。你也可以显式地为它们赋予其他的整数值。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span> &#123;</span></span><br><span class="line">    SUNDAY = <span class="number">1</span>,</span><br><span class="line">    MONDAY,</span><br><span class="line">    TUESDAY,</span><br><span class="line">    WEDNESDAY,</span><br><span class="line">    THURSDAY,</span><br><span class="line">    FRIDAY,</span><br><span class="line">    SATURDAY</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，SUNDAY 被显式赋值为1，那么 MONDAY 对应的值就是2，TUESDAY 对应的值就是3，以此类推。</p><h3 id="5-3-如何使用枚举"><a href="#5-3-如何使用枚举" class="headerlink" title="5.3 如何使用枚举"></a>5.3 如何使用枚举</h3><p>定义了枚举类型后，你就可以声明该类型的变量，并将枚举常量赋给它。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span> <span class="title">day</span>;</span></span><br><span class="line">day = MONDAY;</span><br></pre></td></tr></table></figure><p>你也可以直接使用枚举常量，因为它们本质上就是整数。例如，你可以在 printf 函数中打印它们：<br><strong>printf(“%d\n”, MONDAY); &#x2F;&#x2F; 打印1</strong><br>或者在 switch 语句中使用它们：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Today is Monday.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TUESDAY:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Today is Tuesday.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 其他情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结来说，枚举是一种非常有用的工具，它可以帮助我们创建一组命名的整数常量，使程序更加清晰和易于理解。</p><h2 id="六、C语言中的类型定义和typedef"><a href="#六、C语言中的类型定义和typedef" class="headerlink" title="六、C语言中的类型定义和typedef"></a>六、C语言中的类型定义和typedef</h2><h3 id="6-1-类型定义的概念"><a href="#6-1-类型定义的概念" class="headerlink" title="6.1 类型定义的概念"></a>6.1 类型定义的概念</h3><p>在 C 语言中，typedef 是一个关键字，它用于为复杂的数据类型定义新的名称，以方便在程序中使用。这通常被用来简化复杂的类型声明，或者为某种特定的类型定义更具可读性的名称。</p><h3 id="6-2-typedef-的基本语法"><a href="#6-2-typedef-的基本语法" class="headerlink" title="6.2 typedef 的基本语法"></a>6.2 typedef 的基本语法</h3><p>作用：给变量更换名字</p><p>typedef 的基本语法是这样的：<br><strong>typedef existing_type new_type_name;</strong><br>在这个语句中，existing_type 是一个已经存在的类型，可以是内置的类型（如 int, float 等），也可以是用户定义的类型（如结构体，联合体等）。new_type_name 是你想要定义的新类型的名称。<br>例如，你可以为 unsigned int 类型定义一个新的名称 uint：<br><strong>typedef unsigned int uint;</strong><br>之后，你就可以在程序中使用 uint 来代替 unsigned int 类型：<br><strong>uint a &#x3D; 10;</strong></p><h3 id="6-3-typedef-在结构体和联合体中的使用"><a href="#6-3-typedef-在结构体和联合体中的使用" class="headerlink" title="6.3 typedef 在结构体和联合体中的使用"></a>6.3 typedef 在结构体和联合体中的使用</h3><p>typedef 在结构体和联合体中的使用非常常见。例如，你可以为结构体定义一个新的类型名称，这样在声明结构体变量时就不用再写 struct 关键字了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; Point;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在你可以直接使用 Point 来声明变量</span></span><br><span class="line">Point p1, p2;</span><br></pre></td></tr></table></figure><p>这种方式在定义复杂的类型，如指向结构体的指针或者结构体数组时，会让代码更加清晰易读。<br>总结来说，typedef 是一个非常有用的工具，它可以帮助我们简化复杂的类型声明，提高代码的可读性。</p><h1 id="第七章-文件操作和预处理器"><a href="#第七章-文件操作和预处理器" class="headerlink" title="第七章 文件操作和预处理器"></a><strong>第七章 文件操作和预处理器</strong></h1><p>@[toc]<strong>目标</strong></p><ul><li>1、C语言的文件操作</li><li>2、C语言中的文件读写函数</li><li>3、C语言中的文件定位函数</li><li>4、C语言中的文件实战</li><li>5、C语言中的预处理器指令</li><li>6、C语言中的模块化编程</li><li>7、C语言中的宏函数和内联函数</li></ul><p><img src="/././images/1695088035509-427cdd79-45a7-4cd9-a9ec-410a1da1c686.jpeg" alt="img"></p><h2 id="一、C语言的文件操作"><a href="#一、C语言的文件操作" class="headerlink" title="一、C语言的文件操作"></a>一、C语言的文件操作</h2><h3 id="1-1-文件操作的基本概念"><a href="#1-1-文件操作的基本概念" class="headerlink" title="1.1 文件操作的基本概念"></a>1.1 文件操作的基本概念</h3><p>在C语言中，文件是一种存储在存储设备上（如硬盘、光盘等）的数据集合。文件是数据的重要载体，是操作系统中对数据管理的一种抽象方式。文件不仅可以存储程序代码，还可以存储各种类型的数据，如文字、图片、音频、视频等。C语言提供了一系列的文件操作函数，可以帮助我们实现对文件的读取、写入、修改等操作。</p><h3 id="1-2-文件的打开和关闭"><a href="#1-2-文件的打开和关闭" class="headerlink" title="1.2 文件的打开和关闭"></a>1.2 文件的打开和关闭</h3><p>在C语言中，我们使用fopen函数来打开一个文件，fopen函数需要两个参数：一个是文件路径，另一个是文件模式。文件模式决定了我们可以进行哪些操作，例如，我们可以选择只读模式（”r”）、只写模式（”w”）、读写模式（”rw”）等。<br>在操作完文件后，我们需要使用fclose函数来关闭文件，以释放操作系统分配给该文件的资源。这是一个良好的编程习惯，可以防止资源泄漏，提高程序的稳定性和运行效率。</p><h3 id="1-3-文件模式"><a href="#1-3-文件模式" class="headerlink" title="1.3 文件模式"></a>1.3 文件模式</h3><p>文件模式用于决定如何操作文件。以下是C语言中常用的文件模式：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/8368890/1695052366873-08a7b38d-ee80-40ae-b43d-7c9d514b3511.png#averageHue=%23f1f1f1&clientId=u6674c2ea-3afd-4&from=paste&height=591&id=uc15feaa9&originHeight=886&originWidth=1691&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=570163&status=done&style=none&taskId=u99c57e77-6df2-4fef-ad4c-b50a6b548e9&title=&width=1127.3333333333333" alt="img"></p><ul><li>“r”：只读模式。这种模式下，程序只能读取文件，不能写入。如果文件不存在，fopen函数会返回NULL。</li><li>“w”：只写模式。这种模式下，程序只能写入文件，不能读取。如果文件不存在，fopen函数会创建一个新文件。如果文件已存在，它的内容将被清空，即被覆盖。</li><li>“a”：追加模式。这种模式下，程序只能在文件的末尾写入数据。如果文件不存在，fopen函数会创建一个新文件。</li><li><strong>“r+”：读写模式。这种模式下，程序既能读取文件，也能写入文件。文件必须存在，否则fopen函数会返回NULL。</strong></li><li><strong>“w+”：读写模式。这种模式下，程序既能读取文件，也能写入文件。如果文件不存在，fopen函数会创建一个新文件。如果文件已存在，它的内容将被清空，即被覆盖。</strong></li><li><strong>“a+”：读写模式。这种模式下，程序既能读取文件，也能在文件的末尾写入数据。如果文件不存在，fopen函数会创建一个新文件。</strong></li></ul><p>在这些模式中，我们可以添加一个”b”来打开一个二进制文件，如”rb”、”wb”、”ab”、”r+b”、”w+b”、”a+b”。在二进制模式下，文件将按照二进制形式进行读取或写入，这对于处理图像、音频、视频等非文本文件非常有用。</p><h2 id="二、C语言中的文件读写函数"><a href="#二、C语言中的文件读写函数" class="headerlink" title="二、C语言中的文件读写函数"></a>二、C语言中的文件读写函数</h2><h3 id="2-1-读写函数的基本概念"><a href="#2-1-读写函数的基本概念" class="headerlink" title="2.1 读写函数的基本概念"></a>2.1 读写函数的基本概念</h3><p>在C语言中，我们可以使用特定的函数来从文件中读取数据或者向文件中写入数据。这些函数主要分为三类：</p><ol><li><strong>字符读写函数</strong>：这类函数用于读取或写入单个字符，例如 fgetc 和 fputc。</li><li><strong>行读写函数</strong>：这类函数用于读取或写入一行字符串，例如 fgets 和 fputs。</li><li><strong>格式化读写函数</strong>：这类函数用于读取或写入特定格式的数据，例如 fscanf 和 fprintf。</li></ol><p>所有这些函数都需要一个文件指针作为参数，这个文件指针指向要读取或写入的文件。接下来，我们将详细介绍这些函数的使用方法。</p><h4 id="2-2-使用-fgetc-和-fputc-进行字符读写"><a href="#2-2-使用-fgetc-和-fputc-进行字符读写" class="headerlink" title="2.2 使用 fgetc 和 fputc 进行字符读写"></a>2.2 使用 fgetc 和 fputc 进行字符读写</h4><p>fgetc 和 fputc 是C语言中最基本的文件读写函数，它们分别用于从文件中读取单个字符和向文件中写入单个字符。</p><h5 id="fgetc-函数"><a href="#fgetc-函数" class="headerlink" title="fgetc 函数"></a>fgetc 函数</h5><ul><li><strong>头文件</strong>：stdio.h</li><li><strong>函数原型</strong>：int fgetc(FILE *stream);</li><li><strong>函数功能</strong>：从参数stream所指的文件中读取一个字符。</li><li><strong>返回值</strong>：读取成功返回字符的ASCII值，读到文件结束或发生错误返回EOF。</li></ul><h5 id="fputc-函数"><a href="#fputc-函数" class="headerlink" title="fputc 函数"></a>fputc 函数</h5><ul><li><strong>头文件</strong>：stdio.h</li><li><strong>函数原型</strong>：int fputc(int c, FILE *stream);</li><li><strong>函数功能</strong>：将参数c指定的字符写入参数stream所指的文件中。</li><li><strong>返回值</strong>：写入成功返回写入的字符，发生错误返回EOF。</li></ul><h5 id="示例程序："><a href="#示例程序：" class="headerlink" title="示例程序："></a>示例程序：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     FILE *fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);  <span class="comment">//读写模式</span></span><br><span class="line">     <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Open file failed!\n&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用fputc向文件中写入字符</span></span><br><span class="line">     <span class="type">char</span> c;</span><br><span class="line">     <span class="keyword">for</span> (c = <span class="string">&#x27;A&#x27;</span>; c &lt;= <span class="string">&#x27;Z&#x27;</span>; c++) &#123;</span><br><span class="line">         fputc(c, fp);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 将文件指针重新定位到文件开头</span></span><br><span class="line">     rewind(fp);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用fgetc从文件中读取字符</span></span><br><span class="line">     <span class="keyword">while</span> ((c = fgetc(fp)) != EOF) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, c);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 关闭文件</span></span><br><span class="line">     fclose(fp);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>此程序首先向文件test.txt中写入了从’A’到’Z’的所有大写字母，然后将文件指针重新定位到文件开头，接着用fgetc从文件中读取并打印出所有字符。</p><ol><li><p>编写一个程序，使用fgetc和fputc复制一个文件的内容到另一个文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *sourceFile, *destinationFile;  <span class="comment">// 定义两个文件指针</span></span><br><span class="line">    <span class="type">char</span> ch;                            <span class="comment">// 用于存储读取的字符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开源文件，以只读模式（&quot;r&quot;）</span></span><br><span class="line">    sourceFile = fopen(<span class="string">&quot;source.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sourceFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开源文件。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 文件打开失败，退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建或打开目标文件，以写入模式（&quot;w&quot;）</span></span><br><span class="line">    destinationFile = fopen(<span class="string">&quot;destination.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (destinationFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法创建或打开目标文件。\n&quot;</span>);</span><br><span class="line">        fclose(sourceFile);  <span class="comment">// 关闭源文件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 文件打开失败，退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐个字符读取并写入</span></span><br><span class="line">    <span class="keyword">while</span> ((ch = fgetc(sourceFile)) != EOF) &#123;  <span class="comment">// EOF是文件结束标志</span></span><br><span class="line">        fputc(ch, destinationFile);  <span class="comment">// 将读取的字符写入目标文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(sourceFile);</span><br><span class="line">    fclose(destinationFile);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件复制完成。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写一个程序，使用fgetc读取一个文本文件，并统计其中的字符数量。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3-使用-fgets-和-fputs-进行行读写"><a href="#2-3-使用-fgets-和-fputs-进行行读写" class="headerlink" title="2.3 使用 fgets 和 fputs 进行行读写"></a>2.3 使用 fgets 和 fputs 进行行读写</h3><p>fgets 和 fputs 是C语言中用于处理字符串的文件读写函数，它们分别用于从文件中读取一行字符串和向文件中写入一行字符串。</p><h5 id="fgets-函数"><a href="#fgets-函数" class="headerlink" title="fgets 函数"></a>fgets 函数</h5><ul><li><strong>头文件</strong>：stdio.h</li><li><strong>函数原型</strong>：char <em>fgets(char</em> str, int n, FILE *stream);</li><li><strong>函数功能</strong>：从参数stream所指的文件中读取一行字符串（包括’\n’）到str所指的字符数组，最多读取n-1个字符（最后一个字符会被自动赋值为’\0’）。</li></ul><h5 id="fgets-函数参数解释"><a href="#fgets-函数参数解释" class="headerlink" title="fgets 函数参数解释"></a>fgets 函数参数解释</h5><ul><li><strong>str</strong>：这是指向一个字符数组的指针，该数组将存储从文件中读取的字符串。</li><li><strong>n</strong>：这是要读取的最大字符数，包括空字符’\0’。换句话说，str指向的字符数组的大小应至少为n。</li><li><strong>stream</strong>：这是一个指向FILE类型的指针，它指定了要从中读取字符的文件。</li><li><strong>返回值</strong>：读取成功返回str，读到文件结束或发生错误返回NULL。</li></ul><h5 id="fputs-函数"><a href="#fputs-函数" class="headerlink" title="fputs 函数"></a>fputs 函数</h5><ul><li><strong>头文件</strong>：stdio.h</li><li><strong>函数原型</strong>：int fputs(const char <em>str, FILE</em> stream);</li><li><strong>函数功能</strong>：将参数str所指的字符串写入参数stream所指的文件中。</li></ul><h5 id="fputs-函数参数解释"><a href="#fputs-函数参数解释" class="headerlink" title="fputs 函数参数解释"></a>fputs 函数参数解释</h5><ul><li><strong>str</strong>：这是一个指针，指向要写入文件的字符串。字符串应以空字符’\0’结尾。</li><li><strong>stream</strong>：这是一个指向FILE类型的指针，它指定了要写入字符串的文件。</li><li><strong>返回值</strong>：写入成功返回非负值，发生错误返回EOF。</li></ul><h5 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     FILE *fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;文件打开失败\n&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用fputs向文件中写入字符串</span></span><br><span class="line">     <span class="type">char</span> str[] = <span class="string">&quot;Hello, World!\n&quot;</span>;</span><br><span class="line">     <span class="built_in">fputs</span>(str, fp);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 将文件指针重新定位到文件开头</span></span><br><span class="line">     rewind(fp);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用fgets从文件中读取字符串</span></span><br><span class="line">     <span class="type">char</span> buffer[<span class="number">50</span>];</span><br><span class="line">     <span class="keyword">while</span> (fgets(buffer, <span class="number">50</span>, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 关闭文件</span></span><br><span class="line">     fclose(fp);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-使用-fscanf-和-fprintf-进行格式化读写"><a href="#2-4-使用-fscanf-和-fprintf-进行格式化读写" class="headerlink" title="2.4 使用 fscanf 和 fprintf 进行格式化读写"></a>2.4 使用 fscanf 和 fprintf 进行格式化读写</h4><p>fscanf 和 fprintf 是C语言中用于格式化文件读写的函数，它们可以分别从文件中读取和向文件中写入各种类型的数据，包括字符、数字和字符串。</p><h5 id="fscanf-函数"><a href="#fscanf-函数" class="headerlink" title="fscanf 函数"></a>fscanf 函数</h5><ul><li><p><strong>头文件</strong>：stdio.h</p></li><li><p><strong>函数原型</strong>：int fscanf(FILE <em>stream, const char</em> format, …);</p></li><li><p><strong>函数功能</strong>：从参数stream所指的文件中按照参数format所指定的格式读取数据。</p></li><li><p>参数解析： </p></li><li><p><strong>stream</strong>：这是一个指向FILE类型的指针，它指定了要从中读取数据的文件。</p></li><li><p><strong>format</strong>：这是一个格式字符串，它包含一个或多个用于指定要读取的数据类型的格式说明符。</p></li><li><p>**…**：这是变长参数列表，每一个参数都应该是一个指向变量的指针，这些变量将被用于存储从文件中读取的数据。</p></li><li><p><strong>返回值</strong>：成功读取的项数，或者在读取失败或读到文件末尾时返回EOF。</p></li></ul><h5 id="fprintf-函数"><a href="#fprintf-函数" class="headerlink" title="fprintf 函数"></a>fprintf 函数</h5><ul><li><p><strong>头文件</strong>：stdio.h</p></li><li><p><strong>函数原型</strong>：int fprintf(FILE <em>stream, const char</em> format, …);</p></li><li><p><strong>函数功能</strong>：将参数format所指定的格式的数据写入参数stream所指的文件。</p></li><li><p>参数解析： </p></li><li><p><strong>stream</strong>：这是一个指向FILE类型的指针，它指定了要写入数据的文件。</p></li><li><p><strong>format</strong>：这是一个格式字符串，它包含一个或多个用于指定要写入的数据类型的格式说明符。</p></li><li><p>**…**：这是变长参数列表，每一个参数都应该是一个变量，这些变量的值将被写入文件。</p></li><li><p><strong>返回值</strong>：成功写入的项数，或者在写入失败时返回负值。</p></li></ul><h5 id="示例程序-1"><a href="#示例程序-1" class="headerlink" title="示例程序"></a>示例程序</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">     FILE * fp = fopen(<span class="string">&quot;hello.txt&quot;</span> , <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;文件打开失败!!!&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用fprintf向文件写入数据</span></span><br><span class="line">     <span class="type">int</span> age = <span class="number">30</span>;</span><br><span class="line">     <span class="type">float</span> height = <span class="number">180.5</span>;</span><br><span class="line">     <span class="built_in">fprintf</span>(fp , <span class="string">&quot;年龄 :%d\n身高 :%.2f\n&quot;</span>, age , height);    <span class="comment">//格式化输入字符到文件中</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//将文件重新定义到文件开头</span></span><br><span class="line">     rewind(fp);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用fscanf 从文件中读取格式化的数据</span></span><br><span class="line">     <span class="type">int</span> read_age = <span class="number">0</span>;</span><br><span class="line">     <span class="type">float</span> read_height = <span class="number">0</span>;</span><br><span class="line">     <span class="built_in">fscanf</span>(fp , <span class="string">&quot;年龄 :%d\n身高 :%f\n&quot;</span>, &amp;read_age , &amp;read_height);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;年龄 :%d\n身高 :%.2f\n&quot;</span>, read_age , read_height);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     fclose(fp);  <span class="comment">//关闭文件</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>*<strong>fprintf和fscanf格式和文件内部格式一定要相同，不要自己写，ctrl c v*</strong></p><h2 id="三、C语言中的文件定位函数"><a href="#三、C语言中的文件定位函数" class="headerlink" title="三、C语言中的文件定位函数"></a>三、C语言中的文件定位函数</h2><h3 id="3-1-文件定位函数的基本概念"><a href="#3-1-文件定位函数的基本概念" class="headerlink" title="3.1 文件定位函数的基本概念"></a>3.1 文件定位函数的基本概念</h3><p>文件定位函数用于操作文件指针，改变文件指针的当前位置。它们使得我们可以在文件中随机地访问数据，而不仅仅是按顺序读取或写入数据。这在处理大文件或需要随机访问的应用中尤其有用。<br>C语言中的文件定位函数主要包括以下几种：</p><ol><li>fseek 函数：移动文件指针到指定位置</li><li>ftell 函数：获取当前文件指针的位置</li><li>rewind 函数：将文件指针重置到文件的开头</li></ol><p>文件指针是一个指示当前正在读取或写入的文件位置的指针。每个文件在被打开时都会有一个文件指针与之关联，这个指针最初总是指向文件的开头。当我们读取或写入数据时，文件指针会随之移动，以指示下一个将要操作的位置。</p><h3 id="3-2-使用-fseek-进行文件定位"><a href="#3-2-使用-fseek-进行文件定位" class="headerlink" title="3.2 使用 fseek 进行文件定位"></a>3.2 使用 fseek 进行文件定位</h3><ul><li><p><strong>头文件</strong>：#include &lt;stdio.h&gt;</p></li><li><p><strong>函数原型</strong>：int fseek(FILE *stream, long offset, int whence);</p></li><li><p><strong>函数名称</strong>：fseek</p></li><li><p><strong>函数参数</strong>： </p></li><li><p>FILE *stream: 需要进行定位的文件指针。</p></li><li><p>long offset: 需要移动的字节数，从 whence 指定的位置算起。</p></li><li><p>int whence: 偏移的起始位置，可以有三个值： </p></li><li><p><strong>SEEK_SET: 文件开头</strong></p></li><li><p><strong>SEEK_CUR: 当前位置</strong></p></li><li><p><strong>SEEK_END: 文件结尾</strong></p></li><li><p><strong>函数返回值</strong>：如果成功，返回0。如果发生错误，返回非0值。</p></li><li><p><strong>示例程序</strong>：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     FILE *fp;</span><br><span class="line"></span><br><span class="line">     fp = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">     <span class="built_in">fputs</span>(<span class="string">&quot;This is a test&quot;</span>, fp);</span><br><span class="line"></span><br><span class="line">     fseek(fp, <span class="number">7</span>, SEEK_SET);</span><br><span class="line">     <span class="built_in">fputs</span>(<span class="string">&quot; Hello World!&quot;</span>, fp);</span><br><span class="line">     fclose(fp);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>以上程序会创建一个新文件 file.txt，并在其中写入 “This is a test”。然后，程序将文件指针移动到文件的第7个字节（即 ‘a’ 后面的空格），并接着写入 “ Hello World!”。所以，最后的文件内容将是 “This is Hello World!”。</p><ul><li><p>练习： </p></li><li><p>创建一个文件，并写入一些文本。</p></li><li><p>使用 fseek 函数将文件指针移动到文件中的某个位置。</p></li><li><p>在该位置写入一些文本。</p></li><li><p>关闭文件，并查看最后的文件内容。</p></li></ul><h3 id="3-3-使用-ftell-获取当前位置"><a href="#3-3-使用-ftell-获取当前位置" class="headerlink" title="3.3 使用 ftell 获取当前位置"></a>3.3 使用 ftell 获取当前位置</h3><p>ftell 是一个标准库函数，它返回参数指定的文件流的当前文件位置指示器的位置。该函数是非常有用的，尤其是当你需要在文件中进行随机访问时。<br><strong>头文件</strong>：需要包含头文件 #include &lt;stdio.h&gt;<br><strong>函数原型</strong>：long ftell(FILE *stream);<br><strong>函数名</strong>：ftell<br><strong>函数参数</strong>：FILE *stream，指向FILE对象的指针，该FILE对象指定了一个输入流。<br><strong>函数返回值</strong>：如果成功，该函数返回当前文件位置指示器的位置，否则返回-1并设置全局变量 errno。<br><strong>示例程序</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     FILE *fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Open file failed!\n&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 移动文件位置指示器到文件中间</span></span><br><span class="line">     fseek(fp, <span class="number">5</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取当前文件位置</span></span><br><span class="line">     <span class="type">long</span> pos = ftell(fp);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Current file position: %ld\n&quot;</span>, pos);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 关闭文件</span></span><br><span class="line">     fclose(fp);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先打开一个文件，并使用 fseek 函数将文件位置指示器移到文件的中间。然后，我们使用 ftell 函数获取当前的文件位置，并打印出来。最后，我们关闭文件。<br><strong>练习</strong>：尝试修改示例程序，让文件位置指示器移动到文件的不同位置，然后使用 ftell 函数获取并打印当前的文件位置。</p><h3 id="3-4-使用-回到文件首部"><a href="#3-4-使用-回到文件首部" class="headerlink" title="3.4 使用 回到文件首部"></a>3.4 使用 回到文件首部</h3><p>rewind 是一个标准库函数，它将文件位置指示器移回参数指定的文件流的开始位置，同时清除和流有关的错误和结束文件状态。<br><strong>头文件</strong>：需要包含头文件 #include &lt;stdio.h&gt;<br><strong>函数原型</strong>：void rewind(FILE *stream);<br><strong>函数名</strong>：rewind<br><strong>函数参数</strong>：FILE *stream，指向FILE对象的指针，该FILE对象指定了一个输入流。<br><strong>函数返回值</strong>：无。<br><strong>示例程序</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     FILE *fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Open file failed!\n&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 写入一些数据到文件</span></span><br><span class="line">     <span class="built_in">fputs</span>(<span class="string">&quot;Hello, world!&quot;</span>, fp);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用rewind将文件位置指示器重置到文件开始</span></span><br><span class="line">     rewind(fp);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 读取并打印文件中的数据</span></span><br><span class="line">     <span class="type">char</span> buffer[<span class="number">50</span>];</span><br><span class="line">     fgets(buffer, <span class="number">50</span>, fp);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 关闭文件</span></span><br><span class="line">     fclose(fp);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先打开一个文件并写入一些数据。然后我们使用 rewind 函数将文件位置指示器重置到文件的开始。接着，我们读取并打印出文件中的数据。最后，我们关闭文件。<br><strong>练习</strong>：尝试修改示例程序，使用 fseek 函数将文件位置指示器移动到文件的不同位置，然后使用 rewind 函数重置文件位置指示器，并使用 fgets 函数读取并打印出文件中的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Open file failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入一些数据到文件</span></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;Hello, world!\nThis is a test file.\n&quot;</span>, fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用rewind将文件位置指示器重置到文件开始</span></span><br><span class="line">    rewind(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取并打印文件中的数据</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">50</span>];</span><br><span class="line">    fgets(buffer, <span class="number">50</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First read: %s&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用fseek将文件位置指示器移动到文件的特定位置</span></span><br><span class="line">    <span class="comment">// 移动到文件开头后50个字节的位置</span></span><br><span class="line">    fseek(fp, <span class="number">50</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次读取并打印文件中的数据</span></span><br><span class="line">    fgets(buffer, <span class="number">50</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nSecond read: %s&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、C语言中的文件实战"><a href="#四、C语言中的文件实战" class="headerlink" title="四、C语言中的文件实战"></a>四、C语言中的文件实战</h2><h3 id="4-1-实战项目介绍"><a href="#4-1-实战项目介绍" class="headerlink" title="4.1 实战项目介绍"></a>4.1 实战项目介绍</h3><h3 id="4-2-代码实现"><a href="#4-2-代码实现" class="headerlink" title="4.2 代码实现"></a>4.2 代码实现</h3><h3 id="4-3-代码测试和问题解决"><a href="#4-3-代码测试和问题解决" class="headerlink" title="4.3 代码测试和问题解决"></a>4.3 代码测试和问题解决</h3><h2 id="五、C语言中的预处理器指令"><a href="#五、C语言中的预处理器指令" class="headerlink" title="五、C语言中的预处理器指令"></a>五、C语言中的预处理器指令</h2><p>C 语言的预处理器指令是在编译器开始编译程序代码之前由预处理器执行的一些指令。以下是一些常见的预处理器指令：</p><ol><li>#include - 用于包含头文件。例如： #include &lt;stdio.h&gt;</li></ol><p><strong>include</strong><br>include &lt;&gt; : 调用系统库内的.h文件<br>include “” : 调用本地文件的.h文件， 如果没有则查找系统库内的文件</p><ol><li>#define - 用于定义宏。例如： #define PI 3.14159</li></ol><p>define 宏定义 ： 无脑替换<br>定义常量<br>定义函数</p><ol><li>#undef - 用于取消已定义的宏。例如： #undef PI</li><li>#if, #elif, #else, #endif - 用于条件编译。例如：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(WIN32)</span></span><br><span class="line"><span class="comment">// Windows 平台的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(LINUX)</span></span><br><span class="line"><span class="comment">// Linux 平台的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// 其他平台的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ol><li>#ifdef 和 #ifndef - 用于检查宏是否已定义或未定义。例如：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="comment">// 调试模式下的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>注意，预处理器指令不是C语言的一部分，它们是由C预处理器处理的，而不是C编译器。预处理器指令通常不遵循C语言的语法规则，而是遵循自己的规则集。</p><h2 id="六、C语言中的模块化编程"><a href="#六、C语言中的模块化编程" class="headerlink" title="六、C语言中的模块化编程"></a>六、C语言中的模块化编程</h2><h2 id="七、C语言中的宏函数和内联函数"><a href="#七、C语言中的宏函数和内联函数" class="headerlink" title="七、C语言中的宏函数和内联函数"></a>七、C语言中的宏函数和内联函数</h2><p>在C语言中，宏是由预处理器（preprocessor）处理的一种机制，可以用来为代码创建别名或者执行简单的代码生成任务。宏可以分为对象宏和函数宏两种。</p><h3 id="1-对象宏（Object-Macros）"><a href="#1-对象宏（Object-Macros）" class="headerlink" title="1. 对象宏（Object Macros）"></a>1. 对象宏（Object Macros）</h3><p>对象宏用于为某个值或表达式定义一个名字。它们通常是这样定义的：<br>#define PI 3.14159<br>在这里，PI 是一个宏，它被定义为3.14159。</p><h3 id="2-函数宏（Function-Macros）"><a href="#2-函数宏（Function-Macros）" class="headerlink" title="2. 函数宏（Function Macros）"></a>2. 函数宏（Function Macros）</h3><p>函数宏类似于函数，但它们是在预处理阶段展开的，而不是在运行时被调用。函数宏是这样定义的：<br>#define SQUARE(x) ((x) * (x))<br>在这里，SQUARE是一个宏，它接受一个参数x，并返回x的平方。注意，参数被括在括号里，以避免由于运算符优先级引起的问题。</p><h3 id="3-宏函数的使用注意事项："><a href="#3-宏函数的使用注意事项：" class="headerlink" title="3. 宏函数的使用注意事项："></a>3. 宏函数的使用注意事项：</h3><ol><li><strong>括号的使用</strong>：为了避免优先级的问题，参数和整个宏都应该用括号括起来。</li><li><strong>副作用</strong>：由于宏是在预处理阶段展开的，所以如果宏的参数有副作用（例如，它是一个具有副作用的表达式），那么这个副作用可能会发生多次。</li><li><strong>代码膨胀</strong>：使用宏可以导致代码膨胀，因为宏每次被调用时都会被其定义所替换。</li><li><strong>调试困难</strong>：使用宏可以使代码更难调试，因为编译器在编译代码之前会先展开宏，这使得源代码和编译器看到的代码之间存在差异。</li></ol><h3 id="4-一个例子："><a href="#4-一个例子：" class="headerlink" title="4. 一个例子："></a>4. 一个例子：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">double</span> radius = <span class="number">2.0</span>;</span><br><span class="line">     <span class="type">double</span> area = PI * SQUARE(radius);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Area: %f\n&quot;</span>, area);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了两个宏：PI 和 SQUARE，并使用它们来计算一个圆的面积。</p><p>内联函数是一种特殊类型的函数，它的目的是为了减少函数调用的开销。当你将一个函数声明为内联时，编译器会尝试将该函数的代码嵌入到每一个调用点，就像宏一样。但是与宏不同，内联函数仍然是一个真正的函数，这意味着它遵循常规的类型检查和作用域规则。</p><h3 id="声明内联函数"><a href="#声明内联函数" class="headerlink" title="声明内联函数"></a>声明内联函数</h3><p>要声明一个内联函数，你可以使用 inline 关键字，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特点和注意事项"><a href="#特点和注意事项" class="headerlink" title="特点和注意事项"></a>特点和注意事项</h3><ol><li><strong>类型检查</strong>：内联函数与普通函数一样，进行类型检查，而宏不进行类型检查。</li><li><strong>编译器决定</strong>：即使你将一个函数声明为内联，编译器也可能决定不内联它，特别是如果函数体很大或者很复杂。</li><li><strong>代码膨胀</strong>：与宏一样，内联函数也可能导致代码膨胀，因为它们的代码可以被插入到多个调用点。</li><li><strong>调用开销减少</strong>：通过内联一个函数，你可以减少函数调用的开销，这可能会使你的程序运行得更快，但是这也可能增加你的程序的大小。</li><li><strong>多重定义</strong>：在多个源文件中包含相同的内联函数定义是允许的，但所有的定义必须是完全相同的。</li></ol><h3 id="内联函数的例子："><a href="#内联函数的例子：" class="headerlink" title="内联函数的例子："></a>内联函数的例子：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> x * x;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Square of %d is %d\n&quot;</span>, a, square(a));</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个内联函数 square，用于计算一个数的平方，并在 main 函数中调用它。注意，我们使用 inline 关键字来指示编译器我们想要将这个函数作为内联函数。</p><h1 id="第八章-高级C语言特性"><a href="#第八章-高级C语言特性" class="headerlink" title="第八章 高级C语言特性"></a><strong>第八章 高级C语言特性</strong></h1><p>@[toc]<strong>目标</strong></p><ul><li>1、C语言中的动态内存分配</li><li>2、C语言中的可变参数函数</li><li>3、C语言中的递归函数</li></ul><h2 id="一、C语言中的动态内存分配"><a href="#一、C语言中的动态内存分配" class="headerlink" title="一、C语言中的动态内存分配"></a>一、C语言中的动态内存分配</h2><h3 id="1-内存管理"><a href="#1-内存管理" class="headerlink" title="1. 内存管理"></a>1. 内存管理</h3><p>内存的使用是程序设计中需要考虑的重要因素，尤其是在嵌入式系统中，对于内存资源是有限的。<br>在C语言中，内存通常分为以下几个区域：</p><ul><li><p><strong>代码区（Text Segment）</strong>：该区域存放程序的代码（可执行指令），它是只读的，以防止程序在运行时自我修改。</p></li><li><p><strong>数据区</strong>：又可以细分为以下几部分： </p></li><li><p><strong>全局变量与静态变量区</strong>：此区域用于存放全局变量和静态变量。这些变量的内存是在程序启动时分配的，并在程序结束时释放。</p></li><li><p><strong>常量区</strong>：存放如字符串常量的区域。</p></li><li><p><strong>堆区（Heap）</strong>：堆是用于动态内存分配的区域，使用malloc，calloc或realloc函数分配内存，并使用free函数释放内存。动态内存分配提供了灵活性，但也增加了内存泄漏和其他问题的可能性。</p></li><li><p><strong>栈区（Stack）</strong>：栈用于存放局部变量和函数调用的信息。它是系统自管理的，每当进入一个函数时，就会为该函数分配一块新的栈空间，函数返回时，该块栈空间被释放。虽然栈的使用很高效，但空间有限 ，在Linux中只有8m 8192。</p></li></ul><p><img src="/././images/1695190187057-9ac6f647-031b-4c12-98ce-852571ada6cf.jpeg" alt="img"><br><strong>示例与解释</strong><br>例如，当我们定义如下结构体时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果学生的姓名超过我们所定义的空间，可能会发生内存溢出的问题。因此，在这种情况下使用动态内存分配更合理，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以动态分配内存来存储姓名，这样可以避免内存溢出的问题。在分配内存时，我们可以根据实际需要来分配内存空间，而不是预先分配固定大小的空间。<br>下面这段程序示例了不同类型的内存分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//  申请空间</span></span><br><span class="line"><span class="comment">//  void * 类型   泛指针   -&gt;  可以转换成其他类型的</span></span><br><span class="line"><span class="comment">// extern void *malloc (size_t __size)</span></span><br><span class="line"><span class="comment">//  size_t __size   要申请空间的大小</span></span><br><span class="line"><span class="comment">//  malloc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放空间</span></span><br><span class="line"><span class="comment">//  extern void free (void *__ptr) </span></span><br><span class="line"><span class="comment">//  free(__ptr)</span></span><br><span class="line"><span class="comment">//  __ptr   要释放的空间</span></span><br><span class="line"><span class="comment">// 强制类型转换 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zzh</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> * name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;zzh;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//申请空间</span></span><br><span class="line">    zzh * zzh1 = (zzh *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(zzh));</span><br><span class="line">    <span class="comment">//  zzh * zzh1   创建结构体指针</span></span><br><span class="line">    <span class="comment">//  (zzh *)malloc(sizeof(zzh));</span></span><br><span class="line">    <span class="comment">//      (zzh *)         类型转换</span></span><br><span class="line">    <span class="comment">//      malloc          申请空间的函数</span></span><br><span class="line">    <span class="comment">//      sizeof(zzh)     申请空间的大小</span></span><br><span class="line">    <span class="comment">//判断空间创建是否成功</span></span><br><span class="line">    <span class="comment">//      指针指向问题  :  指针只能指向同类型的变量地址</span></span><br><span class="line">    <span class="keyword">if</span> (zzh1 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zzh1-&gt;id = <span class="number">666</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , zzh1-&gt;id);</span><br><span class="line">    zzh1-&gt;name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span> , zzh1-&gt;name);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放空间</span></span><br><span class="line">    <span class="built_in">free</span>(zzh1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个名为stu的结构体，包含一个字符指针和一个整数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> *name;</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配内存以存储一个stu结构体实例</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">s</span> =</span> (<span class="keyword">struct</span> stu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> stu));</span><br><span class="line">    <span class="comment">// 检查内存分配是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为结构体中的name字段动态分配内存，可以容纳50个字符</span></span><br><span class="line">    s-&gt;name = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">50</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="comment">// 检查内存分配是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;name == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(s); <span class="comment">// 在退出前释放之前分配的内存</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置结构体中的id和name字段</span></span><br><span class="line">    s-&gt;id = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">snprintf</span>(s-&gt;name, <span class="number">50</span>, <span class="string">&quot;Student Name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印结构体中的id和name字段</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ID: %d, Name: %s\n&quot;</span>, s-&gt;id, s-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="built_in">free</span>(s-&gt;name);</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 程序成功结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此程序中，我们创建了一个stu结构体并动态分配了内存来存储结构体及其name字段。在程序结束时，我们释放了分配的内存，避免了内存泄漏。</p><h3 id="2、动态内存的申请和释放"><a href="#2、动态内存的申请和释放" class="headerlink" title="2、动态内存的申请和释放"></a>2、动态内存的申请和释放</h3><p>malloc 和 free 是 C 语言中用于动态内存分配和释放的两个主要函数。下面我们将详细介绍这两个函数的用法和一些相关注意事项：</p><h4 id="1-malloc"><a href="#1-malloc" class="headerlink" title="1. malloc"></a>1. malloc</h4><p><strong>功能</strong>：malloc ，用于在堆上分配一块指定大小的内存。<br><strong>原型</strong>：<br>void* malloc(size_t size);<br><strong>参数</strong>：</p><ul><li>size：要分配的内存大小，以字节为单位。</li></ul><p><strong>返回值</strong>：</p><ul><li>如果分配成功，则返回指向分配的内存块的指针。</li><li>如果分配失败，则返回 NULL。</li></ul><p><strong>例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配一块足够存放一个整数的内存</span></span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed\n&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">*ptr = <span class="number">42</span>; <span class="comment">// 初始化分配的内存</span></span><br></pre></td></tr></table></figure><h4 id="2-free"><a href="#2-free" class="headerlink" title="2. free"></a>2. free</h4><p><strong>功能</strong>：释放由 malloc（或 calloc, realloc）分配的内存块。<br><strong>原型</strong>：<br>void free(void* ptr);<br><strong>参数</strong>：</p><ul><li>ptr：指向要释放的内存块的指针。</li></ul><p><strong>返回值</strong>：无<br><strong>例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed\n&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">*ptr = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(ptr); <span class="comment">// 释放分配的内存</span></span><br><span class="line">ptr = <span class="literal">NULL</span>; <span class="comment">// 为了避免悬挂指针，将 ptr 设置为 NULL</span></span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li><strong>内存泄漏</strong>：如果你分配了内存但未释放它，就会发生内存泄漏。为了避免内存泄漏，你应该确保每次调用 malloc 后，最终都调用 free 来释放内存。</li><li><strong>悬挂指针</strong>：在释放内存后，应将指针设置为 NULL 以避免产生悬挂指针（指针仍然指向已释放的内存区域）。</li><li><strong>双重释放</strong>：避免对同一内存块进行多次释放，因为这将导致未定义的行为。</li><li><strong>内存初始化</strong>：malloc 分配的内存块不会被初始化，它可能包含垃圾数据。在使用前，你应该自己初始化这块内存。</li></ol><p>通过适当使用 malloc 和 free，你可以更灵活地管理程序中的内存，但也要注意避免相关的内存管理问题。</p><h3 id="3、堆和栈的区别"><a href="#3、堆和栈的区别" class="headerlink" title="3、堆和栈的区别"></a>3、堆和栈的区别</h3><p>堆（Heap）和栈（Stack）是两种不同的内存分配机制，它们在程序中扮演不同的角色。以下是它们之间的一些主要区别：<br><strong>堆 ：</strong> 程序员手动申请 ， 手动释放<br><strong>栈 ：</strong> 系统自动申请，自动释放 (局部变量）</p><h4 id="1-内存管理-1"><a href="#1-内存管理-1" class="headerlink" title="1. 内存管理"></a>1. <strong>内存管理</strong></h4><ul><li><p><strong>堆（Heap）</strong></p></li><li><p>堆是一个由操作系统管理的内存区域，主要用于<strong>动态内存分配</strong>。在C语言中，你可以使用malloc(), calloc(), realloc()等函数来在堆上分配内存，<strong>并使用free()来释放内存。</strong></p></li><li><p>堆内存的分配和释放由程序员控制，容易产生内存泄漏（memory leaks）和悬挂指针（dangling pointers）等问题，如果不妥善管理。</p></li><li><p><strong>栈（Stack）</strong></p></li><li><p>栈是一个由编译器自动管理的内存区域，用于存储局部变量、函数参数和返回地址等。</p></li><li><p>栈内存的分配和释放是自动的，由编译器在函数调用和返回时进行。</p></li></ul><h4 id="2-内存分配速度"><a href="#2-内存分配速度" class="headerlink" title="2. 内存分配速度"></a>2. <strong>内存分配速度</strong></h4><ul><li><p><strong>堆（Heap）</strong></p></li><li><p>动态内存分配和释放通常比栈上的分配和释放要慢，因为它涉及到更复杂的内存管理算法和可能的系统调用。</p></li><li><p><strong>栈（Stack）</strong></p></li><li><p>栈上的内存分配和释放速度非常快，因为它仅涉及到栈指针的移动。</p></li></ul><h4 id="3-内存大小"><a href="#3-内存大小" class="headerlink" title="3. 内存大小"></a>3. <strong>内存大小</strong></h4><ul><li><p><strong>堆（Heap）</strong></p></li><li><p>堆通常有很大的空间，可以用于存储大量数据。</p></li><li><p>在堆上分配大量内存可能会导致内存碎片化（memory fragmentation）。</p></li><li><p><strong>栈（Stack）</strong></p></li><li><p>栈的大小通常比堆小，因此适合存储小量的数据。</p></li><li><p>超出栈的大小限制（例如递归调用深度太深）可能会导致栈溢出（stack overflow）。</p></li></ul><h4 id="4-生命周期"><a href="#4-生命周期" class="headerlink" title="4. 生命周期"></a>4. <strong>生命周期</strong></h4><ul><li><p><strong>堆（Heap）</strong></p></li><li><p>分配在堆上的内存的生命周期由程序员控制，可以跨越多个函数调用。</p></li><li><p><strong>栈（Stack）</strong></p></li><li><p>栈上的内存有限制的生命周期，通常与它们所在的函数调用的生命周期相同。</p></li></ul><h4 id="5-可见性"><a href="#5-可见性" class="headerlink" title="5. 可见性"></a>5. <strong>可见性</strong></h4><ul><li><p><strong>堆（Heap）</strong></p></li><li><p>堆上分配的内存可以被程序中的任何函数访问，只要你有指向该内存的有效指针。</p></li><li><p><strong>栈（Stack）</strong></p></li><li><p>栈上的内存（如局部变量）仅在其声明的函数内部可见。</p></li></ul><p>希望这有助于你理解堆和栈的区别！如果你有任何其他问题或需要更多的解释，请随时问。</p><h2 id="二、C语言中的可变参数函数"><a href="#二、C语言中的可变参数函数" class="headerlink" title="二、C语言中的可变参数函数"></a>二、C语言中的可变参数函数</h2><p>在C语言中，可变参数函数是一种可以接受可变数量的参数的函数。要创建可变参数函数，您需要包含头文件 &lt;stdarg.h&gt;，然后使用一组宏来访问这些参数。下面是一个简单的步骤和示例说明如何创建和使用可变参数函数：</p><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol><li><strong>包含头文件</strong>：&lt;stdarg.h&gt;是包含可变参数宏的头文件，您需要在程序中包含它。 #include &lt;stdarg.h&gt;</li><li><strong>定义函数</strong>：在函数定义中，至少应有一个已命名的参数，后跟省略号（…），表示函数可以接收可变数量的参数。 void my_function(int num, …);</li><li><strong>声明va_list</strong>：在函数内部，使用va_list类型的变量来存储可变参数的列表。</li><li><strong>初始化va_list</strong>：使用va_start宏初始化va_list变量。</li><li><strong>访问可变参数</strong>：使用va_arg宏来访问可变参数列表中的每个参数。</li><li><strong>清理va_list</strong>：使用va_end宏来清理va_list变量。</li></ol><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_function</span><span class="params">(<span class="type">int</span> num, ...)</span> &#123;</span><br><span class="line">     va_list args;</span><br><span class="line">     va_start(args, num);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">         <span class="type">int</span> value = va_arg(args, <span class="type">int</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Argument %d: %d\n&quot;</span>, i+<span class="number">1</span>, value);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     va_end(args);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     my_function(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，my_function是一个可变参数函数，它接受一个整数参数num，表示将传递多少个可变参数，然后是实际的可变参数。它使用va_list和相关的宏来访问和处理这些参数。</p><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Argument 1: 1</span><br><span class="line">Argument 2: 2</span><br><span class="line">Argument 3: 3</span><br></pre></td></tr></table></figure><p>这是创建和使用可变参数函数的基本方式。您可以根据需要修改和扩展这个示例，以适应更复杂的情况和不同类型的参数。</p><h2 id="三、C语言中的递归函数"><a href="#三、C语言中的递归函数" class="headerlink" title="三、C语言中的递归函数"></a>三、C语言中的递归函数</h2><p>在C语言中，递归是一个函数直接或间接地调用自身的过程。递归函数是解决分治问题的有力工具，但是必须有一个明确的基本情况或停止条件，以避免无限递归。下面是一个递归函数的基本结构和一个简单的示例（计算阶乘）：</p><h3 id="递归函数的基本结构："><a href="#递归函数的基本结构：" class="headerlink" title="递归函数的基本结构："></a>递归函数的基本结构：</h3><ol><li><strong>基本情况</strong>：这是递归结束的条件，避免无限递归。</li><li><strong>递归步骤</strong>：这是一个或多个递归调用，通过逐步减小问题的规模来解决原始问题。</li></ol><h3 id="示例：计算阶乘"><a href="#示例：计算阶乘" class="headerlink" title="示例：计算阶乘"></a>示例：计算阶乘</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">     <span class="comment">// 基本情况</span></span><br><span class="line">     <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 递归步骤</span></span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> number = <span class="number">5</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;The factorial of %d is: %d\n&quot;</span>, number, factorial(number));</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ● 基本情况：当n等于0时，函数返回1，因为0的阶乘定义为1。</span></span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ● 递归步骤：否则，函数调用自身，参数为n-1，并将返回值与n相乘。</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> num * fun(num - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  压栈</span></span><br><span class="line"><span class="comment">//  fun -&gt;   num = 5</span></span><br><span class="line"><span class="comment">//      fun -&gt; num = 4</span></span><br><span class="line"><span class="comment">//          fun -&gt; num = 3</span></span><br><span class="line"><span class="comment">//              fun -&gt; num = 2</span></span><br><span class="line"><span class="comment">//                  fun -&gt; num = 1</span></span><br><span class="line"><span class="comment">//                      fun -&gt; num = 0  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  出栈</span></span><br><span class="line"><span class="comment">//                      fun -&gt; num = 1  fun(num - 1) -&gt;1    num * 1;    1</span></span><br><span class="line"><span class="comment">//                  fun -&gt; num = 2  fun(num - 1) -&gt;1    num * 1;        2</span></span><br><span class="line"><span class="comment">//               fun -&gt; num = 3  fun(num - 1) -&gt;1    num * 1;           6</span></span><br><span class="line"><span class="comment">//            fun -&gt; num = 4  fun(num - 1) -&gt;1    num * 1;              24</span></span><br><span class="line"><span class="comment">//          fun -&gt; num = 5  fun(num - 1) -&gt;1    num * 1;                120</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d 的阶乘是%d\n&quot;</span> , num , fun(num));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//   压栈</span></span><br></pre></td></tr></table></figure><p>在这个示例中：</p><ul><li><strong>基本情况</strong>：当n等于0时，函数返回1，因为0的阶乘定义为1。</li><li><strong>递归步骤</strong>：否则，函数调用自身，参数为n-1，并将返回值与n相乘。</li></ul><p>递归函数的调用栈会增长到它达到基本情况并开始返回。在上述示例中，调用栈将如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">factorial(<span class="number">5</span>)</span><br><span class="line">   → factorial(<span class="number">4</span>)</span><br><span class="line">     → factorial(<span class="number">3</span>)</span><br><span class="line">       → factorial(<span class="number">2</span>)</span><br><span class="line">         → factorial(<span class="number">1</span>)</span><br><span class="line">           → factorial(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>然后它开始返回并计算结果。<br>注意，<strong>递归函数要小心设计，以避免无限递归和栈溢出，还应注意可能的高时间和空间复杂度。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 函数 </tag>
            
            <tag> 指针 </tag>
            
            <tag> 结构体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2023/08/06/test/2024-08-06-%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/08/06/test/2024-08-06-%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="测试测试"><a href="#测试测试" class="headerlink" title="测试测试"></a>测试测试</h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2023/08/06/test/%E5%8D%9A%E5%AE%A2/2024-08-06-%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/08/06/test/%E5%8D%9A%E5%AE%A2/2024-08-06-%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="测试测试"><a href="#测试测试" class="headerlink" title="测试测试"></a>测试测试</h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派配置使用教程</title>
      <link href="/2022/05/05/test/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2022/05/05/test/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="树莓派配置使用教程-HQ"><a href="#树莓派配置使用教程-HQ" class="headerlink" title="树莓派配置使用教程 - HQ"></a>树莓派配置使用教程 - HQ</h1><p>[TOC]</p><hr><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><a href="http://mp.weixin.qq.com/mp/homepage?__biz=MzkzMDE4MDM2NQ==&hid=2&sn=9f206e6f23e14e08383bab0cdd812062&scene=18#wechat_redirect">树莓派使用文章汇总 - 编程那些年 - 已摘录</a></li><li><a href="http://mp.weixin.qq.com/mp/homepage?__biz=MzkzMDE4MDM2NQ==&hid=3&sn=a29994435d8945a531f14c5be3b4f801&scene=18#wechat_redirect">Linux基础文章汇总 - 编程那些年 - 已摘录</a></li><li><a href="https://blog.csdn.net/weixin_45911959/article/details/122709090">超简单教你在树莓派上安装opencv(一) - 未摘录</a></li><li><a href="https://blog.csdn.net/weixin_45911959/article/details/124157416">超简单教你在树莓派上安装opencv(一) - 未摘录</a></li></ul><hr><h2 id="【树莓派】基本使用-基本操作"><a href="#【树莓派】基本使用-基本操作" class="headerlink" title="【树莓派】基本使用 &amp; 基本操作"></a>【树莓派】基本使用 &amp; 基本操作</h2><p>打开树莓派Linux系统可视化配置界面  <code>sudo raspi-config</code></p><blockquote><img src="././images/image-20220505212046292-1748585431990-15.png" alt="image-20220505212046292" style="zoom:50%;"></blockquote><h2 id="【树莓派】静态IP的正确配置方式-wifi"><a href="#【树莓派】静态IP的正确配置方式-wifi" class="headerlink" title="【树莓派】静态IP的正确配置方式(wifi)"></a>【树莓派】静态IP的正确配置方式(wifi)</h2><p>WiFi模式下使用以下几种方法，可以快速配置静态IP， 不用担心因为路由器DHCP的租约到期导致IP被重新分配的问题，并且会保留配置好的网络环境对应的静态IP，不用每次都来修改配置，非常方便。接下来就讲下几种配置方法。</p><h3 id="方法一：直接修改配置文件"><a href="#方法一：直接修改配置文件" class="headerlink" title="方法一：直接修改配置文件"></a>方法一：直接修改配置文件</h3><p>1、刷完机后首先根据需要，参考公众号文章《<strong>【树莓派】配置串口登录</strong>》<strong>、《【树莓派】系统启用SSH服务》</strong>选择性的做相应的配置<br>2、根据《<strong>【树莓派】配置无线网络(wifi)<strong>》文章连接WIFI，并确认动态获取的IP，通过</strong>ifconfig</strong>命令查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ ifconfig wlan0</span><br><span class="line">wlan0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.120  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        inet6 fe80::23ec:e056:3e62:59f1  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether b8:27:eb:5d:03:fe  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 303  bytes 39869 (38.9 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 26  bytes 3706 (3.6 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>3、并通过<strong>route</strong>命令查看默认路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.1.1     0.0.0.0         UG    303    0        0 wlan0</span><br><span class="line">192.168.1.0     0.0.0.0         255.255.255.0   U     303    0        0 wlan0</span><br><span class="line">pi@raspberrypi:~ $ </span><br></pre></td></tr></table></figure><p>4、通过<strong>vim.tiny</strong>或者nano命令修改**&#x2F;etc&#x2F;dhcpcd.conf**文件，将动态获取的IP以静态配置的方式追加到该文件末尾：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ vim.tiny  /etc/dhcpcd.conf# fallback to static profile on eth0</span><br><span class="line">#interface eth0</span><br><span class="line">#fallback static_eth0</span><br><span class="line">interface wlan0</span><br><span class="line">static ip_address=192.168.1.120/24</span><br><span class="line">static routers=192.168.1.1</span><br><span class="line">static domain_name_servers=192.168.1.1</span><br></pre></td></tr></table></figure><p>这其中 “interface wlan0”表示无线网卡，如果要配置有线网卡为静态IP，则改为”interface eth0”即可<br>“static ip_address&#x3D;192.168.1.120&#x2F;24”表示静态IP设置为上面获取的”192.168.1.120”， 24表示子网掩码为”255.255.255.0 “</p><p>“static routers&#x3D;192.168.1.1”表示默认路由为上面的”192.168.1.1”</p><p>“static domain_name_servers&#x3D;192.168.1.1”表示DNS为”192.168.1.1”,当然不同的网络这里会有差异，可在电脑上通过ipconfig命令查看确认的DNS</p><p>最后重启树莓派即可。</p><h3 id="方法二：通过网络设置界面"><a href="#方法二：通过网络设置界面" class="headerlink" title="方法二：通过网络设置界面"></a>方法二：通过网络设置界面</h3><p>1、刷完机后首先根据需要，参考公众号文章《<strong>【树莓派】配置串口登录</strong>》、《<strong>【树莓派】系统启用SSH服务</strong>》选择性的做相应的配置<br>2、根据《<strong>【树莓派】配置无线网络(wifi)<strong>》文章连接WIFI，并确认动态获取的IP，通过</strong>ifconfig</strong>命令查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ ifconfig wlan0</span><br><span class="line">wlan0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.120  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        inet6 fe80::23ec:e056:3e62:59f1  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether b8:27:eb:5d:03:fe  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 303  bytes 39869 (38.9 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 26  bytes 3706 (3.6 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>3、并通过<strong>route</strong>命令查看默认路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.1.1     0.0.0.0         UG    303    0        0 wlan0</span><br><span class="line">192.168.1.0     0.0.0.0         255.255.255.0   U     303    0        0 wlan0</span><br><span class="line">pi@raspberrypi:~ $ </span><br></pre></td></tr></table></figure><p>4、树莓派接上HDM显示器I重新开机或者通过VNC、RDP（<em>PS:远程登录要预先配置好响应服务</em>）等方式远程登录进树莓派，右键右上角的网络图标，选择**”Wireless &amp; Wired Network Settings”：**</p><blockquote><img src="././images/64022-1748585431990-14.jpeg" alt="图片" style="zoom:67%;"></blockquote><p>5、弹出的**”Network Preferences”<strong>窗口，选择”<strong>Configure-&gt;Interface-&gt;wlan0”</strong>, 勾选</strong>“Automatically configure empty options”<strong>, 勾选</strong>“Disable IPv6”<strong>, 并根据上面动态获取到的IP和默认路由输入到对应的</strong>“IPV4 Address**”和**”Router”**栏中。并点击一次”Apply”，然后点击”Close”如下：</p><blockquote><img src="././images/640-16516755057291-1748585431990-16.jpeg" alt="图片" style="zoom:67%;"></blockquote><p>如果保存成功的话，通过<strong>cat &#x2F;etc&#x2F;dhcpcd.conf</strong>可看到如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># fallback to static profile on eth0</span><br><span class="line">#interface eth0</span><br><span class="line">#fallback static_eth0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface wlan0</span><br><span class="line">inform 192.168.1.120</span><br><span class="line">static routers=192.168.1.1</span><br><span class="line">noipv6 </span><br></pre></td></tr></table></figure><p>可以看到本质也是配置的dhcpcd.conf文件。</p><h3 id="方法三、骚操作-修改路由器"><a href="#方法三、骚操作-修改路由器" class="headerlink" title="方法三、骚操作 修改路由器"></a>方法三、骚操作 修改路由器</h3><p>1、刷完机后首先根据需要，参考公众号文章《<strong>【树莓派】配置串口登录</strong>》、《<strong>【树莓派】系统启用SSH服务</strong>》选择性的做相应的配置<br>2、根据《<strong>【树莓派】配置无线网络(wifi)<strong>》文章连接WIFI，并确认动态获取的IP<br>3、通过浏览器直接进入路由器web管理界面,找到IP和MAC绑定选项，查找到树莓派的IP，直接将其</strong>IP和MAC绑定</strong>即可*(不同的路由器配置的位置不太一样)*：</p><blockquote><img src="././images/640-16516755057292-1748585431990-17.jpeg" alt="图片" style="zoom:67%;"></blockquote><h2 id="【树莓派】系统刷机教程"><a href="#【树莓派】系统刷机教程" class="headerlink" title="【树莓派】系统刷机教程"></a>【树莓派】系统刷机教程</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>树莓派（Raspberry Pi）是一款小型的专门为学习而设计的ARM开发板，支持Raspbian，Ubuntu Mate， Ubuntu Server等多种Linux操作系统。接下来就简单的讲解下如何烧录树莓派系统。</p><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><h5 id="准备一张8G以上存储大小的SD卡"><a href="#准备一张8G以上存储大小的SD卡" class="headerlink" title="准备一张8G以上存储大小的SD卡"></a>准备一张8G以上存储大小的SD卡</h5><h3 id="下载镜像及工具"><a href="#下载镜像及工具" class="headerlink" title="下载镜像及工具"></a>下载镜像及工具</h3><p>1、 进入Raspberry Pi官网(<a href="https://www.raspberrypi.org/)%EF%BC%8C%E4%B8%8B%E8%BD%BD%E6%89%80%E9%9C%80%E7%9A%84%E9%95%9C%E5%83%8F%EF%BC%8C%E6%9C%89%E4%B8%89%E4%B8%AA%E9%80%89%E9%A1%B9%E5%8F%AF%E9%80%89%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83+%E6%8E%A8%E8%8D%90%E8%BD%AF%E4%BB%B6%E3%80%81%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83%E3%80%81%E6%9C%80%E5%B0%8F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%EF%BC%9A">https://www.raspberrypi.org/)，下载所需的镜像，有三个选项可选，分别是桌面环境+推荐软件、桌面环境、最小运行环境：</a></p><blockquote><img src="././images/640-16516755401936-1748585431990-18.jpeg" alt="图片" style="zoom:67%;"></blockquote><p>或者下载NOOBS压缩包（方法三使用）</p><blockquote><img src="././images/640-16516755401947-1748585431990-19.png" alt="图片" style="zoom:67%;"></blockquote><p><em>（PS：可在公众号回复”树莓派”获取”桌面环境版本”和NOOBS压缩包）</em></p><p>2、下载刻录镜像所需的工具，这里可选择”Win32DiskImager” 或者树莓派官方提供的”Raspberry Pi Imager”</p><p>Win32DiskImager下载地址如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1https://win32diskimager.download/</span><br></pre></td></tr></table></figure><p>Raspberry Pi Imager下载地址如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1https://www.raspberrypi.org/software/</span><br></pre></td></tr></table></figure><p>（注：也可直接在公众号回复”树莓派”获取刻录工具）</p><h3 id="烧录镜像"><a href="#烧录镜像" class="headerlink" title="烧录镜像"></a>烧录镜像</h3><p>  首先在电脑上插入TF卡，并采用以上几种刻录工具中的一种对下载好的img镜像进行刻录。</p><h4 id="1、采用Win32DiskImager刻录："><a href="#1、采用Win32DiskImager刻录：" class="headerlink" title="1、采用Win32DiskImager刻录："></a>1、采用Win32DiskImager刻录：</h4><p>  打开Win32DiskImager软件， 点击”文件”图标，选择要刻录的img系统镜像，并在”设备”处确认TF卡的正常分区号。然后点击写入即可开始刻录系统。</p><blockquote><img src="././images/640-16516755401958-1748585431991-22.jpeg" alt="图片" style="zoom:67%;"></blockquote><p>等待烧录</p><blockquote><img src="././images/640-16516755401959-1748585431990-20.png" alt="图片" style="zoom:67%;"></blockquote><p>当提示”写入成功”后，根据需要配置下<a href="http://mp.weixin.qq.com/s?__biz=MzkzMDE4MDM2NQ==&mid=2247483746&idx=1&sn=9c09f6a167f989eb3ad136c47c1f6149&chksm=c27f7d00f508f416ecc48f7e1f067200cd22fd5c498afb99e57e27ea24640d21f79dedd8c75f&scene=21#wechat_redirect">树莓派的串口</a>和<a href="http://mp.weixin.qq.com/s?__biz=MzkzMDE4MDM2NQ==&mid=2247483728&idx=1&sn=dc585685feab7f1b6b7f1c64961906ba&chksm=c27f7d32f508f42454bf01b04fdcaadacbc7fbeab58909664b2f1fd25f93914cc7b81df9d401&scene=21#wechat_redirect">SSH服务</a>后， 把TF拔下来插到树莓派上即可。</p><blockquote><img src="././images/640-165167554019510-1748585431991-21.png" alt="图片" style="zoom:67%;"></blockquote><h4 id="2、采用Raspberry-Pi-Imager工具烧录"><a href="#2、采用Raspberry-Pi-Imager工具烧录" class="headerlink" title="2、采用Raspberry Pi Imager工具烧录"></a>2、采用Raspberry Pi Imager工具烧录</h4><p>打开Raspberry Pi Imager工具</p><blockquote><img src="././images/640-165167554019511-1748585431991-23.png" alt="图片" style="zoom:67%;"></blockquote><p>点击”CHOOSE OS”按钮， 选择要在线安装的操作系统（受限于网络）或已经提前下载好的系统，</p><blockquote><img src="././images/640-165167554019512-1748585431991-24.jpeg" alt="图片" style="zoom:67%;"></blockquote><blockquote><img src="././images/640-165167554019513-1748585431991-25.png" alt="图片" style="zoom:67%;"></blockquote><p>点击”CHOOSE SD CARD READ”按钮 ,选择要写入的TF卡后</p><blockquote><img src="././images/640-165167554019614-1748585431991-26.png" alt="图片" style="zoom:67%;"></blockquote><blockquote><img src="././images/640-165167554019615-1748585431991-27.jpeg" alt="图片" style="zoom: 67%;"></blockquote><p>点击”WRITE”按钮，开始烧录</p><blockquote><img src="././images/640-165167554019616-1748585431991-28.png" alt="图片" style="zoom: 67%;"></blockquote><blockquote><img src="././images/640-165167554019617-1748585431991-30.jpeg" alt="图片" style="zoom:67%;"></blockquote><p>等待烧录完成后，根据需要配置下<a href="http://mp.weixin.qq.com/s?__biz=MzkzMDE4MDM2NQ==&mid=2247483746&idx=1&sn=9c09f6a167f989eb3ad136c47c1f6149&chksm=c27f7d00f508f416ecc48f7e1f067200cd22fd5c498afb99e57e27ea24640d21f79dedd8c75f&scene=21#wechat_redirect">树莓派的串口</a>和<a href="http://mp.weixin.qq.com/s?__biz=MzkzMDE4MDM2NQ==&mid=2247483728&idx=1&sn=dc585685feab7f1b6b7f1c64961906ba&chksm=c27f7d32f508f42454bf01b04fdcaadacbc7fbeab58909664b2f1fd25f93914cc7b81df9d401&scene=21#wechat_redirect">树莓派的SSH服务</a>等配置后， 把TF拔下来插到树莓派上即可。</p><h4 id="3、利用NOOBS文件刷机"><a href="#3、利用NOOBS文件刷机" class="headerlink" title="3、利用NOOBS文件刷机"></a>3、利用NOOBS文件刷机</h4><p>去Raspberry Pi官网下载NOOBS压缩包（PS：也可直接在公众号回复”树莓派”获取）<br>将SD卡格式化为FAT32格式<br>将下载好的NOOBS文件解压，并将NOOBS文件夹的全部内容拷贝到SD卡的根目录中</p><blockquote><img src="././images/640-165167554019818-1748585431991-29.png" alt="图片" style="zoom:67%;"></blockquote><p> 将SD卡插入树莓派，并接上HDMI显示和键盘，上电开机机， NOOBS会自动将你的SD卡进行分区。<br> 然后会弹出系统安装窗口，你可以根据自己的喜好选择其一安装（不需要网络），这里我选择了Raspbian，并选择好所需的语言和键盘语言</p><blockquote><img src="././images/640-165167554019819-1748585431991-31.jpeg" alt="图片" style="zoom:67%;"></blockquote><p>然后等待安装完成即可</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>如果在刷机过程中出现刷机失败，可利用”SD Card Formatter”软件对SD卡进行格式化后，再重新刷机。</p><p>以上工具均可在公众号回复“树莓派”获取网盘下载链接</p><h2 id="【树莓派】让你的SD卡快速扩容"><a href="#【树莓派】让你的SD卡快速扩容" class="headerlink" title="【树莓派】让你的SD卡快速扩容"></a>【树莓派】让你的SD卡快速扩容</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>在树莓派实际使用当中，我们会发现SD卡的存储并没有得到充分的利用，是否有办法让可用空间变的更大，毫无疑问肯定是有的，不然我就不在这里废话了。</p><h3 id="准备环境-1"><a href="#准备环境-1" class="headerlink" title="准备环境"></a>准备环境</h3><p>  <strong>设备：</strong>树莓派 3B<em>（其他型号也可以）</em><br>  <strong>SD卡容量：</strong>16G</p><h3 id="方案一：使用raspi-config扩容（推荐）"><a href="#方案一：使用raspi-config扩容（推荐）" class="headerlink" title="方案一：使用raspi-config扩容（推荐）"></a>方案一：使用raspi-config扩容（推荐）</h3><p>  首先输入**”df -h”**命令可以看到，当前root分区总共只用了3.1G，而可用空间仅剩288M，但实际我们的存储是16G的，所以可用空间理论上不应该这么小，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~$ df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/root       3.1G  2.7G  288M  91% /</span><br><span class="line">devtmpfs        310M     0  310M   0% /dev</span><br><span class="line">tmpfs           438M     0  438M   0% /dev/shm</span><br><span class="line">tmpfs           438M   17M  421M   4% /run</span><br><span class="line">tmpfs           5.0M  4.0K  5.0M   1% /run/lock</span><br><span class="line">tmpfs           438M     0  438M   0% /sys/fs/cgroup</span><br><span class="line">/dev/mmcblk0p1   43M   22M   21M  51% /boot</span><br><span class="line">tmpfs            88M     0   88M   0% /run/user/1000</span><br><span class="line">pi@raspberrypi:~$</span><br></pre></td></tr></table></figure><p>此时可以利用**”raspi-config”**对root分区进行扩容，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure><p>选择**”7 Advanced Options”**回车：</p><blockquote><img src="././images/640-165167557649734-1748585431991-32.png" alt="图片" style="zoom:67%;"></blockquote><p>然后选择**”A1 Expand Filesystem Ensures that all of ….”**,回车：</p><blockquote><img src="././images/640-165167557649835-1748585431991-33.png" alt="图片" style="zoom:67%;"></blockquote><p>询问是否修改root分区，直接回车：</p><blockquote><img src="././images/640-165167557649836-1748585431991-35.png" alt="图片" style="zoom:67%;"></blockquote><p>到首页面，按**”Tab”<strong>键，选择</strong>“Finish”**，回车：</p><blockquote><img src="././images/640-165167557649837-1748585431991-34.png" alt="图片" style="zoom:67%;"></blockquote><p>询问是否重启，选择重启：</p><blockquote><img src="././images/640-165167557649838-1748585431991-36.png" alt="图片" style="zoom:67%;"></blockquote><p>重启完后，输入**”df -h”**,会发现root分区已经扩容成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/root        15G  2.9G   11G  22% /</span><br><span class="line">devtmpfs        433M     0  433M   0% /dev</span><br><span class="line">tmpfs           438M     0  438M   0% /dev/shm</span><br><span class="line">tmpfs           438M   12M  426M   3% /run</span><br><span class="line">tmpfs           5.0M  4.0K  5.0M   1% /run/lock</span><br><span class="line">tmpfs           438M     0  438M   0% /sys/fs/cgroup</span><br><span class="line">/dev/mmcblk0p1  253M   53M  200M  21% /boot</span><br><span class="line">tmpfs            88M     0   88M   0% /run/user/1000</span><br></pre></td></tr></table></figure><p>又可以愉快的玩耍了。</p><h3 id="方案二：利用fdisk和resize2fs扩容"><a href="#方案二：利用fdisk和resize2fs扩容" class="headerlink" title="方案二：利用fdisk和resize2fs扩容"></a>方案二：利用fdisk和resize2fs扩容</h3><p>  利用**”fdisk”<strong>和</strong>“resize2fs”<strong>命令确认mmcblk0p2节点的其实地址为：</strong>“532480”**（注：根据实际情况确认该地址，要输错了会导致分区出错，很重要！！！）,并对该分区重新创建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ sudo  fdisk  /dev/mmcblk0</span><br><span class="line"></span><br><span class="line">Welcome to fdisk (util-linux 2.33.1).</span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line"></span><br><span class="line">Command (m for help): p #查看分区信息， /dev/mmcblk0p2 start地址很重要</span><br><span class="line">Disk /dev/mmcblk0: 14.6 GiB, 15681454080 bytes, 30627840 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0xea7d04d6</span><br><span class="line"></span><br><span class="line">Device         Boot  Start     End Sectors  Size Id Type</span><br><span class="line">/dev/mmcblk0p1        8192  532479  524288  256M  c W95 FAT32 (LBA)</span><br><span class="line">/dev/mmcblk0p2      532480 7397375 6864896  3.3G 83 Linux</span><br><span class="line"></span><br><span class="line">Command (m for help): d #删除mmcblk0p2分区</span><br><span class="line">Partition number (1,2, default 2): 2</span><br><span class="line"></span><br><span class="line">Partition 2 has been deleted.</span><br><span class="line"></span><br><span class="line">Command (m for help): n #新建分区</span><br><span class="line">Partition type</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended (container for logical partitions)</span><br><span class="line">Select (default p):</span><br><span class="line"></span><br><span class="line">Using default response p.</span><br><span class="line">Partition number (2-4, default 2): 2 #分区号选择2 即mmcblk0p2分区</span><br><span class="line">First sector (2048-30627839, default 2048): 532480  #刚才查看的mmcblk0p2起始地址</span><br><span class="line">Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (532480-30627839, default 30627839): #默认直接回车</span><br><span class="line"></span><br><span class="line">Created a new partition 2 of type &#x27;Linux&#x27; and of size 14.4 GiB.</span><br><span class="line">Partition #2 contains a ext4 signature.</span><br><span class="line"></span><br><span class="line">Do you want to remove the signature? [Y]es/[N]o: y</span><br><span class="line"></span><br><span class="line">The signature will be removed by a write command.</span><br><span class="line"></span><br><span class="line">Command (m for help): p #这里重新查看发现mmcblk0p2分区变大了</span><br><span class="line">Disk /dev/mmcblk0: 14.6 GiB, 15681454080 bytes, 30627840 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0xea7d04d6</span><br><span class="line"></span><br><span class="line">Device         Boot  Start      End  Sectors  Size Id Type</span><br><span class="line">/dev/mmcblk0p1        8192   532479   524288  256M  c W95 FAT32 (LBA)</span><br><span class="line">/dev/mmcblk0p2      532480 30627839 30095360 14.4G 83 Linux</span><br><span class="line"></span><br><span class="line">Filesystem/RAID signature on partition 2 will be wiped.</span><br><span class="line"></span><br><span class="line">Command (m for help): w #保存，如果输错了，按q不保存重新来</span><br><span class="line">The partition table has been altered.</span><br><span class="line">Syncing disks.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pi@raspberrypi:~ $ sudo resize2fs /dev/mmcblk0p2 #利用resize2fs调整文件系统实际大小</span><br><span class="line">resize2fs 1.44.5 (15-Dec-2018) </span><br><span class="line">Filesystem at /dev/mmcblk0p2 is mounted on /; on-line resizing required</span><br><span class="line">old_desc_blocks = 1, new_desc_blocks = 1</span><br><span class="line">The filesystem on /dev/mmcblk0p2 is now 3761920 (4k) blocks long.</span><br></pre></td></tr></table></figure><p>然后重启，也是可以愉快的玩耍的。</p><h3 id="交换分区大小"><a href="#交换分区大小" class="headerlink" title="交换分区大小"></a>交换分区大小</h3><p>虽然可用空间变大了，但我们在使用的实际当中会发现有些卡顿，这是因为树莓派默认的给的swap分区只要100M。</p><p><strong>关于交换分区的解释大致如下：</strong></p><p>  Swap分区是存储上一个特殊用途的分区或文件，是当系统内存不够用的时候，把物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放或交换出来的内容就会被临时保存到Swap分区中，等到程序需要时，再从Swap分区中恢复数据到内存中。</p><p><strong>修改方法如下：</strong></p><p>  通过修改**”&#x2F;etc&#x2F;dphys-swapfile”<strong>文件的</strong>“CONF_SWAPSIZE”*<em>字段达到扩大交换分区的目的（</em>以M为单位*）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ sudo vi /etc/dphys-swapfile #输入如下命令</span><br><span class="line"></span><br><span class="line"># /etc/dphys-swapfile - user settings for dphys-swapfile package</span><br><span class="line"># author Neil Franklin, last modification 2010.05.05</span><br><span class="line"># copyright ETH Zuerich Physics Departement</span><br><span class="line">#   use under either modified/non-advertising BSD or GPL license</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># this file is sourced with . so full normal sh syntax applies</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># the default settings are added as commented out CONF_*=* lines</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># where we want the swapfile to be, this is the default</span><br><span class="line">#CONF_SWAPFILE=/var/swap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># set size to absolute value, leaving empty (default) then uses computed value</span><br><span class="line">#   you most likely don&#x27;t want this, unless you have an special disk situation</span><br><span class="line">CONF_SWAPSIZE=2048 #将该字段的100改为2048</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># set size to computed value, this times RAM size, dynamically adapts,</span><br><span class="line">#   guarantees that there is enough swap without wasting disk space on excess</span><br><span class="line">#CONF_SWAPFACTOR=2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># restrict size (computed and absolute!) to maximally this limit</span><br><span class="line">#   can be set to empty for no limit, but beware of filled partitions!</span><br><span class="line">#   this is/was a (outdated?) 32bit kernel limit (in MBytes), do not overrun it</span><br><span class="line">#   but is also sensible on 64bit to prevent filling /var or even / partition</span><br><span class="line">#CONF_MAXSWAP=2048</span><br></pre></td></tr></table></figure><p>然后重启下服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ sudo /etc/init.d/dphys-swapfile restart</span><br><span class="line">[ ok ] Restarting dphys-swapfile (via systemctl): dphys-swapfile.service.</span><br><span class="line">pi@raspberrypi:~</span><br></pre></td></tr></table></figure><p>酱紫，我们就把Swap分区从100M调整到了2G，可通过**”free -m”**命令查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            875         101         613          11         159         712</span><br><span class="line">Swap:          2047           0        2047  #这里就是交换的内容</span><br><span class="line">pi@raspberrypi:~ $</span><br></pre></td></tr></table></figure><h2 id="【树莓派】系统备份与还原"><a href="#【树莓派】系统备份与还原" class="headerlink" title="【树莓派】系统备份与还原"></a>【树莓派】系统备份与还原</h2><p>很多同学在开发树莓派的过程中会遇到因为操作失误导致系统无法正常启动或者偶然出现宕机的情况，此时如果没有备份，需要重刷系统是一件很崩溃的事情， 本文就讲解下如何简单的对Pi上的系统进行备份。</p><p><strong>方法一、利用Win32DiskImager工具备份</strong></p><p>​    首先下载Win32DiskImager， 下载地址如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://sourceforge.net/projects/win32diskimager/</span><br></pre></td></tr></table></figure><p>​     将SD卡接到windows主机上，打开Win32DiskImager工具，点击<strong>文件图标</strong>，输入选择要保存的路径，同时输入文件名称，然后选择<strong>“打开”</strong>，如下：</p><blockquote><img src="././images/640-165167560614344-1748585431991-38.png" alt="图片" style="zoom:67%;"></blockquote><p>​      点击<strong>“读取”</strong>开始备份，耐心等待备份完成即可， 如下：</p><blockquote><img src="././images/640-165167560614345-1748585431991-37.png" alt="图片" style="zoom:67%;"></blockquote><p>  正常整个img备份下来的大小和实际TF的大小一样（如TF卡实际可读写大小为14.6G，那么备份出来的大小就是14.6G）。下次如果TF卡无法正常启动，可利用Win32DiskImager将备份好的img再次写入即可。</p><p><strong>方法二、利用Linux dd命令主机备份</strong></p><p>  该方法要求：Linux主机可利用空间要大于SD卡的实际大小。 将SD卡接到Linux主机或者连接到Linux虚拟机后，用如下命令备份<em>（SD卡的实际设备节点可通过lsblk确认）</em>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:/$ lsblk</span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0   20G  0 disk </span><br><span class="line">└─sda1   8:1    0   20G  0 part /</span><br><span class="line">sdb      8:16   1 14.6G  0 disk </span><br><span class="line">├─sdb1   8:17   1  256M  0 part /media/linux/boot</span><br><span class="line">└─sdb2   8:18   1  3.3G  0 part /media/linux/rootfs</span><br><span class="line">:/$ sudo dd bs=4M if=/dev/sdb of=/mnt/hgfs/F/2021-01-02.img</span><br></pre></td></tr></table></figure><p>​    如果需要还原，则直接通过dd命令还原，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:/$ sudo dd bs=4M if=/mnt/hgfs/F/2021-01-02.img of=/dev/sdb</span><br></pre></td></tr></table></figure><p>  当然，由于dd出来的img会比较大，可以利用gzip等压缩工具对img进行压缩，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:/$ sudo dd bs=4M if=/dev/sdb | gzip &gt;/mnt/hgfs/F/2021-01-02.img.gz</span><br></pre></td></tr></table></figure><p>​    此后，如果需要进行还原，可利用如下命令实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:/$  gunzip --stdout /mnt/hgfs/F/2021-01-02.img.gz | sudo dd bs=4M of=/dev/sdb</span><br></pre></td></tr></table></figure><p><strong>方法三、利用dump 和 restore 备份工具</strong></p><p>   偷懒直接参考别人写好的脚步，首先从在Pi上下载相关脚步， github地址如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/nanhantianyi/rpi-backup</span><br></pre></td></tr></table></figure><p>​     然后在Pi上接入u盘，将其挂载在&#x2F;media目录， 并利用backup.sh脚本备份系统，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /media/linux</span><br><span class="line">sudo mount /dev/sdb1 /media/linux</span><br><span class="line">cd rpi-backup/</span><br><span class="line">pi@pi:~/rpi-backup$ sudo ./back.sh /media/linux/2021-01-02.img</span><br></pre></td></tr></table></figure><p>​    如果要还原，可直接使用Win32DiskImager或者Linux dd命令均可，还原后，再利用resize.sh脚本在Pi上进行root分区扩容，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash resize.sh </span><br></pre></td></tr></table></figure><h2 id="【树莓派】配置串口登录"><a href="#【树莓派】配置串口登录" class="headerlink" title="【树莓派】配置串口登录"></a>【树莓派】配置串口登录</h2><p>当树莓派刚刷完机之后，它的硬件串口（&#x2F;dev&#x2F;ttyAMA0）默认是分配给板载蓝牙使用的，因此无法通过串口进行登录。这个时候就需要对串口进行配置， 才能够通过MobaXterm等软件以Serial的方式登录到树莓派的终端上。</p><p><strong>方式一、直接修改配置文件</strong></p><p>  1、树莓派下电， 把TF卡从Pi上拔下来，插到电脑上，直接进入根目录，用Nopad++软件打开<strong>config.txt</strong>，在文件末尾添加如下内容：</p><blockquote><p><img src="/././images/640-165167595867548-1748585431991-39.png" alt="图片"></p></blockquote><p>保存后退出。 </p><p>   2、修改cmdline.txt文件， 确保里面包含”<strong>console&#x3D;serial0,115200”,<strong>同时删除“</strong>rootwait”</strong>之后的内容。最后保存下来的内容如下:</p><blockquote><p><img src="/././images/640-165167595867649-1748585431991-40.png" alt="图片"></p></blockquote><p> 如果配置正常，在树莓派上通过**”cat &#x2F;proc&#x2F;cmdline”**，可以看到 **”consle&#x3D;ttyAMA0,115200”**字样，如下所示：</p><blockquote><p><img src="/././images/640-165167595867650-1748585431991-41.png" alt="图片"></p></blockquote><p><strong>方式二、接HDMI显示或者远程登陆，通过命令行配置</strong></p><p>   如果有接着HDMI显示器或者直接之前开启过SSH，则可以通过开启终端，在终端上输入<strong>“sudo raspi-config”</strong>命令，然后按方向键**”↓”**键选择 <strong>“5 Interfacing Options”</strong>，回车，如下所示：</p><blockquote><img src="././images/640-165167595867651-1748585431991-43.png" alt="图片" style="zoom:67%;"></blockquote><p>  用方向键**”↓”<strong>键，选择</strong>“P6 Serial “，** 回车：</p><blockquote><img src="././images/640-165167595867652-1748585431991-42.png" alt="图片" style="zoom:67%;"></blockquote><p>然后选择**”YES”<strong>即可</strong>*（备注：如果想关闭串口登录，去编程读写串口，则选择”NO”）***，回车即可，如下：</p><blockquote><img src="././images/640-165167595867653-1748585431991-44.png" alt="图片" style="zoom:67%;"></blockquote><p>选择**”OK”,**回车：</p><blockquote><img src="././images/image-20220505091552848-1748585431991-46.png" alt="image-20220505091552848" style="zoom:67%;"></blockquote><p>然后在配置首页按**”Tab”<strong>键，选择</strong>“Finish”，重启树莓派，**正常就能通过串口登录。</p><p> 另外需要注意的是： 通常采用USB转TTL去接树莓派时，通常需要接三个线，即：</p><ul><li><p>树莓派的<strong>GND接</strong>USB转TTL的<strong>GND</strong></p></li><li><p>树莓派的<strong>TX接</strong>USB转TTL的<strong>RX</strong></p></li><li><p>树莓派的<strong>RX接</strong>USB转TTL的<strong>TX</strong></p></li></ul><p>树莓派的<strong>引脚视图</strong>如下：</p><blockquote><img src="././images/640-165167595867754-1748585431991-45.png" alt="图片" style="zoom:67%;"></blockquote><h2 id="【树莓派】系统启用SSH服务"><a href="#【树莓派】系统启用SSH服务" class="headerlink" title="【树莓派】系统启用SSH服务"></a>【树莓派】系统启用SSH服务</h2><p>树莓派官方发布的 Raspbian 系统镜像，默认禁用了SSH 服务，因此默认是无法通过SecurityCRT、MobaXterm 或者Putty等软件远程登录到Pi上的。想要通过SSH登录到树莓派控制台，可通过以下四种方式进行配置：</p><p><strong>一、SSH服务配置方法</strong></p><p><strong>方式一、直接添加配置文件</strong></p><p>树莓派下电， 把TF卡从Pi上拔下来，插到电脑上，直接进入<strong>根目录</strong>，新建一个<strong>名为ssh的空白文件</strong>就行了，如下：</p><blockquote><img src="././images/640-165167604961780-1748585431991-47.png" alt="图片" style="zoom: 67%;"></blockquote><p>然后再把卡插回树莓派，重新上电，就可以使用SSH了（前提是已经配置了网络，网络详细配置见《<a href="http://mp.weixin.qq.com/s?__biz=MzkzMDE4MDM2NQ==&mid=2247483683&idx=1&sn=b5e62b916bbc42df384d708d9e6a00c9&chksm=c27f7d41f508f4570b5543e7ebb8bcee4d535d71ca090f9f7a6cbeb6a512ecc33c2bd7e32ac4&scene=21#wechat_redirect">【树莓派】配置无线网络(wifi)</a>》）。</p><p><strong>方式二、通过命令行配置（sudo raspi-config）</strong></p><p>  在命令行输入”**sudo raspi-config”**，然后回车:</p><blockquote><img src="././images/640-165167604961781-1748585431991-48.png" alt="图片" style="zoom:67%;"></blockquote><p>选择**”Interfacing Options”,**回车：</p><blockquote><img src="././images/640-165167604961882-1748585431991-49.png" alt="图片" style="zoom:67%;"></blockquote><p>选择**”P2 SSH”**,回车：</p><blockquote><img src="././images/640-165167604961883-1748585431991-50.png" alt="图片" style="zoom:67%;"></blockquote><p> 按方向键**”←”键<strong>选择</strong>“YES”**，回车：</p><blockquote><img src="././images/640-165167604961884-1748585431991-51.png" alt="图片" style="zoom: 80%;"></blockquote><p>  <strong>再次回车,<strong>然后按</strong>Tab键</strong>选择**”Finish”**退出。  </p><blockquote><img src="././images/image-20220505091730292-1748585431991-52.png" alt="image-20220505091730292" style="zoom:67%;"></blockquote><p>可以通过**”ps ax | grep sshd”**，查看是否有sshd进程：</p><blockquote><p><img src="/images/image-20220505091744039-1748585431991-53.png" alt="image-20220505091744039"></p></blockquote><p>如果有，就说明服务已经起来，就可以连接了。</p><p><strong>方式三、高效命令行方式开启：</strong></p><p>​    首先运行**”sudo systemctl enable ssh.service”**，回车，使能开机启动SSH服务。</p><p>​    然后运行**”sudo systemctl start ssh.service”**，回车，启动SSH服务,如下所示：    </p><blockquote><p><img src="/././images/640-165167604961885-1748585431991-55.png" alt="图片"></p></blockquote><p><strong>方式四、接HDMI显示器，通过界面配置：</strong></p><p>选择“<strong>Start Menu-&gt;Preferences-&gt;Raspberry Pi Configuration</strong>”,</p><blockquote><img src="././images/640-165167604961886-1748585431991-54.png" alt="图片" style="zoom:67%;"></blockquote><p>选中**”Interfaces”<strong>后，将SSH选项</strong>“Enable”**，然后点击”OK”即可，如下：</p><blockquote><img src="././images/640-165167604961887-1748585431991-56.png" alt="图片" style="zoom:67%;"></blockquote><p><strong>二、SSH远程连接设置流程</strong></p><p><strong>以MobaXterm软件为例：</strong></p><p>  首先，打开MobaXterm软件,点击<strong>“Session”</strong>:</p><blockquote><img src="././images/image-20220505091833151-1748585431991-57.png" alt="image-20220505091833151" style="zoom:67%;"></blockquote><p>  单击**”SSH”**按钮，新建SSH会话，输入树莓派的实际IP和登录用户名：</p><blockquote><p><img src="/././images/640-165167604961988-1748585431991-58.png" alt="图片"></p></blockquote><p>然后点击确认，<strong>输入密码，回车</strong>即可连接<em>（<strong>pi</strong>的默认密码为<strong>raspberry</strong>，输入的密码默认不可见**）</em>，如下：</p><blockquote><p><img src="/././images/640-165167604961989-1748585431991-59.png" alt="图片"></p></blockquote><blockquote><img src="././images/640-165167604961990-1748585431991-60.png" alt="图片" style="zoom:67%;"></blockquote><h2 id="【树莓派】配置无线网络-wifi"><a href="#【树莓派】配置无线网络-wifi" class="headerlink" title="【树莓派】配置无线网络(wifi)"></a>【树莓派】配置无线网络(wifi)</h2><p> 树莓派网络分为有线网络和无线网络两种连接方式，有线网络只需要一根网线接入，让设备动态获取IP即可， 基本不需要进行设置。但在使用无线网络连接时，经常会出现一些问题，如输入<strong>ifconfig</strong>命令时<strong>找不到设备节点wlan0</strong>：</p><blockquote><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/y4y47RhOQZxPINKdVGn4k7Tz4FTlF5Te3fepWvB10RcPyRWA8YY9Lm4ftIGlmfE9dqGgUgUyWTKXWiayra4ibRJQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;"></blockquote><p>或者<strong>找到了wlan0设备节点，但是没有获取到IP</strong>：</p><blockquote><img src="././images/640-1651676068912103-1748585431991-61.png" alt="图片" style="zoom:67%;"></blockquote><p>此时我们可以通过<strong>“ls &#x2F;sys&#x2F;class&#x2F;net”</strong>命令确认设备节点是否存在来排除是否为硬件故障或者没有加载驱动：</p><blockquote><p><img src="/././images/640-1651676068912104-1748585431991-62.png" alt="图片"></p></blockquote><p>然后通过<strong>“sudo iw dev wlan0 scan |grep SSID”</strong>命令确认能否搜索到你想要的wifi,如下：</p><blockquote><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/y4y47RhOQZwP6Mpmiaqdh2yehCR7TTvZn8NOAPjMroqCEwzK7wF0qpbcSq6iaaPQReYhkV7IurZTakUQzftA9DOA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p></blockquote><p><strong>可以通过以下几种方式配置wifi网络：</strong></p><p><strong>方式一、通过命令行方式配置（sudo raspi-config）：</strong></p><p>   输入<strong>“sudo raspi-config“，</strong>会出现以下配置界面：</p><blockquote><img src="././images/640-1651676068912106-1748585431991-63.png" alt="图片" style="zoom:67%;"></blockquote><p>用键盘”↓“键选择第二项（<strong>2 Network Options</strong>），然后回车，出现以下界面：</p><blockquote><img src="././images/640-1651676068912107-1748585431991-64.png" alt="图片" style="zoom:67%;"></blockquote><p>选择**N2 Wi-fi,**然后回车:</p><blockquote><img src="././images/image-20220505091952802-1748585431991-65.png" alt="image-20220505091952802" style="zoom:67%;"></blockquote><p>用键盘”↓“键一直下翻，选择<strong>CN China</strong>,然后回车，到输入SSID界面：</p><blockquote><img src="././images/image-20220505092005777-1748585431991-66.png" alt="image-20220505092005777" style="zoom:67%;"></blockquote><p>这是输入<strong>WiFi的名字</strong>（注意有些型号如树莓派3&#x2F;3B是不支持5G和中文的）<strong>，</strong>回车出现下列输入密码界面：</p><blockquote><img src="././images/640-1651676068912108-1748585431991-67.png" alt="图片" style="zoom:67%;"></blockquote><p><strong>输入密码</strong>然后回车，回到raspi-config的首页，用<strong>Tab键</strong>选择<strong>Finish，</strong>然后<strong>重启</strong>，此时在终端上输入<strong>ifconfig</strong>,正常能看到wlan0动态获取到的IP，如下：</p><blockquote><img src="././images/640-1651676068913109-1748585431991-68.png" alt="图片" style="zoom:80%;"></blockquote><p>如果这种方法不生效，可使用其他方法设置。</p><p><strong>方式二、直接修改配置文件</strong></p><p>在终端上输入 sudo nano &#x2F;etc&#x2F;wpa_supplicant.conf</p><p>输入如下内容：（编辑完后先Ctrl+x退出，然后按Y保存退出、按N则不保存退出）</p><blockquote><img src="././images/image-20220505092101048-1748585431991-69.png" alt="image-20220505092101048" style="zoom: 67%;"></blockquote><p>   然后运行<strong>“sudo reboot”</strong>重启树莓派，再次通过<strong>ifconfig</strong>判断是否正确获取到IP:</p><blockquote><p><img src="/././images/640-1651676068913109-1748585431991-68.png" alt="图片"></p></blockquote><p><strong>方式三、接HDMI显示，通过界面配置WIFI</strong></p><p>如果手上有HDMI显示器或者带HDMI接口的电视机，则可直接通过可视化界面配置WIFI，这种方法最为直接简单，如下：</p><blockquote><img src="././images/640-1651676068913110-1748585431991-71.png" alt="图片" style="zoom:67%;"></blockquote><p>注：另外，配置问题如果出现”**Wi-FI is currently blocked by rkfill”**，</p><p>则可以通过**”sudo rfkill unblock all”**解锁，然后按上面的三种配置方式中的其中一种配置即可。</p><h2 id="【树莓派】简单配置CSI摄像头"><a href="#【树莓派】简单配置CSI摄像头" class="headerlink" title="【树莓派】简单配置CSI摄像头"></a>【树莓派】简单配置CSI摄像头</h2><p>本文讲讲树莓派如何正常安装CSI摄像头以及一些基础的配置和简单的使用</p><h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><p><strong>硬件：</strong>树莓派3B&#x2F;3B+<br><strong>系统：</strong>Raspberry Debian 9 &#x2F; Debian 10</p><h3 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h3><p>1、找到 <strong>CSI 接口</strong>(<em>树莓派3B的CSI接口在HDMI接口和音频口中间</em>)，**需要拉起 CSI 接口挡板,**如下：</p><blockquote><img src="././images/image-20220505092158916-1748585431991-70.png" alt="image-20220505092158916" style="zoom:67%;"></blockquote><p>2、将摄像头排线插入CSI接口。<strong>记住，有蓝色胶带的一面应该面向音频口或者网卡方向， 确认方向并插紧排线，将挡板压下去</strong>，如下所示：</p><blockquote><img src="././images/image-20220505092223652-1748585431991-72.png" alt="image-20220505092223652" style="zoom:67%;"></blockquote><p>安装好的效果图大致如下：</p><blockquote><img src="././images/640-16516753824911-1748585431991-73.jpeg" alt="图片" style="zoom:67%;"></blockquote><h3 id="使能摄像头"><a href="#使能摄像头" class="headerlink" title="使能摄像头"></a>使能摄像头</h3><h4 id="1、首先使用”ls”指令来查看是否存在vchiq设备节点："><a href="#1、首先使用”ls”指令来查看是否存在vchiq设备节点：" class="headerlink" title="1、首先使用”ls”指令来查看是否存在vchiq设备节点："></a>1、首先使用”ls”指令来查看是否存在vchiq设备节点：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">linux@ubuntu:~$ ls /dev</span><br><span class="line">pi@raspberrypi:~ $ ls  /dev/</span><br><span class="line">autofs           disk       gpiomem  loop3             mmcblk0             ptmx   ram15  random   stdout  tty15  tty23  tty31  tty4   tty48  tty56  tty7       vchiq   vcs6   vcsa7</span><br><span class="line">block            dri        hwrng    loop4             mmcblk0p1           pts    ram2   raw      tty     tty16  tty24  tty32  tty40  tty49  tty57  tty8       vcio    vcs7   vcsm</span><br><span class="line">btrfs-control    fb0        initctl  loop5             mmcblk0p2           ram0   ram3   rfkill   tty0    tty17  tty25  tty33  tty41  tty5   tty58  tty9       vc-mem  vcsa   vhci</span><br><span class="line">bus              fd         input    loop6             mqueue              ram1   ram4   serial0  tty1    tty18  tty26  tty34  tty42  tty50  tty59  ttyAMA0    vcs     vcsa1  watchdog</span><br><span class="line">cachefiles       full       kmsg     loop7             net                 ram10  ram5   serial1  tty10   tty19  tty27  tty35  tty43  tty51  tty6   ttyprintk  vcs1    vcsa2  watchdog0</span><br><span class="line">char             fuse       log      loop-control      network_latency     ram11  ram6   shm      tty11   tty2   tty28  tty36  tty44  tty52  tty60  ttyS0      vcs2    vcsa3  zero</span><br><span class="line">console          gpiochip0  loop0    mapper            network_throughput  ram12  ram7   snd      tty12   tty20  tty29  tty37  tty45  tty53  tty61  uhid       vcs3    vcsa4</span><br><span class="line">cpu_dma_latency  gpiochip1  loop1    mem               null                ram13  ram8   stderr   tty13   tty21  tty3   tty38  tty46  tty54  tty62  uinput     vcs4    vcsa5</span><br><span class="line">cuse             gpiochip2  loop2    memory_bandwidth  ppp                 ram14  ram9   stdin    tty14   tty22  tty30  tty39  tty47  tty55  tty63  urandom    vcs5    vcsa6</span><br><span class="line">pi@raspberrypi:~ $  </span><br></pre></td></tr></table></figure><p>如果没有，则可能是内核或者设备硬件存在问题，可尝试重刷系统或更换硬件。</p><h4 id="2、运行”vcgencmd-get-camera”查看当前摄像头是否可用："><a href="#2、运行”vcgencmd-get-camera”查看当前摄像头是否可用：" class="headerlink" title="2、运行”vcgencmd get_camera”查看当前摄像头是否可用："></a>2、运行”vcgencmd get_camera”查看当前摄像头是否可用：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~$ vcgencmd get_camera</span><br><span class="line">supported=1 detected=1&quot;</span><br></pre></td></tr></table></figure><p>如果detected&#x3D;0，说明摄像头模块没接好，重新排查下硬件。detected&#x3D;1则说明CSI摄像头接入正常。supported&#x3D;1说明摄像头已经使能，摄像头已经可以使用。supported&#x3D;1则说明CSI摄像头没有使能。需要使能下摄像头模块。</p><h4 id="3、运行”sudo-raspi-config”命令使能树莓派CSI摄像头"><a href="#3、运行”sudo-raspi-config”命令使能树莓派CSI摄像头" class="headerlink" title="3、运行”sudo raspi-config”命令使能树莓派CSI摄像头"></a>3、运行”sudo raspi-config”命令使能树莓派CSI摄像头</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ sudo raspi-config </span><br></pre></td></tr></table></figure><blockquote><img src="././images/640-16516753824922-1748585431991-74.png" alt="图片" style="zoom:67%;"></blockquote><blockquote><img src="././images/640-16516753824923-1748585431992-75.png" alt="图片" style="zoom:67%;"></blockquote><blockquote><img src="././images/640-16516753824934-1748585431992-76.png" alt="图片" style="zoom:67%;"></blockquote><blockquote><img src="././images/640-16516753824935-1748585431992-77.png" alt="图片" style="zoom:67%;"></blockquote><p>然后重启下树莓派</p><h3 id="添加UVC驱动"><a href="#添加UVC驱动" class="headerlink" title="添加UVC驱动"></a>添加UVC驱动</h3><p>有些程序采用V4L2编程，会访问到&#x2F;dev&#x2F;videoX设备，因此需要添加UVC驱动，针对树莓派3B&#x2F;3B+可以采用如下的方法添加bcm2835-v4l2驱动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~$ vim.tiny /etc/modules</span><br><span class="line"># /etc/modules: kernel modules to load at boot time.</span><br><span class="line">#</span><br><span class="line"># This file contains the names of kernel modules that should be loaded</span><br><span class="line"># at boot time, one per line. Lines beginning with &quot;#&quot; are ignored.</span><br><span class="line"></span><br><span class="line">i2c-dev</span><br><span class="line">bcm2835-v4l2</span><br></pre></td></tr></table></figure><p>然后重启即可在&#x2F;dev&#x2F;目录下看到videoX（X为数字编号,如0）的驱动</p><h3 id="使用rapistill命令拍照"><a href="#使用rapistill命令拍照" class="headerlink" title="使用rapistill命令拍照"></a>使用rapistill命令拍照</h3><p>运行**”raspistill -o image.jpg”**即可成功拍照并保存，更多参数使用raspistill –help</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ raspistill -o image.jpg</span><br></pre></td></tr></table></figure><p>将image.jpg图片传输到windows桌面打开， 即可看到拍照出来的效果，如</p><h2 id="【树莓派】扩展root分区"><a href="#【树莓派】扩展root分区" class="headerlink" title="【树莓派】扩展root分区"></a>【树莓派】扩展root分区</h2><p>最近用安装魔镜，老是提醒我root分区已满，我还总是不信，因为自己用的是16G的内存卡，结果一查看确实不足了。</p><p>输入 df -h</p><blockquote><p><img src="/././images/cb9ba1b5c1a8b9e65f383e1ae50ed585-11831-1748585431992-78" alt="img"></p></blockquote><p>原来我的root只被分到4.5个G啊，这还是我重新烧录系统后的结果。</p><p>更改分区有风险，我就因为更改一次而系统崩溃启动不了，所以请大家跟我一步一步操作。</p><h3 id="1、进入分区管理"><a href="#1、进入分区管理" class="headerlink" title="1、进入分区管理"></a>1、进入分区管理</h3><p>输入 sudo fdisk &#x2F;dev&#x2F;mmcblk0 </p><p>输入p，看到两个分区，第一个分区不要动，我们改动第二个分区。</p><p>注意，记住&#x2F;dev&#x2F;mmcblk0p2的start起始块数，我的为98304。</p><blockquote><p><img src="/././images/2a0e6b3a9e49a81f6063231382d521e8-18310-1748585431992-79" alt="img"></p></blockquote><h3 id="2、删除分区"><a href="#2、删除分区" class="headerlink" title="2、删除分区"></a>2、删除分区</h3><p>输入d ， 再输入2，删除第二分区</p><p>接着输入p，确认只剩下一个分区</p><blockquote><p><img src="/././images/3f0e9b5cd5dd5fa469ad45d8f1984e03-13926-1748585431992-80" alt="img"></p></blockquote><h3 id="3、创建分区"><a href="#3、创建分区" class="headerlink" title="3、创建分区"></a>3、创建分区</h3><p>输入n，创建一个分区</p><blockquote><p><img src="/././images/6c44757c91a5595c3519b9785cdabf5c-3853-1748585431992-81" alt="img"></p></blockquote><p>输入p，建立主分区</p><p>输入2，输入起始块数98304</p><p>接着回车，默认能够分配到最大</p><p>最后输入y，确认</p><blockquote><p><img src="/././images/54f7c3bf7131d66ea4c1b92085059dc2-9604-1748585431992-82" alt="img"></p></blockquote><h3 id="4、保存并重启"><a href="#4、保存并重启" class="headerlink" title="4、保存并重启"></a>4、保存并重启</h3><p>输入w，保存更改</p><p>输入sudo reboot，重启</p><blockquote><p><img src="/././images/abc497433aeef314ce2212af96a4bff7-7345-1748585431992-83" alt="img"></p></blockquote><h3 id="5、修护分区"><a href="#5、修护分区" class="headerlink" title="5、修护分区"></a>5、修护分区</h3><p>输入sudo resize2fs &#x2F;dev&#x2F;mmcblk0p2</p><blockquote><p><img src="/././images/77b309ec33b9186bedc253ae2b6c0f95-8173-1748585431992-84" alt="img"></p></blockquote><p>最后再查看一下</p><p>输入df -h</p><blockquote><p><img src="/././images/f0113c097eaadd09f7e7fc517e277ee3-11624-1748585431992-85" alt="img"></p></blockquote><p>看到我们的root分区已经被扩展到15G了。</p><p>如果以后出现安装不了文件的情况，请尝试输入sudo apt-get update 和 sudo apt-get upgrade。</p><h2 id="【树莓派】apt更改镜像源"><a href="#【树莓派】apt更改镜像源" class="headerlink" title="【树莓派】apt更改镜像源"></a>【树莓派】apt更改镜像源</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>原理就是使用国内的镜像源，代替国外的镜像源。</p><p>有两个推荐的源：</p><ul><li>清华大学镜像：<a href="https://links.jianshu.com/go?to=https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/">https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/</a></li><li>阿里云镜像：<a href="https://links.jianshu.com/go?to=https://mirrors.aliyun.com/raspbian/raspbian/">https://mirrors.aliyun.com/raspbian/raspbian/</a></li></ul><p><strong>1.备份原系统的apt的源镜像列表</strong></p><p>sudo cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.bak</p><p><strong>2.编辑sources.list 文件</strong></p><p>sudo vim &#x2F;etc&#x2F;apt&#x2F;sources.list</p><p><strong>3.注释掉原来的内容，添加以下内容：</strong></p><p>deb <a href="http://mirrors.aliyun.com/raspbian/raspbian/">http://mirrors.aliyun.com/raspbian/raspbian/</a> buster main contrib non-free rpi</p><p>deb-src <a href="http://mirrors.aliyun.com/raspbian/raspbian/">http://mirrors.aliyun.com/raspbian/raspbian/</a> buster main contrib non-free rpi</p><p><strong>注意：这里编辑的时候需要注意版本（只需要更换链接部分的内容就可以）</strong></p><p><strong>sudo apt-get install screenfetch</strong></p><p><strong>screenfetch &#x2F;&#x2F;查看当前版本信息</strong></p><table><thead><tr><th>Debian版本</th><th>对应名称</th></tr></thead><tbody><tr><td>Debian7</td><td>wheezy</td></tr><tr><td>Debian8</td><td>jessie</td></tr><tr><td>Debian9</td><td>stretch</td></tr><tr><td>Debian10</td><td>buster</td></tr></tbody></table><p>保存退出。</p><p>再执行 sudo apt-get update 和 sudo apt-get upgrade，就能看到加速效果了</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">\#将原有内容用#注释掉</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/raspbian/raspbian/ buster main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/raspbian/raspbian/ buster main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">sudo nano /etc/apt/sources.list.d/raspi.list</span><br><span class="line"></span><br><span class="line">\#将原有内容用#注释掉</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/raspbian/raspbian/ buster main</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/raspbian/raspbian/ buster main</span><br></pre></td></tr></table></figure><p>更新</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-mark hold raspberrypi-bootloader //锁住内核和驱动</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get upgrade -y</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">1.编辑sources.list</span><br><span class="line"></span><br><span class="line">打开终端 输入</span><br><span class="line"></span><br><span class="line">sudo nano /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">用#注释或直接删除原有的内容，新增两条：</span><br><span class="line"></span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">\#deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">ctrl+x 保存并退出。</span><br><span class="line"></span><br><span class="line">编辑raspi.list</span><br><span class="line"></span><br><span class="line">sudo nano /etc/apt/sources.list.d/raspi.list</span><br><span class="line"></span><br><span class="line">用#注释或直接删除原有的内容，新增两条：</span><br><span class="line"></span><br><span class="line">deb http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ stretch main ui</span><br><span class="line"></span><br><span class="line">\#deb-src http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ stretch main ui</span><br><span class="line"></span><br><span class="line">ctrl+x 保存并退出。</span><br><span class="line"></span><br><span class="line">更新软件源列表：</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">我的设置：</span><br><span class="line"></span><br><span class="line">\#deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">\#deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">\#deb http://mirrors.zju.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">\#deb-src http://mirrors.zju.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">\#deb http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">\# Uncomment line below then &#x27;apt-get update&#x27; to enable &#x27;apt-get source&#x27;</span><br><span class="line"></span><br><span class="line">\#deb-src http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">\#deb http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ stretch main ui</span><br><span class="line"></span><br><span class="line">\#deb-src http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ stretch main ui</span><br><span class="line"></span><br><span class="line">\#deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/ stretch main ui</span><br><span class="line"></span><br><span class="line">\#deb-src http://mirrors.ustc.edu.cn/archive.raspberrypi.org/ stretch main ui</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/raspbian/raspbian/ stretch main</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/raspbian/raspbian/ stretch main</span><br><span class="line"></span><br><span class="line">\#deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/ stretch main ui</span><br><span class="line"></span><br><span class="line">\#deb http://archive.raspberrypi.org/debian/ buster main</span><br><span class="line"></span><br><span class="line">\# Uncomment line below then &#x27;apt-get update&#x27; to enable &#x27;apt-get source&#x27;</span><br><span class="line"></span><br><span class="line">\#deb-src http://archive.raspberrypi.org/debian/ buster main</span><br></pre></td></tr></table></figure><h2 id="【树莓派】登录与连接方法"><a href="#【树莓派】登录与连接方法" class="headerlink" title="【树莓派】登录与连接方法"></a>【树莓派】登录与连接方法</h2><p>默认情况，树莓派的串口和蓝牙连接。</p><p>想办法断开蓝牙连接，把串口用来数据通信</p><p><a href="https://blog.csdn.net/syjsxxjy/article/details/80774262">https://blog.csdn.net/syjsxxjy/article/details/80774262</a></p><ol><li><strong>观看树莓派的启动过程，字符</strong></li><li><strong>串口登录树莓派</strong></li></ol><blockquote><img src="././images/8db6125e6ce01661317a9c9b848913be-37781-1748585431992-86" alt="img" style="zoom:67%;"></blockquote><blockquote><p>默认账号：pi</p><p>默认密码：raspberry</p></blockquote><h3 id="配置方法-1"><a href="#配置方法-1" class="headerlink" title="配置方法 1"></a>配置方法 1</h3><p>首先查看wlan0是否连接，连接的情况下会展示连接的无线网名称和状态，没有连接会输出”Not connected”</p><p>iw wlan0 link</p><p>检索附近的无线网络名称</p><p>sudo iwlist wlan0 scan | grep ESSID</p><p>在选择某个无线网名称时会在配置文件中进行修改，如果是只读文件的话需要先赋予读写权限sudo chmod 666 &#x2F;etc&#x2F;wpa_supplicant&#x2F;wpa_supplicant.conf 再修改</p><p>vi &#x2F;etc&#x2F;wpa_supplicant&#x2F;wpa_supplicant.conf</p><p>如果需要更换网络，将原先的network这组数据注释，添加新的网络</p><p>修改完网络之后需要先停用后启用</p><p>sudo ifdown wlan0 关闭（down）wlan0端口</p><p>sudo ifup wlan0 启用（up）wlan0端口</p><p>如果密码不对，就会连接不上。请确认密码是否正确</p><p>查看网络是否连接成功，IP地址是否分配</p><p>ifconfig wlan0</p><p>这样算是重新连接成功</p><p>ifconfig不到wlan0相关信息</p><p>我们所使用的 Raspberry-pi-os是2020最新版本，无论哪个版本的树莓派装了这个后，用ifconfig指令都看不到wlan无线网络的信息，但是用sudo ifconfig -a可以看到有wlan0，</p><p>那就证明我们的网卡驱动没问题，只是无线射频被锁起来了，使用rfkill list查看是否关闭射频：</p><p>我这有一个被锁住了，需要打开它：rfkill unblock all，全部打开，再ifconfig 看看</p><h3 id="配置方法-2"><a href="#配置方法-2" class="headerlink" title="配置方法 2"></a>配置方法 2</h3><p><strong>打开ssh功能</strong></p><p>sudo raspi-config</p><p>修改  <a href="https://blog.csdn.net/qq_36760780/article/details/82016711">https://blog.csdn.net/qq_36760780/article/details/82016711</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/wpa_supplicant/wpa_supplicant.conf</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line"></span><br><span class="line">    ssid=&quot;wifipig&quot;</span><br><span class="line"></span><br><span class="line">    psk=&quot;123456789&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><img src="././images/d3b10475d315a458ee302b2ba0529517-11243-1748585431992-87" alt="img" style="zoom:67%;"></blockquote><p>Nano是文档编辑器，已进入便可以编写。</p><p>Ctrl+o 保存<strong>，</strong>会有提示是否写入。我们按回车。Ctrl+x退出</p><p>固定树莓派的ip地址&#x3D;&#x3D;（错误方式，只是障眼法，并未改变实际ip地址）&#x3D;&#x3D;</p><p>sudo nano   &#x2F;etc&#x2F;rc.local</p><blockquote><img src="././images/3a77cdc11fc86e07ef3970e847cdb8d8-7242-1748585431992-88" alt="img" style="zoom:67%;"></blockquote><h3 id="Xrdp界面登录"><a href="#Xrdp界面登录" class="headerlink" title="Xrdp界面登录"></a>Xrdp界面登录</h3><p>sudo apt-get install xrdp</p><p>安装好之后通过win10的远程电脑登录即可。</p><blockquote><p><img src="/././images/cbf2211488fd1b66315ae091fe1d7ada-2352-1748585431992-89" alt="img"></p></blockquote><h3 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h3><p>使用filezilla软件</p><p>连接主机的IP地址前加上sftp:&#x2F;&#x2F;即可稳定连接<a href="sftp://192.168.3.104/">sftp://192.168.3.104</a></p><h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><p>cmdline.txt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console=serial0,115200 console=tty1 root=PARTUUID=f4481065-02 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait quiet init=/usr/lib/raspi-config/init_resize.sh splash plymouth.ignore-serial-consoles</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>config.txt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">For more options and information see</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http://rpf.io/configtxt</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Some settings may impact device functionality. See <span class="built_in">link</span> above <span class="keyword">for</span> details</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uncomment <span class="keyword">if</span> you get no picture on HDMI <span class="keyword">for</span> a default <span class="string">&quot;safe&quot;</span> mode</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hdmi_safe=1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uncomment this <span class="keyword">if</span> your display has a black border of unused pixels visible</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and your display can output without overscan</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">disable_overscan=1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uncomment the following to adjust overscan. Use positive numbers <span class="keyword">if</span> console</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">goes off screen, and negative <span class="keyword">if</span> there is too much border</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">overscan_left=16</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">overscan_right=16</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">overscan_top=16</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">overscan_bottom=16</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uncomment to force a console size. By default it will be display<span class="string">&#x27;s size minus</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">overscan.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">framebuffer_width=1280</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">framebuffer_height=720</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">uncomment if hdmi display is not detected and composite is being output</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">hdmi_force_hotplug=1</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">uncomment to force a specific HDMI mode (this will force VGA)</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">hdmi_group=1</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">hdmi_mode=1</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">uncomment to force a HDMI mode rather than DVI. This can make audio work in</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">DMT (computer monitor) modes</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">hdmi_drive=2</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">uncomment to increase signal to HDMI, if you have interference, blanking, or</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">no display</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">config_hdmi_boost=4</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">uncomment for composite PAL</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">sdtv_mode=2</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">uncomment to overclock the arm. 700 MHz is the default.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">arm_freq=800</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Uncomment some or all of these to enable the optional hardware interfaces</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">dtparam=i2c_arm=on</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">dtparam=i2s=on</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">dtparam=spi=on</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Uncomment this to enable infrared communication.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">dtoverlay=gpio-ir,gpio_pin=17</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">dtoverlay=gpio-ir-tx,gpio_pin=18</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Additional overlays and parameters are documented /boot/overlays/README</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Enable audio (loads snd_bcm2835)</span></span></span><br><span class="line">dtparam=audio=on</span><br><span class="line"></span><br><span class="line">[pi4]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Enable DRM VC4 V3D driver on top of the dispmanx display stack</span></span></span><br><span class="line">dtoverlay=vc4-fkms-v3d</span><br><span class="line">max_framebuffers=2</span><br><span class="line"></span><br><span class="line">[all]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">dtoverlay=vc4-fkms-v3d</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派交叉编译与内核编译完全指南</title>
      <link href="/2022/01/01/test/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2022/01/01/test/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="树莓派交叉编译-内核编译-HQ"><a href="#树莓派交叉编译-内核编译-HQ" class="headerlink" title="树莓派交叉编译 &amp; 内核编译 - HQ"></a>树莓派交叉编译 &amp; 内核编译 - HQ</h1><p>[TOC]</p><hr><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>- </p><hr><h1 id="树莓派交叉编译"><a href="#树莓派交叉编译" class="headerlink" title="树莓派交叉编译"></a>树莓派交叉编译</h1><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p><strong>为什么要交叉编译</strong></p><ol><li><p>因为目的平台上的资源贫乏，无法运行我们所需要编译器，平台上不允许或不能够安装我们所需要的编译器比如C51。</p></li><li><p>树莓派有时又是因为目的平台还没有建立，连操作系统都没有，根本谈不上运行什么编译器。操作系统也是代码，也要编译。</p></li></ol><blockquote><p>平台运行需要两样至少东西：bootloader（启动引导代码）以及操作系统核心</p><p>宿主机（host） ：编辑和编译程序的平台，一般是基于X86的PC机，通常也被称为主机。</p><p>目标机（target）：用户开发的系统，通常都是非X86平台。host编译得到的可执行代码在target上运行。</p></blockquote><p><strong>交叉编译需要用到什么工具</strong></p><p>交叉编译器、交叉编译工具链</p><h3 id="交叉编译工具链的安装"><a href="#交叉编译工具链的安装" class="headerlink" title="交叉编译工具链的安装"></a>交叉编译工具链的安装</h3><p><a href="https://github.com/raspberrypi/">https://github.com/raspberrypi/</a></p><ol><li>从共享文件夹拷贝到工作目录  <code>cp /mnt/hgfs/share/tools-master.zip .</code></li><li>解压  <code>unzip tools-master.zip</code></li><li>&#96;&#96;cd &#x2F;home&#x2F;CLC&#x2F;lessonPI&#x2F;tools-master&#x2F;arm-bcm2708&#x2F;gcc-linaro-arm-linux-gnueabihf-raspbian-x64&#x2F;bin&#96;</li><li><code>pwd</code>获得路径</li><li><code>echo $PATH</code> 获得当前环境变量的值</li></ol><p><strong>临时有效，配置环境变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PATH 环境变量</span><br><span class="line"></span><br><span class="line">export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/home/CLC/lessonPI/tools-master/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin</span><br></pre></td></tr></table></figure><p><strong>永久有效，配置环境变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修改工作目录下的.bashrc 隐藏文件，配置命令终端的  vi /home/CLC/.bashrc</span><br><span class="line"></span><br><span class="line">在文件最后一行加入：</span><br><span class="line"></span><br><span class="line">export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/home/CLC/lessonPI/tools-master/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin</span><br><span class="line"></span><br><span class="line">source /home/CLC/.bashrc 加载配置文件，马上生效配置。</span><br></pre></td></tr></table></figure><blockquote><p><img src="/././images/bf23abb9335c7529fe25d8eb3ffa5024-42710-1748585374057-1" alt="img"></p></blockquote><p>将安装路径添加到PATH中，添加到.bashrc的结尾即可</p><blockquote><p><img src="/././images/a3538b7515fa89f7810eff02416638ae-62196-1748585374057-2" alt="img"></p></blockquote><blockquote><p><img src="/././images/6c7d0cf21d41865a112762b2a5de831e-9882-1748585374057-3" alt="img"></p></blockquote><h3 id="交叉编译使用举例"><a href="#交叉编译使用举例" class="headerlink" title="交叉编译使用举例"></a>交叉编译使用举例</h3><p>交叉编译：检查下交叉编译工具对不对 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc -v    4.8.3  </span><br><span class="line">arm-linux-gnueabihf-gcc xxx.c -o xxx</span><br></pre></td></tr></table></figure><p>如何把编译生成的可执行文件下载到开发板  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 指令 文件名 开发板用户名@开发板地址：开发板的绝对路径</span><br><span class="line">scp clientInPi pi@192.168.43.30:/home/pi</span><br></pre></td></tr></table></figure><h1 id="树莓派源码分析-内核编译-简略"><a href="#树莓派源码分析-内核编译-简略" class="headerlink" title="树莓派源码分析 &amp; 内核编译 - 简略"></a>树莓派源码分析 &amp; 内核编译 - 简略</h1><h3 id="Linux内核源代码目录树结构"><a href="#Linux内核源代码目录树结构" class="headerlink" title="Linux内核源代码目录树结构"></a>Linux内核源代码目录树结构</h3><p><strong>arch：</strong>包含和硬件体系结构相关的代码，每种平台占一个相应的目录。和32位PC相关的代码存放在i386目录下，其中比较重要的包括kernel（内核核心部分）、mm（内存管理）、math-emu（浮点单元仿真）、lib（硬件相关工具函数）、boot（引导程序）、pci（PCI总线）和power（CPU相关状态）。</p><p><strong>block：</strong>部分块设备驱动程序。</p><p><strong>crypto：</strong>常用加密和散列算法（如AES、SHA等），还有一些压缩和CRC校验算法。</p><p><strong>Documentation：</strong>关于内核各部分的通用解释和注释。</p><p><strong>drivers：</strong>设备驱动程序，每个不同的驱动占用一个子目录。</p><p><strong>fs：</strong>各种支持的文件系统，如ext、fat、ntfs等。</p><p><strong>include：</strong>头文件。其中，和系统相关的头文件被放置在linux子目录下。</p><p><strong>init：</strong>内核初始化代码（注意不是系统引导代码）。</p><p><strong>ipc：</strong>进程间通信的代码。</p><p><strong>kernel：</strong>内核的最核心部分，包括进程调度、定时器等，和平台相关的一部分代码放在arch&#x2F;*&#x2F;kernel目录下。</p><p><strong>lib：</strong>库文件代码。</p><p><strong>mm：</strong>内存管理代码，和平台相关的一部分代码放在arch&#x2F;*&#x2F;mm目录下。</p><p><strong>net：</strong>网络相关代码，实现了各种常见的网络协议。</p><p><strong>scripts：</strong>用于配置内核文件的脚本文件。</p><p><strong>security：</strong>主要是一个SELinux的模块。</p><p><strong>sound：</strong>常用音频设备的驱动程序等。</p><p><strong>usr：</strong>实现了一个cpio。</p><p>在i386体系下，系统引导将从<code>arch/i386/kernel/head.s</code>开始执行，并进而转移到<code>init/main.c</code>中的<code>main()函数</code>初始化内核。</p><h3 id="树莓派Linux源码配置"><a href="#树莓派Linux源码配置" class="headerlink" title="树莓派Linux源码配置"></a>树莓派Linux源码配置</h3><p><strong><code>.config</code>文件是linux内核配置文件，当执行#make uImage编译生成内核时，顶层的Makefile会读取<code>.config</code>文件的内容，根据这个配置文件来编译所定制的内核。</strong></p><p>内核源码配置的三种方式</p><ol><li>根据厂家提供的Linux内核源码，进行修改，<code>厂家.config</code>-&gt;<code>自己.config</code></li><li><code>make menuconfig</code> 进行配置，通常是基于厂家的config来配置。</li><li>完全自己开发</li></ol><h3 id="内核编译-详细过程参考下一章"><a href="#内核编译-详细过程参考下一章" class="headerlink" title="内核编译 - 详细过程参考下一章"></a>内核编译 - 详细过程参考下一章</h3><p><strong>1.编译内核</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make -j4 zImage modules dtbs</span><br></pre></td></tr></table></figure><blockquote><p><code>-j4</code> 指定用多少电脑资源进行编译</p><p><code>zImage</code> 生成内核镜像</p><p><code>modules</code> 要生成驱动模块</p><p><code>dtbs</code> 生成配置文件（设备树）</p></blockquote><p><strong>2.编译成功后</strong></p><p>看到源码树目录多了vmlinux，失败则无此文件，成功后，目标zImage镜像arch&#x2F;arm&#x2F;boot底下。</p><p><strong>3.打包zImage成树莓派可用的xxx.img</strong></p><p>直接用linux源码包里的工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./scripts/mkknlimg arch/arm/boot/zImage ./kernel_new.img</span><br></pre></td></tr></table></figure><p><strong>4.数据拷贝</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir data1 data2</span><br></pre></td></tr></table></figure><p>挂载U盘</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/sdb1 data1  一个fat分区，是boot相关的内容，kernel的img</span><br><span class="line">sudo mount /dev/sdb2 data2  一个是ext4分区，也就是系统的根目录分区。</span><br></pre></td></tr></table></figure><p>安装modules, 设备驱动文件，如 hdmi usb wifi io …</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make INSTALL_MOD_PATH=/home/chenlc/data2 modules_install</span><br></pre></td></tr></table></figure><p>安装更新 kernel.img 文件，注意镜像名字是kernel7.img</p><p>再把编译新生成的拷贝到data1，起名kernel7.img</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp kernel_new.img /home/chenlc/data1/kernel7.img</span><br></pre></td></tr></table></figure><p>拷贝配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp arch/arm/boot/dts/.*dtb* /home/chenlc/data1</span><br></pre></td></tr></table></figure><p>后面步骤参考下一章</p><blockquote><p><img src="/././images/6a13d650389171ea0e9f2e726c339f0f-5095752-1748585374057-4" alt="img"></p></blockquote><h1 id="树莓派交叉编译-本地编译-详细"><a href="#树莓派交叉编译-本地编译-详细" class="headerlink" title="树莓派交叉编译 &amp; 本地编译 - 详细"></a>树莓派交叉编译 &amp; 本地编译 - 详细</h1><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>树莓派的github主页：<a href="https://github.com/raspberrypi%EF%BC%8C%E9%87%8C%E9%9D%A2%E5%8C%85%E5%90%AB%E4%BA%86linux%E6%BA%90%E7%A0%81%E3%80%81%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E7%AD%89%E5%86%85%E5%AE%B9%E3%80%82">https://github.com/raspberrypi，里面包含了linux源码、交叉编译工具链等内容。</a></p><p>对于我们要用到的有两个仓库：</p><p><a href="https://github.com/raspberrypi/linux">https://github.com/raspberrypi/linux</a> 内核源码</p><p><a href="https://github.com/raspberrypi/tools">https://github.com/raspberrypi/tools</a> 交叉编译工具链（仅在交叉编译时用到）</p><p>注：<br>1、树莓派里安装的系统镜像版本要和kernel代码对应。因为树莓派系统是在不断开发和升级的，如果你的树莓派使用的是某个时间的系统镜像，那么最好也使用当时的kernel代码。<br>2、关于内核编译方法，官网有很详细的介绍：<a href="https://www.raspberrypi.org/documentation/linux/kernel/building.md%EF%BC%8C%E8%BF%99%E9%87%8C%E7%AE%97%E6%98%AF%E7%BF%BB%E8%AF%91%E5%92%8C%E8%A1%A5%E5%85%85%E3%80%82">https://www.raspberrypi.org/documentation/linux/kernel/building.md，这里算是翻译和补充。</a><br>3、以下编译过程在树莓派1和树莓派3B上测试ok。</p><h3 id="二、ubuntu里交叉编译"><a href="#二、ubuntu里交叉编译" class="headerlink" title="二、ubuntu里交叉编译"></a>二、ubuntu里交叉编译</h3><h4 id="1、获取交叉编译工具和源码"><a href="#1、获取交叉编译工具和源码" class="headerlink" title="1、获取交叉编译工具和源码"></a>1、获取交叉编译工具和源码</h4><p>源码：<strong>git clone <a href="mailto:&#x67;&#x69;&#116;&#x40;&#x67;&#105;&#116;&#x68;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;">&#x67;&#x69;&#116;&#x40;&#x67;&#105;&#116;&#x68;&#117;&#98;&#x2e;&#x63;&#x6f;&#x6d;</a>:raspberrypi&#x2F;linux</strong></p><p>交叉编译工具：<strong>git clone <a href="mailto:&#103;&#105;&#116;&#x40;&#103;&#x69;&#116;&#x68;&#117;&#98;&#46;&#x63;&#111;&#109;">&#103;&#105;&#116;&#x40;&#103;&#x69;&#116;&#x68;&#117;&#98;&#46;&#x63;&#111;&#109;</a>:raspberrypi&#x2F;tools</strong></p><h4 id="2、配置编译环境变量"><a href="#2、配置编译环境变量" class="headerlink" title="2、配置编译环境变量"></a>2、配置编译环境变量</h4><h5 id="2-1-手动配置环境变量"><a href="#2-1-手动配置环境变量" class="headerlink" title="2.1 手动配置环境变量"></a>2.1 手动配置环境变量</h5><p>编译工具下载后，在64位ubuntu上编译我们需要的编译工具bin文件在：<code>tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin</code> 目录下，将此目录添加到环境变量PATH中，添加方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=$PATH:/home/nicek/githubProjects/raspberrypi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin</span><br></pre></td></tr></table></figure><p>如果是在32位系统中编译则要选择32位的交叉编译工具。</p><p>配置完成之后可以用编译工具命令查看到版本号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc -v</span><br></pre></td></tr></table></figure><p>之后，所有的make命令都要指明一些环境变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7</span><br></pre></td></tr></table></figure><table><thead><tr><th>ARCH&#x3D;arm</th><th>指明当前要编译arm，虽然树莓派是64位的，这里仍然选择arm，而不是arm64。</th></tr></thead><tbody><tr><td>CROSS_COMPILE</td><td>指明交叉工具链名称。</td></tr><tr><td>KERNEL</td><td>指明kernel类型，<strong>树莓派1设置为kernel，树莓派2、3设置为kernel7。</strong></td></tr></tbody></table><p>每次make都需要指明这些环境变量，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make menuconfig</span><br><span class="line">ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make -j4 zImage</span><br></pre></td></tr></table></figure><h5 id="2-2-自动配置环境变量"><a href="#2-2-自动配置环境变量" class="headerlink" title="2.2 自动配置环境变量"></a>2.2 自动配置环境变量</h5><p>上面这些环境变量每次命令都要写很麻烦，可以通过export一次设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/home/nicek/githubProjects/raspberrypi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7</span><br></pre></td></tr></table></figure><p>之后在本终端里执行的所有命令都带有这些环境变量信息。</p><p>此 export 命令可以写成一个脚本，然后在编译前在终端里source一下这个脚本即可设置好所有的环境变量。就像android编译前也要先source一下envsetup.sh一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash DIR=&quot;$( cd &quot;$( dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot; )&quot; &amp;&amp; pwd )&quot; export PATH=&quot;$PATH:$DIR/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin/&quot; export ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 </span><br></pre></td></tr></table></figure><p>上述命令中的路径可能和你实际不同，注意修改。</p><p>export环境变量后，在本终端里的后续命令都可以不用再指明这些环境变量，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">配置之前的命令：</span><br><span class="line">ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make menuconfig</span><br><span class="line">配置之后的命令：</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><h4 id="3、配置config"><a href="#3、配置config" class="headerlink" title="3、配置config"></a>3、配置config</h4><p>linux源码中有很多工程：<br>树莓派1的工程是<strong>bcmrpi_defconfig</strong><br>树莓派2、3的工程是<strong>bcm2709_defconfig</strong></p><h5 id="3-1-使用源码里自带的config"><a href="#3-1-使用源码里自带的config" class="headerlink" title="3.1 使用源码里自带的config"></a>3.1 使用源码里自带的config</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make bcm2709_defconfig</span><br></pre></td></tr></table></figure><blockquote><p><code>ARCH=ARM</code> 指定ARM架构</p><p><code>CROSS_COMPILE=arm-linux-gnueabihf-</code> 指定编译器</p><p><code>KERNEL=kernel7</code> 树莓派</p><p><code>make bcm2709_defconfig</code> 主要核心指令</p></blockquote><p>此命令功能是获取bcm2709_defconfig的配置到 .config里。<br>我们可以直接用工程里的配置，但这样的话可能会丢失原来使用的树莓派的配置，这里提供一个方法可以获取当前正在使用的树莓派的config。</p><h5 id="3-2-获取当前树莓派的config"><a href="#3-2-获取当前树莓派的config" class="headerlink" title="3.2 获取当前树莓派的config"></a>3.2 获取当前树莓派的config</h5><p>已经开机的树莓派上会有这个节点：**&#x2F;proc&#x2F;config.gz<strong>，从这个节点可以获取本树莓派的config。<br>如果没有这个节点的话则需要先加载模块：</strong>sudo modprobe configs**</p><p>把 config.gz 内容复制到要编译的电脑上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp pi@[ip]:/proc/config.gz .</span><br></pre></td></tr></table></figure><p>解压，保存为.confg文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcat config.gz &gt; .config</span><br></pre></td></tr></table></figure><p>注：必须在linux环境下解压，在mac下会乱码。</p><p>把此config文件复制到linux源码的根目录。</p><h4 id="4、编译"><a href="#4、编译" class="headerlink" title="4、编译"></a>4、编译</h4><p>安装必要的库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install bc</span><br><span class="line">sudo apt-get install libncurses5-dev libncursesw5-dev</span><br><span class="line">sudo apt-get install zlib1g:i386</span><br><span class="line">sudo apt-get install libc6-i386 lib32stdc++6 lib32gcc1 lib32ncurses5</span><br></pre></td></tr></table></figure><p><strong>4.1 执行menuconfig</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make menuconfig</span><br></pre></td></tr></table></figure><p>如果没什么改的就不用执行这一步。</p><p><strong>4.2 编译</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make -j4 zImage modules dtbs 2&gt;&amp;1 | tee build.log</span><br></pre></td></tr></table></figure><p>以n进程编译。不指明几进程的话则默认以单进程编译。</p><p><strong>4.3 打包zImage文件</strong></p><p>直接用linux源码包里的工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./scripts/mkknlimg arch/arm/boot/zImage ./kernel_new.img</span><br></pre></td></tr></table></figure><p>在本目录生成一个kernel_new.img文件，这个文件就是要放到sd卡中的文件。<br>注：网上很多地方说的用 tools&#x2F;mkimage&#x2F;imagetool-uncompressd.py 的方法不行！！</p><h4 id="5、挂载树莓派sd卡，并安装编译出的DIRECTLY-到sd卡"><a href="#5、挂载树莓派sd卡，并安装编译出的DIRECTLY-到sd卡" class="headerlink" title="5、挂载树莓派sd卡，并安装编译出的DIRECTLY 到sd卡"></a>5、挂载树莓派sd卡，并安装编译出的DIRECTLY 到sd卡</h4><p>把树莓派的sd卡插入ubuntu系统电脑，树莓派的sd卡有两个分区：<br>一个fat分区，是boot相关的内容，kernel的img文件就放在这个分区里；<br>一个是ext4分区，也就是系统的根目录分区。</p><p>我们生成的文件涉及到这两个分区的内容，一般插入ubuntu后会自动挂载，fat分区可以不用root权限操作，ext4分区需要root权限操作。<br>两个分区具体挂载在什么地方可以自己决定，以下用[fat]表示boot挂载的路径，[ext4]表示ext4挂载的路径。</p><p><strong>5.1 安装modules</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make INSTALL_MOD_PATH=[ext4] modules_install</span><br></pre></td></tr></table></figure><p>操作ext4分区，需要root权限。</p><p><strong>5.2 更新 kernel.img 文件</strong><br>前面已经用 mkknlimg 工具打包了kernel_new.img文件了，把它复制到boot分区并配置使用即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp kernel_new.img [fat]/</span><br></pre></td></tr></table></figure><p>编辑 [fat]&#x2F;config.txt 文件，在最后加入一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel=kernel_new.img</span><br></pre></td></tr></table></figure><p><strong>5.3 复制其他相关文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp arch/arm/boot/dts/*.dtb [fat]/</span><br><span class="line">cp arch/arm/boot/dts/overlays/*.dtb* [fat]/overlays/</span><br><span class="line">cp arch/arm/boot/dts/overlays/README [fat]/overlays/</span><br></pre></td></tr></table></figure><p>更新完成后插回树莓派即可开机，开机后可以用 uname -a 命令查看kernel信息已经改变。</p><h3 id="三、树莓派本地编译"><a href="#三、树莓派本地编译" class="headerlink" title="三、树莓派本地编译"></a>三、树莓派本地编译</h3><p>树莓派上本地编译和上面交叉编译原理基本相同，由于是本地编译，在编译工具和环境变量配置方面还简单一些。<br>树莓派上编一次内核花了将近2小时。</p><h4 id="1、获取源码"><a href="#1、获取源码" class="headerlink" title="1、获取源码"></a>1、获取源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:raspberrypi/linux</span><br></pre></td></tr></table></figure><h4 id="2、配置编译环境"><a href="#2、配置编译环境" class="headerlink" title="2、配置编译环境"></a>2、配置编译环境</h4><p>在ubuntu里交叉编译时需要配置的环境变量有：</p><ul><li>PATH: 添加交叉工具链的目录</li><li>ARCH: 配置成arm</li><li>CROSS_COMPILE: 配置成ubuntu上使用的交叉工具链arm-linux-gnueabihf- KERNEL&#x3D;kernel7</li><li>KERNEL: 配置成kernel7</li></ul><p>而在树莓派本地编译：<br>关于交叉工具链，本身的编译工具就可以编译给自己使用，所以不用配置；<br>只需要配置 KERNEL&#x3D;kernel7 即可。</p><p>和上面相同，可以用 export KERNEL&#x3D;kernel7，一次设置之后此终端里所有命令都带有此环境变量。<br>也可以更进一步写成脚本，不过这里这一行命令很简单，不写脚本也可以。</p><h4 id="3、配置config-1"><a href="#3、配置config-1" class="headerlink" title="3、配置config"></a>3、配置config</h4><p>和上面一样，<br>树莓派1使用的是 <strong>bcmrpi_defconfig</strong>，<br>树莓派2、3使用的是 <strong>bcm2709_defconfig</strong>。<br>例：KERNEL&#x3D;kernel7 make bcm2709_defconfig</p><p>如果要使用树莓派自带的config的话：<br><strong>sudo modprobe configs</strong> # 加载模块<br><strong>zcat config.gz &gt; .config</strong> # 获取配置</p><h4 id="4、编译-1"><a href="#4、编译-1" class="headerlink" title="4、编译"></a>4、编译</h4><p>安装必要的库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install bc</span><br><span class="line">sudo apt-get install libncurses5-dev libncursesw5-dev</span><br><span class="line">sudo apt-get install zlib1g</span><br><span class="line">sudo apt-get install libc6</span><br></pre></td></tr></table></figure><p>1、执行menuconfig<br><strong>KERNEL&#x3D;kernel7 make menuconfig</strong><br>没什么要改的话就不用执行这一步。</p><p>2、编译<br><strong>KERNEL&#x3D;kernel7 make -j4 zImage modules dtbs 2&gt;&amp;1 | tee build.log</strong><br>以n进程编译。不指明几进程的话则默认以单进程编译。</p><p>3、打包zImage文件<br>直接用linux源码包里的工具：<br><strong>.&#x2F;scripts&#x2F;mkknlimg arch&#x2F;arm&#x2F;boot&#x2F;zImage .&#x2F;kernel_new.img</strong><br>在本目录生成一个kernel_new.img文件，这个文件就是要放到sd卡中的文件。</p><h4 id="5、更新系统"><a href="#5、更新系统" class="headerlink" title="5、更新系统"></a>5、更新系统</h4><p>1、安装模块<br><strong>sudo make modules_install</strong></p><p>2、复制dtb文件<br><strong>sudo cp arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;*.dtb &#x2F;boot&#x2F; sudo cp arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;overlays&#x2F;*.dtb* &#x2F;boot&#x2F;overlays&#x2F; sudo cp arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;overlays&#x2F;README &#x2F;boot&#x2F;overlays&#x2F;</strong></p><p>3、更新kernel.img文件<br><strong>sudo cp arch&#x2F;arm&#x2F;boot&#x2F;zImage &#x2F;boot&#x2F;$KERNEL.img</strong></p><h1 id="树莓派Linux内核编译-编程那些年"><a href="#树莓派Linux内核编译-编程那些年" class="headerlink" title="树莓派Linux内核编译 - 编程那些年"></a>树莓派Linux内核编译 - 编程那些年</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzkzMDE4MDM2NQ==&mid=2247483946&idx=1&sn=c896dceca1b41e69705d0f5d1e439838&scene=19#wechat_redirect">编程那些年 - 文章</a></p><p>树莓派的Linux内核编译有两种方法: 一种是在树莓派上直接编译，另一种是利用交叉编译的方法。一般我们都推荐采用交叉编译的方式进行编译，这是因为通常交叉编译Pi内核的速度比Pi本身编译快得多（性能因素）。下面就讲下如下利用这两种方式来编译Pi内核。 </p><h3 id="第一种方法：Pi本地编译"><a href="#第一种方法：Pi本地编译" class="headerlink" title="第一种方法：Pi本地编译"></a>第一种方法：Pi本地编译</h3><p><strong>前提条件</strong></p><p>准备一张16G以上TF卡。</p><p>如果上述没有该条件，可以利用NFS挂载方式，将源码目录挂载到主机上，利用主机的空间来存储代码，但会影响到编译速度。 比如我将虚拟机的nfs目录挂载到Pi的&#x2F;mnt目录下，并在该目录下存储代码，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ mount | grep mnt</span><br><span class="line">192.168.1.133:/nfs/ on /mnt type nfs (rw,relatime,vers=3,rsize=524288,wsize=524288,namlen=255,hard,nolock,proto=tcp,port=2049,timeo=70,retrans=3,sec=sys,local_lock=all,addr=192.168.1.133)</span><br><span class="line">pi@raspberrypi:~ $ ls /mnt/</span><br><span class="line">linux</span><br><span class="line">pi@raspberrypi:~ $</span><br></pre></td></tr></table></figure><p><strong>编译前准备</strong></p><p>​    首先，配置好树莓派的网络<em>（用推荐用有线网络，否则下载会非常慢）</em>和树莓派的源（推荐使用阿里源，将<strong>“raspbian.raspberrypi.org”</strong>替换为<strong>“mirrors.aliyun.com&#x2F;raspbian”</strong>字段），正常souces.list前后替换后差异内容大致如下：</p><p><img src="/././images/640-1748585374057-5.png" alt="图片"></p><p>  安装git和树莓派内核编译所需的依赖库，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install git bc bison flex libssl-dev make</span><br></pre></td></tr></table></figure><p><strong>下载内核源码</strong></p><p>   利用git获取当前git仓库默认Pi的内核源码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --depth=1 https://github.com/raspberrypi/linux</span><br></pre></td></tr></table></figure><p>  当然，你也可以选择下载自己所需的内核源码版本，如需要下载4.14.y，可利用branch参数下载，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --depth=1 https://github.com/raspberrypi/linux --branch rpi-4.14.y</span><br></pre></td></tr></table></figure><p><strong>配置内核</strong></p><p>根据当前你使用的Raspberry Pi的实际型号，通过运行以下具体命令进行准备默认配置：</p><p>​    如果是Raspberry Pi 2, Pi 3, Pi 3+系列，默认配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:/mnt $ cd linux</span><br><span class="line">pi@raspberrypi:/mnt/linux $ KERNEL=kernel7</span><br><span class="line">pi@raspberrypi:/mnt/linux $ make bcm2709_defconfig</span><br></pre></td></tr></table></figure><p>Raspberry Pi 4的默认配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:/mnt $ cd linux</span><br><span class="line">pi@raspberrypi:/mnt/linux $ KERNEL=kernel7l</span><br><span class="line">pi@raspberrypi:/mnt/linux $ make bcm2711_defconfig</span><br></pre></td></tr></table></figure><p>Raspberry Pi 1、Pi Zero、Pi Zero W系列的默认采用配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:/mnt $ cd linux</span><br><span class="line">pi@raspberrypi:/mnt/linux $ KERNEL=kernel</span><br><span class="line">pi@raspberrypi:/mnt/linux $ make bcmrpi_defconfig</span><br></pre></td></tr></table></figure><p>​    如果需要额外对内核进行配置，则可以利用如下命令实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:/mnt/linux $ make menuconfig</span><br></pre></td></tr></table></figure><p> <strong>编译和安装</strong></p><p>​    最后进行编译安装内核、驱动模块、设备树配置操作，这个过程会比较漫长，需要耐心等待，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:/mnt/linux $ make -j4 zImage modules dtbs</span><br><span class="line">pi@raspberrypi:/mnt/linux $ sudo make modules_install</span><br><span class="line">pi@raspberrypi:/mnt/linux $ sudo cp arch/arm/boot/dts/*.dtb /boot/</span><br><span class="line">pi@raspberrypi:/mnt/linux $ sudo cp arch/arm/boot/dts/overlays/*.dtb* /boot/overlays/</span><br><span class="line">pi@raspberrypi:/mnt/linux $ sudo cp arch/arm/boot/dts/overlays/README /boot/overlays/</span><br><span class="line">pi@raspberrypi:/mnt/linux $ sudo cp arch/arm/boot/zImage /boot/$KERNEL.img</span><br><span class="line">pi@raspberrypi:/mnt/linux $  sudo reboot -f</span><br></pre></td></tr></table></figure><h3 id="第二种方法：交叉编译内核"><a href="#第二种方法：交叉编译内核" class="headerlink" title="第二种方法：交叉编译内核"></a>第二种方法：交叉编译内核</h3><p>首先，需要准备一台Linux交叉编译主机，比如Ubuntu 18.04（可以安装实体机或者VMware或VirtualBox里）。</p><p><strong>编译前准备</strong><br>首先在交叉编译Linux主机上安装所需的依赖和交叉编译工具，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git bc bison flex libssl-dev make libc6-dev libncurses5-dev</span><br></pre></td></tr></table></figure><p>如果Pi安装的是32的内核，则安装32位的交叉编译工具链：</p><p>（注：通过在Pi里运行<strong>“file &#x2F;sbin&#x2F;busybox”</strong> 或其他可执行程序可查看当前内核是32位还是64位的。如果是32位的，会显示如下32-bit 字段，否则为64位的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install crossbuild-essential-armhf</span><br></pre></td></tr></table></figure><p>否则，如果Pi使用的是64的内核，则安装64位的交叉编译工具链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install crossbuild-essential-arm64</span><br></pre></td></tr></table></figure><p><strong>获取源码</strong></p><p> 利用git获取当前git仓库默认Pi的内核源码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --depth=1 https://github.com/raspberrypi/linux</span><br></pre></td></tr></table></figure><p>  当然，你也可以选择下载自己所需的内核源码版本，如需要下载4.14.y，可利用branch参数下载，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --depth=1 https://github.com/raspberrypi/linux --branch rpi-4.14.y</span><br></pre></td></tr></table></figure><p><strong>配置内核</strong></p><p><strong>针对32位系统:</strong></p><p>如果是Pi 2, Pi 3, Pi 3+, 和3系列树莓派，运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux@ubuntu:~$ cd linux</span><br><span class="line">linux@ubuntu:~/linux$ KERNEL=kernel7</span><br><span class="line">linux@ubuntu:~/linux$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcm2709_defconfig</span><br></pre></td></tr></table></figure><p>如果是Raspberry Pi 4，运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux@ubuntu:~$ cd linux</span><br><span class="line">linux@ubuntu:~/linux$ KERNEL=kernel7l</span><br><span class="line">linux@ubuntu:~/linux$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcm2711_defconfig</span><br></pre></td></tr></table></figure><p>如果是Pi 1, Pi Zero, Pi Zero W，运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux@ubuntu:~$ cd linux</span><br><span class="line">linux@ubuntu:~/linux$ KERNEL=kernel</span><br><span class="line">linux@ubuntu:~/linux$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcmrpi_defconfig</span><br></pre></td></tr></table></figure><p><strong>针对64位系统：</strong></p><p>  如果是Pi 2, Pi 3, Pi 3+, 和3系列树莓派，运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux@ubuntu:~$ cd linux</span><br><span class="line">linux@ubuntu:~/linux$ KERNEL=kernel8</span><br><span class="line">linux@ubuntu:~/linux$ make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- bcmrpi3_defconfig</span><br></pre></td></tr></table></figure><p>如果是Raspberry Pi 4，运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux@ubuntu:~$ cd linux</span><br><span class="line">linux@ubuntu:~/linux$ KERNEL=kernel8</span><br><span class="line">linux@ubuntu:~/linux$ make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- bcm2711_defconfig</span><br></pre></td></tr></table></figure><p><strong>编译内核</strong></p><p>如果是32位内核，运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j4  ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage modules dtbs</span><br></pre></td></tr></table></figure><p>如果是64位内核，运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j4  ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- Image modules dtbs</span><br></pre></td></tr></table></figure><p><strong>内核安装到TF卡</strong></p><p>将TF卡接到Linux交叉编译主机上（如果是VMwar虚拟机，则需要将”设置-&gt;硬件-&gt;USB控制机-&gt;USB兼容性(C)”调成“USB 1.1”）</p><p>运行<strong>lsblk</strong>命令查看识别到的TF卡设备节点，如下：*</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">linux@ubuntu:~/linux$ lsblk</span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0   20G  0 disk </span><br><span class="line">└─sda1   8:1    0   20G  0 part /</span><br><span class="line">sdb      8:16   1 14.6G  0 disk </span><br><span class="line">├─sdb1   8:17   1  256M  0 part /media/linux/boot</span><br><span class="line">└─sdb2   8:18   1  3.3G  0 part /media/linux/rootfs</span><br></pre></td></tr></table></figure><p>正常TF卡设备会自动挂载到&#x2F;media&#x2F;${当前用户目录}&#x2F;下的boot和rootfs目录下，如果没有自动挂载，则根据识别到实际TF卡的设备节点，将设备挂载到主机上，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /media/linux/rootfs -p</span><br><span class="line">sudo mkdir /media/linux/boot -p</span><br><span class="line">sudo mount /dev/sdb1 /media/linux/boot</span><br><span class="line">sudo mount /dev/sdb2 /media/linux/rootfs</span><br></pre></td></tr></table></figure><p>​    然后将内核模块安装到SD中：</p><p>  如果是32位内核，运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo env PATH=$PATH make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- INSTALL_MOD_PATH=/media/linux/rootfs modules_install</span><br></pre></td></tr></table></figure><p>如果是64位内核，运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo env PATH=$PATH make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- INSTALL_MOD_PATH=/media/linux/rootfs modules_install</span><br></pre></td></tr></table></figure><p>最后备份原理SD卡中的旧内核， 并将新内核和设备树配置文件到SD卡中:</p><p>如果是32位内核，运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /media/linux/boot/$KERNEL.img /media/linux/boot/$KERNEL-backup.img</span><br><span class="line">sudo cp arch/arm/boot/zImage /media/linux/boot/$KERNEL.img</span><br><span class="line">sudo cp arch/arm/boot/dts/*.dtb /media/linux/boot</span><br><span class="line">sudo cp arch/arm/boot/dts/overlays/*.dtb* /media/linux/boot/overlays/</span><br><span class="line">sudo cp arch/arm/boot/dts/overlays/README /media/linux/boot/overlays/</span><br><span class="line">sudo umount /media/linux/boot</span><br><span class="line">sudo umount /media/linux/rootfs</span><br></pre></td></tr></table></figure><p>如果是64位内核，运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo</span><br><span class="line">cp /media/linux/boot/$KERNEL.img /media/linux/boot/$KERNEL-backup.img</span><br><span class="line">sudo cp arch/arm64/boot/Image /media/linux/boot/$KERNEL.img</span><br><span class="line">sudo cp arch/arm64/boot/dts/broadcom/*.dtb /media/linux/boot/</span><br><span class="line">sudo cp arch/arm64/boot/dts/overlays/*.dtb* /media/linux/boot/overlays/</span><br><span class="line">sudo cp arch/arm64/boot/dts/overlays/README /media/linux/boot/overlays/</span><br><span class="line">sudo umount /media/linux/boot/</span><br><span class="line">sudo umount /media/linux/rootfs</span><br></pre></td></tr></table></figure><p>当然，你也可以不备份旧的内核，而是通过重命令编译出来的内核名称，如将编译出来的img改为kernel-new.img，然后修改config.txt的配置文件种的kernel字段,如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel=kernel-new.img</span><br></pre></td></tr></table></figure><p>这么做的好处是保证原有的内核不被破坏，如果新的内核无法启动，只需要将config.txt的kernel字段改回来即可。</p><p>最后，将TF卡插回Pi上，然后启动Pi即可。</p>]]></content>
      
      
      <categories>
          
          <category> 树莓派 </category>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux开发 </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> 树莓派 </tag>
            
            <tag> 交叉编译 </tag>
            
            <tag> 内核编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态库与动态库详解</title>
      <link href="/2022/01/01/test/%E6%A0%91%E8%8E%93%E6%B4%BE/%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/"/>
      <url>/2022/01/01/test/%E6%A0%91%E8%8E%93%E6%B4%BE/%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="静态库与动态库-HQ"><a href="#静态库与动态库-HQ" class="headerlink" title="静态库与动态库 - HQ"></a>静态库与动态库 - HQ</h1><p>[TOC]</p><hr><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><a href="https://www.cnblogs.com/sunsky303/p/7731911.html">参考文章1 - 未摘录</a></li><li><a href="https://blog.csdn.net/wk_bjut_edu_cn/article/details/81735956">参考文章2 - 未摘录</a></li></ul><hr><h3 id="库的制作"><a href="#库的制作" class="headerlink" title="库的制作"></a>库的制作</h3><h4 id="静态库的制作"><a href="#静态库的制作" class="headerlink" title="静态库的制作"></a>静态库的制作</h4><p>格式  xxxx.a</p><ol><li><code>gcc calcufuncs.c -c</code> 生成xxx.o文件</li><li><code>ar rcs libcalcufunc.a calcufuncs.o</code> xxx.o文件生成xxx.a静态库文件</li></ol><h4 id="动态库的制作"><a href="#动态库的制作" class="headerlink" title="动态库的制作"></a>动态库的制作</h4><p>格式  xxxx.so</p><p><code>gcc -shared -fpic calcufuncs.c -o libcalc.so</code></p><blockquote><p>-shared 指定生成动态库</p><p>-fpic 标准，fPIC 选项作用于编译阶段,在生成目标文件时就得使用该选项,以生成位置无关的代码。</p></blockquote><h3 id="库的使用"><a href="#库的使用" class="headerlink" title="库的使用"></a>库的使用</h3><h4 id="静态库使用"><a href="#静态库使用" class="headerlink" title="静态库使用"></a>静态库使用</h4><p><code>gcc calculatorT.c -lcalcufunc -L ./ -o mainProStatic</code> </p><blockquote><p>-lcalcufunc -l（小写l）是指定要用的动态库，库名砍头去尾，只要用中间的名字</p><p>-L告诉gcc编译器从-L指定的路径去找静态库，默认是从&#x2F;usr&#x2F;lib &#x2F;usr&#x2F;local&#x2F;lib去找</p></blockquote><h4 id="动态库使用"><a href="#动态库使用" class="headerlink" title="动态库使用"></a>动态库使用</h4><p><code>gcc calculatorT.c -lcalc -L ./ -o mainProDy</code> </p><p>带动态库的程序，可以指定该程序运行时候，在LD_LIBRARY_PATH 所指定的路径去找库文件</p><p><code>export LD_LIBRARY_PATH=&quot;/home/pi/back/test&quot;</code></p><h3 id="linux动态库-so-搜索路径-目录-设置方法"><a href="#linux动态库-so-搜索路径-目录-设置方法" class="headerlink" title="linux动态库(.so)搜索路径(目录)设置方法"></a>linux动态库(.so)搜索路径(目录)设置方法</h3><p><strong>在Linux 中，动态库的搜索路径除了默认的搜索路径外，还可通过三种方法来指定：</strong></p><p>方法一：在配置文件&#x2F;etc&#x2F;ld.so.conf中指定动态库搜索路径；</p><p>方法二：通过环境变量LD_LIBRARY_PATH指定动态库搜索路径；</p><p>方法三：在编译目标代码时指定该程序的动态库搜索路径。</p><p>众所周知，&#x3D;&#x3D;Linux动态库的默认搜索路径是&#x2F;lib和&#x2F;usr&#x2F;lib&#x3D;&#x3D;。动态库被创建后，一般都复制到这两个目录中。</p><p>当程序执行时需要某动态库，并且该动 态库还未加载到内存中，则系统会自动到这两个默认搜索路径中去查找相应的动态库文件，然后加载该文件到内存中，这样程序就可以使用该动态库中的函数，以及该动态库的其它资源了。</p><p><strong>在Linux 中，动态库的搜索路径除了默认的搜索路径外，还可以通过以下三种方法来指定。</strong> </p><h4 id="方法一：在配置文件-etc-ld-so-conf中指定动态库搜索路径。"><a href="#方法一：在配置文件-etc-ld-so-conf中指定动态库搜索路径。" class="headerlink" title="方法一：在配置文件&#x2F;etc&#x2F;ld.so.conf中指定动态库搜索路径。"></a>方法一：在配置文件&#x2F;etc&#x2F;ld.so.conf中指定动态库搜索路径。</h4><p><code>vi /etc/ld.so.conf</code></p><p>添加 lib目录 ldconfig</p><h4 id="方法二：通过环境变量LD-LIBRARY-PATH指定动态库搜索路径。"><a href="#方法二：通过环境变量LD-LIBRARY-PATH指定动态库搜索路径。" class="headerlink" title="方法二：通过环境变量LD_LIBRARY_PATH指定动态库搜索路径。"></a>方法二：通过环境变量LD_LIBRARY_PATH指定动态库搜索路径。</h4><p><code>export LD_LIBRARY_PATH=”LD_LIBRARY_PATH:/opt/”</code></p><h4 id="方法三：在编译目标代码时指定该程序的动态库搜索路径。"><a href="#方法三：在编译目标代码时指定该程序的动态库搜索路径。" class="headerlink" title="方法三：在编译目标代码时指定该程序的动态库搜索路径。"></a>方法三：在编译目标代码时指定该程序的动态库搜索路径。</h4><p>还可以在编译目标代码时指定程序的动态库搜索路径。</p><p>通过gcc 的参数 ”-Wl,-rpath,” 指定</p><p>&#x3D;&#x3D;其中方法三可以避免安装部署的麻烦&#x3D;&#x3D;</p><p><strong>方法三示例</strong></p><p>假设main.cpp,hello.h,hello.cpp,其中main.cpp调用了hello类中的方法</p><p>1、生成hello.so</p><p> <code>g++ -shared hello.cpp -o libhello.so</code></p><p>2、编译main.cpp,并链接,并指定运行时libhello.so的位置</p><p> <code>g++ main.cpp -lhello -L./ -Wl,-rpath=./ -o main</code> </p><blockquote><p>值得一提的是,如果采用带版本号的库,例如libhello.so.2</p><p>链接命令可使用<code>g++ main.cpp libhello.so.2 -L./ -Wl,-rpath=./ -o main</code> </p></blockquote><p>3、加入第二个so库</p><p><code>g++ main.cpp -L./second/ -Wl,-rpath=./second/ -lsecond -L./hello/ -Wl,-rpath=./hello/ -lhello -o main</code></p><blockquote><p>ps,遇到过一个奇怪的问题,就是假设libhello.so还用到了libother.so,由于在&#x2F;etc&#x2F;ld.so.conf里配置错误了libother.so的目录路径,导致一直产生undefined reference to错误,但是在工程里对libother目录路径配置是正确的,有可能于查找路径顺序有关。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态库 </tag>
            
            <tag> 动态库 </tag>
            
            <tag> Linux编程 </tag>
            
            <tag> 编译链接 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
