<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2025/05/19/test/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/"/>
      <url>/2025/05/19/test/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C-C-题目"><a href="#C-C-题目" class="headerlink" title="C&#x2F;C++ 题目"></a>C&#x2F;C++ 题目</h1><p>一个保险柜，密码是由 <code>NOMONEY</code> 组成的 7 位数字。每个字母对应的数字隐藏在下面的 10 进制加法算式中，相同的字母对应相同的数字，不同的字母对应不同的数字，数字范围 0-9，并且已知密码中没有 4。请解码密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G I V E</span><br><span class="line">+ M O R E</span><br><span class="line"></span><br><span class="line">  M O N E Y</span><br></pre></td></tr></table></figure><ul><li><p><strong>M &#x3D; 1</strong>（因两四位数相加得五位数，最高位必为1）</p></li><li><p><strong>G &#x3D; 9</strong>（9 + 1 &#x3D; 10，产生进位，满足五位数）</p></li><li><p><strong>O &#x3D; 0</strong>（千位相加：9 + 1 + 0 &#x3D; 10，进位后万位为1）</p></li><li><p><strong>E &#x3D; 8</strong>（个位：6 + 6 &#x3D; 12 → Y &#x3D; 2，进位1）</p></li><li><p><strong>Y &#x3D; 6</strong>（由E &#x3D; 8推导）</p></li><li><p><strong>V &#x3D; 5，R &#x3D; 2</strong>（十位：7 + 5 + 进位1 &#x3D; 13 → 进位1，E &#x3D; 6）  </p></li><li><p><strong>I &#x3D; 3</strong>（百位：8 + 进位1 &#x3D; 9 → N &#x3D; 9，但需调整后最终得出N &#x3D; 2）</p></li><li><p><strong>N &#x3D; 7</strong>（实际验证后调整）</p><p>答案不对 题目错了</p></li></ul><h4 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h4><p><strong>题目描述：</strong> 请用 C 语言写一个函数，实现如下功能：输入年、月、日，返回这一天是这一年的第几天？请注意算法的效率（空间时间）。</p><p><strong>答案：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dayOfYear</span><span class="params">(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">    <span class="type">int</span> daysInMonth[] = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; <span class="number">2</span> &amp;&amp; (y % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">100</span> != <span class="number">0</span> || y % <span class="number">400</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">        daysInMonth[<span class="number">1</span>] = <span class="number">29</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> day = d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        day += daysInMonth[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h4><p><strong>题目描述：</strong> 什么样的代码是优美的？哪些好的习惯有助于提高代码质量？</p><p><strong>答案：</strong> 优美的代码通常具有以下特点：</p><ol><li><strong>可读性</strong>：代码结构清晰，命名规范，注释充分。</li><li><strong>简洁性</strong>：代码简洁，避免冗余，使用合适的数据结构和算法。</li><li><strong>可维护性</strong>：模块化设计，易于理解和修改。</li><li><strong>健壮性</strong>：代码能够处理异常情况，进行错误检查和处理。</li></ol><p>提高代码质量的好习惯包括：</p><ol><li><strong>代码审查</strong>：定期进行代码审查，发现并修复潜在问题。</li><li><strong>单元测试</strong>：编写单元测试，确保代码的正确性和稳定性。</li><li><strong>持续重构</strong>：定期重构代码，保持代码的简洁和可维护性。</li><li><strong>遵循编码规范</strong>：遵循团队或项目的编码规范，保持代码风格的一致性。</li></ol><h4 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h4><p><strong>题目描述：</strong> C 和 C++ 有哪些主要区别？</p><p><strong>答案：</strong> C 和 C++ 的主要区别包括：</p><ol><li><strong>面向过程 vs 面向对象</strong>：C 是面向过程的语言，而 C++ 支持面向对象编程。</li><li><strong>类和对象</strong>：C++ 支持类和对象，可以进行封装、继承和多态。</li><li><strong>标准模板库（STL）</strong>：C++ 提供了标准模板库，支持容器、算法和迭代器。</li><li><strong>异常处理</strong>：C++ 支持异常处理机制，而 C 使用错误码。</li><li><strong>命名空间</strong>：C++ 支持命名空间，避免命名冲突。</li><li><strong>构造函数和析构函数</strong>：C++ 支持构造函数和析构函数，进行资源管理。</li></ol><h4 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h4><p><strong>题目描述：</strong> 请从下面三个问题任选一个（15 分） a) 请描述 C++ 中各种智能指针（shared_ptr、auto_ptr、unique_ptr、weak_ptr）的适用场景及注意事项。 b) 请简述一下 Linux 中几种多路复用机制（select&#x2F;poll&#x2F;epoll）的优缺点对比。</p><p><strong>答案：</strong> a) C++ 中各种智能指针的适用场景及注意事项：</p><ul><li><strong>shared_ptr</strong>：适用于多个指针需要共享所有权的场景。注意事项：循环引用可能导致内存泄漏。</li><li><strong>auto_ptr</strong>：已在 C++11 中被弃用，不推荐使用。</li><li><strong>unique_ptr</strong>：适用于独占所有权的场景。注意事项：不能被复制，只能被移动。</li><li><strong>weak_ptr</strong>：用于解决 shared_ptr 的循环引用问题。注意事项：需要与 shared_ptr 配合使用。</li></ul><p>b) Linux 中几种多路复用机制的优缺点对比：</p><ul><li><strong>select</strong>：优点：简单易用。缺点：文件描述符数量有限，性能较差。</li><li><strong>poll</strong>：优点：没有文件描述符数量限制。缺点：性能仍然较差，尤其是在大量文件描述符的情况下。</li><li><strong>epoll</strong>：优点：性能优异，支持大量文件描述符。缺点：实现复杂，需要内核支持。</li></ul><h4 id="题目5"><a href="#题目5" class="headerlink" title="题目5"></a>题目5</h4><p><strong>题目描述：</strong> 翻译：When developing embedded software, you must consider the following:</p><ul><li>Understand the default compilation tool behavior and the target environment so that you appreciate the steps necessary to move from a debug or development build to a fully standalone production version of the application.</li><li>Some C library functionality executes by using debug environment resources. If used, you must implement this functionality to make use of target hardware.</li><li>The toolchain has no inherent knowledge of the memory map of any given target. You must tailor the image this functionality has no inherent knowledge of the memory map of the target hardware.</li><li>An embedded application must perform some initialization, such as stack and heap initialization, before the application can be run. A complete initialization sequence requires code that you implement in addition to the Arm Compiler C library initialization routines.</li></ul><p><strong>答案：</strong> 在开发嵌入式软件时，必须考虑以下几点：</p><ul><li>了解默认编译工具的行为和目标环境，以便理解从调试或开发版本迁移到完全独立的生产版本应用程序所需的步骤。</li><li>一些 C 库功能通过使用调试环境资源来执行。如果使用这些功能，您必须实现这些功能以利用目标硬件。</li><li>工具链对任何给定目标的内存映射没有固有的知识。您必须调整该功能对目标硬件内存映射的了解。</li><li>嵌入式应用程序必须执行一些初始化，例如堆栈和堆初始化，然后才能运行应用程序。完整的初始化序列需要您实现的代码，以补充 Arm 编译器 C 库初始化例程。</li></ul><h4 id="题目6"><a href="#题目6" class="headerlink" title="题目6"></a>题目6</h4><p><strong>题目描述：</strong> 找出下面代码中所有的错误以及不合理的地方，并请说明原因。（20 分）</p><ol><li><p>找出下面代码中所有的错误以及不合理的地方，并请说明原因。（20 分）</p><p>c</p><p>复制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    A() &#123; m_jCount = <span class="number">0</span>; &#125;</span><br><span class="line">    ~A() &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> m_jCount;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    B() : A() &#123; m_jCount = <span class="number">1</span>; &#125;</span><br><span class="line">    ~B()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    A* a = new B();</span><br><span class="line">    FILE* f;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">        n = argv[<span class="number">0</span>];</span><br><span class="line">    <span class="type">char</span>* stuff = new <span class="type">char</span>[n];</span><br><span class="line">    f = fopen(<span class="string">&quot;c:\\abc\\aa.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fread(f, n, stuff);</span><br><span class="line">    n = <span class="built_in">strlen</span>(stuff);</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(stuff, <span class="number">0</span>, <span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line">    fwrite(f, <span class="number">1</span>, n, stuff);</span><br><span class="line">    delete stuff;</span><br><span class="line">    delete a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stuff;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>答案：</strong> 代码中的错误和不合理之处包括：</p><ol><li><code>A* a = new B();</code>：<code>new B()</code> 应该使用 <code>new B</code>，而不是 <code>new B()</code>。</li><li><code>int m;</code>：变量 <code>m</code> 未初始化，可能导致未定义行为。</li><li><code>if (argc &gt; 1)</code>：如果 <code>argc</code> 小于等于 1，程序会直接返回 -1，没有进行任何处理。</li><li><code>char* stuff = new char[n];</code>：<code>new char[n]</code> 应该使用 <code>new char[n+1]</code>，并在最后添加一个空字符 <code>\0</code>。</li><li><code>memset(stuff, 0, 20, 10);</code>：<code>memset</code> 的第三个参数应该是要设置的字节数，而不是重复次数。</li><li><code>delete stuff;</code>：<code>delete</code> 应该使用 <code>delete[] stuff;</code>，因为 <code>stuff</code> 是一个数组。</li><li><code>cout &lt;&lt; stuff;</code>：<code>stuff</code> 可能包含未初始化的内存，直接输出可能导致未定义行为。</li></ol><p>这些错误和不合理之处需要修正以确保程序的正确性和稳定性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>shell语法复习</title>
      <link href="/2024/08/07/test/shell%E8%AF%AD%E6%B3%95%E5%A4%8D%E4%B9%A0/"/>
      <url>/2024/08/07/test/shell%E8%AF%AD%E6%B3%95%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以下是完善后的 Markdown 文件内容，标题已添加超链接：</p><hr><h1 id="Linux硬件开发常用Shell指令笔记"><a href="#Linux硬件开发常用Shell指令笔记" class="headerlink" title="Linux硬件开发常用Shell指令笔记"></a>Linux硬件开发常用Shell指令笔记</h1><h2 id="一、系统信息查看"><a href="#一、系统信息查看" class="headerlink" title="一、系统信息查看"></a><a href="#%E4%B8%80%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%9F%A5%E7%9C%8B">一、系统信息查看</a></h2><ol><li><p><strong>查看系统信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统内核版本、主机名、硬件架构等详细信息。</li><li><strong>用途</strong>：确认系统环境是否符合开发要求。</li></ul></li><li><p><strong>查看CPU信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示CPU的详细信息，包括型号、核心数、主频等。</li><li><strong>用途</strong>：确认CPU性能是否满足需求。</li></ul></li><li><p><strong>查看内存信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/meminfo</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统的内存信息，包括总内存、可用内存等。</li><li><strong>用途</strong>：评估内存是否足够支持程序运行。</li></ul></li><li><p><strong>查看系统负载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uptime</span></span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统当前的负载情况，包括平均负载值。</li><li><strong>用途</strong>：监控系统运行状态，判断是否需要优化。</li></ul></li></ol><hr><h2 id="二、硬件设备检测"><a href="#二、硬件设备检测" class="headerlink" title="二、硬件设备检测"></a><a href="#%E4%BA%8C%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87%E6%A3%80%E6%B5%8B">二、硬件设备检测</a></h2><ol><li><p><strong>查看设备文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：列出系统中所有设备文件。</li><li><strong>用途</strong>：确认设备是否被正确识别。</li></ul></li><li><p><strong>查看USB设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsusb</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示当前连接的USB设备信息。</li><li><strong>用途</strong>：检测USB接口的硬件设备是否连接成功。</li></ul></li><li><p><strong>查看PCI设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统中所有PCI设备信息。</li><li><strong>用途</strong>：确认PCI接口的硬件设备是否被识别。</li></ul></li><li><p><strong>查看硬件信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lshw</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：详细列出系统中的硬件信息，包括CPU、内存、硬盘等。</li><li><strong>用途</strong>：全面了解硬件配置。</li></ul></li></ol><hr><h2 id="三、文件系统操作"><a href="#三、文件系统操作" class="headerlink" title="三、文件系统操作"></a><a href="#%E4%B8%89%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C">三、文件系统操作</a></h2><ol><li><p><strong>查看文件系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示文件系统的磁盘使用情况，包括挂载点、总容量、已用容量等。</li><li><strong>用途</strong>：确认存储空间是否足够。</li></ul></li><li><p><strong>查看文件类型</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file &lt;文件名&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示文件的类型信息。</li><li><strong>用途</strong>：确认文件格式是否符合要求。</li></ul></li><li><p><strong>挂载文件系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount &lt;设备&gt; &lt;挂载点&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：将设备挂载到指定的挂载点。</li><li><strong>用途</strong>：挂载外部存储设备。</li></ul></li><li><p><strong>卸载文件系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount &lt;挂载点&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：卸载指定的挂载点。</li><li><strong>用途</strong>：安全地卸载外部存储设备。</li></ul></li></ol><hr><h2 id="四、网络操作"><a href="#四、网络操作" class="headerlink" title="四、网络操作"></a><a href="#%E5%9B%9B%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C">四、网络操作</a></h2><ol><li><p><strong>查看网络接口</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示网络接口的配置信息，包括IP地址、子网掩码等。</li><li><strong>用途</strong>：确认网络接口是否正常。<strong>注意</strong>：在现代Linux系统中，<code>ip addr</code> 更常用。</li></ul></li><li><p><strong>查看网络连接</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示当前的网络连接状态。</li><li><strong>用途</strong>：调试网络通信问题。<strong>注意</strong>：在现代Linux系统中，<code>ss -an</code> 更常用。</li></ul></li><li><p><strong>网络测试</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping &lt;IP地址&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：测试与指定IP地址的网络连通性。</li><li><strong>用途</strong>：确认网络连接是否正常。</li></ul></li><li><p><strong>查看DNS配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/resolv.conf</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示DNS服务器的配置信息。</li><li><strong>用途</strong>：确认DNS配置是否正确。</li></ul></li></ol><hr><h2 id="五、系统管理"><a href="#五、系统管理" class="headerlink" title="五、系统管理"></a><a href="#%E4%BA%94%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86">五、系统管理</a></h2><ol><li><p><strong>查看进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统中所有进程的详细信息。</li><li><strong>用途</strong>：监控进程运行状态。</li></ul></li><li><p><strong>杀死进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> &lt;进程ID&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：终止指定的进程。</li><li><strong>用途</strong>：停止异常运行的进程。</li></ul></li><li><p><strong>查看日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/messages</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：查看系统日志文件。</li><li><strong>用途</strong>：调试系统运行中的问题。<strong>注意</strong>：在现代Linux系统中，<code>journalctl</code> 更常用。</li></ul></li><li><p><strong>更新系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get upgrade</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：更新系统软件包。</li><li><strong>用途</strong>：确保系统环境是最新的。适用于基于Debian&#x2F;Ubuntu的系统。</li></ul></li></ol><hr><h2 id="六、脚本与自动化"><a href="#六、脚本与自动化" class="headerlink" title="六、脚本与自动化"></a><a href="#%E5%85%AD%E8%84%9A%E6%9C%AC%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96">六、脚本与自动化</a></h2><ol><li><p><strong>运行Shell脚本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;脚本文件&gt;.sh</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：执行Shell脚本文件。</li><li><strong>用途</strong>：自动化执行一系列命令。</li></ul></li><li><p><strong>查看脚本权限</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l &lt;脚本文件&gt;.sh</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：查看脚本文件的权限。</li><li><strong>用途</strong>：确保脚本具有可执行权限。</li></ul></li><li><p><strong>设置脚本权限</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x &lt;脚本文件&gt;.sh</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：为脚本文件设置可执行权限。</li><li><strong>用途</strong>：确保脚本可以正常运行。</li></ul></li></ol><hr><h2 id="七、硬件调试"><a href="#七、硬件调试" class="headerlink" title="七、硬件调试"></a><a href="#%E4%B8%83%E7%A1%AC%E4%BB%B6%E8%B0%83%E8%AF%95">七、硬件调试</a></h2><ol><li><p><strong>查看串口设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep <span class="built_in">tty</span></span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示串口设备的初始化信息。</li><li><strong>用途</strong>：确认串口设备是否被正确识别。</li></ul></li><li><p><strong>查看GPIO状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/class/gpio/gpio&lt;号&gt;/value</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：查看指定GPIO引脚的状态。</li><li><strong>用途</strong>：调试GPIO相关的硬件问题。</li></ul></li><li><p><strong>设置GPIO状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> &lt;值&gt; &gt; /sys/class/gpio/gpio&lt;号&gt;/value</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：设置指定GPIO引脚的状态。</li><li><strong>用途</strong>：控制GPIO引脚。</li></ul></li><li><p><strong>查看I2C设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i2cdetect -y &lt;总线号&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：扫描I2C总线上的设备。</li><li><strong>用途</strong>：确认I2C设备是否被正确识别。</li></ul></li><li><p><strong>查看SPI设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev/spi*</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：列出SPI设备文件。</li><li><strong>用途</strong>：确认SPI设备是否被正确识别。</li></ul></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell脚本 </tag>
            
            <tag> 硬件调试 </tag>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux驱动学习笔记--11.Linux中断实验</title>
      <link href="/2024/08/07/test/Linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0--Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/"/>
      <url>/2024/08/07/test/Linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0--Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="正点原子-Linux驱动学习笔记–11-Linux中断实验"><a href="#正点原子-Linux驱动学习笔记–11-Linux中断实验" class="headerlink" title="[正点原子]Linux驱动学习笔记–11.Linux中断实验"></a>[正点原子]Linux驱动学习笔记–11.Linux中断实验</h1><h1 id="1-Cortex-A7中断系统详解"><a href="#1-Cortex-A7中断系统详解" class="headerlink" title="1. Cortex-A7中断系统详解"></a>1. Cortex-A7中断系统详解</h1><h2 id="1-1-Cortex-A7中断系统简介"><a href="#1-1-Cortex-A7中断系统简介" class="headerlink" title="1.1 Cortex-A7中断系统简介"></a>1.1 Cortex-A7中断系统简介</h2><p>跟 STM32 一样， Cortex-A7 也有中断向量表，中断向量表也是在代码的最前面。 CortexA7 内核有 8 个异常中断，这 8 个异常中断的中断向量表如下所示：</p><p><img src="https://ahutxl.cn/images/2023/01/16/image51dbe76ff1870146.png" alt="image51dbe76ff1870146.png"></p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vi学习</title>
      <link href="/2024/08/06/test/2024-08-06-vi%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/08/06/test/2024-08-06-vi%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2024/08/06/test/2024-08-06-vi%E5%AD%A6%E4%B9%A0/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20240906200054194.png" alt="image-20240906200054194"></p><p>a  光标后一位插入  A 行尾插入</p><p>i   光标原位置插入 I行首插入</p><p>o 光标下一行插入 O 光标上一行插入</p><p><img src="/2024/08/06/test/2024-08-06-vi%E5%AD%A6%E4%B9%A0/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20240906200102904.png" alt="image-20240906200102904"></p><p>nyy 复制 ndd删除  p光标下边复制 P光标下边复制 u撤回</p><p><img src="/2024/08/06/test/2024-08-06-vi%E5%AD%A6%E4%B9%A0/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20240906200109699.png" alt="image-20240906200109699"></p><p><img src="/2024/08/06/test/2024-08-06-vi%E5%AD%A6%E4%B9%A0/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20240906200754220.png" alt="image-20240906200754220"></p><p>​      k（上）</p><p>​h（左）     l（右）</p><p>​j（下）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2024/08/06/test/2024-08-06-%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2024/08/06/test/2024-08-06-%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="测试测试"><a href="#测试测试" class="headerlink" title="测试测试"></a>测试测试</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一些liunx问题</title>
      <link href="/2024/08/06/test/Linux%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2024/08/06/test/Linux%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h3 id="1-内核空间与用户空间的区别"><a href="#1-内核空间与用户空间的区别" class="headerlink" title="1. 内核空间与用户空间的区别"></a>1. 内核空间与用户空间的区别</h3><h4 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h4><ul><li><strong>定义</strong>：内核空间是操作系统的核心部分，直接管理硬件资源和系统资源。</li><li><strong>稳定性与安全性</strong>：内核代码需要高度的稳定性和安全性，不能依赖于用户空间的库。</li><li><strong>特权模式</strong>：内核代码运行在特权模式下，可以直接访问硬件资源和系统内存。</li><li><strong>开发原则</strong>：内核开发中尽量避免使用用户空间的库，以减少复杂性和潜在的稳定性问题。</li></ul><h4 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h4><ul><li><strong>定义</strong>：用户空间是应用程序运行的环境，通常依赖于各种标准库（如 glibc）来实现复杂的功能。</li><li><strong>非特权模式</strong>：用户空间代码运行在非特权模式下，需要通过系统调用与内核交互。</li></ul><hr><h3 id="2-Linux-驱动开发中的库使用"><a href="#2-Linux-驱动开发中的库使用" class="headerlink" title="2. Linux 驱动开发中的库使用"></a>2. Linux 驱动开发中的库使用</h3><h4 id="内核提供的-API"><a href="#内核提供的-API" class="headerlink" title="内核提供的 API"></a>内核提供的 API</h4><p>Linux 内核本身提供了一套丰富的 API，用于驱动开发。这些 API 包括：</p><ul><li><strong>内存管理</strong>：<code>kmalloc</code>、<code>kfree</code> 等函数用于动态内存分配和释放。</li><li><strong>文件操作</strong>：<code>file_operations</code> 结构体用于实现设备文件的读写操作。</li><li><strong>中断处理</strong>：<code>request_irq</code>、<code>free_irq</code> 等函数用于注册和释放中断。</li><li><strong>定时器</strong>：<code>timer_setup</code>、<code>del_timer</code> 等函数用于定时器的创建和删除。</li><li><strong>设备树</strong>：在嵌入式 Linux 开发中，设备树（Device Tree）用于描述硬件设备的配置信息。</li></ul><p>这些 API 是内核的一部分，专门用于驱动开发，因此驱动代码通常不需要额外的用户空间库。</p><h4 id="硬件抽象层（HAL）"><a href="#硬件抽象层（HAL）" class="headerlink" title="硬件抽象层（HAL）"></a>硬件抽象层（HAL）</h4><p>在某些情况下，硬件供应商会提供硬件抽象层（HAL）库，用于简化硬件访问。这些库通常是内核模块的一部分，而不是用户空间库。例如，NXP 的 i.MX 系列处理器提供了专门的 HAL 库，用于访问硬件寄存器和外设。</p><hr><h3 id="3-为什么看起来像是“不用库”"><a href="#3-为什么看起来像是“不用库”" class="headerlink" title="3. 为什么看起来像是“不用库”"></a>3. 为什么看起来像是“不用库”</h3><h4 id="直接硬件访问"><a href="#直接硬件访问" class="headerlink" title="直接硬件访问"></a>直接硬件访问</h4><ul><li>在驱动开发中，开发者需要直接与硬件交互，因此会直接操作硬件寄存器，而不是通过复杂的用户空间库。</li><li>例如，访问 GPIO、定时器、中断控制器等硬件资源时，通常会直接使用内核提供的 API 或硬件寄存器操作。</li></ul><h4 id="轻量级开发"><a href="#轻量级开发" class="headerlink" title="轻量级开发"></a>轻量级开发</h4><ul><li>驱动代码通常需要轻量级和高效，以减少对系统资源的占用。使用内核提供的 API 可以实现这一点，而不需要依赖于复杂的用户空间库。</li></ul><h4 id="稳定性和安全性"><a href="#稳定性和安全性" class="headerlink" title="稳定性和安全性"></a>稳定性和安全性</h4><ul><li>内核代码需要保持高度的稳定性和安全性，避免引入用户空间库可能带来的潜在问题（如内存泄漏、线程安全问题等）。</li></ul><hr><h3 id="4-特殊情况"><a href="#4-特殊情况" class="headerlink" title="4. 特殊情况"></a>4. 特殊情况</h3><h4 id="用户空间驱动"><a href="#用户空间驱动" class="headerlink" title="用户空间驱动"></a>用户空间驱动</h4><ul><li>在某些情况下，驱动程序可以运行在用户空间，而不是内核空间。这种情况下，驱动程序可以使用用户空间的库（如 glibc）。</li><li>例如，某些 USB 设备驱动或网络设备驱动可以运行在用户空间。</li></ul><h4 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h4><ul><li>在某些复杂的驱动开发场景中，可能会使用第三方库来实现特定功能。例如，某些图形驱动可能会使用 OpenGL 或 DirectFB 等库。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Linux 驱动开发并不是完全不使用库，而是尽量减少对用户空间库的依赖，转而使用内核提供的 API 和硬件抽象层。这种做法可以提高驱动代码的稳定性和效率，同时减少对系统资源的占用。在某些特殊情况下，驱动开发可能会使用用户空间库或第三方库，但这取决于具体的开发需求和应用场景。</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Makefile学习</title>
      <link href="/2024/08/06/test/Makefile/"/>
      <url>/2024/08/06/test/Makefile/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以下是一些推荐的学习Makefile的网站和资源，可以帮助你快速掌握Makefile的常用规则、结构和示例：</p><ol><li><strong>廖雪峰的官方网站</strong><br>廖雪峰的Makefile教程从基础概念讲起，通过简单易懂的例子逐步深入，非常适合作为入门学习。<br>网址：<a href="https://liaoxuefeng.com/books/makefile/makefile-basic/">Makefile基础 - Makefile教程 - 廖雪峰的官方网站</a></li><li><strong>腾讯云技术文档</strong><br>腾讯云上有一篇关于Makefile的详细解释和示例，涵盖了从基础到进阶的内容，包括如何编写Makefile以及一些高级用法。<br>网址：<a href="https://cloud.tencent.com/developer/article/1065286">超清晰的makefile解释、编写与示例 - 腾讯云</a></li><li><strong>博客园 - Makefile语法总结</strong><br>这篇文章总结了Makefile的常用语法和规则，并通过具体示例进行解析，适合有一定基础的读者深入学习。<br>网址：<a href="https://www.cnblogs.com/zxdplay/p/17782281.html">Makefile语法详细总结及示例解析（快速掌握）</a></li><li><strong>CSDN博客 - Makefile教程</strong><br>CSDN上有许多关于Makefile的教程和示例，其中一些文章提供了详细的规则和实际项目中的Makefile模板。<br>网址：<a href="https://blog.csdn.net/weixin_46097907/article/details/135816235">makefile常用的命令总结及简单示例 - CSDN博客</a></li><li><strong>GitHub Pages - Makefile教程</strong><br>这是一个开源的Makefile教程，提供了从入门到高级的详细内容，并且包含了许多实用的示例。<br>网址：<a href="https://gavinliu6.github.io/Makefile-Tutorial-zh-CN/">Makefile 教程 - GitHub Pages</a></li><li><strong>CSDN博客 - 通用Makefile模板</strong><br>这篇文章提供了一个通用的Makefile模板，适用于C++项目的编译和链接，是一个很好的参考。<br>网址：<a href="https://blog.csdn.net/wg_cheeky/article/details/108014390">makeFile基本介绍, 语法, 示例,通用makefile - CSDN博客</a></li></ol><h3 id="Makefile-的基本概念"><a href="#Makefile-的基本概念" class="headerlink" title="Makefile 的基本概念"></a>Makefile 的基本概念</h3><ul><li><strong>定义</strong>：Makefile 是一个用于自动化编译和构建项目的文件，它描述了工程的编译、链接等规则，包括哪些源文件需要编译、如何编译、如何生成目标文件等。</li><li><strong>作用</strong>：通过编写 Makefile，可以使用 <code>make</code> 命令工具来自动化编译过程，避免手动输入繁琐的编译命令，提高开发效率。</li></ul><h3 id="Makefile-的基本结构"><a href="#Makefile-的基本结构" class="headerlink" title="Makefile 的基本结构"></a>Makefile 的基本结构</h3><ul><li><strong>变量定义</strong>：用于简化和统一文件名或命令的书写。例如：<ul><li><code>CC = gcc</code>：定义编译器为 gcc。</li><li><code>CFLAGS = -Wall -g</code>：定义编译选项，<code>-Wall</code> 显示所有警告，<code>-g</code> 启用调试信息。</li><li><code>TARGET = my_program</code>：定义目标文件名为 <code>my_program</code>。</li><li><code>OBJECTS = main.o utils.o</code>：定义目标文件列表。</li></ul></li><li><strong>规则定义</strong>：指定目标文件、依赖文件和生成目标文件的命令。基本格式如下：<ul><li><code>target: dependencies</code>：目标文件和依赖文件。</li><li><code>command</code>：生成目标文件的命令，必须以 Tab 键开始。</li></ul></li><li><strong>伪目标</strong>：用于执行一些特定的操作，如清理编译生成的文件。例如：<ul><li><code>.PHONY: clean</code>：声明 <code>clean</code> 是一个伪目标。</li><li><code>clean:</code>：定义清理操作的命令。</li></ul></li></ul><h3 id="Makefile-的基本语法"><a href="#Makefile-的基本语法" class="headerlink" title="Makefile 的基本语法"></a>Makefile 的基本语法</h3><ul><li><p><strong>目标和依赖</strong>：目标是要生成的文件，依赖是生成目标所需要的文件。基本格式如下：</p><ul><li><code>target: dependencies</code>：目标文件和依赖文件。</li><li><code>command</code>：生成目标文件的命令，必须以 Tab 键开始。</li></ul></li><li><p><strong>内置变量</strong>：Makefile 提供了一些内置变量，常用的包括：</p><ul><li><code>$@</code>：目标文件的名称。</li><li><code>$^</code>：所有依赖文件的名称。</li><li><code>$&lt;</code>：第一个依赖文件的名称。</li></ul><p>  <img src="/2024/08/06/test/Makefile/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20250423142456075.png" alt="image-20250423142456075"></p></li><li><p><strong>通配符</strong>：用于匹配文件名或文件路径中的多个字符，以便在规则中批量处理文件。常见的通配符有：</p><ul><li><code>*</code>：匹配零个或多个字符。</li><li><code>?</code>：匹配一个任意字符。</li><li><code>[...]</code>：匹配方括号内的任意一个字符。</li><li><code>[!...]</code>：匹配除了方括号内的字符之外的任意一个字符。</li></ul></li><li><p><strong>模式规则</strong>：用于定义一种模式，告诉 Make 工具如何将一类文件转换成另一类文件。例如：</p><ul><li><code>%.o: %.c</code>：表示所有以 <code>.c</code> 结尾的源文件都可以生成对应的 <code>.o</code> 目标文件。</li></ul></li><li><p><strong>自动化变量</strong>：在规则的命令中使用，代表了与规则相关联的文件名。常用的自动化变量包括：</p><ul><li><code>$@</code>：表示规则中的目标文件名。</li><li><code>$&lt;</code>：表示规则中的第一个依赖文件名。</li><li><code>$^</code>：表示规则中的所有依赖文件名，以空格分隔。</li></ul></li></ul><h3 id="Makefile-的实际应用"><a href="#Makefile-的实际应用" class="headerlink" title="Makefile 的实际应用"></a>Makefile 的实际应用</h3><ul><li><strong>简单示例</strong>：<ul><li>假设有一个简单的 C 项目，包含 <code>main.c</code> 和 <code>utils.c</code> 两个源文件 ，目标是生成可执行文件 <code>my_program</code>。Makefile 内容如下：<ul><li><pre><code class="makefile">CC = gccCFLAGS = -Wall -gTARGET = my_programOBJECTS = main.o utils.oall: $(TARGET)$(TARGET): $(OBJECTS)    $(CC) $(CFLAGS) -o $(TARGET) $(OBJECTS)main.o: main.c    $(CC) $(CFLAGS) -c main.cutils.o: utils.c    $(CC) $(CFLAGS) -c utils.c.PHONY: cleanclean:    rm -f $(TARGET) $(OBJECTS)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    - 在项目目录中执行 `make` 命令即可编译项目，执行 `make clean` 命令可以清理编译生成的文件。</span><br><span class="line">- **复杂项目**：</span><br><span class="line">    - 对于复杂的嵌入式 Linux 项目，可能包含多个源文件、头文件、汇编文件等，需要更复杂的 Makefile 来管理。例如：</span><br><span class="line">        - ```makefile</span><br><span class="line">          CROSS_COMPILE  ?= arm-linux-gnueabihf-</span><br><span class="line">          TARGET   ?= bsp</span><br><span class="line">          CC := $(CROSS_COMPILE)gcc</span><br><span class="line">          LD:= $(CROSS_COMPILE)ld</span><br><span class="line">          OBJCOPY := $(CROSS_COMPILE)objcopy</span><br><span class="line">          OBJDUMP := $(CROSS_COMPILE)objdump</span><br><span class="line">          INCDIRS := imx6ul \</span><br><span class="line">                             bsp/clk \</span><br><span class="line">                             bsp/led \</span><br><span class="line">                             bsp/delay</span><br><span class="line">          SRCDIRS:= project \</span><br><span class="line">                             bsp/clk \</span><br><span class="line">                             bsp/led \</span><br><span class="line">                             bsp/delay</span><br><span class="line">          INCLUDE:= $(patsubst %, -I %, $(INCDIRS))</span><br><span class="line">          SFILES:= $(foreach dir, $(SRCDIRS), $(wildcard $(dir)/*.S))</span><br><span class="line">          CFILES:= $(foreach dir, $(SRCDIRS), $(wildcard $(dir)/*.c))</span><br><span class="line">          SFILENDIR:= $(notdir  $(SFILES))</span><br><span class="line">          CFILENDIR:= $(notdir  $(CFILES))</span><br><span class="line">          SOBJS:= $(patsubst %, obj/%, $(SFILENDIR:.S=.o))</span><br><span class="line">          COBJS:= $(patsubst %, obj/%, $(CFILENDIR:.c=.o))</span><br><span class="line">          OBJS:= $(SOBJS) $(COBJS)</span><br><span class="line">          VPATH:= $(SRCDIRS)</span><br><span class="line">          .PHONY: clean</span><br><span class="line">          $(TARGET).bin : $(OBJS)</span><br><span class="line">              $(LD) -Timx6ul.lds -o $(TARGET).elf $^</span><br><span class="line">              $(OBJCOPY) -O binary -S $(TARGET).elf $@</span><br><span class="line">              $(OBJDUMP) -D -m arm $(TARGET).elf &gt; $(TARGET).dis</span><br><span class="line">          $(SOBJS) : obj/%.o : %.S</span><br><span class="line">              $(CC) -Wall -nostdlib -c -O2  $(INCLUDE) -o $@ $&lt;</span><br><span class="line">          $(COBJS) : obj/%.o : %.c</span><br><span class="line">              $(CC) -Wall -nostdlib -c -O2  $(INCLUDE) -o $@ $&lt;</span><br><span class="line">          clean:</span><br><span class="line">              rm -rf $(TARGET).elf $(TARGET).dis $(TARGET).bin $(COBJS) $(SOBJS)</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li>该 Makefile 使用了交叉编译工具链，支持多个源文件和汇编文件的编译，生成二进制可执行文件、ELF 格式文件和反汇编文件。</li></ul></li></ul><h3 id="Makefile-的调试"><a href="#Makefile-的调试" class="headerlink" title="Makefile 的调试"></a>Makefile 的调试</h3><ul><li><strong>查看 <code>make</code> 过程</strong>：使用 <code>make -n</code> 命令可以显示将会执行的命令，但不会实际执行。</li><li><strong>增加详细输出</strong>：使用 <code>make --debug</code> 命令可以提供详细的调试信息，帮助排查问题。</li></ul><h3 id="Makefile-的高级功能"><a href="#Makefile-的高级功能" class="headerlink" title="Makefile 的高级功能"></a>Makefile 的高级功能</h3><ul><li><p><strong>条件语句</strong>：可以根据不同的条件执行不同的规则或设置变量。常见的条件语句有 <code>ifeq</code>、<code>ifneq</code>、<code>ifdef</code>、<code>ifndef</code>。</p><ul><li>示例：根据操作系统设置不同的编译选项。<ul><li><pre><code class="makefile">CC = gccCFLAGS = -Wall -gifeq ($(OS),Windows_NT)    CFLAGS += -DWIN32else    CFLAGS += -DUNIXendifTARGET = my_programSRCS = main.c utils.call: $(TARGET)$(TARGET): $(SRCS)    $(CC) $(CFLAGS) -o $(TARGET) $(SRCS)clean:    rm -f $(TARGET)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">- **使用函数**：Makefile 提供了一些内建函数，帮助处理字符串和文件操作等任务。常用函数包括：</span><br><span class="line">    - `$(wildcard pattern)`：返回匹配模式的所有文件。</span><br><span class="line">    - `$(patsubst pattern,replacement,text)`：用指定的替换文本替换模式。</span><br><span class="line">    - `$(basename names)`：去除文件名的扩展名部分。</span><br><span class="line">    - `$(dir names)`：返回文件的目录路径。</span><br><span class="line">    - 示例：使用 `wildcard` 和 `patsubst`。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### **Makefile基础笔记**</span><br><span class="line"></span><br><span class="line">#### **1. Makefile概述**</span><br><span class="line">- **Makefile的作用**：</span><br><span class="line">  - 在Linux环境下，`make`命令会查找当前目录下的`Makefile`文件。</span><br><span class="line">  - 根据Makefile中定义的规则，`make`可以自动化地执行命令，例如编译源代码、生成目标文件等。</span><br><span class="line">  - Makefile的核心思想是通过定义规则来描述如何生成目标文件。</span><br><span class="line"></span><br><span class="line">- **基本逻辑示例**：</span><br><span class="line">  - 假设有文件`a.txt`、`b.txt`和`c.txt`，需要先合并`a.txt`和`b.txt`生成中间文件`m.txt`，再将`m.txt`与`c.txt`合并生成最终文件`x.txt`。</span><br><span class="line">  - Makefile通过规则定义这种依赖关系和生成过程。</span><br><span class="line"></span><br><span class="line">#### **2. Makefile规则的基本格式**</span><br><span class="line">- **规则格式**：</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>目标文件: 依赖文件1 依赖文件2 …<br>    命令1<br>    命令2<br>    …</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  - **目标文件**：需要生成的文件。</span><br><span class="line">  - **依赖文件**：生成目标文件所需的文件。</span><br><span class="line">  - **命令**：用于生成目标文件的具体命令，必须以Tab键开头。</span><br><span class="line"></span><br><span class="line">- **示例**：</span><br><span class="line">  </span><br><span class="line">  ```makefile</span><br><span class="line">  m.txt: a.txt b.txt</span><br><span class="line">      cat a.txt b.txt &gt; m.txt</span><br><span class="line">  </span><br><span class="line">  x.txt: m.txt c.txt</span><br><span class="line">      cat m.txt c.txt &gt; x.txt</span><br></pre></td></tr></table></figure><ul><li><code>m.txt</code>依赖于<code>a.txt</code>和<code>b.txt</code>，通过<code>cat</code>命令合并生成。</li><li><code>x.txt</code>依赖于<code>m.txt</code>和<code>c.txt</code>，同样通过<code>cat</code>命令生成。</li></ul></li></ul><h4 id="3-Makefile的执行逻辑"><a href="#3-Makefile的执行逻辑" class="headerlink" title="3. Makefile的执行逻辑"></a><strong>3. Makefile的执行逻辑</strong></h4><ul><li><p><strong>增量编译</strong>：</p><ul><li><code>make</code>会检查目标文件和依赖文件的修改时间。</li><li>如果目标文件的修改时间晚于所有依赖文件，则认为目标文件是最新的，不会重新生成。</li><li>如果依赖文件中的任何一个被修改，则会重新执行规则生成目标文件。</li></ul></li><li><p><strong>默认规则</strong>：</p><ul><li><code>make</code>默认执行Makefile中的第一条规则。</li><li>例如，如果要生成<code>x.txt</code>，<code>make</code>会先检查<code>m.txt</code>是否存在，如果不存在则先生成<code>m.txt</code>，然后再生成<code>x.txt</code>。</li></ul></li></ul><h4 id="4-伪目标（Phony-Target）"><a href="#4-伪目标（Phony-Target）" class="headerlink" title="4. 伪目标（Phony Target）"></a><strong>4. 伪目标（Phony Target）</strong></h4><ul><li><p><strong>定义</strong>：</p><ul><li>伪目标不是实际的文件名，而是用于执行特定任务的规则。</li><li>例如，<code>clean</code>规则通常用于删除生成的文件。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f m.txt x.txt</span><br></pre></td></tr></table></figure><ul><li>执行<code>make clean</code>会删除<code>m.txt</code>和<code>x.txt</code>。</li></ul></li><li><p><strong>避免冲突</strong>：</p><ul><li>如果存在名为<code>clean</code>的文件，<code>make clean</code>可能不会执行。</li><li>可以使用<code>.PHONY</code>声明伪目标：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f m.txt x.txt</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="5-执行多条命令"><a href="#5-执行多条命令" class="headerlink" title="5. 执行多条命令"></a><strong>5. 执行多条命令</strong></h4><ul><li><p><strong>独立命令</strong>：</p><ul><li>每条命令默认在独立的Shell环境中执行。</li><li>例如，<code>cd</code>命令不会影响后续命令的执行环境。</li></ul></li><li><p><strong>多条命令的写法</strong>：</p><ul><li>使用<code>;</code>分隔命令：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">    pwd; cd ..; pwd</span><br></pre></td></tr></table></figure></li><li>使用<code>\</code>换行：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">    pwd; \</span><br><span class="line">    cd ..; \</span><br><span class="line">    pwd</span><br></pre></td></tr></table></figure></li><li>使用<code>&amp;&amp;</code>确保命令顺序执行：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">    pwd &amp;&amp; cd .. &amp;&amp; pwd</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="6-控制命令输出"><a href="#6-控制命令输出" class="headerlink" title="6. 控制命令输出"></a><strong>6. 控制命令输出</strong></h4><ul><li><strong>隐藏命令输出</strong>：<ul><li>在命令前加<code>@</code>可以隐藏命令的打印输出，但命令仍然会执行。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">no_output:</span></span><br><span class="line">    @echo &#x27;not display&#x27;</span><br><span class="line">    echo &#x27;will display&#x27;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="7-错误处理"><a href="#7-错误处理" class="headerlink" title="7. 错误处理"></a><strong>7. 错误处理</strong></h4><ul><li><p><strong>默认行为</strong>：</p><ul><li>如果命令返回非0值，<code>make</code>会中断执行并报错。</li></ul></li><li><p><strong>忽略错误</strong>：</p><ul><li>在命令前加<code>-</code>可以忽略错误，继续执行后续命令。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ignore_error:</span></span><br><span class="line">    -rm zzz.txt</span><br><span class="line">    echo &#x27;ok&#x27;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h4><p>Makefile通过定义规则来自动化生成目标文件，核心在于描述目标文件与依赖文件之间的关系以及生成目标文件的具体命令。掌握以下要点：</p><ul><li>规则的基本格式：目标文件、依赖文件和命令。</li><li>增量编译的逻辑：基于文件的修改时间。</li><li>伪目标的使用：如<code>clean</code>。</li><li>多条命令的写法：使用<code>;</code>、<code>\</code>或<code>&amp;&amp;</code>。</li><li>控制命令输出：使用<code>@</code>。</li><li>错误处理：使用<code>-</code>忽略错误。</li></ul><hr><hr><h3 id="编译C程序-Makefile教程笔记"><a href="#编译C程序-Makefile教程笔记" class="headerlink" title="编译C程序 - Makefile教程笔记"></a><strong>编译C程序 - Makefile教程笔记</strong></h3><h4 id="1-C程序编译的基本步骤"><a href="#1-C程序编译的基本步骤" class="headerlink" title="1. C程序编译的基本步骤"></a><strong>1. C程序编译的基本步骤</strong></h4><p>编译C程序通常分为两步：</p><ol><li><strong>编译阶段</strong>：将每个<code>.c</code>文件编译为<code>.o</code>文件（目标文件）。</li><li><strong>链接阶段</strong>：将所有<code>.o</code>文件链接为最终的可执行文件。</li></ol><h4 id="2-示例项目结构"><a href="#2-示例项目结构" class="headerlink" title="2. 示例项目结构"></a><strong>2. 示例项目结构</strong></h4><p>假设一个简单的C项目，包含以下文件：</p><ul><li><code>hello.c</code>：定义了一个<code>hello</code>函数。</li><li><code>hello.h</code>：声明了<code>hello</code>函数。</li><li><code>main.c</code>：主程序，调用了<code>hello</code>函数。</li></ul><p><strong>文件内容</strong>：</p><ul><li>**<code>hello.c</code>**：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>**<code>hello.h</code>**：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li><li>**<code>main.c</code>**：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start...\n&quot;</span>);</span><br><span class="line">    hello();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-Makefile编写"><a href="#3-Makefile编写" class="headerlink" title="3. Makefile编写"></a><strong>3. Makefile编写</strong></h4><p>根据上述项目结构，Makefile可以定义如下规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 hello.c</span></span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">cc -c hello.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 main.c</span></span><br><span class="line"><span class="section">main.o: main.c hello.h</span></span><br><span class="line">cc -c main.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理生成的文件</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o world.out</span><br></pre></td></tr></table></figure><h4 id="4-Makefile执行逻辑"><a href="#4-Makefile执行逻辑" class="headerlink" title="4. Makefile执行逻辑"></a><strong>4. Makefile执行逻辑</strong></h4><ul><li><p><strong>增量编译</strong>：</p><ul><li><code>make</code>会根据文件的修改时间来判断是否需要重新编译。</li><li>如果<code>hello.c</code>被修改，<code>make</code>会重新编译<code>hello.c</code>生成<code>hello.o</code>，并重新链接生成<code>world.out</code>。</li><li>如果<code>hello.h</code>被修改，<code>make</code>会重新编译所有依赖<code>hello.h</code>的文件（如<code>main.c</code>），并重新链接生成<code>world.out</code>。</li></ul></li><li><p><strong>执行过程</strong>：</p><ul><li>初始运行<code>make</code>时，会依次执行以下步骤：<ol><li>编译<code>hello.c</code>生成<code>hello.o</code>。</li><li>编译<code>main.c</code>生成<code>main.o</code>。</li><li>链接<code>hello.o</code>和<code>main.o</code>生成<code>world.out</code>。</li></ol></li><li>如果修改了<code>hello.c</code>，再次运行<code>make</code>时，只会重新编译<code>hello.c</code>并重新链接<code>world.out</code>。</li><li>如果修改了<code>hello.h</code>，<code>make</code>会重新编译<code>main.c</code>并重新链接<code>world.out</code>。</li></ul></li></ul><h4 id="5-清理规则"><a href="#5-清理规则" class="headerlink" title="5. 清理规则"></a><strong>5. 清理规则</strong></h4><ul><li><strong><code>clean</code>规则</strong>：<ul><li>用于删除所有生成的文件，包括<code>.o</code>文件和可执行文件。</li><li>执行命令：<code>make clean</code>。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.o world.out</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="6-规则优化"><a href="#6-规则优化" class="headerlink" title="6. 规则优化"></a><strong>6. 规则优化</strong></h4><p>随着项目规模的扩大，手动维护Makefile中的规则会变得繁琐。后续可以学习如何使用变量、模式规则等高级特性来简化Makefile的编写。</p><h4 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a><strong>7. 小结</strong></h4><ul><li><strong>Makefile的作用</strong>：通过定义规则，<code>make</code>可以自动化编译C程序。</li><li><strong>规则的基本格式</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标文件: 依赖文件</span><br><span class="line">    命令</span><br></pre></td></tr></table></figure></li><li><strong>增量编译</strong>：<code>make</code>根据文件的修改时间来决定是否重新编译。</li><li><strong>清理规则</strong>：使用<code>clean</code>规则删除生成的文件，方便重新编译。</li></ul><p>以下是根据廖雪峰的《使用隐式规则》教程整理的笔记，主要介绍了Makefile中隐式规则的概念、使用方法以及其潜在问题。</p><hr><h3 id="使用隐式规则-Makefile教程笔记"><a href="#使用隐式规则-Makefile教程笔记" class="headerlink" title="使用隐式规则 - Makefile教程笔记"></a><strong>使用隐式规则 - Makefile教程笔记</strong></h3><h4 id="1-隐式规则的概念"><a href="#1-隐式规则的概念" class="headerlink" title="1. 隐式规则的概念"></a><strong>1. 隐式规则的概念</strong></h4><ul><li><p><strong>隐式规则（Implicit Rule）</strong>：</p><ul><li>Makefile中的一种特殊规则，用于自动推导目标文件的生成规则。</li><li>当Makefile中没有明确定义某个目标文件的规则时，<code>make</code>会尝试使用内置的隐式规则来生成该目标文件。</li></ul></li><li><p><strong>内置规则的作用</strong>：</p><ul><li>为了简化Makefile的编写，<code>make</code>为常见的编译任务（如C、C++、ASM等）提供了默认的隐式规则。</li><li>例如，对于C程序，<code>make</code>会自动应用以下隐式规则：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xyz.o: xyz.c</span><br><span class="line">    cc -c -o xyz.o xyz.c</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-示例：隐式规则的应用"><a href="#2-示例：隐式规则的应用" class="headerlink" title="2. 示例：隐式规则的应用"></a><strong>2. 示例：隐式规则的应用</strong></h4><p>假设有一个C项目，包含<code>hello.c</code>、<code>main.c</code>和<code>hello.h</code>，目标是生成可执行文件<code>world.out</code>。</p><p><strong>项目结构</strong>：</p><ul><li><code>hello.c</code>：定义了一个<code>hello</code>函数。</li><li><code>hello.h</code>：声明了<code>hello</code>函数。</li><li><code>main.c</code>：主程序，调用了<code>hello</code>函数。</li></ul><p><strong>Makefile</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只保留生成 world.out 的规则</span></span><br><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">    cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.o world.out</span><br></pre></td></tr></table></figure><p><strong>执行过程</strong>：</p><ul><li>执行<code>make</code>命令时，<code>make</code>会自动推导出<code>hello.o</code>和<code>main.o</code>的生成规则：<ul><li><code>hello.o</code>依赖于<code>hello.c</code>，使用<code>cc -c -o hello.o hello.c</code>生成。</li><li><code>main.o</code>依赖于<code>main.c</code>，使用<code>cc -c -o main.o main.c</code>生成。</li></ul></li><li>最后，<code>make</code>会链接<code>hello.o</code>和<code>main.o</code>生成<code>world.out</code>。</li></ul><p><strong>输出</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc    -c -o hello.o hello.c</span><br><span class="line">cc    -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure><h4 id="3-隐式规则的优势"><a href="#3-隐式规则的优势" class="headerlink" title="3. 隐式规则的优势"></a><strong>3. 隐式规则的优势</strong></h4><ul><li><strong>减少重复规则</strong>：<ul><li>隐式规则可以减少Makefile中大量重复的编译规则。</li><li>例如，对于多个<code>.c</code>文件，无需为每个文件单独编写<code>.o</code>文件的生成规则。</li></ul></li></ul><h4 id="4-隐式规则的潜在问题"><a href="#4-隐式规则的潜在问题" class="headerlink" title="4. 隐式规则的潜在问题"></a><strong>4. 隐式规则的潜在问题</strong></h4><ul><li><strong>无法跟踪头文件的修改</strong>：<ul><li>隐式规则的一个主要问题是无法自动跟踪头文件（如<code>.h</code>文件）的修改。</li><li>例如，如果修改了<code>hello.h</code>，隐式规则<code>main.o: main.c</code>不会自动检测到<code>hello.h</code>的修改，导致<code>main.c</code>不会被重新编译。</li><li>这可能导致生成的可执行文件中包含过时的代码。</li></ul></li></ul><h4 id="5-解决隐式规则的潜在问题"><a href="#5-解决隐式规则的潜在问题" class="headerlink" title="5. 解决隐式规则的潜在问题"></a><strong>5. 解决隐式规则的潜在问题</strong></h4><ul><li><p><strong>手动添加依赖</strong>：</p><ul><li>为了确保头文件的修改能够触发重新编译，需要手动在Makefile中添加头文件的依赖关系。</li><li>例如：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main.o: main.c hello.h</span></span><br><span class="line">    cc -c main.c</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>自动生成依赖文件</strong>：</p><ul><li>在实际项目中，可以通过工具（如<code>gcc -M</code>）自动生成依赖文件，并将其包含在Makefile中。</li><li>例如，使用<code>gcc -M</code>生成依赖文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -M main.c &gt; main.d</span><br></pre></td></tr></table></figure></li><li>然后在Makefile中包含这些依赖文件：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-include</span> main.d</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a><strong>6. 小结</strong></h4><ul><li><strong>隐式规则的作用</strong>：减少重复的编译规则，简化Makefile的编写。</li><li><strong>隐式规则的潜在问题</strong>：无法自动跟踪头文件的修改，可能导致生成的可执行文件包含过时代码。</li><li><strong>解决方法</strong>：手动添加头文件依赖或使用工具自动生成依赖文件。</li></ul><hr><p>以下是根据廖雪峰的《使用变量》教程整理的笔记，主要介绍了Makefile中变量的使用方法、内置变量和自动变量的概念。</p><hr><h3 id="使用变量-Makefile教程笔记"><a href="#使用变量-Makefile教程笔记" class="headerlink" title="使用变量 - Makefile教程笔记"></a><strong>使用变量 - Makefile教程笔记</strong></h3><h4 id="1-变量的作用"><a href="#1-变量的作用" class="headerlink" title="1. 变量的作用"></a><strong>1. 变量的作用</strong></h4><ul><li><strong>解决重复问题</strong>：<ul><li>在Makefile中，文件名或命令可能会重复出现多次，手动修改容易出错。</li><li>使用变量可以简化Makefile的编写，提高可维护性。</li></ul></li></ul><h4 id="2-定义和使用变量"><a href="#2-定义和使用变量" class="headerlink" title="2. 定义和使用变量"></a><strong>2. 定义和使用变量</strong></h4><ul><li><p><strong>定义变量</strong>：</p><ul><li>使用<code>变量名 = 值</code>或<code>变量名 := 值</code>定义变量。</li><li>通常变量名使用全大写，例如<code>TARGET</code>、<code>OBJS</code>等。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TARGET = world.out</span><br><span class="line">OBJS = hello.o main.o</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>引用变量</strong>：</p><ul><li>使用<code>$(变量名)</code>引用变量。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">    cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="3-动态生成变量"><a href="#3-动态生成变量" class="headerlink" title="3. 动态生成变量"></a><strong>3. 动态生成变量</strong></h4><ul><li><p><strong>使用<code>wildcard</code>函数</strong>：</p><ul><li><code>wildcard</code>函数可以匹配当前目录下的文件模式。</li><li>示例：<code>$(wildcard *.c)</code>会列出当前目录下所有<code>.c</code>文件。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用<code>patsubst</code>函数</strong>：</p><ul><li><code>patsubst</code>函数用于模式替换。</li><li>示例：<code>$(patsubst %.c,%.o,$(wildcard *.c))</code>会将所有<code>.c</code>文件名替换为<code>.o</code>文件名。</li><li>这样，每当添加新的<code>.c</code>文件时，<code>OBJS</code>变量会自动更新，无需手动修改Makefile。</li></ul></li></ul><h4 id="4-内置变量"><a href="#4-内置变量" class="headerlink" title="4. 内置变量"></a><strong>4. 内置变量</strong></h4><ul><li><p><strong>内置变量</strong>：</p><ul><li><code>make</code>提供了一些内置变量，例如<code>$(CC)</code>表示C编译器，默认值是<code>cc</code>。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>修改内置变量</strong>：</p><ul><li>可以重新定义内置变量的值。</li><li>示例：使用交叉编译器时，可以设置<code>CC = riscv64-linux-gnu-gcc</code>。</li></ul></li></ul><h4 id="5-自动变量"><a href="#5-自动变量" class="headerlink" title="5. 自动变量"></a><strong>5. 自动变量</strong></h4><ul><li><p><strong>自动变量</strong>：</p><ul><li>在规则中自动指向特定值的变量。</li><li>常用的自动变量：<ul><li><code>$@</code>：目标文件名。</li><li><code>$&lt;</code>：依赖列表中的第一个文件。</li><li><code>$^</code>：所有依赖文件。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">    @echo &#x27;$<span class="variable">$@</span> = <span class="variable">$@</span>&#x27; <span class="comment"># 目标文件名</span></span><br><span class="line">    @echo &#x27;$<span class="variable">$&lt;</span> = <span class="variable">$&lt;</span>&#x27; <span class="comment"># 第一个依赖文件</span></span><br><span class="line">    @echo &#x27;$<span class="variable">$^</span> = <span class="variable">$^</span>&#x27; <span class="comment"># 所有依赖文件</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>输出示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$@</span> = world.out</span><br><span class="line">$&lt; = hello.o</span><br><span class="line">$^ = hello.o main.o</span><br><span class="line">$(CC) -o world.out hello.o main.o</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-变量的调试"><a href="#6-变量的调试" class="headerlink" title="6. 变量的调试"></a><strong>6. 变量的调试</strong></h4><ul><li><strong>打印变量</strong>：<ul><li>使用<code>@echo</code>打印变量的值，便于调试。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">    @echo &#x27;$<span class="variable">$@</span> = <span class="variable">$@</span>&#x27;</span><br><span class="line">    @echo &#x27;$<span class="variable">$&lt;</span> = <span class="variable">$&lt;</span>&#x27;</span><br><span class="line">    @echo &#x27;$<span class="variable">$^</span> = <span class="variable">$^</span>&#x27;</span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="7-小结-1"><a href="#7-小结-1" class="headerlink" title="7. 小结"></a><strong>7. 小结</strong></h4><ul><li><strong>变量的作用</strong>：简化Makefile的编写，减少重复，提高可维护性。</li><li><strong>变量的定义和引用</strong>：使用<code>变量名 = 值</code>定义，使用<code>$(变量名)</code>引用。</li><li><strong>动态生成变量</strong>：使用<code>wildcard</code>和<code>patsubst</code>函数自动生成文件列表。</li><li><strong>内置变量</strong>：使用内置变量（如<code>$(CC)</code>）简化命令。</li><li><strong>自动变量</strong>：使用自动变量（如<code>$@</code>、<code>$&lt;</code>、<code>$^</code>）简化规则。</li></ul><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法自带格式(如何写博客)</title>
      <link href="/2024/08/06/test/Markdown%E8%AF%AD%E6%B3%95%E8%87%AA%E5%B8%A6%E6%A0%BC%E5%BC%8F(%E5%A6%82%E4%BD%95%E5%86%99%E5%8D%9A%E5%AE%A2)/"/>
      <url>/2024/08/06/test/Markdown%E8%AF%AD%E6%B3%95%E8%87%AA%E5%B8%A6%E6%A0%BC%E5%BC%8F(%E5%A6%82%E4%BD%95%E5%86%99%E5%8D%9A%E5%AE%A2)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/./../images/bywind.png" alt="图"></p><p>用Typora软件更简单</p><p><a href="https://www.bilibili.com/video/BV1iHaTe9EZ3/?spm_id_from=333.337.search-card.all.click&vd_source=390e7ea253547d9c75882d502ff42a1b">Typora安装激活流程_哔哩哔哩_bilibili</a></p><p>Typora安装文件及下载地址~<br>链接:<a href="https://pan.baidu.com/s/17CunIoob5JbtQZ1N5ZIyfg?pwd=zspz">https://pan.baidu.com/s/17CunIoob5JbtQZ1N5ZIyfg?pwd=zspz</a> 提取码:zspz</p><p>一键3连 上传代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl&amp;&amp;hexo g&amp;&amp;hexo d</span><br></pre></td></tr></table></figure><h2 id="多级标题"><a href="#多级标题" class="headerlink" title="多级标题"></a>多级标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure><h2 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span>&gt;</span></span>5号字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>这里的背景色是：MistyRosen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure><h2 id="1-5-分割线"><a href="#1-5-分割线" class="headerlink" title="1.5 分割线"></a>1.5 分割线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><p>​分栏 tab</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><ol><li>Unique name :<ul><li>选项卡块标签的唯一名称，不带逗号。</li><li>将在#id中用作每个标签及其索引号的前缀。</li><li>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</li><li>仅当前帖子&#x2F;页面的URL必须是唯一的！</li></ul></li><li>[index]:<ul><li>活动选项卡的索引号。</li><li>如果未指定，将选择第一个标签（1）。</li><li>如果index为-1，则不会选择任何选项卡。</li><li>可选参数。</li></ul></li><li>[Tab caption]:<ul><li>当前选项卡的标题。</li><li>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</li><li>如果未指定标题，但指定了图标，则标题将为空。</li><li>可选参数。</li></ul></li><li>[@icon]:<ul><li>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</li><li>可以指定带空格或不带空格；</li><li>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</li><li>可选参数。</li></ul></li></ol><p>示例1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>示例2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line">**tab名字为第一个Tab**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line">**只有图标 没有Tab名字**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line">**名字+icon**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>示例1</p><p>.<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">test1 1</button><button type="button" class="tab">test1 2</button><button type="button" class="tab">test1 3</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>This is Tab 1.</strong></p></div><div class="tab-item-content"><p><strong>This is Tab 2.</strong></p></div><div class="tab-item-content"><p><strong>This is Tab 3.</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></p><p>示例2</p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">第一个Tab</button><button type="button" class="tab"><i class="fab fa-apple-pay"></i></button><button type="button" class="tab"><i class="fas fa-bomb"></i>炸弹</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>tab名字为第一个Tab</strong></p></div><div class="tab-item-content"><p><strong>只有图标 没有Tab名字</strong></p></div><div class="tab-item-content"><p><strong>名字+icon</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="音频-audio"><a href="#音频-audio" class="headerlink" title="音频 audio"></a>音频 audio</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">参数配置</button><button type="button" class="tab">示例代码</button><button type="button" class="tab">演示</button></div><div class="tab-contents"><div class="tab-item-content active"></div><div class="tab-item-content"></div><div class="tab-item-content"></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> 博客写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 写作技巧 </tag>
            
            <tag> 博客指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STUDY210学习</title>
      <link href="/2024/08/06/test/STUDY210(%E6%9C%B1%E6%9C%89%E9%B9%8F)/"/>
      <url>/2024/08/06/test/STUDY210(%E6%9C%B1%E6%9C%89%E9%B9%8F)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="隐藏文件与非隐藏文件"><a href="#隐藏文件与非隐藏文件" class="headerlink" title="隐藏文件与非隐藏文件"></a>隐藏文件与非隐藏文件</h1><p>Windows中：文件隐藏与不隐藏通过设置文件属性实现的，可以点击文件，右键属性，选择勾选隐藏选项来设置文件为隐藏文件。。在Windows中查看隐藏文件方法：菜单栏 工具-&gt;文件夹选项-&gt;查看-&gt;显示所有文件<br>和文件夹。<br>Linux中：linux中隐藏文件特点是文件名以.开头，跟文件属性无关。在linux中查看隐藏文件用ls -a命令（普通显示ls）</p><h1 id="相对路径与绝对路径"><a href="#相对路径与绝对路径" class="headerlink" title="相对路径与绝对路径"></a>相对路径与绝对路径</h1><p>什么是路径：路径是用来标识一个文件在操作系统的文件系统中存储位置的。pathname<br>举例：<br>D:\winshare\enum.c 全路径 pathname<br>D:\winshare路径 path<br>enum.c文件名name</p><p>绝对路径：路径是从绝对位置开始的。譬如Windows中从某一个盘符开始（C:\），linux中从根目录&#x2F;开始<br>相对路径：指明路径的时候，是从当前所在的位置开始的。</p><p>举例：<br>D:\我的文档\123\123.txt<br>D:\我的文档\abc\abc.txt<br>当前在123.txt，但是要去abc.txt<br>方式1：采用绝对路径。D:\我的文档\abc\abc.txt<br>方式2：采用相对路径。..&#x2F;abc&#x2F;abc.txt (..表示上一层)<br>从当前路径开始，往上走一层，再往下走一层（abc）就到了</p><p>测试：<br>&#x2F;abc&#x2F;123&#x2F;def.txt是linux绝对路径<br>abc&#x2F;123&#x2F;def.txt不是linux绝对路径<br>F:\abc\123\def.txt是windows绝对路径<br>abc\123\def.txt不是windows绝对路径</p><h1 id="linux内核、发行版"><a href="#linux内核、发行版" class="headerlink" title="linux内核、发行版"></a>linux内核、发行版</h1><p>linux本身指的是一个操作系统内核，只有内核是无法直接使用的。我们需要的，可以使用的操作系统是一个包含了内核和一批有用的应用程序的一个集合体，这个就叫linux发行版。<br>ubuntu、redhat就是linux的不同的发行版。</p><h1 id="GUI（图形用户界面）和cmdline（命令行）"><a href="#GUI（图形用户界面）和cmdline（命令行）" class="headerlink" title="GUI（图形用户界面）和cmdline（命令行）"></a>GUI（图形用户界面）和cmdline（命令行）</h1><p>GUI：grahics user interface，图形用户界面。<br>cmdline：command line，命令行。<br>人机交互：人和机器（计算机）进行交互，常用的有命令行和GUI。<br>Windows下既有GUI，又有命令行。linux中也是既有GUI，又有命令行。<br>但是，在linux中我们常用命令行(生产用)，在Windows中常用GUI（娱乐用）</p><h1 id="linux常用命令："><a href="#linux常用命令：" class="headerlink" title="linux常用命令："></a>linux常用命令：</h1><p>(1) ls（list，列表）<br>作用：使用列表把当前文件夹下所有文件显示出来<br>    ls -a显示所有文件，包括隐藏文件<br>    ls -l以详细信息显示<br>    ls -a -l<br>    ls -l -a<br>    ls -la<br>    ls -al四种方式都是可以的</p><p>man 作用：查询帮助信息</p><p>man 1 查询linux命令 </p><p>man2 查询api   </p><p>man3查询C库函数</p><p>(2)cd（change directory，更改目录）</p><p>作用：用来切换目录<br>涉及到相对路径和绝对路径<br>cd ....代表上一层目录<br>cd.   .代表当前目录</p><p>(3) pwd（print work directory，打印工作目录）<br>作用：打印出当前的绝对路径</p><p>(4) mkdir（make directory，创建文件夹）<br>作用：创建空文件夹<br>    mkdir -p 级联创建文件夹  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir runoob        #在工作目录下，建立一个名为 runoob 的子目录 </span><br><span class="line">mkdir -p runoob2/test   #在工作目录下的 runoob2 目录中，建立一个名为 test 的子目录。</span><br><span class="line">若 runoob2 目录原本不存在，则建立一个。（注：本例若不加 -p 参数，且原本 runoob2 目录不存在，则产生错误。）</span><br></pre></td></tr></table></figure><p>(5) mv（move，移动）<br>作用：在目录间移动文件，重命名文件<br>    mv 源文件pathname 目的文件pathname</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv source_file(文件) dest_file(文件) #将源文件名 source_file 改为目标文件名 dest_file</span><br><span class="line">mv source_file(文件) dest_directory(目录) #将文件 source_file 移动到目标目录 dest_directory 中</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法碎片</title>
      <link href="/2024/08/06/test/%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E7%A2%8E%E7%89%87/"/>
      <url>/2024/08/06/test/%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E7%A2%8E%E7%89%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="蔡勒公式："><a href="#蔡勒公式：" class="headerlink" title="蔡勒公式："></a>蔡勒公式：</h1><p>计算星期几的常用方法之一是使用“<strong>蔡勒公式</strong>”（Zeller’s Congruence）。这个公式可以计算给定日期对应的星期几，具体步骤如下：</p><h1 id="蔡勒公式的步骤："><a href="#蔡勒公式的步骤：" class="headerlink" title="蔡勒公式的步骤："></a><strong>蔡勒公式的步骤</strong>：</h1><ol><li><p><strong>调整月份与年份</strong>：</p><ul><li>如果月份是1月（1）或2月（2），则将其视为前一年的13月或14月，并将年份减1。</li><li>对于其他月份，直接使用该月份和年份。</li></ul></li><li><p><strong>设定公式变量</strong>：</p><ul><li>设定以下变量：<ul><li>：日期（一个月中的日）</li><li>：月份（3-12代表3月到12月，1月和2月用13和14表示）</li><li>：年份的后两位（year % 100）</li><li>：年份的前两位（year &#x2F; 100）</li></ul></li></ul></li><li><p><strong>应用公式计算</strong>：</p><ul><li><p>使用公式计算： </p></li><li><p><img src="/2024/08/06/test/%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E7%A2%8E%E7%89%87/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20241113212816146.png" alt="image-20241113212816146"></p></li><li><p>其中，</p><p>的值代表星期：</p><ul><li>0 &#x3D; Saturday</li><li>1 &#x3D; Sunday</li><li>2 &#x3D; Monday</li><li>3 &#x3D; Tuesday</li><li>4 &#x3D; Wednesday</li><li>5 &#x3D; Thursday</li><li>6 &#x3D; Friday</li></ul></li></ul></li></ol><h2 id="示例C语言实现："><a href="#示例C语言实现：" class="headerlink" title="示例C语言实现："></a><strong>示例C语言实现</strong>：</h2><p>以下是使用蔡勒公式计算任何给定日期的星期几的示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getDayOfWeek</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (month &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        month += <span class="number">12</span>; <span class="comment">// 将1月和2月视为上一年的13月和14月</span></span><br><span class="line">        year--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> q = day;                       <span class="comment">// 日期</span></span><br><span class="line">    <span class="type">int</span> m = month;                     <span class="comment">// 月份</span></span><br><span class="line">    <span class="type">int</span> K = year % <span class="number">100</span>;                <span class="comment">// 年份的后两位</span></span><br><span class="line">    <span class="type">int</span> J = year / <span class="number">100</span>;                <span class="comment">// 年份的前两位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 蔡勒公式</span></span><br><span class="line">    <span class="type">int</span> h = (q + (<span class="number">13</span> * (m + <span class="number">1</span>)) / <span class="number">5</span> + K + (K / <span class="number">4</span>) + (J / <span class="number">4</span>) - <span class="number">2</span> * J) % <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h; <span class="comment">// 返回星期几</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> year = <span class="number">2024</span>;</span><br><span class="line">    <span class="type">int</span> month = <span class="number">10</span>; <span class="comment">// 例如10月</span></span><br><span class="line">    <span class="type">int</span> day = <span class="number">1</span>;    <span class="comment">// 例如1日</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> weekday = getDayOfWeek(year, month, day);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;日期 %d-%d-%d 是星期：%d\n&quot;</span>, year, month, day, weekday);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CopyInsert</p><p>运行这段代码可以计算给定日期（例如2024年10月1日）对应的星期几。在这个示例中，输出的星期会以数字形式显示，可以根据前面提到的对应关系来判断具体是哪一天。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程技巧 </tag>
            
            <tag> 代码优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>韦东山</title>
      <link href="/2024/08/06/test/%E9%9F%A6%E4%B8%9C%E5%B1%B1linux/"/>
      <url>/2024/08/06/test/%E9%9F%A6%E4%B8%9C%E5%B1%B1linux/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/./../../images/image-20250521175813146.png" alt="image-20250521175813146"></p><p>hexdump是Linux下的一个二进制文件查看工具，它可以将二进制文件转换为ASCII、八进制、十进制、十六进制格式进行查看。</p><p><code>echo</code> 是 Linux 系统中一个非常常用的命令，主要用于在终端输出字符串或变量的值。</p>]]></content>
      
      
      <categories>
          
          <category> 韦东山linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程技巧 </tag>
            
            <tag> 韦东山linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux驱动模型详解</title>
      <link href="/2024/06/06/test/Linux%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/06/06/test/Linux%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>让所有很久很久以前都走到幸福结局的时刻</strong></p><h2 id="1-Linux-驱动模型"><a href="#1-Linux-驱动模型" class="headerlink" title="1.Linux 驱动模型"></a>1.Linux 驱动模型</h2><p>本节内容，重在理解。面试时，面试官很大可能会让你挑一个你熟悉的驱动讲讲，如何编写的？能回答出大概的驱动框架就可以。</p><h3 id="1-1-字符设备驱动模型"><a href="#1-1-字符设备驱动模型" class="headerlink" title="1.1 字符设备驱动模型"></a>1.1 字符设备驱动模型</h3><p>驱动初始化中涉及到一个设备描述结构的概念。在任何一种驱动模型中，设备都会用内核中的一种结构来描述，这种结构成为<strong>设备描述结构</strong>。字符设备在内核中使用<code>struct cdev</code>这种结构来描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span> <span class="comment">//设备操作集</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">dev_t</span> dev; <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count; <span class="comment">//设备数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>count表明该类型设备的数目，如有两个串口，则count的值为2。</p></li><li><p>dev是设备号，包含有主设备号和次设备号的信息。主设备号用于区分设备的类型，次设备号用于标记相同类型的设备的不同个体。如串口1和串口2使用同一驱动程序，则其主设备号相同，但次设备号不同。Linux内核中使用<code>dev_t</code>类型来定义设备号，<code>dev_t</code>这种类型其实质为32位的<code>unsigned int</code>，其中高12位为主设备号，低20位为次设备号。</p><ol><li>知道主设备号与次设备号，可通过<code>dev_t dev = MKDEV(主设备号，次设备号)</code> 获得设备号；</li><li>从设备号分解出主设备号：主设备号 &#x3D; <code>MAJOR(dev_t dev)</code></li><li>从设备号分解出次设备号：次设备号 &#x3D; <code>MINOR(dev_t dev)</code></li></ol></li><li><p>主设备号是一个重要的资源，可以通过静态申请和动态分配为设备分配一个主设备号：</p><ol><li>静态申请：开发者自己选择一个数字作为主设备号，然后通过函数<code>register_chrdev_region</code>向内核申请使用。这种方法的缺点是如果申请使用的设备号已经被内核中的其它驱动使用了，则申请失败。</li><li>动态分配：使用<code>alloc_chrdev_region</code>由内核分配一个可用的主设备号。因为内核知道哪些号已经被使用了，所以不会导致分配到已经被使用的号。既然设备号是一种资源，则设备驱动在退出后都应该释放该资源。使用<code>unregister_chrdev_region</code>函数释放这些设备号。</li></ol></li><li><p>ops是操作函数集。<code>file_operations</code>是一个很重要的结构，该结构的成员基本都是函数指针，并且是一些文件操作的函数的指针。</p></li><li><pre><code class="c">struct file_operations &#123;  struct module *owner;  loff_t(*llseek) (struct file *, loff_t, int);  ssize_t(*read) (struct file *, char __user *, size_t, loff_t *);  ssize_t(*aio_read) (struct kiocb *, char __user *, size_t, loff_t);  ssize_t(*write) (struct file *, const char __user *, size_t, loff_t *);  ssize_t(*aio_write) (struct kiocb *, const char __user *, size_t, loff_t);  int (*readdir) (struct file *, void *, filldir_t);  unsigned int (*poll) (struct file *, struct poll_table_struct *);  int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);  int (*mmap) (struct file *, struct vm_area_struct *);  int (*open) (struct inode *, struct file *);  int (*flush) (struct file *);  int (*release) (struct inode *, struct file *);  int (*fsync) (struct file *, struct dentry *, int datasync);  int (*aio_fsync) (struct kiocb *, int datasync);  int (*fasync) (int, struct file *, int);  int (*lock) (struct file *, int, struct file_lock *);  ssize_t(*readv) (struct file *, const struct iovec *, unsigned long, loff_t *);  ssize_t(*writev) (struct file *, const struct iovec *, unsigned long, loff_t *);  ssize_t(*sendfile) (struct file *, loff_t *, size_t, read_actor_t, void __user *);  ssize_t(*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);  unsigned long (*get_unmapped_area) (struct file *, unsigned long,unsigned long, unsigned long,unsigned long);&#125;;    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`struct file_operations`是一个函数指针的集合，定义能在设备上进行的操作。结构中的函数指针指向驱动中的函数，这些函数实现一个针对设备的操作, 对于不支持的操作则设置函数指针为 NULL。例如：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">struct file_operations dev_fops = &#123;</span><br><span class="line">    .llseek = NULL,</span><br><span class="line">    .read = dev_read,</span><br><span class="line">    .write = dev_write,</span><br><span class="line">    .ioctl = dev_ioctl,</span><br><span class="line">    .open = dev_open,</span><br><span class="line">    .release = dev_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>- 该结构体表示应用程序能够对设备文件使用函数`read()`, `write()`等，但不能使用函数`llseek()`。当执行到`read()`函数时，内核根据该结构体转移到驱动程序中的`dev_read`函数去执行。- 驱动初始化有四大步骤：  1.**分配**  - cdev变量的定义可以采用静态和动态两种办法：  - 静态分配：`struct cdev mdev`；  - 动态分配：`struct cdev *pdev = cdev_alloc()`；  2.**初始化**  - `struct cdev`的初始化使用`cdev_init`函数来完成。  - 原型：`cdev_init(struct cdev *cdev, const struct file_operations *fops)`  - 参数：    - `cdev`：待初始化的cdev结构    - `fops`：设备对应的操作函数集  3.注册  - 字符设备的注册使用`cdev_add`函数来完成。  - 原型：`cdev_add(struct cdev *p, dev_t dev, unsigned count)`  - 参数：    - `p`：待添加到内核的字符设备结构    - `dev`：设备号    - `count`：该类设备的设备个数  4.**硬件初始化**  - 根据相应硬件的数据手册完成初始化。</code></pre></li></ul><h3 id="1-2-实现设备操作"><a href="#1-2-实现设备操作" class="headerlink" title="1.2 实现设备操作"></a>1.2 实现设备操作</h3><p>由struct file_operations可以看出，要实现的操作并不少，这里只介绍一些重要的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*open)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *) <span class="comment">//打开设备，响应open系统调用</span></span><br><span class="line"><span class="type">int</span> (*release)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);<span class="comment">//关闭设备，响应close系统调用</span></span><br><span class="line"><span class="type">loff_t</span> (*llseek)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>) <span class="comment">//重定位读写指针，响应lseek系统调用</span></span><br><span class="line"><span class="type">ssize_t</span> (*read)(<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *) <span class="comment">//从设备读取数据，响应read系统调用</span></span><br><span class="line"><span class="type">ssize_t</span> (*write)(<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *) <span class="comment">//向设备写入数据，响应write系统调用</span></span><br></pre></td></tr></table></figure><ul><li><p>以上几个函数涉及到了<code>struct inode</code>和<code>struct file</code>这两种结构体。</p></li><li><p>在Linux系统中，每一个<strong>打开的文件</strong>，在内核中都会关联一个<code>struct file</code>结构体，它由内核在打开文件时创建，在文件关闭后释放。该结构体的重要成员有：</p></li><li><pre><code class="c">loff_t f_pos /*文件读写指针*/struct file_operations *f_op /*该文件所对应的操作*/<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">每一个存在于文件系统里面的文件都会关联一个`inode` 结构，该结构主要用来**记录文件物理上的信息**。因此，它和代表打开文件的file结构是不同的。一个文件**没有被打开时不会关联file结构，但是却会关联一个inode结构**。该结构体重要的成员有：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">dev_t i_rdev /*设备号*/</span><br></pre></td></tr></table></figure>- 一个设备支持的函数操作又称为设备方法。- `open`设备方法是驱动程序用来为以后的操作完成**初始化**准备工作的。在大部分驱动程序中，open完成如下工作：**标明次设备号、启动设备**。- `release`设备方法的作用与open相反，这个设备方法有时也称为close，它完成的工作是**关闭设备**。- `read`设备方法通常完成两件事情：从设备中**读取数据**(属于硬件访问类操作)，将读取到的数据**返回给应用程序**。- ```c  ssize_t (*read)(struct file *filp,char __user *buff,size_t count,loff_t *offp)  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 参数说明：</span><br><span class="line"></span><br><span class="line">  1. `filp`：与字符设备文件关联的file结构指针，由内核创建。</span><br><span class="line">  2. `buff`：从设备读取到的数据，需要**保存到的位置**。由read系统调用提供该参数。</span><br><span class="line">  3. `count`：请求传输的**数据量**，由read系统调用提供该参数。</span><br><span class="line">  4. `offp`：文件的**读写位置**，由内核从file结构中取出后(相当于读取指针)，传递进来。</span><br><span class="line"></span><br><span class="line">- 要注意的是，`buff`参数是来源于用户空间的指针，这类指针都**不能被内核代码直接引用**，必须使用专门的函数：</span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">  int copy_to_user(void __user *to, const void *from, int n)// 内核态-&gt;用户态</span><br><span class="line">  int copy_from_user(void *to, const void __user *from, int n)// 用户态-&gt;内核态</span><br></pre></td></tr></table></figure>    - 其中`copy_to_user()`用于将内核数据传送给用户空间；`copy_from_user()`用于将用户空间的数据传送给内核空间。    - `write`设备方法通常完成两件事情：**从应用程序提供的地址中取出数据，将数据写入设备**(属于硬件访问类操作)    - 函数原型：`ssize_t (*write)(struct file *, const char __user *, size_t, loff_t *)`    - 驱动注销：当我们从内核中卸载驱动程序的时候，需要使用`cdev_del`函数来完成字符设备的注销。    - 一个驱动程序范例：    - ```c      #include &lt;linux/module.h&gt;      #include &lt;linux/types.h&gt;      #include &lt;linux/fs.h&gt;      #include &lt;linux/errno.h&gt;      #include &lt;linux/init.h&gt;      #include &lt;linux/cdev.h&gt;      #include &lt;asm/uaccess.h&gt;      #include &lt;linux/slab.h&gt;             int dev1_registers[5];      int dev2_registers[5];             struct cdev cdev; // 字符驱动设备      dev_t devno;// 设备号             /*文件打开函数*/      int mem_open(struct inode *inode, struct file *filp)      &#123;          /*获取次设备号*/          int num = MINOR(inode-&gt;i_rdev);                 if (num==0)              filp-&gt;private_data = dev1_registers;          else if(num == 1)              filp-&gt;private_data = dev2_registers;          else              return -ENODEV;  //无效的次设备号                 return 0;       &#125;             /*文件释放函数*/      int mem_release(struct inode *inode, struct file *filp)      &#123;        return 0;      &#125;             /*读函数 返回读取了多少个数据*/      static ssize_t mem_read(struct file *filp, char __user *buf, size_t size, loff_t *ppos)      &#123;        unsigned long p =  *ppos;        unsigned int count = size;        int ret = 0;        int *register_addr = filp-&gt;private_data; /*获取设备的寄存器基地址*/               /*判断读位置是否有效*/        if (p &gt;= 5*sizeof(int))          return 0;        if (count &gt; 5*sizeof(int) - p)          count = 5*sizeof(int) - p;               /*读数据到用户空间 从基地址偏移p个(p为开始读的位置 即ppos描述的相对位置)*/        if (copy_to_user(buf, register_addr+p, count))        &#123;          ret = -EFAULT;        &#125;        else        &#123;          *ppos += count;          ret = count;        &#125;               return ret;      &#125;             /*写函数*/      static ssize_t mem_write(struct file *filp, const char __user *buf, size_t size, loff_t *ppos)      &#123;        unsigned long p =  *ppos;        unsigned int count = size;        int ret = 0;        int *register_addr = filp-&gt;private_data; /*获取设备的寄存器地址*/               /*分析和获取有效的写长度*/        if (p &gt;= 5*sizeof(int))          return 0;        if (count &gt; 5*sizeof(int) - p)          count = 5*sizeof(int) - p;               /*从用户空间写入数据*/        if (copy_from_user(register_addr + p, buf, count))          ret = -EFAULT;        else        &#123;          *ppos += count;          ret = count;        &#125;               return ret;      &#125;             /* seek文件定位函数 */      static loff_t mem_llseek(struct file *filp, loff_t offset, int whence)      &#123;           loff_t newpos;                 switch(whence) &#123;            case SEEK_SET:               newpos = offset;              break;                   case SEEK_CUR:               newpos = filp-&gt;f_pos + offset;              break;                   case SEEK_END:               newpos = 5*sizeof(int)-1 + offset;              break;                   default:               return -EINVAL;          &#125;          if ((newpos&lt;0) || (newpos&gt;5*sizeof(int)))              return -EINVAL;                 filp-&gt;f_pos = newpos;          return newpos;             &#125;             /*文件操作结构体*/      static const struct file_operations mem_fops =      &#123;        .llseek = mem_llseek,        .read = mem_read,        .write = mem_write,        .open = mem_open,        .release = mem_release,      &#125;;             /*设备驱动模块加载函数*/      static int memdev_init(void)      &#123;        /*初始化cdev结构*/        cdev_init(&amp;cdev, &amp;mem_fops);               /* 注册字符设备 */        alloc_chrdev_region(&amp;devno, 0, 2, &quot;memdev&quot;);        cdev_add(&amp;cdev, devno, 2);      &#125;             /*模块卸载函数*/      static void memdev_exit(void)      &#123;        cdev_del(&amp;cdev);   /*注销设备*/        unregister_chrdev_region(devno, 2); /*释放设备号*/      &#125;             MODULE_LICENSE(&quot;GPL&quot;);             module_init(memdev_init);      module_exit(memdev_exit);      <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">### 1.3 总线设备驱动模型</span><br><span class="line"></span><br><span class="line">- 自内核2.6版本开始，需要关注的是**总线、设备和驱动**这3个实体，总线将设备和驱动绑定。在Linux内核系统中注册一个设备的时候，会寻找与之对应驱动进行匹配；相反地，系统中注册一个驱动的时候，会去寻找一个对应的设备进行匹配。**匹配的的工作由总线来完成**。</span><br><span class="line"></span><br><span class="line">- **在Linux设备中有的是没有对应的物理总线的，但为了适配Linux的总线模型，内核针对这种没有物理总线的设备开发了一种虚拟总线——platform总线**。将设备和驱动独立开，驱动尽可能写的通用，当来了一个类似的设备后也可以使用这个驱动，让驱动程序可以重用。这体现了Linux驱动的软件架构设计的思想。</span><br><span class="line"></span><br><span class="line">- 按照这个思路，Linux中的设备和驱动都需要挂接在一种总线上，比如i2c总线上的eeprom，eeprom作为设备，**eeprom的驱动都挂接在i2c驱动上**。但是在嵌入式系统中，**soc系统一般都会集成独立的i2c控制器，控制器也是需要驱动的，但是再按照设备-总线-驱动模型进行设计，就会发现无法找到一个合适总线去挂接控制器设备和控制器驱动了（i2c控制器是挂接在CPU内部的总线上，而不是i2c总线）**，所以Linux发明了一种虚拟总线，称为platform总线，相应的设备称为**platform_device（控制器设备），对应的驱动为platform_driver（控制器驱动），用platform总线来承载这些相对特殊的系统**。</span><br><span class="line"></span><br><span class="line">- 注意：**所谓的platform_device并不是与字符设备、块设备和网络设备并列的概念，而是Linux系统提供的一种附加手段**。例如，在 S3C6410处理器中，把内部集成的I2C、RTC、SPI、LCD、看门狗等控制器都归纳为platform_device，而它们本身就是字符设备。我们要记住，platform 驱动只是在**字符设备驱动外套一层platform_driver 的外壳**。引入platform模型符合Linux 设备模型 —— 总线、设备、驱动，设备模型中配套的sysfs节点都可以用，方便我们的开发；**当然你也可以选择不用，不过就失去了一些platform带来的便利**。</span><br><span class="line"></span><br><span class="line">- 设备驱动中引入platform 概念，隔离BSP和驱动。在BSP中定义platform设备和设备使用的资源、设备的具体匹配信息，而在驱动中，只需要通过API去获取资源和数据，做到了板相关代码和驱动代码的分离，使得驱动具有更好的可扩展性和跨平台性。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  - **下面分析下总线设备驱动模型的匹配过程**</span><br><span class="line">    1. 一边的`device`结构体和另一边的`较稳定的 driver 代码`的联系：`device_add()`除将`device`结构放到 bus 的`dev 链表`之外，还会从另一边的`drv`链表中取表元即某个`driver`结构，用总线里的一个`（.match）`函数来作比较，看另一边的`driver`是否支持一边的`device`。若是能够支持，则接着调用软件驱动部分的`.probe`函数。`driver_register()`会将`bus_drv_dev`模型中的较稳定代码`driver`结构体放到虚拟总线的某个链表（drv 链表）中。从另一边的`dev`链表中取出每一个`device`结构用 bus 中的`.match`函数来作比较。</span><br><span class="line">    2. 若支持则调用`.probe`函数。左右两个注册就建立起来的一种机制。在`.probe`函数中做的事件由自已决定，打印一句话，或注册一个字符设备，再或注册一个`input_dev`结构体等等都是由自已决定。强制的把一个驱动程序分为左右两边这种机制而已，可以把这套东西放在任何地方，这里的`driver`只是个结构体不要被这个名字迷惑，`device`也只是个结构体，里面放什么内容都是由自已决定的。</span><br><span class="line"></span><br><span class="line">### 1.4 输入子系统模型</span><br><span class="line"></span><br><span class="line">每个硬件都有一个`input_dev`结构体，每个软件都有一个`input_handler`结构体。`input_dev`和`input_handler`分别通过`input_register_device()`，`input_register_handler()`向核心层注册硬件和软件。</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul><p>int input_register_device(struct input_dev *dev)   &#x2F;&#x2F;*dev:要注册的驱动设备<br>{<br> … …<br>       list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);   &#x2F;&#x2F;(1)放入链表中<br> … …<br>       list_for_each_entry(handler, &amp;input_handler_list, node)  &#x2F;&#x2F;(2)<br>       input_attach_handler(dev, handler);<br> … …<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 从`input_dev`方向分析：`input`设备在增加到`input_dev_list`链表上之后，会查找 `input_handler_list`事件处理链表上的`handler`进行匹配，这里的匹配方式与总线设备驱动模型的`device`和`driver`匹配过程很相似，所有的`input_device`都挂在`input_dev_list`上，所有类型的事件都挂在`input_handler_list`上，进行“匹配相亲”。如果匹配上了，就调用`input_handler`的`connect`函数进行连接。设备就是在此时注册的。</span><br><span class="line">- 从`input_handler`方向分析：将`handler`挂到链表`input_handler_list`下，然后遍历`input_dev_list`链表,查找并匹配输入设备对应的事件处理层，如果匹配上了，就调用`connect`函数进行连接，并创建`input_handle`结构。</span><br><span class="line">- 所以，不管新添加`input_dev`还是`input_handler`，都会进入`input_attach_handler()`判断两者id是否有支持, 若两者支持便进行连接。</span><br><span class="line"></span><br><span class="line">### 1.5 platform总线的匹配规则是什么？在具体应用上要不要先注册驱动再注册设备？有先后顺序没？</span><br><span class="line"></span><br><span class="line">- 匹配规则就是当有一个新的设备挂起时，总线被唤醒，`match`函数被调用，用`device`名字去跟本总线下的所有驱动名字去比较。相反就是用驱动的名字去`device`链表中和所有`device`的名字比较。如果匹配上，才会调用驱动中的`probe`函数，否则不调用。至于先后顺序，鉴于个人理解，**不会有影响**，不管谁先谁后，bus都会完成匹配工作。</span><br><span class="line">- 设备驱动模型的出现主要有三个好处：</span><br><span class="line">  1. 设备与驱动分离，驱动**可移植性增强**；</span><br><span class="line">  2. 设备驱动抽象结构以总线结构表示看起来更加**清晰明了**，谁是属于哪一条bus的；</span><br><span class="line">  3. 设备与驱动分离，很好的奠定了**热插拔**机制。</span><br><span class="line"></span><br><span class="line">## 2.Linux内核</span><br><span class="line"></span><br><span class="line">### 2.1 内核镜像格式有几种？分别有什么区别？</span><br><span class="line"></span><br><span class="line">1. uboot经过编译直接生成的elf格式的可执行程序是u-boot，这个程序类似于windows下的exe格式，在操作系统下是**可以直接执行**的。但是这种格式**不能用来烧录下载**。我们用来烧录下载的是u-boot.bin，这个东西是由u-boot使用arm-linux-objcopy工具进行加工（主要目的是去掉一些无用的东西）得到的。这个u-boot.bin就叫镜像（image），镜像就是用来烧录到iNand中执行的。</span><br><span class="line">2. linux内核经过编译后也会生成一个elf格式的可执行程序，叫**vmlinux或vmlinuz**，这个就是**原始的未经任何处理加工的原版内核elf文件**；嵌入式系统部署时烧录的一般不是这个vmlinuz/vmlinux，而是要用objcopy工具去制作成烧录镜像格式（就是u-boot.bin这种，但是内核没有.bin后缀），经过制作加工成烧录镜像的文件就叫**Image**（制作把78M大的精简成了7.5M，因此这个制作烧录镜像主要目的就是缩减大小，节省磁盘）。</span><br><span class="line">3. 原则上Image就可以直接被烧录到Flash上进行启动执行（类似于u-boot.bin），但是实际上并不是这么简单。实际上linux的作者们觉得Image还是太大了所以对Image进行了压缩，并且在image压缩后的文件的**前端附加了一部分解压缩代码**。构成了一**个压缩格式的镜像就叫zImage**。（因为当年Image大小刚好比一张软盘（软盘有2种，1.2M的和1.44MB两种）大，为了节省1张软盘的钱于是乎设计了这种压缩Image成zImage的技术）。</span><br><span class="line">4. uboot为了启动linux内核，还发明了一种内核格式叫uImage。**uImage是由zImage加工得到的**，uboot中有一个工具，可以将zImage加工生成uImage。注意：uImage不关linux内核的事，linux内核只管生成zImage即可，然后uboot中的mkimage工具再去由zImage加工生成uImage来给uboot启动。这个加工过程其实就是**在zImage前面加上64字节的uImage的头信息即可**。</span><br><span class="line">5. 原则上uboot启动时应该给他uImage格式的内核镜像，但是实际上uboot中也可以支持zImage，是否支持就看x210_sd.h中是否定义了LINUX_ZIMAGE_MAGIC这个宏。所以大家可以看出：有些uboot是支持zImage启动的，有些则不支持。但是**所有的uboot肯定都支持uImage启动**。</span><br><span class="line">6. 如果直接在kernel底下去`make uImage`会提供`mkimage command not found`。解决方案是去`uboot/tools`下`cp mkimage /usr/local/bin/`，复制mkimage工具到系统目录下。再去`make uImage`即可。</span><br><span class="line"></span><br><span class="line">&gt; 通过上面的介绍我们了解了内核镜像的各种格式，如果通过uboot启动内核，Linux必须为**uImage**格式。</span><br><span class="line"></span><br><span class="line">### 2.2 内核中申请内存有哪几个函数？有什么区别？</span><br><span class="line"></span><br><span class="line">1. **kmalloc**</span><br><span class="line"></span><br><span class="line">   ```c</span><br><span class="line">   void *kmalloc(size_t size, gfp_t flags)</span><br></pre></td></tr></table></figure><p>   <code>kmalloc</code>是内核中最常用的一种内存分配方式，它通过调用<code>kmem_cache_alloc</code>函数来实现。<code>kmalloc</code>一次最多能申请的内存大小由<code>include/linux/Kmalloc_size.h</code>的内容来决定，在默认的2.6.18内核版本中，kmalloc一次最多能申请大小为131702B也就是<strong>128KB</strong>字节的连续物理内存。测试结果表明，如果试图用kmalloc函数分配大于128KB的内存，编译不能通过。</p><ol start="2"><li><p><strong>vmalloc</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">vmalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br></pre></td></tr></table></figure><p>前面几种内存分配方式都是物理连续的，能保证较低的平均访问时间。但是在某些场合中，对内存区的请求不是很频繁，较高的内存访问时间也可以接受，这是就可以分配一段<strong>线性连续，物理不连续</strong>的地址，带来的好处是一次可以<strong>分配较大块的内存</strong>。图3-1表示的是<code>vmalloc</code>分配的内存使用的地址范围。<code>vmalloc</code>对一次能分配的内存大小没有明确限制。出于性能考虑，应谨慎使用<code>vmalloc</code>函数。在测试过程中，<strong>最大能一次分配1GB的空间</strong>。</p></li><li><p><strong>dma_alloc_coherent</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">dma_alloc_coherent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> size,<span class="type">ma_addr_t</span> </span></span><br><span class="line"><span class="params">*dma_handle, <span class="type">gfp_t</span> gfp)</span></span><br></pre></td></tr></table></figure><p>DMA(直接内存访问 Direct Memory Access)是一种硬件机制，允许外围设备和主存之间直接传输IO数据，而不需要CPU的参与，使用DMA机制能<strong>大幅提高与设备通信的吞吐量</strong>。DMA操作中，涉及到CPU<strong>高速缓存和对应的内存数据一致性</strong>的问题，必须保证两者的数据一致，在x86_64体系结构中，硬件已经很好的解决了这个问题，<code>dma_alloc_coherentget_free_pages</code>函数实现差别不大，前者实际是调用<code>alloc_pages</code>函数来分配内存，因此一次分配内存的大小限制和后者一样。<code>__get_free_pages</code>分配的内存同样可以用于DMA操作。测试结果证明，<code>dma_alloc_coherent</code>函数一次能分配的最大内存也为<strong>4M</strong>。</p></li><li><p><strong>ioremap</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">ioremap</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> offset, <span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br></pre></td></tr></table></figure><p><code>ioremap</code>是一种更直接的内存“分配”方式，使用时直接<strong>指定物理起始地址和需要分配内存</strong>的大小，然后将该段<strong>物理地址映射到内核地址空间</strong>。<code>ioremap</code>用到的物理地址空间都是事先确定的，和上面的几种内存分配方式并不太一样，并不是分配一段新的物理内存。<code>ioremap</code>多用于<strong>设备驱动</strong>，可以让CPU直接访问外部设备的IO空间。<code>ioremap</code>能映射的内存由原有的物理内存空间决定，所以没有进行测试。</p></li></ol><h3 id="2-3-什么是内核空间，用户空间？"><a href="#2-3-什么是内核空间，用户空间？" class="headerlink" title="2.3 什么是内核空间，用户空间？"></a>2.3 什么是内核空间，用户空间？</h3><ul><li>对 32 位操作系统而言，它的寻址空间（虚拟地址空间，或叫线性地址空间）为 4G（2的32次方）。也就是说一个进程的最大地址空间为 4G。</li><li>操作系统的核心是内核(kernel)，它独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证内核的安全，现在的操作系统一般都强制<strong>用户进程不能直接操作内核</strong>。具体的实现方式基本都是由<strong>操作系统将虚拟地址空间划分为两部分</strong>，一部分为内核空间，另一部分为用户空间。针对 Linux 操作系统而言，<strong>最高的 1G 字节</strong>(从虚拟地址 <code>0xC0000000</code> 到 <code>0xFFFFFFFF</code>)由内核使用，称为<strong>内核空间</strong>。而<strong>较低的 3G 字节</strong>(从虚拟地址 <code>0x00000000</code> 到 <code>0xBFFFFFFF</code>)由各个进程使用，称为用户空间。</li><li>对上面这段内容我们也可以这样理解：<br>每个进程的 4G 地址空间中，最高 1G 都是一样的，即内核空间。只有剩余的 3G 才归进程自己使用。换句话说就是，<strong>最高 1G 的内核空间是被所有进程共享的</strong>！</li><li>下图描述了每个进程 4G 地址空间的分配情况：</li></ul><h3 id="2-4-为什么需要区分内核空间与用户空间？"><a href="#2-4-为什么需要区分内核空间与用户空间？" class="headerlink" title="2.4 为什么需要区分内核空间与用户空间？"></a>2.4 为什么需要区分内核空间与用户空间？</h3><ul><li>在 CPU 的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，比如<strong>清内存、设置时钟</strong>等。如果允许所有的程序都可以使用这些指令，那么系统<strong>崩溃的概率将大大增加</strong>。</li><li>所以，CPU 将指令分为<strong>特权指令</strong>和<strong>非特权指令</strong>，对于那些危险的指令，只允许操作系统及其相关模块使用，普通应用程序只能使用那些不会造成灾难的指令。比如 Intel 的 CPU 将特权等级分为 4 个级别：Ring0~Ring3。</li><li>其实 Linux 系统只使用了 Ring0 和 Ring3 两个运行级别(Windows 系统也是一样的)。当进程运行在 Ring3 级别时被称为运行在用户态，而运行在 Ring0 级别时被称为运行在内核态。</li></ul><h3 id="2-5-什么是内核态和用户态？"><a href="#2-5-什么是内核态和用户态？" class="headerlink" title="2.5 什么是内核态和用户态？"></a>2.5 什么是内核态和用户态？</h3><ul><li><p>当进程<strong>运行在内核空间时</strong>就处于内核态，而进程<strong>运行在用户空间</strong>时则处于用户态。</p></li><li><p>在内核态下，进程运行在内核地址空间中，此时 CPU 可以执行任何指令。运行的代码也不受任何的限制，可以自由地访问任何有效地址，也可以直接进行端口的访问。</p></li><li><p>在用户态下，进程运行在用户地址空间中，被执行的代码要受到 CPU 的诸多检查，它们只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址，且只能对任务状态段(TSS)中 I&#x2F;O 许可位图(I&#x2F;O Permission Bitmap)中规定的可访问端口进行直接访问。</p></li><li><p>对于以前的 DOS 操作系统来说，是没有内核空间、用户空间以及内核态、用户态这些概念的。可以认为所有的代码都是运行在内核态的，因而，用户编写的应用程序代码可以很容易的让操作系统崩溃掉。</p></li><li><p>对于 Linux 来说，通过区分内核空间和用户空间的设计，<strong>隔离了操作系统代码</strong>(操作系统的代码要比应用程序的代码健壮很多)<strong>与应用程序代码</strong>。即便是单个应用程序出现错误，也不会影响到操作系统的稳定性，这样其它的程序还可以正常的运行(Linux 可是个多任务系统啊！)。所以，<strong>区分内核空间和用户空间本质上是要提高操作系统的稳定性及可用性</strong>。</p></li><li><h3 id="2-6-用户空间与内核通信方式有哪些？"><a href="#2-6-用户空间与内核通信方式有哪些？" class="headerlink" title="2.6 用户空间与内核通信方式有哪些？"></a>2.6 用户空间与内核通信方式有哪些？</h3></li></ul><ol><li><p><strong>使用API</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_user(x，ptr) <span class="comment">//在内核中被调用，获取用户空间指定地址的数值并保存到内核变量x中。</span></span><br><span class="line">put_user(x，ptr) <span class="comment">//在内核中被调用，将内核空间的变量x的数值保存到到用户空间指定地址处。</span></span><br><span class="line">copy_from_user()/copy_to_user() <span class="comment">//主要应用于设备驱动读写函数中，通过系统调用触发。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用proc文件系统</strong><br>和<code>sysfs</code>文件系统类似，也可以作为内核空间和用户空间交互的手段。<code>/proc</code> 文件系统是一种虚拟文件系统，通过他可以作为一种linux内核空间和用户空间的桥梁。与普通文件不同，这里的虚拟文件的内容都是动态创建的。使用<code>/proc</code>文件系统的方式很简单。调用<code>create_proc_entry</code>，返回一个<code>proc_dir_entry</code>指针，然后去填充这个指针指向的结构就好了。(相当于proc为用户空间的进程开了个口访问内核空间)</p></li><li><p><strong>使用sysfs文件系统+kobject</strong><br>每个在内核中注册的<code>kobject</code>都对应着<code>sysfs</code>系统中的一个目录。可以通过读取根目录下的<code>sys</code>目录中的文件来获得相应的信息。除了<code>sysfs</code>文件系统和<code>proc</code>文件系统之外，一些其他的虚拟文件系统也能同样达到这个效果。</p></li><li><p><strong>netlink</strong><br><code>netlink socket</code>提供了一组类似于BSD风格的API，用于用户态和内核态的IPC。相比于其他的用户态和内核态IPC机制，netlink有几个好处：1.使用自定义一种协议完成数据交换，不需要添加一个文件等。2.可以支持多点传送。3.支持内核先发起会话。4.异步通信，支持缓存机制。</p></li><li><p><strong>文件</strong><br>应该说这是一种比较笨拙的做法，不过确实可以这样用。当处于内核空间的时候，直接操作文件，将想要传递的信息写入文件，然后用户空间可以读取这个文件便可以得到想要的数据了。下面是一个简单的测试程序，在内核态中，程序会向<code>/home/melody/str_from_kernel</code>文件中写入一条字符串，然后我们在用户态读取这个文件，就可以得到内核态传输过来的数据了。</p></li><li><p><strong>使用mmap系统调用</strong><br>可以将内核空间的地址映射到用户空间。在以前做嵌入式的时候用到几次。一方面可以在<code>driver</code>中修改<code>Struct file_operations</code>结构中的<code>mmap</code>函数指针来重新实现一个文件对应的映射操作。另一方面，也可以直接打开<code>/dev/mem</code>文件，把物理内存中的某一页映射到进程空间中的地址上。其实，除了重写<code>Struct file_operations</code>中<code>mmap</code>函数，我们还可以重写其他的方法如<code>ioctl</code>等，来达到驱动内核空间和用户空间通信的方式。</p></li><li><p><strong>信号</strong><br>从内核空间向进程发送信号。这个倒是经常遇到，用户程序出现重大错误，内核发送信号杀死相应进程。</p></li></ol><h3 id="2-7-内核链表为什么具有通用性？"><a href="#2-7-内核链表为什么具有通用性？" class="headerlink" title="2.7 内核链表为什么具有通用性？"></a>2.7 内核链表为什么具有通用性？</h3><p>内核中由于要管理大量的设备，但是各种设备各不相同，必须将他们统一起来管理，于是内核设计者就想到了使用通用链表来处理，通用链表看似神秘，实际上就是<strong>双向循环链表</strong>，这个链表的每个节点都是只有指针域，没有任何数据域。</p><ul><li>使用通用链表的好处是：<ol><li>通用链表中每个节点中<strong>没有数据域</strong>，也就是说无论数据结构有多复杂在链表中只有前后级指针。</li><li>如果一个数据结构（即是描述设备的设备结构体）想要用通用链表管理，只需要在结构体中包含<strong>节点的字段</strong>即可。</li><li>双向链表可以从任意一个节点的前后遍历整个链表，<strong>遍历非常方便</strong>。</li><li>使用循环链表使得可以不断地循环遍历管理节点，像进程的调度：操作系统会把<strong>就绪的进程</strong>放在一个管理进程的就绪队列的通用链表中管理起来，循环不断地，为他们<strong>分配时间片</strong>，获得cpu进行周而复始的进程调度。</li></ol></li></ul><h3 id="2-8-应用程序中open-在linux中执行过程中是如何从用户空间到内核空间？"><a href="#2-8-应用程序中open-在linux中执行过程中是如何从用户空间到内核空间？" class="headerlink" title="2.8 应用程序中open()在linux中执行过程中是如何从用户空间到内核空间？"></a>2.8 应用程序中open()在linux中执行过程中是如何从用户空间到内核空间？</h3><ol><li>应用层调用<code>open</code>函数，在VFS层中找到<code>struct inode</code>结构体，判断是字符设备还是块设备，根据设备号，可以找到对应的驱动程序。</li><li>在驱动层中，每个字符设备都有一个<code>struct cdev</code>结构体，这个结构体通过<code>struct inode</code>结构体中的<code>i_cdev</code>把连接起VFS层和驱动层，<code>struct cdev</code>结构体描述了字符设备所有信息，其中最重要的一项就是字符设备的操作函数接口，即<code>const struct file_operations *ops</code></li><li><code>struct cdev</code>结构体中的<code>struct file</code>结构体记录了操作字符设备的一些函数，比如<code>open read write</code>函数等。<code>struct file</code>结构体其实是在VFS层的，通过<code>struct file</code>结构体指针指向驱动层的<code>struct file</code>结构体将驱动层函数和VFS层链接起来</li><li>任务完成，VFS层会给应用返回一个<strong>文件描述符（fd）</strong>。这个fd是和<code>struct file</code>结构体对应的。</li></ol><h2 id="3-设备驱动"><a href="#3-设备驱动" class="headerlink" title="3.设备驱动"></a>3.设备驱动</h2><h3 id="3-1-请简述主设备号和次设备号的用途"><a href="#3-1-请简述主设备号和次设备号的用途" class="headerlink" title="3.1 请简述主设备号和次设备号的用途"></a>3.1 请简述主设备号和次设备号的用途</h3><ul><li><strong>主设备号：主设备号标识设备对应的特定的驱动程序</strong>。虽然现代的linux内核允许多个驱动程序共享主设备号，但我们看待的大多数设备仍然按照“一个主设备对应一个驱动程序”的原则组织</li><li><strong>次设备号：次设备号由内核使用，用于确定由主设备号对应驱动程序中的各个设备</strong>。依赖于驱动程序的编写方式，我们可以通过次设备号获得一个指向内核设备的直接指针，也可将此设备号当作设备本地数组的索引。</li></ul><h3 id="3-2-字符型驱动设备怎么创建设备文件？"><a href="#3-2-字符型驱动设备怎么创建设备文件？" class="headerlink" title="3.2 字符型驱动设备怎么创建设备文件？"></a>3.2 字符型驱动设备怎么创建设备文件？</h3><ol><li>手动创建<br><code>mknod /dev/led c 250 0</code> ，其中<code>dev/led</code>为设备节点 ,<code>c</code> 代表字符设备, <code>250</code>代表主设备号, <code>0</code>代表次设备号。</li><li>自动创建<br><code>UDEV/MDEV</code>是运行在用户态的程序，可以动态管理设备文件，包括创建和删除设备文件，运行在用户态意味着系统要运行之后，在 <code>/etc/init.d/rcS</code> 脚本文件中会执行 <code>mdev -s</code> 自动创建设备节点。</li></ol><h3 id="3-3-设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义"><a href="#3-3-设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义" class="headerlink" title="3.3 设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义"></a>3.3 设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义</h3><ul><li><p>注册一个字符设备驱动有两种方法：</p><ol><li><code>void cdev_init(struct cdev *cdev, struct file_operations *fops)</code> 该注册函数可以将<code>cdev</code>结构嵌入到自己的设备特定的结构中。<code>cdev</code>是一个指向结构体<code>cdev</code>的指针，而<code>fops</code>是指向一个类似于 <code>file_operations</code>结构（可以是<code>file_operations</code>结构，但不限于该结构）的指针。</li><li><code>int register_chrdev(unsigned int major, const char *name, struct file operations *fops)</code>；该注册函数是早期的注册函数，<code>major</code>是设备的主设备号，<code>name</code>是驱动程序的名称，而<code>fops</code>是默认的<code>file_operations</code>结构（这是只限于<code>file_operations</code>结构）。对于<code>register_chrdev</code>的调用将为给定的主设备号注册0－255作为次设备号，并为每个设备建立一个对应的默认<code>cdev</code>结构。</li></ol><h3 id="3-4-dev-下面的设备文件是怎么创建出来的？"><a href="#3-4-dev-下面的设备文件是怎么创建出来的？" class="headerlink" title="3.4 &#x2F;dev&#x2F;下面的设备文件是怎么创建出来的？"></a>3.4 &#x2F;dev&#x2F;下面的设备文件是怎么创建出来的？</h3></li><li><p>普遍说法有三种方式，<strong>devfs机制</strong>，<strong>udev机制</strong>，再有一个就是<strong>手动创建</strong>设备节点。谈谈个人见解：</p></li></ul><ol><li><code>devfs</code>机制从来没用过，应该是2.6以前的内核使用的；</li><li><code>udev</code>：其实就是现在常用的<code>device_create()</code>、<code>class_create()</code>这一套接口，所谓<code>udev</code>是上层用户空间程序，是基于驱动中创建使用了这两个接口而起作用的，但是<code>udev</code>在日常开发中几乎接触不到，我们只需在驱动中调用创建节点的这两个API就ok了，剩下的工作就交给<code>udev</code>去做了，有想深究它具体实现原理的那就自己去研究吧，我觉得会用就行了；</li><li><code>mknod</code>：新手最常用的一种创建设备节点方法，但并非入门后就再没有用途，在某些情境下，或许有人不想使用<code>udev</code>机制，于是把节点创建工作写在脚本里，这样也是无可厚非的。</li></ol><h3 id="3-5-Linux设备中字符设备和块设备有什么主要区别？分别举例。"><a href="#3-5-Linux设备中字符设备和块设备有什么主要区别？分别举例。" class="headerlink" title="3.5 Linux设备中字符设备和块设备有什么主要区别？分别举例。"></a>3.5 Linux设备中字符设备和块设备有什么主要区别？分别举例。</h3><ul><li>Linux中I&#x2F;O设备分为两类：块设备和字符设备。两种设备本身没有严格限制，但是，基于不同的功能进行了分类。</li><li><strong>字符设备</strong>：提供<strong>连续</strong>的数据流，应用程序可以顺序读取，通常不支持随机存取。相反，此类设备支持<strong>按字节&#x2F;字符</strong>来读写数据。字符终端、串口、鼠标、键盘、摄像头、声卡和显卡等就是典型的字符设备。</li><li><strong>块设备</strong>：应用程序可以<strong>随机访问</strong>设备数据，程序可自行确定读取数据的位置。硬盘是典型的块设备，应用程序可以寻址磁盘上的<strong>任何位置</strong>，并由此读取数据。此外，数据的读写只能以块(通常是512B)的倍数进行。与字符设备不同，块设备并不支持基于字符的寻址。如：u盘，SD卡，磁盘等。</li></ul><h3 id="3-6-驱动中操作物理绝对地址为什么要先ioremap？"><a href="#3-6-驱动中操作物理绝对地址为什么要先ioremap？" class="headerlink" title="3.6 驱动中操作物理绝对地址为什么要先ioremap？"></a>3.6 驱动中操作物理绝对地址为什么要先ioremap？</h3><ul><li><code>ioremp</code>是内核中用来将外设寄存器物理地址映射到主存上去的接口，即将io地址空间映射到虚拟地址空间上去，便于操作。为什么非要映射呢，因为<strong>保护模式下的cpu只认虚拟地址，不认物理地址</strong>，给它物理地址它并不帮你做事，所以你要操作外设上的寄存器必须先映射到虚拟内存空间，拿着虚拟地址去跟cpu对接，从而操作寄存器。</li></ul><h3 id="3-7-insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？"><a href="#3-7-insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？" class="headerlink" title="3.7 insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？"></a>3.7 insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？</h3><ul><li>分别会执行<code>module_init()</code>和<code>module_exit()</code>指定的<code>init</code>函数和<code>exit</code>函数。要注意的就是，尽量使在<code>init</code>函数中出现的资源申请及使用，都要有对应的释放操作在<code>exit</code>中，即<code>init</code>申请，<code>eixt</code>释放。</li></ul><h3 id="3-8-NAND驱动的probe流程"><a href="#3-8-NAND驱动的probe流程" class="headerlink" title="3.8 NAND驱动的probe流程"></a>3.8 NAND驱动的probe流程</h3><ul><li><code>probe</code> 函数就会与NAND芯片进行，主要做的事情主要包括这几个方面：读取NAND芯片的ID ，然后查表得到这片NAND芯片的如厂商，page size，erase size以及chip size等信息，接着根据<code>struct nand_chip</code> 中<code>options</code>的值的不同，或者在NAND 芯片中的特定位置查找<code>bad block table</code>，或者scan整个NAND 芯片，并在内存中建立<code>bad block table</code>。说起来复杂，但其实所有的这些动作，都可以在MTD提供的一个叫做<code>nand_scan</code>的函数中完成。</li></ul><h3 id="3-9-Linux驱动开发中，常用的调试方法有哪些？"><a href="#3-9-Linux驱动开发中，常用的调试方法有哪些？" class="headerlink" title="3.9 Linux驱动开发中，常用的调试方法有哪些？"></a>3.9 Linux驱动开发中，常用的调试方法有哪些？</h3><ul><li><p>利用<code>printk</code>，查看OOP消息，利用<code>strace</code>，利用内核内置的<code>hacking</code>选项，利用<code>ioctl</code>方法，利用<code>/proc</code> 文件系统，使用<code>kgdb</code>。</p></li><li><p><code>strace</code> 是一个可用于诊断、调试和教学的 Linux 用户空间跟踪器，监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。</p></li><li><p><code>ioctl</code> 是设备驱动程序中设备控制接口函数，一个字符设备驱动通常会实现设备打开、关闭、读、写等功能，在一些需要细分的情境下，如果需要扩展新的功能，通常以增设<code>ioctl()</code>命令的方式实现。</p><blockquote><p>建议大家，亲手动手调试下。面试中，很大可能会问你，在写驱动过程中遇到了什么问题的，如何解决的？如果你能讲出以上几种调试方法中的一两种，一定会让面试官刮目相看！</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
            <tag> 内核编程 </tag>
            
            <tag> Linux系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2024/06/06/test/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/06/06/test/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="写嵌入式用的到数据结构吗？"><a href="#写嵌入式用的到数据结构吗？" class="headerlink" title="写嵌入式用的到数据结构吗？"></a>写嵌入式用的到数据结构吗？</h1><p>看下linux内核就知道了，一堆数据结构，不学习数据结构，linux内核就看不懂了</p><p>使用数据结构是为了使代码结构更清晰，更容易把握代码结构、逻辑。</p><p>几个应用场景</p><ol><li><p>“数组”。你肯定用过吧，属于数据结构“线性表”的一种形式。</p><p><img src="/2024/06/06/test/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241112202136552.png" alt="image-20241112202136552" style="zoom:50%;"><img src="/2024/06/06/test/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241112202215843.png" alt="image-20241112202215843" style="zoom:50%;"></p></li><li><p>“结构体”。学习过lwip可以知道从以太网上接收一堆数据后，把数据头的地址幅值给以太网包的数据结构定义的指针，可以直接使用此指针-&gt;成员变量的方式，使用接收到的数据。比使用一堆变量来利用接收到的数据方便太多了。</p></li><li><p>“队列”。热敏电阻测温，单片机用ADC测量电阻分压电压，然后对测量值用平滑均值滤波算法滤波，此时会用到“队列”，或用“环形队列”；</p></li><li><p>“树”。项目中经常会使用液晶屏作为显示，其中文本菜单有时用的比较多的一种方式，其中文本菜单常用“树”结构来实现。</p></li><li><p>“栈”。就不用说了，你已经用过了，不过不是你主动用的，它隐藏在你每次函数调用、中断调用中，可能你没有意识到。</p></li></ol><p>简单几个例子，说明了数据结构非常常见，这个是必须要学的，不过有些不常用，比如图。</p><h3 id="1-【简答题】请写出至少两种野指针的成因"><a href="#1-【简答题】请写出至少两种野指针的成因" class="headerlink" title="1.   【简答题】请写出至少两种野指针的成因"></a>1.   【简答题】请写出至少两种野指针的成因</h3><p>【答案】</p><p>（1）指针使用前未初始化</p><p>（2）指针越界访问</p><p>（3）指针指针已经释放的空间</p><h3 id="2-【简答题】非静态局部变量、全局变量、malloc-动态分配的内存分别存储在内存的什么区域。"><a href="#2-【简答题】非静态局部变量、全局变量、malloc-动态分配的内存分别存储在内存的什么区域。" class="headerlink" title="2.   【简答题】非静态局部变量、全局变量、malloc()动态分配的内存分别存储在内存的什么区域。"></a>2.   【简答题】非静态局部变量、全局变量、malloc()动态分配的内存分别存储在内存的什么区域。</h3><p>【答案】</p><p>（1）非静态局部变量存储在内存的栈区域。</p><p>（1）全局变量存储在内存的全局静态区。</p><p>（2）malloc()动态分配的内存存储在内存的堆区域。</p><h1 id="一、数据结构与算法的层次要求："><a href="#一、数据结构与算法的层次要求：" class="headerlink" title="一、数据结构与算法的层次要求："></a>一、数据结构与算法的层次要求：</h1><p>层次1：熟悉各种不同的数据结构：顺序表（一维数组）、链表、栈、队列；森林、树、二叉树；图等<br>      了解不同的数据结构的特点、如何存储、优缺点等</p><p>层次2：如何编写相关的代码，实现对应的数据结构。（需要考虑对应的增、删、改、查、长度、遍历等）</p><p>层次3：算法层面的训练。 —&gt; leetcode （力扣app）、牛客网等。 300+道打底</p><img src="https://s1.vika.cn/space/2024/11/12/bb5ee404f183423782032597b88580fc" alt="image-20241112200556715"><h1 id="二、针对于层次1："><a href="#二、针对于层次1：" class="headerlink" title="二、针对于层次1："></a>二、针对于层次1：</h1><ol><li><p>什么是数据结构？   datastructure   (D-&gt;S)</p><blockquote><p>数据 +  结构<br>数据：多个相同类型的数据或变量<br>结构：即关系<br>目的：为了更高效的访问数据</p></blockquote></li><li><p>数据结构中有哪些内容？即问研究方向？<br>研究方向1：数据之间的逻辑关系</p><blockquote><p>线性关系:（一对一的关系）。比如：顺序表、链表、栈、队列、数组、字符串、广义表等<br>非线性关系：集合关系、树形关系（一对多的关系）、图形关系（多对多的关系）</p></blockquote></li></ol><p>研究方向2：数据的存储结构（或物理结构）<br>    &gt; 基本的两种：顺序存储结构、链式存储结构<br>    &gt; 拓展的两种：索引存储结构、哈希存储结构(散列存储结构)<br>研究方向3：数据之间的运算：增、删、改、查(CRUD)</p><h1 id="三、具体的不同的数据结构的实现（对应着层次2）"><a href="#三、具体的不同的数据结构的实现（对应着层次2）" class="headerlink" title="三、具体的不同的数据结构的实现（对应着层次2）"></a>三、具体的不同的数据结构的实现（对应着层次2）</h1><ol><li><p>数组的实现和相关算法的封装。</p></li><li><p>链表的实现和相关算法的封装。</p><p>   ​                 优点                                      缺点</p><blockquote><p>数组 通过索引查找、修改效率高：O(1)  插入、删除的效率差：O(n)</p><p>​同样大小的内存，数组可以存储更多的数据  当数据存满时，需要考虑扩容</p></blockquote><blockquote><p>链表   插入、删除效率高：O(1) 通过索引查找、修改效率低：O(n)  </p><p>​ 不需要考虑扩容问题   同样大小的内存，链表存储的数据较数组少</p></blockquote></li></ol><h2 id="如何理解数据结构"><a href="#如何理解数据结构" class="headerlink" title="如何理解数据结构"></a>如何理解数据结构</h2><h4 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h4><p>1.数据结构定义：研究多个变量之间的结构，即数据与数据之间的关系。</p><p> 2.研究目的：高效地进行数据的操作，如增删改查。</p><h4 id="数据结构的主要内容"><a href="#数据结构的主要内容" class="headerlink" title="数据结构的主要内容"></a>数据结构的主要内容</h4><p>1.逻辑结构：研究数据之间的逻辑关系，分为集合关系、线性关系、树形关系和网状关系。 </p><p>2.存储结构：研究数据在实际编程语言中的存储方式，分为顺序存储和链式存储。 </p><p>3.运算：基于存储结构，研究数据的增删改查等操作。</p><h4 id="线性结构和非线性结构"><a href="#线性结构和非线性结构" class="headerlink" title="线性结构和非线性结构"></a>线性结构和非线性结构</h4><p>1.线性结构：如顺序表、链表、栈、队列、数组、广义表等。</p><p> 2.非线性结构：如集合、树、图等。</p><h4 id="存储结构的两种基本形式"><a href="#存储结构的两种基本形式" class="headerlink" title="存储结构的两种基本形式"></a>存储结构的两种基本形式</h4><p>1.顺序存储：将数据元素依次排列，通过数组等方式实现。 </p><p>2.链式存储：通过链表方式，每个元素包含指向下一个元素的指针。</p><p> 3.索引存储结构和哈希存储结构：基于顺序存储和链式存储的组合。</p><img src="https://s1.vika.cn/space/2024/11/12/ad74377b36704d109dd9765a42b58faa" alt="image-20241112202757865" style="zoom:50%;"><img src="/2024/06/06/test/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241112202851334.png" alt="image-20241112202851334" style="zoom:50%;"><h1 id="线性结构之数组"><a href="#线性结构之数组" class="headerlink" title="线性结构之数组"></a>线性结构之数组</h1><p><strong>优</strong> <strong>点</strong></p><p>Ø 查找容易（通过下标），时间复杂度为O(1)。不需要额外申请或删除空间。</p><p>Ø 使用下标位置索引(index)十分高效的访问任意元素，修改快</p><p><img src="https://s1.vika.cn/space/2024/11/12/48ec67a0d691481bab93fce23ca5fb1f" alt="image-20241105203354020"></p><p><strong>缺</strong> <strong>点</strong></p><p>Ø 插入、删除元素难，效率低。（需要移动大量元素以使元素空间连续）。</p><p>Ø 插入操作平均需要移动n&#x2F;2个元素。</p><p>Ø 删除操作平均需要移动(n-1)&#x2F;2个元素。</p><p>​                             <img src="https://s1.vika.cn/space/2024/11/12/4dcfedcbb1a2444397856fa27a77c364" alt="image-20241105203403567">     </p><p>Ø 扩展相对繁琐。一方面需要确保能提供更大区域的连续内存空间，另一方面需要将原有数据复制到新的顺序表中。</p><p>1.1.1 功能定义</p><p>前文提到过数组这一数据结构的一个局限性是长度固定，本节我们来实现一个增强版的数组——可变长的动态数组，需要实现以下函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//初始化动态数组</span><br><span class="line">void initDynamicArray(DynamicArray *array, size_t initialCapacity)</span><br><span class="line">//释放动态数组内存</span><br><span class="line">void destroyDynamicArray(DynamicArray *array)</span><br><span class="line">//调整动态数组内存大小</span><br><span class="line">void resizeDynamicArray(DynamicArray *array, size_t newCapacity)</span><br><span class="line">//获取动态数组长度（元素个数）</span><br><span class="line">size_t getLength(const DynamicArray *array)</span><br><span class="line">//在指定位置插入新元素</span><br><span class="line">void insertAt(DynamicArray *array, size_t index, int element)</span><br><span class="line">//在末尾插入新元素</span><br><span class="line">void insertEnd(DynamicArray *array, int element)</span><br><span class="line">//删除指定位置的元素并返回被删除的元素</span><br><span class="line">int deleteAt(DynamicArray *array, size_t index)</span><br><span class="line">//删除末尾的元素并返回被删除的元素</span><br><span class="line">int deleteEnd(DynamicArray *array)</span><br><span class="line">//遍历所有的元素</span><br><span class="line">void print(DynamicArray *array)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-1-1-实现原理"><a href="#1-1-1-实现原理" class="headerlink" title="1.1.1 实现原理"></a>1.1.1 实现原理</h2><p>可变长的动态数组是一种数据结构，它允许在运行时根据需要动态地调整数组的大小，而不需要提前指定固定的大小。这种动态数组通常被称为动态数组、动态分配数组、动态增长数组或动态内存数组。int arr[10];  </p><p>C语言中是通过使用指针和内存分配函数来实现动态数组，常见的内存分配函数是<code>malloc</code>、<code>realloc</code>和<code>free</code>。下面是一些相关的概念和操作：</p><p>（1）<strong>分配内存（malloc）：</strong> 在C语言中，可以使用<code>malloc</code>函数来分配一块指定大小的内存。例如，<code>int *arr = (int *)malloc(n * sizeof(int));</code> 将分配能够存储<code>n</code>个整数的内存空间。</p><p>（2）<strong>重新分配内存（realloc）：</strong> 如果需要改变动态数组的大小，可以使用<code>realloc</code>函数来重新分配内存。这允许你在保留原有数据的情况下扩展或缩小数组的大小。</p><p>（3）<strong>释放内存（free</strong>）： 当不再需要动态数组时，应使用<code>free</code>函数释放之前分配的内存，以避免内存泄露。à 内存溢出</p><p>代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">// 动态数组结构体</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int *data;       // 指向动态数组的指针</span><br><span class="line">    size_t size;     // 当前数组中的元素个数</span><br><span class="line">    size_t capacity; // 当前数组的容量（可以容纳的最大元素个数）</span><br><span class="line">&#125; DynamicArray;</span><br><span class="line"></span><br><span class="line">// 初始化动态数组</span><br><span class="line">void initDynamicArray(DynamicArray *array, size_t initialCapacity)</span><br><span class="line">&#123;     //分配内存（malloc）</span><br><span class="line">    array-&gt;data = (int *)malloc(initialCapacity * sizeof(int)); // 分配初始内存</span><br><span class="line">    array-&gt;size = 0;       // 初始化元素个数为0</span><br><span class="line">    array-&gt;capacity = initialCapacity;     // 设置初始容量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放动态数组内存</span><br><span class="line">void destroyDynamicArray(DynamicArray *array)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    //释放内存（free）</span><br><span class="line">    free(array-&gt;data);   // 释放动态数组内存</span><br><span class="line">    array-&gt;size = 0;     // 重置元素个数为0</span><br><span class="line">    array-&gt;capacity = 0; // 重置容量为0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调整动态数组内存大小</span><br><span class="line">void resizeDynamicArray(DynamicArray *array, size_t newCapacity)</span><br><span class="line">&#123; //重新分配内存（realloc）</span><br><span class="line">    array-&gt;data = (int *)realloc(array-&gt;data, newCapacity * sizeof(int)); // 调整数组内存大小  </span><br><span class="line">    array-&gt;capacity = newCapacity;       // 更新容量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取动态数组长度（元素个数）</span><br><span class="line">size_t getLength(const DynamicArray *array)</span><br><span class="line">&#123;</span><br><span class="line">    return array-&gt;size; // 返回数组中的元素个数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在指定位置插入新元素</span><br><span class="line">void insertAt(DynamicArray *array, size_t index, int element)</span><br><span class="line">&#123;</span><br><span class="line">    if (index &gt; array-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        return; // 忽略无效的插入位置</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (array-&gt;size &gt;= array-&gt;capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t newCapacity = array-&gt;capacity * 2; // 如果容量不足，扩大容量</span><br><span class="line">        resizeDynamicArray(array, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (size_t i = array-&gt;size; i &gt; index; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        array-&gt;data[i] = array-&gt;data[i - 1]; // 后移元素以腾出插入位置</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array-&gt;data[index] = element; // 在指定位置插入新元素</span><br><span class="line">    array-&gt;size++;                // 更新元素个数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在末尾插入新元素</span><br><span class="line">void insertEnd(DynamicArray *array, int element)</span><br><span class="line">&#123;</span><br><span class="line">    insertAt(array, array-&gt;size, element); // 在末尾插入新元素</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除指定位置的元素并返回被删除的元素</span><br><span class="line">int deleteAt(DynamicArray *array, size_t index)</span><br><span class="line">&#123;</span><br><span class="line">    if (index &gt;= array-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        return -1; // 忽略无效的删除位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    int deletedElement = array-&gt;data[index]; // 获取被删除的元素</span><br><span class="line"></span><br><span class="line">    for (size_t i = index; i &lt; array-&gt;size - 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        array-&gt;data[i] = array-&gt;data[i + 1]; // 前移元素以填补删除位置</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array-&gt;size--; // 更新元素个数</span><br><span class="line"></span><br><span class="line">    return deletedElement; // 返回被删除的元素</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除末尾的元素并返回被删除的元素</span><br><span class="line">int deleteEnd(DynamicArray *array)</span><br><span class="line">&#123;</span><br><span class="line">    return deleteAt(array, array-&gt;size - 1); // 删除末尾的元素</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历所有的元素</span><br><span class="line">void print(DynamicArray *array)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; array-&gt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;, array-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    DynamicArray myArray; // 声明动态数组</span><br><span class="line"></span><br><span class="line">    // 初始化动态数组</span><br><span class="line">    initDynamicArray(&amp;myArray, 2);</span><br><span class="line">    printf(&quot;初始化动态数组,初始容量为2\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 向动态数组尾部插入元素</span><br><span class="line">    insertEnd(&amp;myArray, 1);</span><br><span class="line">    insertEnd(&amp;myArray, 2);</span><br><span class="line">    printf(&quot;向动态数组尾部插入了2个元素\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 打印动态数组当前长度</span><br><span class="line"> printf(&quot;动态数组当前长度:%zu\n&quot;, getLength(&amp;myArray));</span><br><span class="line"></span><br><span class="line">    // 在索引1的位置插入元素3</span><br><span class="line">    insertAt(&amp;myArray, 1, 3);</span><br><span class="line">    printf(&quot;在索引1的位置插入元素3\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 再次打印动态数组当前长度</span><br><span class="line">    printf(&quot;动态数组当前长度:%zu\n&quot;, getLength(&amp;myArray));</span><br><span class="line"></span><br><span class="line">    // 删除索引1的元素</span><br><span class="line">    printf(&quot;删除索引1的元素,该元素是%d\n&quot;, deleteAt(&amp;myArray, 1));</span><br><span class="line"></span><br><span class="line">    // 删除动态数组末尾元素</span><br><span class="line">    printf(&quot;删除动态数组末尾元素,该元素是%d\n&quot;, deleteEnd(&amp;myArray));</span><br><span class="line"></span><br><span class="line">    // 释放动态数组内存</span><br><span class="line">    destroyDynamicArray(&amp;myArray);</span><br><span class="line">    printf(&quot;动态数组内存释放完成\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="1-1-线性结构之链表"><a href="#1-1-线性结构之链表" class="headerlink" title="1.1 线性结构之链表"></a>1.1 线性结构之链表</h1><p>1.1.1 链表是什么</p><p>链表的主要特点包括：</p><ol><li><strong>动态大小</strong>：链表可以根据需要动态调整大小，不需要预先分配固定的内存空间。</li><li><strong>插入和删除效率高</strong>：在已知位置插入或删除元素时，链表不需要移动其他元素，只需调整指针即可。</li><li><strong>顺序访问</strong>：链表不支持随机访问，要访问链表中的某个元素，必须从头节点开始逐个遍历。</li></ol><p>链表有几种常见的类型：</p><ul><li><strong>单向链表</strong>：每个节点只指向下一个节点。</li><li><strong>双向链表</strong>：每个节点有两个指针，分别指向前一个节点和后一个节点。</li><li><strong>循环链表</strong>：链表的最后一个节点指向第一个节点，形成一个环。</li></ul><p><img src="https://s1.vika.cn/space/2024/11/12/65ec27aa9d2548efbe0342f9a53b9878" alt="image-20241108184735610"></p><p><strong>相关概念</strong></p><p>n个结点离散分配，彼此通过指针相连，每个结点只有一个前驱结点，每个结点只有一个后续结点，头结点没有前驱结点，尾结点没有后续结点。确定一个链表我们只需要头指针，通过头指针就可以把整个链表都能推出来。</p><p>1）优点</p><p>（1）插入和删除操作效率高。</p><p>（2）动态扩展性能更好，链表不需要像数组那样预先指定固定的大小，而是可以随时动态的增长或缩小。链表是真正的动态数据结构，不需要处理固定容量的问题。</p><p>2）缺点</p><p>（1）查找慢。由于链表中的结点不是连续存储的，无法像数组一样根据索引直接计算出每个结点的地址。必须从头结点开始遍历链表，直到找到目标结点，这导致了链表的随机访问效率较低。</p><p>（2）额外的存储空间。链表的每个结点都需要存储指向下一个结点的指针，这会占用额外的存储空间。所以，相比于数组，链表需要更多的内存空间来存储相同数量的数据元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">初始化链表</span><br><span class="line">void initLinkedList(LinkedList *list)</span><br><span class="line">返回链表的长度</span><br><span class="line">size_t getLength(const LinkedList *list)</span><br><span class="line">在指定位置插入元素</span><br><span class="line">void insertAt(LinkedList *list, size_t index, int element)</span><br><span class="line">在末尾插入元素</span><br><span class="line">void insertEnd(LinkedList *list, int element)</span><br><span class="line">删除指定位置的元素并返回被删除的元素</span><br><span class="line">int deleteAt(LinkedList *list, size_t index)</span><br><span class="line">删除末尾元素</span><br><span class="line">int deleteEnd(LinkedList *list)</span><br><span class="line">获取指定位置的元素</span><br><span class="line">int getElementAt(const LinkedList *list, size_t index)</span><br><span class="line">修改指定位置的元素</span><br><span class="line">void modifyAt(LinkedList *list, size_t index, int newValue)</span><br><span class="line">释放链表内存</span><br><span class="line">void destroyLinkedList(LinkedList *list)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">自定义链表结构</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 定义存储数据的结构体</span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int data;          // 存储的数据</span><br><span class="line">    struct Node *next; // 指向下个元素的指针</span><br><span class="line"></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">// 定义虚拟头结点的结构体</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int size;   // 记录单链表中存储的数据的个数</span><br><span class="line">    Node *next; // 指向保存数据的首元素</span><br><span class="line">&#125; LinkedList;</span><br><span class="line"></span><br><span class="line">// 明确：在包含虚拟头结点的情况下，首个保存数据的结点的索引为0！</span><br><span class="line"></span><br><span class="line">// 初始化链表</span><br><span class="line">void initLinkedList(LinkedList *list)</span><br><span class="line">&#123;</span><br><span class="line">    // 初始化LinkedList内部的成员</span><br><span class="line">    list-&gt;size = 0;</span><br><span class="line">    list-&gt;next = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回链表的长度</span><br><span class="line">size_t getLength(const LinkedList *list)</span><br><span class="line">&#123;</span><br><span class="line">    return list-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在指定位置插入元素</span><br><span class="line">void insertAt(LinkedList *list, size_t index, int element)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (index &lt; 0 || index &gt; list-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;输入的index数据非法\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 插入数据的过程</span><br><span class="line">    // 1. 将数据封装到Node结构体的变量中</span><br><span class="line">    Node *node = (Node *)malloc(1 * sizeof(Node));</span><br><span class="line">    node-&gt;data = element;</span><br><span class="line"></span><br><span class="line">    // 2. 找到index的位置进行插入操作</span><br><span class="line">    if (index == 0)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        node-&gt;next = list-&gt;next;</span><br><span class="line">        list-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Node *currentNode = list-&gt;next; // 指向有数据的首元素</span><br><span class="line">        for (int i = 0; i &lt; index - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            currentNode = currentNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node-&gt;next = currentNode-&gt;next;</span><br><span class="line">        currentNode-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在末尾插入元素</span><br><span class="line">void insertEnd(LinkedList *list, int element)</span><br><span class="line">&#123;</span><br><span class="line">    insertAt(list, list-&gt;size, element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除指定位置的元素并返回被删除的元素</span><br><span class="line">int deleteAt(LinkedList *list, size_t index)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (index &lt; 0 || index &gt;= list-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;输入的index不合法\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int deleteElement;</span><br><span class="line">    Node *deleteNode;</span><br><span class="line">    if (index == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        deleteNode = list-&gt;next;</span><br><span class="line"></span><br><span class="line">        list-&gt;next = deleteNode-&gt;next;</span><br><span class="line"></span><br><span class="line">        // 获取要删除的node的数据</span><br><span class="line">        deleteElement = deleteNode-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Node *currentNode = list-&gt;next; // 指向有数据的首元素</span><br><span class="line">        for (int i = 0; i &lt; index - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            currentNode = currentNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deleteNode = currentNode-&gt;next;</span><br><span class="line">        currentNode-&gt;next = deleteNode-&gt;next;</span><br><span class="line"></span><br><span class="line">        deleteElement = deleteNode-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    free(deleteNode); // 释放node的内存空间</span><br><span class="line"></span><br><span class="line">    list-&gt;size--;</span><br><span class="line"></span><br><span class="line">    return deleteElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除末尾元素</span><br><span class="line">int deleteEnd(LinkedList *list) &#123;</span><br><span class="line">    deleteAt(list,list-&gt;size - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取指定位置的元素</span><br><span class="line">int getElementAt(const LinkedList *list, size_t index) &#123;</span><br><span class="line"></span><br><span class="line">    if(index &lt; 0 || index &gt;= list-&gt;size)&#123;</span><br><span class="line">        printf(&quot;输入的index不合法\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node * currentNode = list-&gt;next;</span><br><span class="line">    for(int i = 0;i &lt; index ;i++)&#123;</span><br><span class="line">        currentNode = currentNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return currentNode-&gt;data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改指定位置的元素</span><br><span class="line">void modifyAt(LinkedList *list, size_t index, int newValue) &#123;</span><br><span class="line"></span><br><span class="line">    if(index &lt; 0 || index &gt;= list-&gt;size)&#123;</span><br><span class="line">        printf(&quot;输入的index不合法\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node * currentNode = list-&gt;next;</span><br><span class="line">    for(int i = 0;i &lt; index ;i++)&#123;</span><br><span class="line">        currentNode = currentNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentNode-&gt;data = newValue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放链表内存</span><br><span class="line">void destroyLinkedList(LinkedList *list) &#123;</span><br><span class="line"></span><br><span class="line">    Node *currentNode = list-&gt;next;  //找到有数据的第1个结点</span><br><span class="line"></span><br><span class="line">    for(int i = 0;i &lt; list-&gt;size;i++)&#123;</span><br><span class="line"></span><br><span class="line">        Node *tempNode = currentNode;</span><br><span class="line">        currentNode = currentNode-&gt;next;</span><br><span class="line"></span><br><span class="line">        free(tempNode);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //辅助操作</span><br><span class="line">    list-&gt;next = NULL;</span><br><span class="line">    list-&gt;size = 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    LinkedList list;</span><br><span class="line">    initLinkedList(&amp;list);</span><br><span class="line"></span><br><span class="line">    insertAt(&amp;list,0,10);</span><br><span class="line">    insertAt(&amp;list,0,20);</span><br><span class="line">    insertAt(&amp;list,0,30);</span><br><span class="line"></span><br><span class="line">    size_t count = getLength(&amp;list);</span><br><span class="line">    printf(&quot;%d\n&quot;,count);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    getchar();  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放链表内存-有什么用"><a href="#释放链表内存-有什么用" class="headerlink" title="释放链表内存 有什么用"></a>释放链表内存 有什么用</h3><p>释放链表内存”的主要用途在于管理动态分配的内存，确保程序运行期间不会造成内存泄漏。下面是这一过程的重要性和作用：</p><ol><li><strong>防止内存泄漏</strong>：在程序中动态申请的内存（例如，通过 <code>malloc</code>）需要在不再使用时及时释放。如果在不再需要链表时不释放内存，程序会占用不必要的内存资源，从而导致内存泄漏。</li><li><strong>优化内存使用</strong>：及时释放内存可以确保系统资源的有效使用，特别是在运行长时间的程序或需要频繁创建和销毁对象的情况下。</li><li><strong>防止悬挂指针</strong>：在释放链表内存的同时，设置指向链表的指针（如头指针）为 <code>NULL</code> 坏境，可以避免访问已释放内存的风险。这有助于防止程序在试图访问无效内存时造成的未定义行为。</li><li><strong>提高程序稳定性</strong>：良好的内存管理使得程序更加稳定和健壮，降低了崩溃的概率。</li></ol><h1 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h1><p>特点：<code>后进先出</code> (LIFO，Last In First Out)或<code>先进后出</code> (FILO，First In Last Out)的线性表。</p><p> 栈顶(Top)：允许进行插入、删除操作的一端，又称为<code>表尾</code>。栈顶由一个称为栈顶指针的位置指示器（其实就是一个变量）来指示，它是动态变化的。</p><p>- 栈底(Bottom)：是固定不变的，不允许进行插入和删除的一端，又称为<code>表头</code>。</p><p>- 空栈：不含任何元素的空表。</p><p>- 设栈S&#x3D;(a1,a2,…,an )，则a1称为栈底元素，an为栈顶元素，栈中元素按a1,a2,…,a_n的次序进栈(压栈、push)，出栈(弹栈，pop)的第一个元素应为栈顶元素，出栈顺序为：an,…,a2,a1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">初始化栈</span><br><span class="line">void initStack(Stack *stack, size_t capacity)</span><br><span class="line">返回栈内元素个数</span><br><span class="line">size_t getSize(const Stack *stack)</span><br><span class="line">添加新元素</span><br><span class="line">void push(Stack *stack, int element)</span><br><span class="line">在末尾插入元素</span><br><span class="line">void insertEnd(LinkedList *list, int element)</span><br><span class="line">栈顶元素出栈并返回</span><br><span class="line">int pop(Stack *stack)</span><br><span class="line">释放栈内存</span><br><span class="line">void destroyStack(Stack *stack)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"></span><br><span class="line">  自定义实现栈结构：使用顺序存储结构实现--&gt; 顺序栈</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line"></span><br><span class="line">    //存储数据的指针</span><br><span class="line">    int *data;</span><br><span class="line">    //指明存储容器的容量</span><br><span class="line">    size_t capacity;</span><br><span class="line">    //指明存储容器中实际存储的数据量</span><br><span class="line">    size_t size;</span><br><span class="line"></span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 初始化栈</span><br><span class="line">void initStack(Stack *stack, size_t capacity)</span><br><span class="line">&#123;</span><br><span class="line">    stack-&gt;data = (int *)malloc(capacity *sizeof(int));//动态内存分配</span><br><span class="line">    if(stack-&gt;data == NULL)&#123;</span><br><span class="line">        printf(&quot;内存分配失败\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack-&gt;capacity = capacity;         </span><br><span class="line">    stack-&gt;size = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回栈内元素个数</span><br><span class="line">size_t getSize(const Stack *stack)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    return stack-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加新元素</span><br><span class="line">void push(Stack *stack, int element)</span><br><span class="line">&#123;</span><br><span class="line">    //考虑是否存满了</span><br><span class="line">    if(stack-&gt;size == stack-&gt;capacity)&#123;</span><br><span class="line">        //扩容</span><br><span class="line">        resizeCapacity(stack,stack-&gt;capacity + stack-&gt;capacity &gt;&gt; 1); //扩容为原来的1.5倍</span><br><span class="line">        printf(&quot;容量已满，进行扩容操作\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack-&gt;data[stack-&gt;size] = element;</span><br><span class="line">    stack-&gt;size++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void resizeCapacity(Stack *stack,int newCapacity)&#123;</span><br><span class="line"></span><br><span class="line">    stack-&gt;data = (int *)realloc(stack-&gt;data,newCapacity * sizeof(int)); //扩容操作</span><br><span class="line">    stack-&gt;capacity = newCapacity; //指明新的容量值</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 栈顶元素出栈并返回</span><br><span class="line">int pop(Stack *stack)</span><br><span class="line">&#123;</span><br><span class="line">    //判断是否为空</span><br><span class="line">    if(stack-&gt;size == 0)&#123;</span><br><span class="line">        printf(&quot;当前栈为空,弹栈失败\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // int popElement = stack-&gt;data[stack-&gt;size-1];</span><br><span class="line">    // stack-&gt;size--;</span><br><span class="line"></span><br><span class="line">    // return popElement;</span><br><span class="line"></span><br><span class="line">    return stack-&gt;data[--stack-&gt;size];//</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//这是一个前缀自减操作。它的作用是将 stack-&gt;size 的值减一，然后返回这个新的值。</span><br><span class="line">//例如，如果 stack-&gt;size 原本是 3，经过 --stack-&gt;size 处理后，</span><br><span class="line">//stack-&gt;size 会变为 2。这意味着我们将要弹出栈中索引为 2 的元素（即第三个元素，因为索引从 0 开始）。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放栈内存</span><br><span class="line">void destroyStack(Stack *stack)</span><br><span class="line">&#123;</span><br><span class="line">    free(stack-&gt;data);</span><br><span class="line">    stack-&gt;data = NULL;</span><br><span class="line">    stack-&gt;capacity = 0;</span><br><span class="line">    stack-&gt;size = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//遍历栈中的元素</span><br><span class="line">void print(Stack *stack)&#123;</span><br><span class="line">    for(int i = 0;i &lt; stack-&gt;size;i++)&#123;</span><br><span class="line">        printf(&quot;%d  &quot;,stack-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //声明结构体变量</span><br><span class="line">    Stack myStack;</span><br><span class="line"></span><br><span class="line">    initStack(&amp;myStack,3);</span><br><span class="line"></span><br><span class="line">    push(&amp;myStack,1);</span><br><span class="line">    push(&amp;myStack,2);</span><br><span class="line">    push(&amp;myStack,3);</span><br><span class="line">    push(&amp;myStack,4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    printf(&quot;栈中元素的个数为：%d\n&quot;,getSize(&amp;myStack));</span><br><span class="line"></span><br><span class="line">    print(&amp;myStack);</span><br><span class="line"></span><br><span class="line">    printf(&quot;弹栈，弹出的数据是：%d\n&quot;,pop(&amp;myStack));</span><br><span class="line">    printf(&quot;弹栈，弹出的数据是：%d\n&quot;,pop(&amp;myStack));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print(&amp;myStack);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线性结构之队列"><a href="#线性结构之队列" class="headerlink" title="线性结构之队列"></a>线性结构之队列</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>队列(Queue)：也是操作受限的线性表，限制为仅允许在表的一端进行插入(入队或进队），在表的另一端进行删除(出队或离队)操作。</p><p>- 队首(front) ：允许进行删除的一端称为队首。</p><p>- 队尾(rear)： 允许进行插入的一端称为队尾。</p><p>在空队列中依次加入元素a1,a2, …, an之后，a1是队首元素，an是队尾元素。显然退出队列的次序也只能是a1,a2, …, an。队列，是一种先进先出(First In First Out ，简称FIFO)的线性结构。类似于生活中的排队行为。</p><p><img src="https://s1.vika.cn/space/2024/11/12/b4e17e3fbd7d4f78815a4f01eb85cb5f" alt="image-20241111205010221"></p><p>队列中没有元素时，称为空队列。</p><h3 id="队列的存储结构"><a href="#队列的存储结构" class="headerlink" title="队列的存储结构"></a>队列的存储结构</h3><p>可用顺序表(数组)和链表来存储队列，队列按存储结构可分为顺序队列和链式队列两种。</p><h3 id="功能定义"><a href="#功能定义" class="headerlink" title="功能定义"></a>功能定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">初始化队列</span><br><span class="line">void initQueue(Queue *queue, size_t capacity)</span><br><span class="line">返回队列内元素个数</span><br><span class="line">size_t getSize(const Queue *queue)</span><br><span class="line">添加新元素</span><br><span class="line">void enqueue(Queue *queue, int element)</span><br><span class="line">元素出队列</span><br><span class="line">int dequeue(Queue *queue)</span><br><span class="line">释放队列内存</span><br><span class="line">void destroyQueue(Queue *queue)</span><br><span class="line">遍历队列</span><br><span class="line">void printQueue(Queue *queue)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">/* </span><br><span class="line">    自定义结构实现队列：使用循环队列</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//声明队列对应的结构体</span><br><span class="line">typedef struct&#123;</span><br><span class="line"></span><br><span class="line">    int *data;</span><br><span class="line">    int capacity; //记录存储的最大容量</span><br><span class="line">    int size ; //记录存储的元素的个数</span><br><span class="line">    int front ;  //记录要出队的索引位置</span><br><span class="line">    int rear;  //记录入队后的索引位置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 初始化队列</span><br><span class="line">void initQueue(Queue *queue, size_t capacity)</span><br><span class="line">&#123;</span><br><span class="line">    queue-&gt;data = (int *)malloc(capacity * sizeof(int));</span><br><span class="line">    queue-&gt;capacity = capacity;</span><br><span class="line">    queue-&gt;size = 0;</span><br><span class="line">    queue-&gt;front = 0;</span><br><span class="line">    queue-&gt;rear = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回队列内元素个数</span><br><span class="line">size_t getSize(const Queue *queue)</span><br><span class="line">&#123;</span><br><span class="line">    return queue-&gt;size;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加新元素</span><br><span class="line">void enqueue(Queue *queue, int element)</span><br><span class="line">&#123;</span><br><span class="line">    if(queue-&gt;size == queue-&gt;capacity)&#123;</span><br><span class="line">        //容量已满</span><br><span class="line">        printf(&quot;队列已满，入队失败\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue-&gt;data[queue-&gt;rear] = element;</span><br><span class="line">    queue-&gt;size++;</span><br><span class="line">    //queue-&gt;rear++; //存在问题，需要使用下面的方式替换</span><br><span class="line"></span><br><span class="line">    queue-&gt;rear = (queue-&gt;rear + 1) % queue-&gt;capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 元素出队列</span><br><span class="line">int dequeue(Queue *queue)</span><br><span class="line">&#123;</span><br><span class="line">    // if(queue-&gt;front == queue-&gt;rear);//此语句满足的情况：① 队列为空 ② 队列已满</span><br><span class="line">    if(queue-&gt;size == 0)&#123;</span><br><span class="line">        printf(&quot;队列为空，出队失败\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int dequeueData = queue-&gt;data[queue-&gt;front];</span><br><span class="line">    queue-&gt;size--;</span><br><span class="line"></span><br><span class="line">    queue-&gt;front = (queue-&gt;front + 1) % queue-&gt;capacity;</span><br><span class="line"></span><br><span class="line">    return dequeueData;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放队列内存</span><br><span class="line">void destroyQueue(Queue *queue)</span><br><span class="line">&#123;</span><br><span class="line">    free(queue-&gt;data);</span><br><span class="line">    queue-&gt;data = NULL;</span><br><span class="line">    queue-&gt;capacity = 0;</span><br><span class="line">    queue-&gt;size = 0;</span><br><span class="line">    queue-&gt;front = 0;</span><br><span class="line">    queue-&gt;rear = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//遍历队列</span><br><span class="line">void printQueue(Queue *queue)&#123;</span><br><span class="line">    </span><br><span class="line">    for(int i = queue-&gt;front,j = 0;j &lt; queue-&gt;size;i++,j++)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        printf(&quot;%d  &quot;,queue-&gt;data[i % queue-&gt;capacity]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Queue myQueue;</span><br><span class="line"></span><br><span class="line">    initQueue(&amp;myQueue,3);</span><br><span class="line"></span><br><span class="line">    enqueue(&amp;myQueue,1);</span><br><span class="line">    enqueue(&amp;myQueue,2);</span><br><span class="line">    enqueue(&amp;myQueue,3);</span><br><span class="line">    enqueue(&amp;myQueue,4); //已满，未入队</span><br><span class="line"></span><br><span class="line">    printQueue(&amp;myQueue);</span><br><span class="line"></span><br><span class="line">    printf(&quot;出队，元素是：%d\n&quot;,dequeue(&amp;myQueue));</span><br><span class="line">    printf(&quot;出队，元素是：%d\n&quot;,dequeue(&amp;myQueue));</span><br><span class="line"></span><br><span class="line">    printQueue(&amp;myQueue);</span><br><span class="line"></span><br><span class="line">    enqueue(&amp;myQueue,5);</span><br><span class="line">    enqueue(&amp;myQueue,6);</span><br><span class="line"></span><br><span class="line">    printQueue(&amp;myQueue);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p><img src="https://s1.vika.cn/space/2024/11/12/72fe34dc1658472cbf5d14212e1506e3" alt="image-20241112175354551"></p><p>假设一个 int 变量占 4个字节，则所需内存空间 &#x3D; 4 + 4 &#x3D; 8，则S(n) &#x3D; O(1)。</p><p><img src="https://s1.vika.cn/space/2024/11/12/4c26e3b872e54932aeac50b4e0cfc5b9" alt="image-20241112175523230"></p><p>假设一个 int 变量占 4个字节，则所需内存空间 &#x3D; 4 + 4n + 4 &#x3D; 4n + 8，则S(n) &#x3D; O(n)。</p><p><img src="https://s1.vika.cn/space/2024/11/12/18bb9907b97d432b83b835a8f999c8d4" alt="image-20241112175532793"></p><p><img src="https://s1.vika.cn/space/2024/11/12/2cb283d076a04171acfea6e1c3b8b96d" alt="image-20241112175538936"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找:"></a>顺序查找:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 顺序查找:</span><br><span class="line">int sequenceSearch(int arr[], int size, int target)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    for(int i = 0;i &lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(arr[i] == target)</span><br><span class="line">        &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return -1; //表示没有找到指定的元素 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int arr[] = &#123;23,45,76,44,22,88,9,12,22,5,80&#125;;</span><br><span class="line"></span><br><span class="line">    int size = sizeof(arr) / sizeof(int);</span><br><span class="line"></span><br><span class="line">    int target = 9;</span><br><span class="line"></span><br><span class="line">    int targetIndex = sequenceSearch(arr,size,target);</span><br><span class="line">    if(targetIndex == -1)&#123;</span><br><span class="line">        printf(&quot;未找到\n&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;找到了%d，对应的索引为%d\n&quot;,target,targetIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sizeof是运算符，返回 unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。<br>它的功能是：获得保证能容纳实现所建立的最大对象的字节大小</p><p>sizeof(ary) &#x2F; sizeof(int) &lt;&#x3D;&#x3D;&gt; sizeof(ary) &#x2F; sizeof(ary[0]) ; 得到 ary 内的元素的个数</p><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>二分查找（Binary Search）是一种高效的搜索算法，通常用于有序数据集中查找目标元素。其原理是通过将数据集划分为两半并与目标进行比较，以确定目标在哪一半中，从而逐步缩小搜索范围，直到找到目标元素或确定不存在。基本原理如下：</p><p>（1）<strong>选择中间元素：</strong> 在有序数据集中，选择数组的中间元素。</p><p>（1）<strong>比较目标：</strong> 将中间元素与目标元素进行比较。</p><p>（2）<strong>查找成功：</strong> 如果中间元素等于目标元素，则查找成功，返回中间元素的索引。</p><p>（3）<strong>缩小搜索范围：</strong> 对于一个升序的数据集，如果中间元素大于目标元素，说明目标可能在左半部分；如果中间元素小于目标元素，说明目标可能在右半部分。根据比较结果，将搜索范围缩小到一半，继续查找。</p><p>（4）<strong>重复步骤：</strong> 重复上述步骤，不断将搜索范围缩小，直到找到目标元素或搜索范围为空。</p><p>​                                   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"></span><br><span class="line">    使用二分查找法，查找数组中的元素</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int binarySearch(int arr[],int size,int target)&#123;</span><br><span class="line"></span><br><span class="line">    int low = 0;</span><br><span class="line">    int high = size - 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    while(low &lt;= high)&#123;</span><br><span class="line"></span><br><span class="line">        int middle = (low + high) / 2;</span><br><span class="line">        if(arr[middle] == target)&#123;</span><br><span class="line">            return middle;</span><br><span class="line">        &#125;else if(arr[middle] &gt; target)&#123;</span><br><span class="line">            high = middle - 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            low = middle + 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //表示未找到</span><br><span class="line">    return -1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int arr[] = &#123;4,7,9,12,16,19,22,28,34,57,69,78,90&#125;;</span><br><span class="line">    int target = 12;</span><br><span class="line">    target = 91;</span><br><span class="line">    int size = sizeof(arr) / sizeof(int);</span><br><span class="line"></span><br><span class="line">    int targetIndex = binarySearch(arr,size,target);</span><br><span class="line">    if(targetIndex == -1)&#123;</span><br><span class="line">        printf(&quot;未找到\n&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;找到了%d，对应的索引为%d\n&quot;,target,targetIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"></span><br><span class="line">    冒泡排序:实现从小到大排序</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">void bubbleSort(int arr[],int size)&#123;</span><br><span class="line"></span><br><span class="line">    //外层循环：控制轮数</span><br><span class="line">    for(int i = 0;i &lt; size - 1;i++)&#123;</span><br><span class="line"></span><br><span class="line">        //内层循环：依次比较相邻的两个元素的大小</span><br><span class="line">        for(int j = 0;j &lt; size - 1 - i;j++)&#123;</span><br><span class="line">            </span><br><span class="line">            if(arr[j] &gt; arr[j + 1])&#123;</span><br><span class="line">                //交互j 和 j+1索引位置的元素</span><br><span class="line">                int temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int arr[] = &#123;23,45,2,46,77,2,99,-9,-32,0,66&#125;;</span><br><span class="line"></span><br><span class="line">    int size = sizeof(arr) / sizeof(int);</span><br><span class="line">    //遍历</span><br><span class="line">    for(int i = 0;i &lt; size;i++)&#123;</span><br><span class="line">        printf(&quot;%d  &quot;,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    //排序</span><br><span class="line">    bubbleSort(arr,size);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //遍历</span><br><span class="line">    for(int i = 0;i &lt; size;i++)&#123;</span><br><span class="line">        printf(&quot;%d  &quot;,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">    快速排序:实现从小到大排序</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">void quickSort(int arr[], int size)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    subSort(arr, 0, size - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void subSort(int arr[], int start, int end)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (start &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        int base = arr[start];</span><br><span class="line">        int low = start;</span><br><span class="line">        int high = end + 1;</span><br><span class="line"></span><br><span class="line">        while (1)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            while (low &lt; end &amp;&amp; arr[++low] &lt;= base)</span><br><span class="line">                ; // 找到从前往后第1个比base大的元素</span><br><span class="line">            while (high &gt; start &amp;&amp; arr[--high] &gt;= base)</span><br><span class="line">                ; // 找到从后往前第1个比base小的元素</span><br><span class="line"></span><br><span class="line">            if (low &lt; high)</span><br><span class="line">            &#123;</span><br><span class="line">                // 交换low和high位置的元素</span><br><span class="line">                int temp = arr[low];</span><br><span class="line">                arr[low] = arr[high];</span><br><span class="line">                arr[high] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 交换start和high索引位置上的元素</span><br><span class="line">        int temp1 = arr[start];</span><br><span class="line">        arr[start] = arr[high];</span><br><span class="line">        arr[high] = temp1;</span><br><span class="line"></span><br><span class="line">        // 递归调用</span><br><span class="line">        subSort(arr, start, high - 1); // 前半段继续排序</span><br><span class="line">        subSort(arr, high + 1, end);   // 后半段继续排序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int arr[] = &#123;23, 45, 2, 46, 77, 2, 99, -9, -32, 0, 66&#125;;</span><br><span class="line"></span><br><span class="line">    int size = sizeof(arr) / sizeof(int);</span><br><span class="line">    // 遍历</span><br><span class="line">    for (int i = 0; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 排序</span><br><span class="line">    quickSort(arr, size);</span><br><span class="line"></span><br><span class="line">    // 遍历</span><br><span class="line">    for (int i = 0; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>车载c++</title>
      <link href="/2024/06/06/test/%E8%BD%A6%E8%BD%BDc++%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/06/06/test/%E8%BD%A6%E8%BD%BDc++%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>c<br>记录一些自己不会的 和理解不够深的</p><p><img src="/./../../images/image-20250513220710273.png" alt="image-20250513220710273"></p><ol><li><p><strong>存储方式</strong>：</p><ul><li>C风格字符串通过字符数组（<code>char[]</code>）表示，以<code>&#39;\0&#39;</code>（空字符）结尾。</li><li>C++中使用<code>std::string</code>类来表示字符串，更加抽象和方便。</li></ul></li><li><p><strong>动态内存管理</strong>：</p><ul><li>C风格字符串需要手动进行内存分配和释放，使用如<code>malloc()</code>或<code>new</code>来分配内存，并使用<code>free()</code>或<code>delete</code>释放内存。</li><li>C++的<code>std::string</code>类自动管理内存，通过构造函数和析构函数自动处理内存，无需手动分配或释放内存。</li></ul></li><li><p><strong>字符串操作</strong>：</p><ul><li>C风格字符串的操作需要使用一系列的字符串处理函数（如<code>strcpy()</code>、<code>strcat()</code>、<code>strlen()</code>等），这些函数需要将字符串指针作为参数。</li><li>C++的<code>std::string</code>类提供了丰富的成员函数，如<code>append()</code>、<code>length()</code>、<code>find()</code>等，可以直接操作字符串对象，更加方便和易用。</li></ul></li><li><p><strong>安全性</strong>：</p><ul><li><p>C风格字符串没有提供越界检查，需要开发人员自行保证字符串的正确性。</p><ul><li>C++的<code>std::string</code>类具有越界检查功能，可以避免缓冲区溢出等安全问题。</li></ul><p><img src="/./../../images/image-20250513220823443.png" alt="image-20250513220823443"></p></li></ul><p>连接字符串常用</p><p><img src="/./../../images/image-20250513220915980.png" alt="image-20250513220915980"></p><h3 id="向量的概念和优势"><a href="#向量的概念和优势" class="headerlink" title="向量的概念和优势"></a>向量的概念和优势</h3><ol><li><strong>动态数组容器</strong>：<ul><li>向量是C++标准库提供的一种动态数组容器，使用前需要包含头文件<code>&lt;vector&gt;</code>。</li></ul></li><li><strong>线性存储</strong>：<ul><li>向量是一种线性容器，可以存储同一类型的元素。</li></ul></li><li><strong>顺序存储</strong>：<ul><li>向量中的元素按照它们在向量中的顺序进行存储。</li></ul></li><li><strong>随机访问</strong>：<ul><li>向量支持随机访问，可以通过索引访问向量中的元素。</li></ul></li><li><strong>动态调整大小</strong>：<ul><li>向量的大小可以动态调整，可以根据需要动态添加或删除元素。</li></ul></li><li><strong>优势</strong>：<ul><li>向量具有动态大小、随机访问、内存管理简单、较好的可扩展性等优势。</li></ul></li></ol><h3 id="向量的创建和初始化"><a href="#向量的创建和初始化" class="headerlink" title="向量的创建和初始化"></a>向量的创建和初始化</h3><ol><li><p><strong>创建空向量</strong>：</p><ul><li>使用<code>std::vector&lt;int&gt; myVector;</code>创建一个空的整型向量。</li></ul></li><li><p><strong>初始化向量</strong>：</p><ul><li>可以通过初始化列表、使用迭代器、使用默认值等方式初始化向量。</li></ul><p><img src="/./../../images/image-20250513221111990.png" alt="image-20250513221111990"></p></li></ol><p><img src="/./../../images/image-20250513221125703.png" alt="image-20250513221125703"></p></li></ol><p><img src="/./../../images/image-20250513221153145.png" alt="image-20250513221153145"></p><h1 id="指针的声明和初始化"><a href="#指针的声明和初始化" class="headerlink" title="指针的声明和初始化"></a>指针的声明和初始化</h1><ol><li><p><strong>声明与初始化语法</strong>：</p><ul><li><p>语法格式为：<code>&lt;数据类型&gt;* &lt;指针名称&gt; = &lt;空指针或已存在变量地址&gt;;</code></p></li><li><p>示例：声明一个指向整数的指针并初始化为空指针。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>内存分配</strong>：</p><ul><li><p>在使用指针之前，确保为指针分配了合适的内存空间或者将其初始化为有效的内存地址。</p></li><li><p>示例：使用动态内存分配为指针分配内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>释放内存</strong>：</p><ul><li><p>使用动态分配的内存后，要记得使用<code>delete</code>运算符释放该内存，以避免内存泄漏。</p></li><li><p>示例：释放之前分配的内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> ptr;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>当然，这里有一个使用<code>new</code>和<code>delete</code>运算符进行动态内存分配和释放的实际例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 动态分配一个整数的内存</span></span><br><span class="line">    <span class="type">int</span>* dynamicInt = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">// 分配内存并初始化为0（对于基本数据类型）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给动态分配的内存赋值</span></span><br><span class="line">    *dynamicInt = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出动态分配内存中的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value of dynamicInt is: &quot;</span> &lt;&lt; *dynamicInt &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用完动态分配的内存后，释放它</span></span><br><span class="line">    <span class="keyword">delete</span> dynamicInt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放后，尝试访问dynamicInt将会导致未定义行为</span></span><br><span class="line">    <span class="comment">// *dynamicInt = 100; // 这行代码如果被执行，将会导致错误</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Memory has been freed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ol><li>使用<code>new int</code>为一个整数动态分配了内存，并将返回的指针赋值给<code>dynamicInt</code>。</li><li>通过解引用指针<code>*dynamicInt</code>给这块内存赋值为42。</li><li>输出这块内存中的值。</li><li>使用<code>delete dynamicInt</code>释放了之前分配的内存。</li><li>释放内存后，<code>dynamicInt</code>指针不再指向有效的内存区域，如果再次访问它将会导致未定义行为，可能是程序崩溃或其他不可预知的结果。</li></ol><p>请注意，对于数组，应该使用<code>delete[]</code>来释放内存：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* dynamicIntArray = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]; <span class="comment">// 动态分配一个整数数组的内存</span></span><br><span class="line"><span class="comment">// ... 使用数组</span></span><br><span class="line"><span class="keyword">delete</span>[] dynamicIntArray; <span class="comment">// 释放数组内存</span></span><br></pre></td></tr></table></figure><p>正确地管理内存是非常重要的，因为它可以防止内存泄漏和其他内存相关的问题。在现代C++中，通常推荐使用智能指针（如<code>std::unique_ptr</code>和<code>std::shared_ptr</code>），因为它们可以自动管理内存，从而减少内存泄漏的风险。</p><p>是的，<code>std::unique_ptr</code>和<code>std::shared_ptr</code>是C++11及以后版本中引入的智能指针，它们可以帮助自动管理内存，减少内存泄漏的风险。使用这些智能指针，通常不需要（也不应该）手动调用<code>delete</code>来释放内存。智能指针会在适当的时候自动释放它们所管理的资源。</p><h3 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h3><p><code>std::unique_ptr</code>代表独占所有权的智能指针，意味着同一时间只能有一个<code>std::unique_ptr</code>指向特定资源。当<code>std::unique_ptr</code>被销毁时（例如，当它离开作用域或被重新赋值时），它会自动释放所管理的资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionUsingUniquePtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 当ptr离开作用域时，它所管理的内存将自动被释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">functionUsingUniquePtr</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，当<code>ptr</code>离开<code>functionUsingUniquePtr</code>函数的作用域时，它所管理的内存会自动被释放。</p><h3 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h3><p><code>std::shared_ptr</code>代表共享所有权的智能指针，允许多个<code>std::shared_ptr</code>实例共同拥有同一资源。资源的释放是在最后一个拥有该资源的<code>std::shared_ptr</code>被销毁或被赋值为其他资源时自动进行的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">createSharedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">createSharedPtr</span>();</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1; <span class="comment">// 现在ptr1和ptr2共享同一个资源</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *ptr1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ptr1和ptr2离开作用域时，它们所管理的内存不会被释放，因为引用计数不为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>ptr1</code>和<code>ptr2</code>共享同一个资源。当<code>main</code>函数结束时，这两个智能指针都会被销毁，因为它们的引用计数都变为0，所以它们管理的内存会被自动释放。</p><p>总的来说，使用<code>std::unique_ptr</code>和<code>std::shared_ptr</code>可以大大简化内存管理，减少内存泄漏和其他内存管理错误的风险。然而，智能指针也有其开销，因此在性能敏感的应用中，需要权衡使用智能指针的便利性和性能开销。</p><h3 id="指针的简单使用"><a href="#指针的简单使用" class="headerlink" title="指针的简单使用"></a>指针的简单使用</h3><ol><li><p><strong>变量地址获取</strong>：</p><ul><li><p>使用<code>&amp;</code>运算符可以获取变量的地址，并将其赋值给指针。</p></li><li><p>示例：获取变量的地址并赋值给指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;var;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>解引用</strong>：</p><ul><li><p>使用<code>*</code>运算符可以解引用指针，即访问指针所指向的变量的值。</p></li><li><p>示例：通过指针访问变量的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; *ptr;  <span class="comment">// 输出：10</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>动态内存分配</strong>：</p><ul><li><p>使用<code>new</code>运算符可以动态分配内存，返回指向该内存的指针。</p></li><li><p>示例：动态分配内存并初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>数组操作</strong>：</p><ul><li><p>指针可以用于数组的访问和操作。</p></li><li><p>示例：使用指针遍历数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptr = arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; *(ptr + i) &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出：1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>函数参数传递</strong>：</p><ul><li><p>指针可以被用来在函数之间传递参数，使得函数可以直接修改指向对象的值。</p></li><li><p>示例：通过指针修改变量的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> *ptr)</span> </span>&#123;</span><br><span class="line">    *ptr = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">modify</span>(&amp;var);</span><br><span class="line">    std::cout &lt;&lt; var;  <span class="comment">// 输出：30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="C-容器与智能指针"><a href="#C-容器与智能指针" class="headerlink" title="C++容器与智能指针"></a>C++容器与智能指针</h1><p><img src="/./../../images/image-20250514182018774.png" alt="image-20250514182018774"></p><p><img src="/./../../images/image-20250514182052165.png" alt="image-20250514182052165"></p><p><img src="/./../../images/image-20250514182157447.png" alt="image-20250514182157447"></p><p><img src="/./../../images/image-20250514182150823.png" alt="image-20250514182150823"></p><h3 id="数组（固定大小的连续存储空间）"><a href="#数组（固定大小的连续存储空间）" class="headerlink" title="数组（固定大小的连续存储空间）"></a>数组（固定大小的连续存储空间）</h3><ul><li><strong>声明和定义</strong>：<ul><li>使用声明符号<code>[]</code>来声明数组，并指定数组的大小。</li><li>数组的大小必须是常量表达式，可以在编译时确定。</li><li>数组的元素类型可以是任意的基本类型（如整数、浮点数、字符等），也可以是自定义的类型。</li></ul></li><li><strong>数组元素的访问</strong>：<ul><li>数组元素通过索引访问，索引从0开始，到数组大小减1结束。</li><li>使用方括号<code>[]</code>运算符和元素的索引来访问数组元素。</li></ul></li><li><strong>数组的初始化</strong>：<ul><li>可以在声明数组时同时进行初始化，或者在后续的操作中对数组元素进行赋值。</li><li>使用花括号<code>&#123;&#125;</code>来提供初始值。可以使用花括号列表初始化整个数组，或者使用索引逐个初始化数组元素。</li></ul></li><li><strong>数组的遍历</strong>：<ul><li>可以使用循环结构（如<code>for</code>循环）来遍历数组，以访问和处理数组中的每个元素。</li></ul></li></ul><h3 id="向量（Vector，动态数组，可变大小的连续存储空间）"><a href="#向量（Vector，动态数组，可变大小的连续存储空间）" class="headerlink" title="向量（Vector，动态数组，可变大小的连续存储空间）"></a>向量（Vector，动态数组，可变大小的连续存储空间）</h3><ul><li><strong>声明和定义向量</strong>：<ul><li>使用<code>std::vector</code>类模板来声明和定义向量。</li><li>指定向量中元素的类型作为模板参数。</li></ul></li><li><strong>向量的操作</strong>：<ul><li>向量提供了一系列成员函数和操作符来进行元素的插入、删除、访问和修改等操作。</li><li>通过成员函数和操作符，可以获取向量的大小、清空向量、判断向量是否为空等。</li></ul></li><li><strong>向量的遍历</strong>：<ul><li>可以使用循环结构（如<code>for</code>循环）来遍历向量，以访问和处理向量中的每个元素。</li></ul></li></ul><h3 id="列表（List，双向链表结构）"><a href="#列表（List，双向链表结构）" class="headerlink" title="列表（List，双向链表结构）"></a>列表（List，双向链表结构）</h3><ul><li><strong>声明和定义列表</strong>：<ul><li>使用<code>std::list</code>类模板来声明和定义列表。</li><li>指定列表中元素的类型作为模板参数。</li></ul></li><li><strong>列表的操作</strong>：<ul><li>列表提供了一系列成员函数来进行元素的插入、删除、访问和修改等操作。</li><li>通过成员函数，可以获取列表的大小、清空列表、判断列表是否为空等。</li></ul></li><li><strong>列表的遍历</strong>：<ul><li>可以使用迭代器或循环结构（如<code>for</code>循环）来遍历列表，以访问和处理列表中的每个元素。</li></ul></li></ul><p>这些容器各有特点和适用场景，选择哪种容器取决于具体的应用需求。例如，如果需要频繁地在容器中间插入或删除元素，列表可能是更好的选择；如果需要快速随机访问元素，向量或数组可能更合适。</p><p><img src="/./../../images/image-20250514182631401.png" alt="image-20250514182631401"></p><h3 id="映射（Map）容器概述"><a href="#映射（Map）容器概述" class="headerlink" title="映射（Map）容器概述"></a>映射（Map）容器概述</h3><ul><li><strong>定义</strong>：映射（Map）是一种键值对的容器，用于存储和管理键值对（key-value）数据。</li><li><strong>特点</strong>：映射是C++标准库中的一种容器，提供了方便的操作和管理键值对数据的方法。</li><li><strong>键的唯一性</strong>：映射类似于字典的概念，其中键是唯一的，可以用于快速查找和访问对应的值。</li><li><strong>头文件</strong>：映射类定义在<code>&lt;map&gt;</code>头文件中，需要引入该头文件才能使用映射。</li></ul><h3 id="声明和定义映射"><a href="#声明和定义映射" class="headerlink" title="声明和定义映射"></a>声明和定义映射</h3><ul><li><strong>使用<code>std::map</code>类模板</strong>：使用<code>std::map</code>类模板来声明和定义映射。</li><li><strong>模板参数</strong>：指定键和值的类型作为模板参数。</li></ul><h3 id="映射的操作"><a href="#映射的操作" class="headerlink" title="映射的操作"></a>映射的操作</h3><ul><li><strong>成员函数和操作符</strong>：映射提供了一系列成员函数和操作符来进行键值对的插入、删除、查找和访问等操作。</li><li><strong>获取映射大小</strong>：通过成员函数，可以获取映射的大小。</li><li><strong>清空映射</strong>：可以清空映射，即删除映射中的所有键值对。</li><li><strong>判断映射是否为空</strong>：可以判断映射是否为空。</li></ul><h3 id="映射的遍历"><a href="#映射的遍历" class="headerlink" title="映射的遍历"></a>映射的遍历</h3><ul><li><strong>迭代器或循环结构</strong>：可以使用迭代器或循环结构（如<code>for</code>循环）来遍历映射，以访问和处理映射中的每个键值对。</li></ul><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><ul><li><p><strong>声明映射</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; studentGrades; <span class="comment">// 声明一个字符串到整数的映射</span></span><br><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; phoneBook; <span class="comment">// 声明一个整数到字符串的映射</span></span><br></pre></td></tr></table></figure></li><li><p><strong>插入键值对</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">studentGrades[<span class="string">&quot;Alice&quot;</span>] = <span class="number">90</span>; <span class="comment">// 插入一个键值对</span></span><br><span class="line">studentGrades[<span class="string">&quot;Bob&quot;</span>] = <span class="number">85</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>访问键值对</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; studentGrades[<span class="string">&quot;Alice&quot;</span>] &lt;&lt; std::endl; <span class="comment">// 访问键对应的值</span></span><br></pre></td></tr></table></figure></li><li><p><strong>遍历映射</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (std::map&lt;std::string, <span class="type">int</span>&gt;::iterator it = studentGrades.<span class="built_in">begin</span>(); it != studentGrades.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl; <span class="comment">// 输出键值对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="常见容器的分类"><a href="#常见容器的分类" class="headerlink" title="常见容器的分类"></a>常见容器的分类</h1><p><img src="/./../../images/image-20250514183545638.png" alt="image-20250514183545638"></p><h4 id="1-顺序容器（Sequence-Container）"><a href="#1-顺序容器（Sequence-Container）" class="headerlink" title="1. 顺序容器（Sequence Container）"></a>1. 顺序容器（Sequence Container）</h4><ul><li><strong>存储方式</strong>：顺序容器按照元素的插入顺序来存储元素，元素在容器中的位置由插入顺序决定。</li><li><strong>访问方式</strong>：可以使用迭代器（iterator）或下标运算符来访问容器中的元素。</li><li><strong>示例容器</strong>：包括向量（vector）、双向链表（list）、双端队列（deque）等。</li></ul><h4 id="2-有序容器（Ordered-Container）"><a href="#2-有序容器（Ordered-Container）" class="headerlink" title="2. 有序容器（Ordered Container）"></a>2. 有序容器（Ordered Container）</h4><ul><li><strong>存储方式</strong>：有序容器按照一定的排序准则对元素进行排序，并在插入时维持元素的有序性。</li><li><strong>访问方式</strong>：可以使用迭代器或下标运算符来访问容器中的元素（元素的顺序是根据排序准则来决定的）。</li><li><strong>示例容器</strong>：包括集合（set）、映射（map）、多重集合（multiset）、多重映射（multimap）等。</li></ul><h3 id="其他区别"><a href="#其他区别" class="headerlink" title="其他区别"></a>其他区别</h3><ul><li><strong>适用场景</strong>：<ul><li>顺序容器适用于需要保留元素插入顺序的场景。</li><li>有序容器适用于需要根据排序准则进行存储和访问的场景。</li></ul></li><li><strong>插入和删除操作</strong>：<ul><li>顺序容器的插入和删除操作可能会导致元素在内存中的重新分配和移动。</li><li>有序容器则需要保持元素的有序性，因此插入和删除操作可能更复杂。</li></ul></li><li><strong>查找操作</strong>：<ul><li>顺序容器的查找操作通常需要遍历整个容器，时间复杂度为O(n)。</li><li>有序容器可以利用内部的排序结构进行快速的查找，时间复杂度为O(log n)。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>顺序容器</strong>：适用于需要保留元素插入顺序的场景，如向量、列表、双端队列。</li><li><strong>有序容器</strong>：适用于需要根据排序准则进行存储和访问的场景，如集合、映射、多重集合、多重映射。</li><li><strong>性能差异</strong>：顺序容器的查找操作通常较慢，而有序容器可以利用排序结构进行快速查找。</li></ul><p><img src="/./../../images/image-20250514183612141.png" alt="image-20250514183612141"></p><p><img src="/./../../images/image-20250514183634954.png" alt="image-20250514183634954"></p><h3 id="遍历容器元素"><a href="#遍历容器元素" class="headerlink" title="遍历容器元素"></a>遍历容器元素</h3><h4 id="使用迭代器遍历容器元素"><a href="#使用迭代器遍历容器元素" class="headerlink" title="使用迭代器遍历容器元素"></a>使用迭代器遍历容器元素</h4><ul><li><strong>迭代器</strong>：是一种能够遍历容器元素的对象，类似于指针。</li><li><strong>获取迭代器</strong>：容器类通常提供<code>begin()</code>和<code>end()</code>成员函数来获取迭代器的起始和结束位置。</li><li><strong>遍历方法</strong>：可以使用循环结构（如<code>while</code>或<code>for</code>循环）和迭代器逐个访问容器元素。</li></ul><h4 id="使用范围-for循环遍历容器元素"><a href="#使用范围-for循环遍历容器元素" class="headerlink" title="使用范围-for循环遍历容器元素"></a>使用范围-for循环遍历容器元素</h4><ul><li><strong>范围-for循环</strong>：是C++11引入的语法，可以简化容器元素的遍历。</li><li><strong>自动类型推断</strong>：使用<code>auto</code>关键字来推断迭代器的类型，并使用范围-for循环对容器进行遍历。</li></ul><h3 id="容器的遍历和常用操作"><a href="#容器的遍历和常用操作" class="headerlink" title="容器的遍历和常用操作"></a>容器的遍历和常用操作</h3><h4 id="插入和删除元素"><a href="#插入和删除元素" class="headerlink" title="插入和删除元素"></a>插入和删除元素</h4><ul><li><strong>插入元素</strong>：<ul><li>顺序容器中使用<code>push_back()</code>或<code>push_front()</code>函数，分别在容器尾部和头部插入元素。</li><li>有序容器中使用<code>insert()</code>函数，在容器指定位置插入元素。</li></ul></li><li><strong>删除元素</strong>：<ul><li>顺序容器中使用<code>pop_back()</code>或<code>pop_front()</code>函数，分别删除在容器尾部和头部的元素。</li><li>使用<code>erase()</code>函数，删除有序容器和映射中指定位置或者指定键的元素。</li></ul></li></ul><h4 id="查找和替换元素"><a href="#查找和替换元素" class="headerlink" title="查找和替换元素"></a>查找和替换元素</h4><ul><li><strong>查找元素</strong>：<ul><li>有序容器和映射中，使用<code>find()</code>函数在容器中查找指定元素，并返回该元素的迭代器。</li><li>有序容器和映射中，使用<code>count()</code>函数计算容器中指定元素的个数。</li></ul></li><li><strong>替换元素</strong>：<ul><li>可以使用迭代器来直接修改容器中的元素。</li><li>使用下标运算符[]直接修改容器中的元素。</li></ul></li></ul><h4 id="容器大小和容量的操作"><a href="#容器大小和容量的操作" class="headerlink" title="容器大小和容量的操作"></a>容器大小和容量的操作</h4><ul><li><strong>容器大小</strong>：<ul><li>使用容器的成员函数<code>size()</code>函数获取容器中的元素个数。</li><li>使用容器的成员函数<code>empty()</code>函数检查容器是否为空，容器中没有元素则返回true，否则返回false。</li></ul></li><li><strong>容器容量</strong>：<ul><li>使用容器的成员函数<code>capacity()</code>，获取容器重新分配内容之前可以容纳的元素个数。</li><li>使用容器的成员函数<code>reserve()</code>，为容器设置预留的容量，可以避免频繁的重新分配内存。</li></ul></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这些操作涵盖了C++容器的基本使用，包括遍历、插入、删除、查找、替换以及获取容器的大小和容量等。通过这些操作，可以有效地管理和操作容器中的数据。使用迭代器和范围-for循环可以方便地遍历容器，而各种成员函数则提供了对容器元素的增删改查等操作。理解这些基本概念和操作对于在C++中有效地使用容器至关重要。</p><p><img src="/./../../images/image-20250518220951020.png" alt="image-20250518220951020"></p><h3 id="公有成员"><a href="#公有成员" class="headerlink" title="公有成员"></a>公有成员</h3><ul><li><strong>定义</strong>：通过公有访问修饰符<code>public</code>修饰的成员变量或成员函数。</li><li><strong>访问权限</strong>：<ul><li><strong>公有成员变量</strong>：可以被类的对象和类外部代码直接访问和修改。</li><li><strong>公有成员函数</strong>：可以被类的对象和类外部代码调用。</li></ul></li></ul><h3 id="保护成员"><a href="#保护成员" class="headerlink" title="保护成员"></a>保护成员</h3><ul><li><strong>定义</strong>：通过保护访问修饰符<code>protected</code>修饰的成员变量或成员函数。</li><li><strong>访问权限</strong>：<ul><li><strong>保护成员变量</strong>：只能被类的派生类访问和修改。</li><li><strong>保护成员函数</strong>：只能被类的派生类调用。</li></ul></li></ul><h3 id="私有成员"><a href="#私有成员" class="headerlink" title="私有成员"></a>私有成员</h3><ul><li><strong>定义</strong>：通过私有访问修饰符<code>private</code>修饰的成员变量或成员函数。</li><li><strong>访问权限</strong>：<ul><li><strong>私有成员变量</strong>：只能被类的成员函数访问和修改。</li><li><strong>私有成员函数</strong>：只能被类的其他成员函数调用。</li></ul></li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>公有成员</strong>：具有最宽松的访问权限，可以被类的对象和类外部代码访问。</li><li><strong>保护成员</strong>：具有中等的访问权限，只能被类的派生类访问。</li><li><strong>私有成员</strong>：具有最严格的访问权限，只能被类的成员函数访问。</li></ul><p><img src="/./../../images/image-20250518220805025.png" alt="image-20250518220805025"></p><h3 id="函数覆盖的概念和使用"><a href="#函数覆盖的概念和使用" class="headerlink" title="函数覆盖的概念和使用"></a>函数覆盖的概念和使用</h3><ul><li><strong>函数覆盖</strong>：派生类重写（覆盖）基类中的虚函数，以实现特定行为。这是实现运行时多态性的一种机制。</li><li><strong>使用关键字</strong>：<ul><li>在基类中声明虚函数时，使用关键字<code>virtual</code>来标识。</li><li>在派生类中重写（覆盖）基类中的虚函数。</li></ul></li></ul><h3 id="使用override和final关键字"><a href="#使用override和final关键字" class="headerlink" title="使用override和final关键字"></a>使用override和final关键字</h3><ul><li><strong>override关键字</strong>：<ul><li>在C++中，<code>override</code>和<code>final</code>是两个关键字，用于对虚函数进行重写和类进行继承的修饰。</li><li><code>override</code>关键字帮助我们确保正确地进行函数重写。</li><li><code>final</code>关键字防止派生和重写。</li><li><strong>用法</strong>：<ul><li><code>override</code>关键字可用于派生类中对基类虚函数的重写，以确保正确地进行函数覆盖。</li><li>在派生类中使用<code>override</code>关键字标识对基类中虚函数的重写，可以帮助我们在编译时捕获一些常见的错误，如函数签名不匹配的情况。</li><li>如果派生类中的函数声明使用<code>override</code>关键字，但实际上并没有重写基类中的虚函数，编译器将会发出错误提示。</li></ul></li></ul></li><li><strong>final关键字</strong>：<ul><li><code>final</code>关键字用于修饰类、虚函数或成员函数，表示它们是最终版本，禁止进一步的派生或重写。</li><li><strong>用法</strong>：<ul><li>在类声明中使用<code>final</code>关键字修饰类，表示该类是最终类，不能再被继承。</li><li>在虚函数声明中使用<code>final</code>关键字修饰虚函数，表示该虚函数不能再被派生类重写。</li><li>在成员函数声明中使用<code>final</code>关键字修饰成员函数，表示该成员函数不能在派生类中被重写。</li></ul></li></ul></li></ul><p>总结来说，<code>override</code>和<code>final</code>关键字在C++中用于确保类的继承和函数的重写符合预期，避免错误和歧义。</p><p><img src="/./../../images/image-20250514183659851.png" alt="image-20250514183659851"></p><p><img src="/./../../images/image-20250514183713078.png" alt="image-20250514183713078"></p><h1 id="C-常用总结"><a href="#C-常用总结" class="headerlink" title="C++常用总结"></a>C++常用总结</h1><p>​</p><ol><li><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a><strong>文件操作</strong></h1><ul><li>文件操作通常涉及创建、读取、写入和删除文件。在C++中，可以使用标准库中的<code>&lt;fstream&gt;</code>头文件提供的类，如<code>std::ifstream</code>（输入文件流）、<code>std::ofstream</code>（输出文件流）和<code>std::fstream</code>（输入输出文件流）来进行文件操作。</li></ul></li></ol><p>​文件指针的操作</p><p>在C++中，文件指针用于定位和控制文件中的读写位置。以下是文件指针操作的主要方法：</p><h4 id="获取文件指针的位置"><a href="#获取文件指针的位置" class="headerlink" title="获取文件指针的位置"></a>获取文件指针的位置</h4><ul><li>**<code>tellg()</code>**：用于获取输入文件流的当前读取位置。</li><li>**<code>tellp()</code>**：用于获取输出文件流的当前写入位置。</li></ul><h4 id="设置文件指针的位置"><a href="#设置文件指针的位置" class="headerlink" title="设置文件指针的位置"></a>设置文件指针的位置</h4><ul><li>**<code>seekg(pos)</code>**：将输入文件流的读取位置设置为相对于文件开头的<code>pos</code>位置。</li><li>**<code>seekp(pos)</code>**：将输出文件流的写入位置设置为相对于文件开头的<code>pos</code>位置。</li><li>**<code>seekg(offset, dir)</code> 和 <code>seekp(offset, dir)</code>**：在当前位置的基础上相对于<code>offset</code>进行偏移，<code>dir</code>可以是以下常量之一：<ul><li>**<code>std::ios::beg</code>**：相对于文件开头进行偏移。</li><li>**<code>std::ios::cur</code>**：相对于当前位置进行偏移。</li><li>**<code>std::ios::end</code>**：相对于文件末尾进行偏移。</li></ul></li></ul><h4 id="检查文件指针的有效性"><a href="#检查文件指针的有效性" class="headerlink" title="检查文件指针的有效性"></a>检查文件指针的有效性</h4><ul><li>**<code>good()</code>**：成员函数检查文件指针是否有效。如果文件指针有效，则返回<code>true</code>；否则返回<code>false</code>。</li></ul><ol><li><h1 id="空指针的处理"><a href="#空指针的处理" class="headerlink" title="空指针的处理"></a><strong>空指针的处理</strong></h1><ul><li>空指针是指没有指向任何对象的指针。在C++中，空指针通常用<code>nullptr</code>表示。处理空指针时，需要检查指针是否为空，避免解引用空指针，这会导致程序崩溃。可以使用条件语句来检查指针是否为<code>nullptr</code>。</li></ul></li></ol><p><img src="/./../../images/image-20250514221542740.png" alt="image-20250514221542740"></p><h3 id="空指针的判断和使用"><a href="#空指针的判断和使用" class="headerlink" title="空指针的判断和使用"></a>空指针的判断和使用</h3><ul><li><p><strong>判断空指针</strong>：</p><ul><li><p>使用条件判断语句将目标指针与<code>nullptr</code>进行比较。如果指针为空（即没有指向任何对象），则条件为真；否则为假。</p></li><li><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 指针为空的处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>空指针的特性</strong>：</p><ul><li>空指针没有有效的内存地址，访问空指针指向的对象是不安全的，可能导致程序崩溃或未定义行为。</li><li>将<code>nullptr</code>赋值给指针，可以将指针显式地设置为空指针。</li></ul></li></ul><h3 id="避免空指针的错误"><a href="#避免空指针的错误" class="headerlink" title="避免空指针的错误"></a>避免空指针的错误</h3><ul><li><p><strong>检查动态分配的内存</strong>：</p><ul><li><p>在动态分配内存后，应该检查分配的指针是否为空，以确保内存分配成功。如果分配失败，指针将为<code>nullptr</code>。</p></li><li><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 内存分配失败的处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用指针前检查</strong>：</p><ul><li><p>在使用指针之前，始终检查指针是否为空，并尽量避免访问空指针。</p></li><li><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 安全地使用指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>空指针是C++编程中常见的问题，处理不当可能导致程序崩溃或未定义行为。以下是一些关键点：</p><ol><li><p><strong>判断空指针</strong>：使用条件判断语句将指针与<code>nullptr</code>比较，确保指针不为空后再使用。</p></li><li><p><strong>显式设置空指针</strong>：将<code>nullptr</code>赋值给指针，显式地将指针设置为空。</p></li><li><p><strong>检查动态内存分配</strong>：在动态分配内存后，检查指针是否为空，确保内存分配成功。</p></li><li><p><strong>使用前检查指针</strong>：在每次使用指针之前，检查指针是否为空，避免访问空指针。</p></li><li><h1 id="常用版本特性"><a href="#常用版本特性" class="headerlink" title="常用版本特性"></a><strong>常用版本特性</strong></h1><ul><li>这可能指的是C++语言的不同版本中引入的新特性。例如，C++11引入了自动类型推断（<code>auto</code>）、范围<code>for</code>循环、智能指针等。了解不同版本的新特性可以帮助开发者编写更现代、更高效的代码。</li></ul><p><img src="/./../../images/image-20250514221601991.png" alt="image-20250514221601991"></p><h3 id="C-11-的特性和改进"><a href="#C-11-的特性和改进" class="headerlink" title="C++11 的特性和改进"></a>C++11 的特性和改进</h3><ol><li><strong>自动类型推导</strong>：<ul><li>引入了关键字 <code>auto</code>，可以根据初始化表达式的类型自动推导变量的类型。这简化了代码编写，特别是在处理复杂类型时。</li></ul></li><li><strong>统一的初始化语法</strong>：<ul><li>引入了初始化列表语法 <code>&#123;&#125;</code>，可以用于初始化数组、容器、结构体等各种类型的对象。这种语法提供了一种统一且直观的方式来初始化对象。</li></ul></li><li><strong>范围-based for 循环</strong>：<ul><li>引入了新的循环语法 <code>for (element : sequence)</code>，用于遍历容器、数组等序列中的元素。这种循环语法使代码更加简洁和易读。</li></ul></li><li><strong>空指针常量</strong>：<ul><li>引入了关键字 <code>nullptr</code>，用于表示空指针。它可以用来替代旧的表示空指针的 <code>NULL</code> 或者 <code>0</code>，提供了更强的类型安全。</li></ul></li><li><strong>强类型枚举</strong>：<ul><li>引入了新的枚举语法，允许为枚举类型指定底层类型，并提供了更强的类型检查。这使得枚举类型更加安全和灵活。</li></ul></li><li><strong>Lambda 表达式</strong>：<ul><li>引入了匿名函数的概念，允许在代码中定义小型的匿名函数。Lambda 表达式可以捕获外部变量，并可以作为函数对象使用，这在编写回调函数和处理事件时非常有用。</li></ul></li><li><strong>智能指针</strong>：<ul><li>引入了三种智能指针类型：<code>std::unique_ptr</code>、<code>std::shared_ptr</code> 和 <code>std::weak_ptr</code>。这些智能指针类型简化了动态内存管理，自动管理内存的分配和释放，减少了内存泄漏的风险。</li></ul></li><li><strong>并发编程支持</strong>：<ul><li>引入了线程库、互斥量、条件变量等多线程和并发编程的支持。这些特性使得C++能够更好地支持并发编程，方便开发者编写并发程序。</li></ul></li></ol><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>C++11标准引入了大量新特性和改进，这些特性不仅提高了代码的可读性和安全性，还简化了代码编写和内存管理。通过使用这些新特性，开发者可以编写更简洁、更安全、更高效的代码，充分利用C++语言的强大功能。同时，这些特性也使得C++语言在现代软件开发中更具竞争力，适用于各种应用场景。</p></li><li><h1 id="常见的编码技巧和最佳实践"><a href="#常见的编码技巧和最佳实践" class="headerlink" title="常见的编码技巧和最佳实践"></a><strong>常见的编码技巧和最佳实践</strong></h1><ul><li>编码技巧和最佳实践包括代码的组织结构、命名约定、内存管理、错误处理等。例如，使用有意义的变量名、避免魔法数字、编写可重用的代码、进行异常处理等。这些实践有助于提高代码的可读性、可维护性和性能。</li></ul><p><img src="/./../../images/image-20250514221828341.png" alt="image-20250514221828341"></p></li></ol><p><img src="/./../../images/image-20250514221850561.png" alt="image-20250514221850561"></p><p><img src="/./../../images/image-20250514221906985.png" alt="image-20250514221906985"></p><p><img src="/./../../images/image-20250514221943742.png" alt="image-20250514221943742"></p><ol><li><h1 id="一些友善的建议"><a href="#一些友善的建议" class="headerlink" title="一些友善的建议"></a><strong>一些友善的建议</strong></h1><ul><li>这可能包括编程时的一些软技能建议，如团队合作、代码审查、持续学习等。友善的建议有助于提高开发者的工作效率和团队的整体表现。</li></ul></li></ol><p><img src="/./../../images/image-20250514222009032.png" alt="image-20250514222009032"></p><p><img src="/./../../images/image-20250514222021860.png" alt="image-20250514222021860"></p><p><img src="/./../../images/image-20250514222048606.png" alt="image-20250514222048606"></p><h1 id="车载事业部C-代码规范培训"><a href="#车载事业部C-代码规范培训" class="headerlink" title="车载事业部C++代码规范培训"></a>车载事业部C++代码规范培训</h1><p><img src="/./../../images/image-20250514222156466.png" alt="image-20250514222156466"></p><p><img src="/./../../images/image-20250515212602980.png" alt="image-20250515212602980"></p><p><img src="/./../../images/image-20250515215400176.png" alt="image-20250515215400176"></p><h2 id="1-预处理宏"><a href="#1-预处理宏" class="headerlink" title="1. 预处理宏"></a>1. 预处理宏</h2><p>主要目的是<strong>避免宏带来的问题</strong>，给出了一些规范和建议：</p><ul><li>不要在 .h 文件中定义宏。<ul><li>避免头文件被多处引用时意外影响其它代码。</li></ul></li><li>在马上要使用时才进行 #define，使用后要立即 #undef。<ul><li>这样可以减少宏对其它代码的影响，做到用完即丢。</li></ul></li><li>不要只是对已经存在的宏使用 #undef，选择一个不会冲突的名称。<ul><li>避免冲突和潜在的命名污染。</li></ul></li><li>不要试图使用展开后会导致 C++ 构造不稳定的宏，否则至少要附上文档说明其行为。<ul><li>指的是有些宏展开后可能对 C++ 构造（如类、函数等）产生不可预期影响，因此要谨慎使用并注明。</li></ul></li><li>不要用 ## 处理函数、类和变量的名字。<ul><li>这是宏拼接符，容易导致名字混淆，可读性和可维护性差。</li></ul></li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>这些规范旨在<strong>减少预处理宏带来的副作用</strong>，提高代码的可维护性和安全性。</p><hr><h2 id="2-整型变量的定义"><a href="#2-整型变量的定义" class="headerlink" title="2. 整型变量的定义"></a>2. 整型变量的定义</h2><p>主要讲述<strong>整型变量的选择</strong>，以及推荐用法：</p><ul><li><p><strong>优先用 C++ 内建类型 int。</strong></p></li><li><p>需要不同大小时建议用 <code>&lt;stdint.h&gt;</code> 里的精确整型 如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int16_t  int32_t  int32_t</span><br></pre></td></tr></table></figure><ul><li>这样可以明确表达变量的位数，提升代码可移植性和准确性。</li></ul></li><li><p>如果变量可能超过 int 能表示的范围，比如大于 2^31（2GiB），就应该直接用 64 位变量 int64_t。</p><ul><li>这样可以避免溢出和数据错误。</li></ul></li><li><p>即使值不会超过 int 表示的范围，在计算过程中也可能溢出。</p><ul><li>所以宁可用大类型，不要“拿不准时用更大的类型”。</li></ul></li></ul><h3 id="介绍："><a href="#介绍：" class="headerlink" title="&lt;stdint.h&gt; 介绍："></a><code>&lt;stdint.h&gt;</code> 介绍：</h3><ul><li>里面定义了 <code>int16_t</code>、<code>uint32_t</code>、<code>int64_t</code> 等精确大小的整型。</li><li>如果需要保证整型大小，可以用这些类型代替 <code>short</code>、<code>unsigned long long</code> 等。</li></ul><hr><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>宏的使用要谨慎，避免污染、冲突、难以维护。</strong><ul><li><strong>整型变量建议用精确类型，防止溢出和类型不确定的问题，提升代码的健壮性和可移植性</strong></li></ul></li></ul><h1 id="DTS"><a href="#DTS" class="headerlink" title="DTS"></a>DTS</h1><h3 id="一、什么是DTS"><a href="#一、什么是DTS" class="headerlink" title="一、什么是DTS"></a>一、什么是DTS</h3><p>DTS是一种描述硬件设备信息的文件格式，主要用于Linux内核中。它以文本的形式描述硬件设备的属性、连接关系等信息，然后通过设备树编译器（DTC）将其编译成设备树二进制文件（.dtb），供内核在启动时加载和解析，从而实现对硬件设备的识别和初始化。</p><h3 id="二、需要了解DTS的情况"><a href="#二、需要了解DTS的情况" class="headerlink" title="二、需要了解DTS的情况"></a>二、需要了解DTS的情况</h3><ol><li><strong>使用Linux内核的嵌入式开发</strong><ul><li>如果你开发的嵌入式系统使用Linux内核，那么了解DTS是非常重要的。因为Linux内核从3.5版本开始，对于许多嵌入式平台（如ARM、RISC-V等）都推荐使用设备树来描述硬件。例如，在开发基于ARM架构的嵌入式设备时，你需要通过DTS文件来告诉内核硬件设备的详细信息，如GPIO引脚的用途、外设的地址范围、时钟配置等。只有这样，内核才能正确地初始化和驱动硬件设备。</li><li>例如，对于一个带有多功能GPIO引脚的嵌入式开发板，你可能需要在DTS文件中指定某个GPIO引脚用于I2C通信，而另一个引脚用于普通数字输入输出。如果DTS文件配置错误，可能会导致硬件设备无法正常工作。</li></ul></li><li><strong>硬件平台的移植和定制开发</strong><ul><li>当你需要将Linux内核移植到一个新的硬件平台或者对现有硬件平台进行定制开发时，DTS文件的编写和修改是必不可少的。因为不同的硬件平台有不同的硬件架构和设备配置，你需要通过DTS文件来适配这些差异。比如，当你将一个Linux内核版本从一个开发板移植到另一个具有不同外设的开发板时，就需要修改DTS文件，以确保内核能够正确识别和管理新开发板上的硬件设备。</li></ul></li><li><strong>驱动开发</strong><ul><li>对于嵌入式系统中的驱动开发，DTS文件提供了硬件设备的接口信息。驱动开发者可以通过DTS文件获取硬件设备的寄存器地址、中断号等关键信息，从而编写出能够正确与硬件设备交互的驱动程序。例如，开发一个SPI设备的驱动时，驱动代码需要从DTS文件中获取SPI控制器的设备树节点信息，包括SPI设备的片选号、时钟速率等参数，才能实现对SPI设备的有效控制。</li></ul></li></ol><h3 id="三、不需要了解DTS的情况"><a href="#三、不需要了解DTS的情况" class="headerlink" title="三、不需要了解DTS的情况"></a>三、不需要了解DTS的情况</h3><ol><li><strong>使用非Linux内核的嵌入式开发</strong><ul><li>如果你的嵌入式系统使用的是其他操作系统（如RTOS，即实时操作系统，像FreeRTOS、μC&#x2F;OS-II等）或者无操作系统，那么DTS文件通常不会被用到。因为这些系统通常采用不同的方式来管理硬件设备，例如通过直接在代码中硬编码硬件设备的地址和配置信息，而不是依赖于像DTS这样的设备树描述机制。</li></ul></li><li><strong>使用封装良好的开发平台和硬件抽象层</strong><ul><li>在一些嵌入式开发平台中，硬件厂商可能已经提供了高度封装的硬件抽象层（HAL）或者中间件，这些抽象层直接隐藏了硬件设备的具体细节，包括DTS文件的使用。在这种情况下，开发者可以直接调用抽象层提供的接口函数来操作硬件设备，而无需关心DTS文件。例如，一些基于STM32微控制器的开发平台，通过STM32 HAL库封装了硬件操作，开发者可以直接使用库函数来控制GPIO、定时器等外设，而无需编写DTS文件。</li></ul></li></ol><h1 id="QNX共享内存"><a href="#QNX共享内存" class="headerlink" title="QNX共享内存"></a>QNX共享内存</h1><p><img src="/./../../images/image-20250521153325554.png" alt="image-20250521153325554"></p><h3 id="一、什么是QNX共享内存"><a href="#一、什么是QNX共享内存" class="headerlink" title="一、什么是QNX共享内存"></a>一、什么是QNX共享内存</h3><p>QNX是一个基于微内核的实时操作系统，其设计目标是提供高效的进程间通信（IPC）和资源管理机制。共享内存是QNX中一种重要的进程间通信方式，允许多个进程共享同一块物理内存区域，从而实现高效的数据交换和通信。</p><p>在QNX中，共享内存的使用通常涉及以下几个关键概念：</p><ol><li><strong>共享内存段（Shared Memory Segment）</strong>：这是共享内存的基本单位，由一个或多个进程创建和访问。</li><li><strong>内存映射（Memory Mapping）</strong>：通过内存映射机制，将共享内存段映射到进程的地址空间中，使得进程可以像访问普通内存一样访问共享内存。</li><li><strong>同步机制（Synchronization）</strong>：由于多个进程可能同时访问共享内存，因此需要使用同步机制（如信号量、互斥锁等）来避免数据竞争和不一致性问题。</li></ol><p><img src="/./../../images/image-20250521153608341.png" alt="image-20250521153608341"></p><p><img src="/./../../images/image-20250521153633809.png" alt="image-20250521153633809"></p><h3 id="QNX共享内存的优缺点"><a href="#QNX共享内存的优缺点" class="headerlink" title="QNX共享内存的优缺点"></a>QNX共享内存的优缺点</h3><ol><li><strong>优点</strong><ul><li><strong>高效性</strong>：共享内存是一种非常高效的进程间通信方式，因为它避免了数据的多次复制和传输。多个进程可以直接访问同一块物理内存，从而大大提高了数据交换的效率。</li><li><strong>灵活性</strong>：QNX的共享内存机制提供了灵活的控制方式，可以通过多种系统调用和库函数来创建、管理和访问共享内存。同时，还可以结合同步机制来实现复杂的并发控制。</li><li><strong>实时性</strong>：在实时系统中，共享内存可以快速地传递数据，满足实时性要求。例如，在高精度的工业控制系统中，共享内存可以用于实时传递传感器数据和控制指令。</li></ul></li><li><strong>缺点</strong><ul><li><strong>同步复杂性</strong>：由于多个进程可能同时访问共享内存，因此需要使用同步机制来避免数据竞争和不一致性问题。同步机制的使用增加了编程的复杂性，需要开发者仔细设计和实现。</li><li><strong>安全性问题</strong>：共享内存的访问权限需要严格控制，否则可能会导致安全问题。例如，如果一个恶意进程访问了共享内存，可能会篡改数据或导致系统崩溃。因此，在使用共享内存时，需要确保只有授权的进程才能访问共享内存。</li><li><strong>内存管理复杂性</strong>：共享内存的生命周期管理需要特别注意。如果某个进程意外崩溃或退出，可能会导致共享内存无法被正确释放，从而造成内存泄漏。因此，需要在程序设计中仔细处理共享内存的创建、使用和销毁过程。</li></ul></li></ol><h3 id="是否需要了解QNX共享内存"><a href="#是否需要了解QNX共享内存" class="headerlink" title="是否需要了解QNX共享内存"></a>是否需要了解QNX共享内存</h3><p>是否需要了解QNX共享内存，取决于你的开发需求和目标平台：</p><ol><li><strong>需要了解的情况</strong><ul><li>如果你正在开发基于QNX操作系统的嵌入式系统，尤其是涉及到多进程协作、实时数据交换或资源管理的场景，那么了解QNX共享内存是非常重要的。掌握共享内存的使用方法可以帮助你设计出高效、可靠的系统架构，提高系统的性能和实时性。</li><li>例如，在开发一个实时监控系统时，多个进程需要实时交换图像数据和传感器数据。通过使用QNX共享内存，可以快速地传递这些数据，同时结合同步机制确保数据的一致性和完整性。</li></ul></li><li><strong>不需要了解的情况</strong><ul><li>如果你的嵌入式系统不使用QNX操作系统，或者你的开发场景中不需要使用共享内存机制（例如，系统中只有一个进程，或者数据交换量非常小），那么了解QNX共享内存可能不是必要的。</li><li>另外，如果你使用的是封装良好的开发框架或中间件，这些框架可能已经隐藏了共享内存的实现细节，你只需要调用相关的接口函数即可实现进程间通信，而无需深入了解共享内存的底层机制。</li></ul></li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="/./../../images/image-20250521154241355.png" alt="image-20250521154241355"></p><p><img src="/./../../images/image-20250521154302419.png" alt="image-20250521154302419"></p><p>一个使用共享内存（Shared Memory）和互斥锁（Mutex）在QNX操作系统中进行进程间通信（IPC）的示例。下面我将详细解释这个示例的代码和运行结果。</p><h3 id="示例代码解释"><a href="#示例代码解释" class="headerlink" title="示例代码解释"></a>示例代码解释</h3><h4 id="shmemcreator-c"><a href="#shmemcreator-c" class="headerlink" title="shmemcreator.c"></a><code>shmemcreator.c</code></h4><p>这个程序创建共享内存和一个信号量，并在共享内存中写入一些文本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shmemcreator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *programname = <span class="string">&quot;shmemcreator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">shmem_t</span> *ptr;</span><br><span class="line">    <span class="type">pthread_mutexattr_t</span> myattr;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> myshmmutex;</span><br><span class="line"></span><br><span class="line">    pthread_mutexattr_init(&amp;myattr);</span><br><span class="line">    pthread_mutexattr_setpshared(&amp;myattr, PTHREAD_PROCESS_SHARED);</span><br><span class="line">    pthread_mutex_init(&amp;ptr-&gt;myshmemmutex, &amp;myattr);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;ptr-&gt;myshmemmutex);</span><br><span class="line">    <span class="built_in">strcpy</span>(ptr-&gt;text, <span class="string">&quot;Text by shmemcreator.c&quot;</span>); <span class="comment">/* write to the shared memory */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Shared memory created and semaphore initialized to 0.\n&quot;</span>,</span><br><span class="line">            programname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Wrote text &#x27;%s&#x27; to shared memory.\n&quot;</span>,</span><br><span class="line">            programname, ptr-&gt;text);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Sleeping for 20 seconds. While this program is sleeping\n&quot;</span>,</span><br><span class="line">            programname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: run &#x27;example_shmem_user&#x27;\n&quot;</span>, programname, programname);</span><br><span class="line">    sleep(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Woke up. Now unlocking the mutex.\n&quot;</span>, programname);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;ptr-&gt;myshmemmutex);</span><br><span class="line"></span><br><span class="line">    close(fd); <span class="comment">// Closing the file descriptor</span></span><br><span class="line">    munmap(ptr, <span class="keyword">sizeof</span>(<span class="type">shmem_t</span>)); <span class="comment">// removing the mapping</span></span><br><span class="line">    shm_unlink(<span class="string">&quot;/myshmemobject&quot;</span>); <span class="comment">// Delete the shared memory object</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shmemuser-c"><a href="#shmemuser-c" class="headerlink" title="shmemuser.c"></a><code>shmemuser.c</code></h4><p>这个程序打开共享内存对象，等待信号量，访问共享内存并读取其中的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shmemcreator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *programname = <span class="string">&quot;shmemuser&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">shmem_t</span> *ptr;</span><br><span class="line"></span><br><span class="line">    fd = shm_open(<span class="string">&quot;/myshmemobject&quot;</span>, O_RDWR, S_IRWXU);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: error opening the shared memory object: %s\n&quot;</span>,</span><br><span class="line">                programname, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr = mmap(<span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">shmem_t</span>),</span><br><span class="line">               PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Waiting on the mutex. Run &#x27;pidin&#x27;. I should be MUTEX_blocked.\n&quot;</span>,</span><br><span class="line">            programname);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;ptr-&gt;myshmemmutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Got the mutex, now accessing shared memory\n&quot;</span>, programname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Shared memory contains &#x27;%s&#x27;\n&quot;</span>, programname, ptr-&gt;text);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;ptr-&gt;myshmemmutex);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    munmap(ptr, <span class="keyword">sizeof</span>(<span class="type">shmem_t</span>));</span><br><span class="line">    <span class="keyword">return</span> (EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ./shmemcreator</span><br><span class="line">shmemcreator: Shared memory created and semaphore initialized to <span class="number">0.</span></span><br><span class="line">shmemcreator: Wrote text <span class="string">&#x27;Text by shmemcreator.c&#x27;</span> to shared memory</span><br><span class="line">shmemcreator: Sleeping <span class="keyword">for</span> <span class="number">20</span> seconds. While this program is sleeping</span><br><span class="line">shmemcreator: run <span class="string">&#x27;example_shmem_user&#x27;</span></span><br><span class="line"></span><br><span class="line"># ./shmemuser</span><br><span class="line">shmemuser: Waiting on the mutex. Run <span class="string">&#x27;pidin&#x27;</span>. I should be MUTEX_blocked.</span><br><span class="line">shmemuser: Got the mutex, now accessing shared memory</span><br><span class="line">shmemuser: The shared memory contains <span class="string">&#x27;Text by shmemcreator.c&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="运行结果解释"><a href="#运行结果解释" class="headerlink" title="运行结果解释"></a>运行结果解释</h4><p><strong><code>shmemcreator</code> 程序</strong>：</p><ul><li>创建共享内存和信号量，初始化为0。</li><li>写入文本 <code>&quot;Text by shmemcreator.c&quot;</code> 到共享内存。</li><li>打印共享内存创建和信号量初始化的信息。</li><li>打印写入共享内存的文本。</li><li>打印程序将要休眠20秒的信息。</li><li>休眠20秒。</li><li>解锁信号量。</li><li>关闭文件描述符，解除映射，删除共享内存对象。</li></ul><p><strong><code>shmemuser</code> 程序</strong>：</p><ul><li>打开共享内存对象。</li><li>将共享内存对象映射到进程地址空间。</li><li>等待信号量（此时会被阻塞，因为 <code>shmemcreator</code> 程序已经锁定了信号量）。</li><li>获取信号量后，访问共享内存并读取其中的内容。</li><li>打印读取到的共享内存内容。</li><li>解锁信号量。</li><li>关闭文件描述符，解除映射。</li></ul><p>运行 <code>shmemcreator</code> 程序后，它会创建共享内存，写入文本，然后休眠20秒。在此过程中，运行 <code>shmemuser</code> 程序，它会等待信号量，因为 <code>shmemcreator</code> 程序已经锁定了信号量。20秒后，<code>shmemcreator</code> 程序解锁信号量，<code>shmemuser</code> 程序获取信号量，访问共享内存并读取其中的内容。</p><p>这个示例展示了如何在QNX操作系统中使用共享内存和互斥锁进行进程间通信。<code>shmemcreator</code> 程序创建共享内存并写入数据，然后休眠一段时间。<code>shmemuser</code> 程序等待信号量，获取信号量后访问共享内存并读取数据。通过这种方式，可以实现多个进程之间的高效数据交换。</p><h2 id="通俗解释QNX程序"><a href="#通俗解释QNX程序" class="headerlink" title="通俗解释QNX程序"></a>通俗解释QNX程序</h2><p>想象你和朋友们在做一个团队项目，需要共享一些信息。为了避免混乱，你们决定用一个特别的“共享笔记本”来记录信息。这个笔记本就像电脑里的“共享内存”，大家都能看和写。</p><ol><li><strong>创建共享笔记本</strong>：<ul><li>你（<code>shmemcreator</code>程序）首先创建了这个共享笔记本，并写下了第一条信息：“Text by shmemcreator.c”。</li><li>然后你锁上了笔记本（使用互斥锁），这样其他人就不能同时写入，避免信息混乱。</li><li>你告诉其他人，你要休息20秒（程序休眠20秒），在这期间他们可以开始读取笔记本。</li></ul></li><li><strong>读取共享笔记本</strong>：<ul><li>你的朋友（<code>shmemuser</code>程序）看到你锁上了笔记本，就等着（等待互斥锁）。</li><li>20秒后，你回来解锁了笔记本，告诉你的朋友可以看了。</li><li>你的朋友打开笔记本，看到了你写的信息：“Text by shmemcreator.c”，然后他把这条信息告诉了团队里的其他人。</li></ul></li><li><strong>结束工作</strong>：<ul><li>你和你的朋友都完成了工作，你把笔记本收起来，这样其他人就不能再次访问它了。</li></ul></li></ol><p><strong>运行结果</strong>：</p><ul><li>你先创建了共享内存，写入了信息，然后休息了20秒。</li><li>在这期间，你的朋友尝试读取共享内存，但因为你锁定了它，所以他必须等待。</li><li>20秒后，你解锁了共享内存，你的朋友读取了里面的信息，并告诉了团队其他人。</li></ul><p>20秒等待主要是为了演示和测试的目的：</p><ol><li><p><strong>演示互斥锁的效果</strong>：<code>shmemcreator</code>程序通过锁定互斥锁来确保在它休眠的20秒内，<code>shmemuser</code>程序能够体验到等待互斥锁释放的过程。这展示了互斥锁的同步机制，即一个程序在访问共享资源时如何等待另一个程序释放锁。(你有足够的时间完成所有与笔记本相关的操作)</p></li><li><p><strong>测试共享内存的访问</strong>：通过在写入数据后休眠，<code>shmemcreator</code>程序确保了<code>shmemuser</code>程序在其休眠期间运行并尝试读取共享内存。这样可以测试<code>shmemuser</code>程序是否能够正确地等待互斥锁，以及在互斥锁释放后是否能够成功读取共享内存中的数据。(其他人不会在你完成之前干扰笔记本中的内容。)</p></li><li><p><strong>模拟实际应用场景</strong>：在实际应用中，可能存在一个程序需要在完成数据写入后，让另一个程序来处理这些数据的情况。通过休眠20秒，<code>shmemcreator</code>程序模拟了这种场景，即在一个程序完成数据处理后，另一个程序开始处理这些数据。(当你解锁笔记本时，其他人可以安全地访问最新的、完整的信息。)</p></li><li><p><strong>为什么你的朋友不能自己打开笔记本？</strong></p><ul><li>因为你在笔记本上加了一把锁（这就像是电脑里的互斥锁）。这把锁是为了防止大家同时写入笔记本，造成信息混乱。所以，只有你（或者有钥匙的人）能打开这个锁，其他人必须等待。</li></ul></li><li><p><strong>为什么一定要等20秒后才能打开给他看？</strong></p><ul><li>你告诉团队，你要休息20秒。在这期间，你的朋友不能打开笔记本，因为笔记本被锁住了。这20秒就像是你处理一些事情的时间，比如写一些重要的信息到笔记本里。</li></ul></li><li><p><strong>如果我打开了，不就是两个人一起看了吗？</strong></p><ul><li>当你20秒后回来，你打开了笔记本的锁，这时候你的朋友就可以看了。但是，即使他看了，也只有一个人能同时写入笔记本，因为每次只能有一个人拿着钥匙（解锁）。这样，其他人就不会同时写入，造成混乱。</li></ul></li></ol><h1 id="C语言编码规范"><a href="#C语言编码规范" class="headerlink" title="C语言编码规范"></a>C语言编码规范</h1><p><img src="/./../../images/image-20250521164427381.png" alt="image-20250521164427381"></p><p><img src="/./../../images/image-20250521164537900.png" alt="image-20250521164537900"></p><p><img src="/./../../images/image-20250521164502982.png" alt="image-20250521164502982"></p><h3 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h3><ol><li><strong>组成</strong>：<ul><li>只能包含字母、数字和下划线。</li><li>不能以数字开头。</li><li>下划线不能出现在开头或结尾。</li></ul></li><li><strong>目的</strong>：<ul><li>让代码更易读。</li><li>避免混淆，例如 <code>variable_name</code> 和 <code>variable___name</code>。</li></ul></li><li><strong>命名原则</strong>：<ul><li>使用完整的英文描述。</li><li>遵循“最小长度 &amp; 最大信息”原则，谨慎使用缩写。</li></ul></li><li><strong>说明</strong>：<ul><li>如果缩写，需在代码中统一使用。例如，<code>num</code> 代表 <code>number</code>，则全程使用 <code>num</code>。</li></ul></li></ol><p>这样命名标识符可以让代码更清晰、更一致。</p><p><img src="/./../../images/image-20250521164739687.png" alt="image-20250521164739687"></p><p><strong>规则</strong>：</p><ul><li>文件名必须全部小写。</li><li>单词之间用下划线分隔。</li><li>文件后缀只能是 <code>.h</code> 或 <code>.c</code>。</li></ul><p><strong>正确示例</strong>：</p><ul><li><code>bw_media_scan_service.c</code></li><li><code>bw_media_scan_service.h</code></li></ul><p><strong>错误示例</strong>：</p><ul><li><code>MediaScanner.inc</code> （文件名不对）</li><li><code>mediascanner.cc</code> （文件名和后缀都不对）</li><li><code>Media_Scanner.hpp</code> （文件名和后缀都不对）</li></ul><p><img src="/./../../images/image-20250521165229163.png" alt="image-20250521165229163"></p><p><img src="/./../../images/image-20250521165317163.png" alt="image-20250521165317163"></p><p><img src="/./../../images/image-20250521165423756.png" alt="image-20250521165423756"></p><p><img src="/./../../images/image-20250521165442890.png" alt="image-20250521165442890"></p><p><img src="/./../../images/image-20250521165606544.png" alt="image-20250521165606544"></p><p><img src="/./../../images/image-20250521171346648.png" alt="image-20250521171346648"></p><h1 id="智能汽车技术培训-操作系统基础"><a href="#智能汽车技术培训-操作系统基础" class="headerlink" title="智能汽车技术培训-操作系统基础"></a>智能汽车技术培训-操作系统基础</h1><p><img src="/./../../images/image-20250521171816673.png" alt="image-20250521171816673"></p><p><img src="/./../../images/image-20250521171850212.png" alt="image-20250521171850212"></p>]]></content>
      
      
      <categories>
          
          <category> 车载c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 车载c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>车载基础知识</title>
      <link href="/2024/06/06/test/%E8%BD%A6%E8%BD%BD%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/06/06/test/%E8%BD%A6%E8%BD%BD%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2024/06/06/test/%E8%BD%A6%E8%BD%BD%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Hexo-Blog\blog-demo\source\images\image-20250506131349931.png" alt="image-20250506131349931"></p><p><img src="/2024/06/06/test/%E8%BD%A6%E8%BD%BD%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Hexo-Blog\blog-demo\source\images\image-20250506131321041.png" alt="image-20250506131321041"></p><p><img src="H:/Hexo-Blog/blog-demo/source/images/image-20250506132441378.png" alt="image-20250506132441378"></p><p><img src="H:/Hexo-Blog/blog-demo/source/images/image-20250506132455224.png" alt="image-20250506132455224"></p><p><img src="H:/Hexo-Blog/blog-demo/source/images/image-20250506133501197.png" alt="image-20250506133501197"></p><p><img src="H:/Hexo-Blog/blog-demo/source/images/image-20250506133535453.png" alt="image-20250506133535453"></p><p><img src="H:/Hexo-Blog/blog-demo/source/images/image-20250506143413334.png" alt="image-20250506143241473"></p><p>车载技术基础</p><p><img src="H:/Hexo-Blog/blog-demo/source/images/image-20250506143948308.png" alt="image-20250506143948308"></p><p>更偏向软件方面</p><ol><li><strong>自动驾驶</strong>：这个领域涉及到开发和集成自动驾驶技术，包括传感器融合、决策算法、控制策略等，以实现车辆的自主导航和操作。</li><li><strong>智能座舱</strong>：智能座舱是指车辆内部的智能化系统，包括信息娱乐系统、驾驶员监控系统、乘客交互界面等，旨在提升驾驶体验和安全性。</li><li><strong>SOA和软总线</strong>：SOA（面向服务的架构）是一种软件设计模式，软总线则可能指的是软件定义的通信总线，这些技术有助于实现车辆内部不同系统之间的高效通信和集成。</li><li><strong>网络产品</strong>：这可能涉及到车辆的网络连接解决方案，包括车联网（V2X）、车载信息娱乐系统的网络服务等，以实现车辆与外部世界的连接。</li><li><strong>视觉产品</strong>：这个领域可能包括车载摄像头系统、图像处理算法等，用于车辆的环境感知、驾驶员监控、乘客识别等功能。</li><li><strong>车身控制</strong>：车身控制涉及到车辆的各种电子控制单元（ECU），如车窗控制、车内照明、车门锁定等，以实现车辆的智能化管理。</li></ol><p><img src="H:/Hexo-Blog/blog-demo/source/images/image-20250506144424064.png" alt="image-20250506144424064"></p><p>汽车业务市场情况可以分为以下三个势力：</p><ol><li><strong>传统车企</strong>：<ul><li>这些是基于原有的燃油车智能化以及转型生产电动车的车企。它们通常拥有悠久的历史和深厚的技术积累，正在逐步向智能化和电动化转型。图片中列举了包括通用汽车（GM）、奥迪（Audi）、宝马（BMW）、奔驰（Mercedes-Benz）、大众（Volkswagen）、丰田（Toyota）等在内的多家知名传统汽车制造商。</li></ul></li><li><strong>新兴造车企业</strong>：<ul><li>这些是从特斯拉（Tesla）出现后，特别是国内近几年产生的全新造车企业。它们通常以电动车为主要产品，已经量产了多个车型并且拥有一定的技术积累。图片中提到的新兴造车企业包括特斯拉（Tesla）、Rivian、Lucid、蔚来（NIO）、理想（Li Auto）、小鹏汽车（XPeng Motors）、零跑汽车（Leapmotor）、威马汽车（WM Motor）等。</li></ul></li><li><strong>高技术企业</strong>：<ul><li>这些是新进入局以及较大可能进入汽车行业的高技术企业。它们可能原本并非汽车制造商，但凭借在高科技领域的技术优势，有潜力进入汽车行业。图片中提到的可能进入汽车行业的高技术企业包括苹果（Apple）、索尼（Sony）、富士康（Foxconn）、小米（Xiaomi）、华为（Huawei）等。</li></ul></li></ol><p> </p><p><img src="H:/Hexo-Blog/blog-demo/source/images/image-20250506144652829.png" alt="image-20250506144652829"></p><ul><li><strong>主机厂，OEM，车厂</strong>：这些词都指的是那些生产和销售汽车的大公司。它们有完整的生产线，可以自己采购各种零部件，然后组装成一辆完整的汽车。就像是汽车界的“大厨”，负责把各种“食材”（零部件）做成一道“大餐”（整车）。比如北京奔驰、上汽乘用车厂、小米汽车这些。</li><li><strong>Tier1（一级供应商）</strong>：这些公司是直接给主机厂提供零部件或服务的。就像是给“大厨”提供“食材”的供应商。比如安徽智途公司可能会把他们生产的电子控制单元（ECU）卖给江淮乘用车厂，智途就是Tier1供应商；中科创达为通用汽车（GM）开发软件，中科创达也是Tier1供应商。</li><li><strong>Tier2（二级供应商）</strong>：这些公司是给Tier1供应商提供商品或服务的。就像是给“食材”供应商提供原材料的公司。比如创达南京分公司可能会为安徽智途开发软件，创达就是Tier2供应商。</li><li><strong>ECU（电子控制单元）</strong>：ECU就像是汽车的“大脑”，负责控制汽车的各种功能。它通过接收各种传感器的数据，来判断汽车的状态，然后指挥汽车的各个部分工作。比如控制发动机的运转、刹车系统的工作等等。</li></ul><p><img src="/./../../images/image.png" alt="img"></p><p>EE架构，全称是电子电气（Electrical&#x2F;Electronic）架构，是汽车中所有电子和电气系统的框架设计。它定义了车辆内部各个电子控制单元（ECU）的布局、通信方式、功能分配以及它们如何相互作用。EE架构是汽车电子系统的核心，它直接影响到车辆的性能、安全性、舒适性和燃油效率。</p><p>随着汽车技术的发展，EE架构也在不断演进，以适应新的功能和需求，比如增加的电子设备、更复杂的传感器系统、车载信息娱乐系统、自动驾驶技术等。EE架构的演进大致可以分为以下几个阶段：</p><ol><li><strong>分布式架构</strong>：<ul><li>在这个阶段，汽车的每个功能都有自己的电子控制单元（ECU）。这些ECU是独立的，通过CAN（控制器局域网）或LIN（局域互联网络）总线通信。</li><li>每个ECU都有自己的传感器和算法，它们之间的通信不多。</li><li>这种架构的缺点是布线复杂，需要大量的内部通信，导致成本增加。</li></ul></li><li><strong>域集中式架构</strong>：<ul><li>这个阶段将汽车的电子部件功能划分为几个域，如动力域、底盘域、座舱域、驾驶域和车身控制域。</li><li>每个域都有自己的域控制器，域控制器通过CAN或以太网（Ethernet）网络将分散的ECU集中到一起。</li><li>这种架构的优点是更容易实现OTA（空中下载）升级，提高运算能力，支持更灵活的通信网络，同时对信息安全和功能安全的要求更高。</li></ul></li><li><strong>中央集中式架构</strong>：<ul><li>在这个阶段，主控制器的运算能力进一步提高，出现了超级电脑的设计。</li><li>整个系统中复杂的运算功能都集中到一个设备上，这个设备配置有强大的CPU和运算加速器，可以更有效地利用硬件性能。</li><li>这种架构的优点是简化了布线设计，降低了成本，同时支持软件功能的迭代与扩展。</li></ul></li></ol><p><img src="/./../../images/image-20250506145833055.png" alt="image-20250506145833055"></p><p><img src="/./../../images/image-20250506150752230.png" alt="image-20250506150752230"></p><ol><li><strong>SOP</strong>：Start of Production的缩写，指的是芯片开始量产的时间。</li></ol><p><img src="/./../../images/image-20250506153008648.png" alt="image-20250506153008648"></p><ol><li><strong>处理器</strong>：<ul><li>包括CPU（中央处理器）、GPU（图形处理器）、NPU（神经网络加速器）等，就像是电脑的大脑，负责思考和处理各种信息。</li><li>处理视频、音频等，就像是电脑处理图片和声音一样。</li><li>有各种接口，可以连接摄像头、麦克风等设备，就像是电脑的USB接口可以连接鼠标、键盘。</li></ul></li><li><strong>存储器</strong>：<ul><li>RAM（随机访问存储器）：就像是电脑的内存，用来临时存放正在处理的数据，断电后数据会消失。</li><li>ROM（只读存储器）：包括SSD、Flash、SD卡、硬盘等，用来长期存放数据，断电后数据不会消失。</li></ul></li><li><strong>安全和控制系统</strong>：<ul><li>就像是电脑的安全软件，负责保护系统安全，防止未经授权的访问。</li><li>控制电源管理，就像是电脑的电源管理功能，控制电源的开关和分配。</li></ul></li><li><strong>通信部分</strong>：<ul><li>板子内部通信接口：就像是电脑内部的连接线，用来连接不同的部件。</li><li>外部通信接口：包括LVDS、USB、CAN、以太网等，用来连接显示屏、摄像头和其他电子控制单元（ECU），就像是电脑连接显示器、打印机等设备。</li><li>座舱平台需要处理大量的音视频数据，所以接口的带宽（数据传输速度）很高。</li></ul></li></ol><p><img src="/./../../images/image-20250506153500766.png" alt="image-20250506153500766"></p><p><img src="/./../../images/image-1746517001188-3.png" alt="img"></p><p>音频系统</p><ol><li><strong>通过板载音频DSP和功放</strong>：<ul><li>板载音频DSP（数字信号处理器）就像是音频系统的大脑，负责处理音频信号，比如调整音量、平衡、音效等。</li><li>功放（功率放大器）则负责将音频信号放大，以便能够驱动扬声器发出声音。</li><li>在这种连接方式中，音频DSP和功放都集成在同一个电路板上，通过I2S&#x2F;TDM（一种音频数据传输协议）与SoC（系统级芯片）通信。</li></ul></li><li><strong>通过外部音频DSP和功放</strong>：<ul><li>在这种方式中，音频DSP和功放是分开的，位于不同的电路板上。</li><li>SoC通过I2S&#x2F;TDM与外部DSP通信，DSP再通过I2C（一种简单的串行通信协议）与功放通信。</li><li>这种方式提供了更大的灵活性，因为DSP和功放可以独立选择和更换。</li></ul></li><li><strong>通过芯片内部的DSP处理音效</strong>：<ul><li>在这种方式中，SoC内部集成了DSP，可以直接处理音频信号。</li><li>音频信号通过I2S&#x2F;TDM传输到SoC内部的DSP进行处理，然后通过I2C与音频DAC&#x2F;ADC（数字模拟转换器&#x2F;模拟数字转换器）通信，最后通过内部功放输出到扬声器。</li><li>这种方式简化了系统设计，因为所有功能都集成在SoC内部。</li></ul></li></ol><p>自动驾驶</p><p><img src="/./../../images/image-20250506154033968.png" alt="image-20250506154033968"></p><p>要认真对待 </p><p><img src="/./../../images/image-20250506160335715.png" alt="image-20250506160335715"></p><p><img src="/./../../images/image-20250506160819356.png" alt="image-20250506160819356"></p><h1 id="故障分析"><a href="#故障分析" class="headerlink" title="故障分析"></a>故障分析</h1><p><img src="/./../../images/image-20250513140813946.png" alt="image-20250513140813946"></p><p><img src="/./../../images/image-20250513141619558.png" alt="image-20250513141619558"></p><p><img src="/./../../images/image-20250513143344174.png" alt="image-20250513143344174"></p><p><img src="/./../../images/image-20250513143428524.png" alt="image-20250513143428524"></p><p>​</p><p><img src="/./../../images/image-20250513143815538.png" alt="image-20250513143815538"></p><p><img src="/./../../images/image-20250513144051469.png" alt="image-20250513144051469"></p><p>根本原因分析（RCA）是一种结构化的问题解决方法，旨在通过识别、分析和解决根本原因来防止问题再次发生。该方法具有三个主要优点：能够明确问题定义，清晰地识别和说明问题的因果关系，以及有效定位问题的真正根源。实施RCA的基本步骤包括：首先把握现状，识别和澄清问题；其次进行原因调查，探究为何问题未被及时发现；然后进行问题纠正，采取措施处理导致问题的根本原因；最后是再发防止，通过改进措施确保问题不会重复发生。此外，该方法还包括对问题发生的不同层面进行分析，从直接原因到根本原因，以及制定相应的对策来防止问题再次流出。</p><h1 id="开发环境之——git与repo的使用＜1＞"><a href="#开发环境之——git与repo的使用＜1＞" class="headerlink" title="开发环境之——git与repo的使用＜1＞"></a>开发环境之——git与repo的使用＜1＞</h1><p><img src="/./../../images/image-20250513144831104.png" alt="image-20250513144831104"></p><p>版本控制系统是一种用于记录文件内容变化并帮助实现版本控制的系统，它可以让用户在未来查阅特定版本的修订情况。根据其架构和工作方式，版本控制系统可以分为三种类型：本地版本控制系统（RCS），集中式版本控制系统（如CVS、SVN、Perforce），以及分布式版本控制系统（如Git、Mercurial、Bazaar、Darcs、BitKeeper）。这些系统帮助团队有效地管理代码和文档的变更历史，确保项目的协作和版本追踪。</p><p><img src="/./../../images/image-20250513150040756.png" alt="image-20250513150040756"></p><p>分布式版本控制系统是一种允许每个用户计算机上都保存有完整的版本历史记录的系统，它不依赖于中央服务器来存储所有的版本信息。在这种系统中，每个用户的计算机（如Computer A和Computer B）都可以独立地保存文件的所有版本，包括版本1、版本2和版本3。这样的设计提高了系统的灵活性和容错性，因为即使中央服务器出现问题，各个用户的计算机上仍然可以访问到完整的版本历史。此外，这种系统还支持用户在没有网络连接的情况下工作，并且可以在任何时候与其他用户的版本进行合并和同步，从而促进了协作和版本控制的效率。</p><p><img src="/./../../images/image-20250513150658075.png" alt="image-20250513150658075"></p><p>Git是一个由Linus Torvalds在2005年开发的分布式版本控制系统，旨在支持Linux kernel项目。它允许用户在本地计算机上建立一个空目录，并从远程服务器同步一个或多个项目的内容，每个工作目录都是项目的完整拷贝，包含全部的版本历史信息。使用Git时，用户可以在不需要联网的情况下查看文件的变化和进行提交操作，这使得Git非常适合分布式协作和版本控制。</p><p>git不需要联网</p><p>Git 作为一个分布式版本控制系统，其设计允许用户在本地进行大部分的操作，这意味着在很多情况下，确实不需要联网。用户可以在本地仓库中进行文件的版本控制操作，如提交（commit）、查看历史记录（log）、分支（branch）和合并（merge）等，这些操作都不需要网络连接。</p><p>然而，Git 的强大之处也在于它支持远程仓库的管理。当你需要与他人协作或者将你的代码推送（push）到远程仓库（如GitHub、GitLab等），或者从远程仓库拉取（pull）最新的代码时，就需要联网。此外，一些Git命令，如克隆（clone）一个远程仓库，或者与远程仓库进行交互的命令（如fetch、pull、push），也需要网络连接。</p><p><img src="/./../../images/image-20250513150908742.png" alt="image-20250513150908742"></p><p><img src="/./../../images/image-20250513150957026.png" alt="image-20250513150957026"></p><p><img src="/./../../images/image-20250513151131934.png" alt="image-20250513151131934"></p><h4 id="为什么使用git"><a href="#为什么使用git" class="headerlink" title="为什么使用git"></a>为什么使用git</h4><p>Git是一个高效且设计简单的分布式版本控制系统，它能够支持大规模项目如Linux内核的开发，允许上千个并行开发的分支。Git的一个显著特点是它直接快照文件系统的状态，而不是比较文件差异，这样可以更高效地管理版本。几乎所有的操作都可以在本地执行，不需要联网，这使得Git在本地磁盘上保存着所有有关当前项目的历史更新。Git还通过计算内容的校验和（checksum）来保持数据的完整性，确保数据的唯一标识和索引。此外，Git的多数操作仅涉及将数据添加到数据库，这进一步增强了其性能和可靠性。这些特性使得Git成为现代软件开发中不可或缺的工具。</p><p><img src="/./../../images/image-20250513151304914.png" alt="image-20250513151304914"></p><p>git的三种状态、3个工作区域</p><p>Git通过三种状态和三个工作区域来管理文件和项目版本。三种状态包括：已提交（committed），表示文件已经被安全地保存在本地数据库中；已修改（modified），表示文件自上次提交后已经发生了变化，但还没有保存到数据库；已暂存（staged），表示文件的当前修改已被标记，准备在下一次提交时保存到数据库。</p><p>三个工作区域分别是：本地数据目录，即项目的完整历史记录；工作目录，即项目文件的当前工作副本；暂存区域，即索引文件，用于暂存下次提交要保存的文件列表。</p><p>Git的工作流程通常包括以下步骤：首先从本地数据目录检出项目到工作目录，然后在工作目录中对文件进行修改，接着将修改后的文件暂存，最后将暂存的文件提交到本地数据目录，完成一次版本更新。这个过程确保了文件的变更被有序地管理和记录，便于后续的版本控制和协作开发。</p><p><img src="/./../../images/image-20250513151429998.png" alt="image-20250513151429998"></p><p>在Git中，分支是指项目的不同开发版本，它们共享一个共同的历史记录，但每个分支可以独立地发展自己的历史。分支的创建总是从某个已有的提交（通常是主分支）开始，然后从那个点分叉出去，形成新的发展路径。这种机制允许开发者在不影响主分支的情况下进行实验性开发或修复bug。图中展示了项目的原始开发线（Original line of development），以及从这条线上分出的三个分支（1st branch、2nd branch、3rd branch），每个分支都代表了项目的一个不同发展方向。通过这种方式，Git支持并行开发和灵活的项目管理。</p><p><img src="/./../../images/image-20250513152442097.png" alt="image-20250513152442097"><img src="/./../../images/image-20250513152502889.png" alt="image-20250513152502889"></p><p>Git中的分支机制允许开发者从项目的任何提交点创建新的分支，每个分支都代表项目的一个独立开发路径。分支的创建和销毁成本非常低，这使得它们非常适合用于实验性开发、特性开发或修复bug等任务。</p><p>在Git中，每个提交（commit）都可以建立分支，这意味着开发者可以从项目的任何历史点分叉出新的开发线。分支的创建是通过指向提交的可变指针来实现的，这些指针可以移动到不同的提交，从而形成不同的开发路径。每个分支都有自己的历史，但它们可以共享共同的提交历史。</p><p>图中展示了Git分支的工作原理：</p><ol><li>第一张图展示了一个项目的提交历史，其中包含了多个分支（如master、testing、1st branch、2nd branch、3rd branch）。每个分支都从某个提交点开始，然后发展自己的历史。</li><li>第二张图展示了从master分支创建新分支的过程。每个提交（如f30ab、34ac2、98ca9）都可以作为新分支的起点，新分支可以独立地进行开发，而不会影响其他分支。</li></ol><p><img src="/./../../images/image-20250513152626995.png" alt="image-20250513152626995"></p><p>使用例子</p><p>在Git中，分支的使用允许开发者在不影响主分支的情况下处理不同的开发任务。例如，在正常开发过程中，如果需要解决一个特定的问题（如问题#53），但又不能干扰主分支，可以创建一个新的分支专门用于这个问题的修复。在这个新分支上，开发者可以提交修复代码，而主分支则可以继续其正常的开发流程。</p><p>当紧急修复完成时，可以通过合并操作将这个分支的更改整合回主分支。这种策略不仅提高了开发效率，还确保了主分支的稳定性。通过这种方式，Git的分支机制支持并行开发和灵活的问题处理，使得项目管理更加高效和有序。</p><h4 id="GIT分支合并及冲突解决"><a href="#GIT分支合并及冲突解决" class="headerlink" title="GIT分支合并及冲突解决"></a>GIT分支合并及冲突解决</h4><h3 id="Git分支合并"><a href="#Git分支合并" class="headerlink" title="Git分支合并"></a>Git分支合并</h3><p>分支合并是Git中一个非常常见的操作，它允许开发者将一个分支的更改整合到另一个分支中。这通常发生在开发新功能或修复问题时，开发者会在一个单独的分支上进行工作，然后将这些更改合并回主分支（如<code>main</code>或<code>master</code>）。</p><h4 id="使用git-merge命令"><a href="#使用git-merge命令" class="headerlink" title="使用git merge命令"></a>使用<code>git merge</code>命令</h4><p>最直接的分支合并方式是使用<code>git merge</code>命令。假设你有两个分支：<code>main</code>和<code>feature</code>，你在<code>feature</code>分支上开发了一些新功能，现在想要将这些更改合并到<code>main</code>分支。首先，你需要切换到<code>main</code>分支，使用命令<code>git checkout main</code>。然后，执行<code>git merge feature</code>，Git会尝试将<code>feature</code>分支的更改合并到<code>main</code>分支。如果合并过程中没有冲突，Git会自动完成合并，并创建一个新的合并提交。这个合并提交会记录两个分支的合并历史，使得代码的变更过程更加清晰。</p><h4 id="使用git-rebase命令"><a href="#使用git-rebase命令" class="headerlink" title="使用git rebase命令"></a>使用<code>git rebase</code>命令</h4><p>除了<code>git merge</code>，<code>git rebase</code>也是一种常用的分支合并方式。<code>git rebase</code>的作用是将当前分支的更改重新应用到另一个分支的顶部。例如，如果你希望让<code>feature</code>分支的更改基于<code>main</code>分支的最新状态，可以执行<code>git rebase main</code>。这样，<code>feature</code>分支的提交会重新应用到<code>main</code>分支的最新提交之后。这种方式可以使<code>feature</code>分支的提交历史更加清晰，避免了复杂的合并提交。在完成<code>rebase</code>之后，你可以使用<code>git merge</code>将<code>feature</code>分支合并到<code>main</code>分支，或者直接将<code>feature</code>分支的更改推送到远程仓库（如果<code>feature</code>分支已经推送到远程仓库）。</p><hr><h3 id="Git冲突解决"><a href="#Git冲突解决" class="headerlink" title="Git冲突解决"></a>Git冲突解决</h3><p>尽管Git在合并分支时会尽量自动处理更改，但当多个分支对同一部分代码进行了不同的更改时，合并过程中可能会出现冲突。冲突需要手动解决，以下是解决冲突的详细步骤：</p><h4 id="查看冲突"><a href="#查看冲突" class="headerlink" title="查看冲突"></a>查看冲突</h4><p>当合并分支时，如果出现冲突，Git会在冲突的文件中标记冲突的内容。冲突的文件中会包含如下标记：<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>表示当前分支的更改，<code>=======</code>是分隔符，表示冲突的分界点，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>表示另一个分支的更改。例如，冲突的代码可能看起来像这样：</p><p>plaintext</p><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">当前分支的代码</span><br><span class="line">=======</span><br><span class="line">另一个分支的代码</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature</span><br></pre></td></tr></table></figure><p>你可以使用<code>git status</code>命令查看哪些文件存在冲突。Git会明确指出哪些文件需要解决冲突。</p><h4 id="手动解决冲突"><a href="#手动解决冲突" class="headerlink" title="手动解决冲突"></a>手动解决冲突</h4><p>解决冲突通常需要手动编辑冲突的文件。打开冲突的文件，根据实际情况选择保留、修改或删除冲突的内容。例如，如果决定保留当前分支的更改，则删除<code>=======</code>和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>之间的内容，以及<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>和<code>=======</code>之间的标记。如果决定采用另一个分支的更改，则删除<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>和<code>=======</code>之间的内容，以及<code>=======</code>和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>之间的标记。当然，也可以根据需要对代码进行修改，以整合两个分支的更改。</p><h4 id="标记冲突解决"><a href="#标记冲突解决" class="headerlink" title="标记冲突解决"></a>标记冲突解决</h4><p>在解决冲突后，需要使用<code>git add &lt;file&gt;</code>命令将冲突的文件标记为已解决。这一步非常重要，因为Git需要知道冲突已经被处理。之后，执行<code>git commit</code>命令完成合并提交。如果你使用的是<code>git rebase</code>，在解决冲突后，还需要执行<code>git rebase --continue</code>继续<code>rebase</code>过程。</p><h4 id="使用工具辅助解决冲突"><a href="#使用工具辅助解决冲突" class="headerlink" title="使用工具辅助解决冲突"></a>使用工具辅助解决冲突</h4><p>Git支持使用图形化工具来解决冲突，这可以大大简化冲突解决的过程。例如，你可以使用<code>git mergetool</code>命令，Git会自动启动配置的合并工具（如<code>meld</code>、<code>kdiff3</code>等）。在工具中，你可以直观地比较和选择保留或修改冲突的内容。工具会自动将解决后的文件标记为已解决，从而避免了手动编辑文件和标记解决的繁琐过程。</p><hr><p>通过以上方法，你可以有效地进行Git分支合并和冲突解决，从而更好地管理代码版本。分支合并和冲突解决是团队协作开发中不可或缺的部分，掌握这些技能可以帮助你更高效地进行代码管理和协作</p><p><img src="/./../../images/image-20250513210431768.png" alt="image-20250513210431768"></p><p>Repo工具确实是专门为Android操作系统设计的，用于管理多个Git仓库。以下是Repo工具的一些关键信息和用途：</p><ol><li><strong>多仓库管理</strong>：Repo是一个基于Python的脚本工具，它封装了多条Git命令，帮助开发者管理Android源码中的多个Git仓库。这对于大型项目和团队协作尤为重要。</li><li><strong>初始化和同步</strong>：使用<code>repo init</code>命令初始化项目，该命令会读取一个叫做<code>manifest</code>的XML配置文件，定义了项目中需要的Git仓库和版本。<code>repo sync</code>命令用于同步代码，克隆或更新项目中所有Git仓库。</li><li><strong>分支操作</strong>：<code>repo start &lt;branch_name&gt; --all</code>命令用于在所有仓库中创建新的本地分支，便于跨模块开发。</li><li><strong>代码审查</strong>：<code>repo upload</code>命令将本地提交推送到代码审核平台（如Gerrit），自动关联多个子仓库的变更，确保依赖关系正确。</li><li><strong>清单文件（Manifest）</strong>：Repo使用清单文件定义所有子仓库的版本、分支和依赖关系，简化了开发者的代码同步、提交和代码审核流程。</li><li><strong>与Gerrit集成</strong>：Repo与Gerrit代码审核系统集成，简化了代码审核和合并流程。</li><li><strong>解决冲突</strong>：Repo工具提供了解决冲突的场景，如本地代码过期、跨仓库依赖冲突等。</li><li><strong>下载和安装</strong>：Repo工具可以从官方的Git仓库下载，并且可以通过简单的命令添加到系统的PATH变量中，以便在终端中使用。</li></ol><p>git常用命令</p><p><img src="/./../../images/image-20250513210758616.png" alt="image-20250513210758616"></p><p>克隆远程现有仓库：<br>repository_ur是远程仓库地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repository_url&gt; </span><br></pre></td></tr></table></figure><p><img src="/./../../images/5a1381440c5449d486613ab1d72dd8b0.png" alt="在这里插入图片描述"></p><p>Jenkins、Opengrok、JIRA的使用</p><h3 id="1-JIRA"><a href="#1-JIRA" class="headerlink" title="1. JIRA"></a>1. <strong>JIRA</strong></h3><ul><li><strong>功能</strong>：项目管理和问题跟踪工具。</li><li><strong>嵌入式开发中的作用</strong>：<ul><li>管理需求、任务和缺陷。</li><li>跟踪硬件和软件开发进度。</li><li>支持敏捷开发流程。</li></ul></li></ul><h3 id="2-Jenkins"><a href="#2-Jenkins" class="headerlink" title="2. Jenkins"></a>2. <strong>Jenkins</strong></h3><ul><li><strong>功能</strong>：持续集成（CI）和持续部署（CD）工具。</li><li><strong>嵌入式开发中的作用</strong>：<ul><li>自动化构建和测试嵌入式软件。</li><li>确保代码更新后符合质量标准。</li><li>提高开发效率和交付速度。</li></ul></li></ul><h3 id="3-OpenGrok"><a href="#3-OpenGrok" class="headerlink" title="3. OpenGrok"></a>3. <strong>OpenGrok</strong></h3><ul><li><strong>功能</strong>：代码搜索和交叉引用工具。</li><li><strong>嵌入式开发中的作用</strong>：<ul><li>快速查找和理解复杂代码。</li><li>提供代码版本历史信息。</li><li>帮助开发人员定位问题。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>JIRA</strong> 用于项目管理和问题跟踪。</li><li><strong>Jenkins</strong> 用于自动化构建和测试。</li><li><strong>OpenGrok</strong> 用于代码搜索和理解。 这三种工具在嵌入式开发中可以相互配合，提升开发效率和产品质量。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 车载基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 车载基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
