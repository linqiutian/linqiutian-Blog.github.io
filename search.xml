<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux驱动基础知识</title>
      <link href="/2024/08/07/Linux%E9%A9%B1%E5%8A%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/08/07/Linux%E9%A9%B1%E5%8A%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-指令"><a href="#1-指令" class="headerlink" title="1.指令"></a>1.指令</h1><h2 id="1-1-常用的Linux指令"><a href="#1-1-常用的Linux指令" class="headerlink" title="1.1 常用的Linux指令"></a>1.1 常用的Linux指令</h2><h3 id="1-怎么查看当前进程？怎么执行退出？怎么查看当前路径？"><a href="#1-怎么查看当前进程？怎么执行退出？怎么查看当前路径？" class="headerlink" title="1.怎么查看当前进程？怎么执行退出？怎么查看当前路径？"></a>1.怎么查看当前进程？怎么执行退出？怎么查看当前路径？</h3><p>查看当前进程： <code>ps</code><br>执行退出： <code>exit</code><br>查看当前路径： <code>pwd</code></p><h3 id="2-ls-命令执行什么功能？-可以带哪些参数？"><a href="#2-ls-命令执行什么功能？-可以带哪些参数？" class="headerlink" title="2.ls 命令执行什么功能？ 可以带哪些参数？"></a>2.<strong>ls 命令执行什么功能？ 可以带哪些参数？</strong></h3><p><strong>功能</strong></p><p>列出指定目录中的目录，以及文件</p><p><strong>参数</strong></p><p><code>-a</code> 显示所有文件及目录 (. 开头的隐藏文件也会列出)</p><p><code>-l</code> 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</p><p><code>-r</code> 将文件以相反次序显示(原定依英文字母次序)</p><p><code>-t</code> 将文件依建立时间之先后次序列出</p><ol><li><code>-A</code> 同 -a ，但不列出 “.” (目前目录) 及 “…” (父目录)</li><li><code>-F</code> 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “&#x2F;”</li><li><code>-R</code> 若目录下有文件，则以下之文件亦皆依序列出</li></ol><p><code>../abc/abc.txt (..表示上一层)</code></p><h3 id="3-创建目录用什么命令？"><a href="#3-创建目录用什么命令？" class="headerlink" title="3.创建目录用什么命令？"></a>3.<strong>创建目录用什么命令？</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir runoob        #在工作目录下，建立一个名为 runoob 的子目录 </span><br><span class="line">mkdir -p runoob2/test   #在工作目录下的 runoob2 目录中，建立一个名为 test 的子目录。</span><br><span class="line">若 runoob2 目录原本不存在，则建立一个。（注：本例若不加 -p 参数，且原本 runoob2 目录不存在，则产生错误。）</span><br></pre></td></tr></table></figure><h3 id="4-创建文件用什么命令？"><a href="#4-创建文件用什么命令？" class="headerlink" title="4.创建文件用什么命令？"></a>4.<strong>创建文件用什么命令？</strong></h3><p><strong>vi或vim</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi file1.txt #直接创建并打开一个文件file1.txt</span><br></pre></td></tr></table></figure><p><strong>touch</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch file2.txt #创建新的空文件file2.txt</span><br></pre></td></tr></table></figure><p><strong>echo</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;this is a new file&quot; &gt; file3.txt   #创建文件file3.txt并将this is a new file写入（说明：使用&gt;指令覆盖文件原内容并重新输入内容，若文件不存在则创建文件。）</span><br><span class="line">echo &quot;add contents&quot; &gt;&gt;file3.txt    #在已存在的文件补充写入新内容add contents（说明：使用&gt;&gt;指令向文件追加内容，原内容将保存。）</span><br></pre></td></tr></table></figure><p><strong>less 、more 、cat</strong></p><p>三者都是将文件内容输出到标准输出，其中less和more可以分页显示，cat是显示全部。<br>三者可以根据已经存在的文件创建新的文件。假设已经存在文件1.txt。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat 1.txt &gt; 2.txt</span><br><span class="line">less 1.txt &gt; 3.txt</span><br><span class="line">more 1.txt &gt; 4.txt</span><br></pre></td></tr></table></figure><p>此时创建的文件内容都和1.txt中文件内容相同。</p><p>cd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &gt; file3.txt  #创建新的空文件file3.txt</span><br><span class="line">cd &gt;&gt; file4.txt  #创建新的空文件file4.txt</span><br></pre></td></tr></table></figure><p>cd最主要的作用是切换目录，在cd后面跟&gt;或&gt;&gt;再加上文件名就可以创建一个内容为空的文件。它和echo的区别之处在于<strong>echo可写文件内容，而cd并不能</strong>。</p><h3 id="5-复制文件用什么命令？"><a href="#5-复制文件用什么命令？" class="headerlink" title="5.复制文件用什么命令？"></a>5.<strong>复制文件用什么命令</strong>？</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp –r test/ newtest #将当前目录 test/ 下的所有文件复制到新目录 newtest 下(前-&gt;后)</span><br></pre></td></tr></table></figure><h3 id="6-查看文件内容有哪些命令可以使用？"><a href="#6-查看文件内容有哪些命令可以使用？" class="headerlink" title="6.查看文件内容有哪些命令可以使用？"></a>6.<strong>查看文件内容有哪些命令可以使用</strong>？</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi 文件名  #编辑方式查看，可修改</span><br><span class="line">cat 文件名 #显示全部文件内容</span><br><span class="line">more 文件名 #分页显示文件内容</span><br><span class="line">less 文件名 #与 more 相似，更好的是可以往前翻页</span><br><span class="line">tail 文件名 #仅查看尾部，还可以指定行数</span><br><span class="line">head 文件名 #仅查看头部,还可以指定行数</span><br></pre></td></tr></table></figure><h3 id="7-怎么向屏幕输出带空格的字符串，比如”hello-world”"><a href="#7-怎么向屏幕输出带空格的字符串，比如”hello-world”" class="headerlink" title="7.怎么向屏幕输出带空格的字符串，比如”hello world”?"></a>7.怎么向屏幕输出带空格的字符串，比如”hello world”?</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello world</span><br></pre></td></tr></table></figure><h3 id="8-移动文件用哪个命令？改名用哪个命令？"><a href="#8-移动文件用哪个命令？改名用哪个命令？" class="headerlink" title="8.移动文件用哪个命令？改名用哪个命令？"></a>8.移动文件用哪个命令？改名用哪个命令？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv source_file(文件) dest_file(文件) #将源文件名 source_file 改为目标文件名 dest_file</span><br><span class="line">mv source_file(文件) dest_directory(目录) #将文件 source_file 移动到目标目录 dest_directory 中</span><br></pre></td></tr></table></figure><h3 id="9-删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？"><a href="#9-删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？" class="headerlink" title="9.删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？"></a>9.删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm -rf file/directory    #删除当前目录下的所有文件及目录，并且是直接删除，无需逐一确认</span><br><span class="line">rm -rf  directory/       #删除目录 directory，不管该目录下是否有子目录或文件</span><br></pre></td></tr></table></figure><h3 id="10-查找文件内容用哪个命令？"><a href="#10-查找文件内容用哪个命令？" class="headerlink" title="10.查找文件内容用哪个命令？"></a>10.查找文件内容用哪个命令？</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grep test *file  #在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行</span><br><span class="line">grep -r update /etc/acpi #查找指定目录/etc/acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串&quot;update&quot;的文件(递归)</span><br><span class="line">grep -v test *test*      #查找文件名中包含 test 的文件中不包含test 的行(排除)</span><br></pre></td></tr></table></figure><h3 id="11-查找文件用哪个命令？"><a href="#11-查找文件用哪个命令？" class="headerlink" title="11.查找文件用哪个命令？"></a>11.查找文件用哪个命令？</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.c&quot;  #将当前目录及其子目录下所有文件后缀为 .c 的文件列出来</span><br><span class="line">find . -ctime -20   #将当前目录及其子目录下所有最近 20 天内更新过的文件列出</span><br></pre></td></tr></table></figure><h3 id="12-cat命令"><a href="#12-cat命令" class="headerlink" title="12.cat命令"></a>12.cat命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat -n textfile1  #把 textfile1 的文档内容加上行号后输入到屏幕</span><br><span class="line">cat -n textfile1 &gt; textfile2  #把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里</span><br><span class="line">cat -b textfile1 textfile2 &gt;&gt; textfile3  #把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里</span><br><span class="line">cat /dev/null &gt; /etc/test.txt #清空 /etc/test.txt 文档内容</span><br></pre></td></tr></table></figure><h2 id="1-2-常用的GCC指令"><a href="#1-2-常用的GCC指令" class="headerlink" title="1.2 常用的GCC指令"></a>1.2 常用的GCC指令</h2><h3 id="1-预处理-E-i"><a href="#1-预处理-E-i" class="headerlink" title="1.预处理 (-E .i)"></a>1.预处理 (-E .i)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E test.c -o test.i #把预处理的结果导出到test.i文件</span><br></pre></td></tr></table></figure><h3 id="2-编译为汇编代码-S-s"><a href="#2-编译为汇编代码-S-s" class="headerlink" title="2.编译为汇编代码(-S .s)"></a>2.编译为汇编代码(-S .s)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S test.i -o test.s #编译器将test.i翻译成汇编语言，并将结果存储在test.s文件中。</span><br></pre></td></tr></table></figure><h3 id="3-汇编-c-o"><a href="#3-汇编-c-o" class="headerlink" title="3.汇编(-c .o)"></a>3.汇编(-c .o)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c test.s -o test.o #将汇编代码编译为目标文件（.o）但不链接</span><br></pre></td></tr></table></figure><h3 id="4-链接-无后缀"><a href="#4-链接-无后缀" class="headerlink" title="4.链接(无后缀)"></a>4.链接(无后缀)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.o -o test #将生成的目标文件test.o生成最终的可执行文件test</span><br></pre></td></tr></table></figure><h3 id="5-一步到位编译-c-无后缀"><a href="#5-一步到位编译-c-无后缀" class="headerlink" title="5.一步到位编译(.c 无后缀)"></a>5.一步到位编译(.c 无后缀)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o test #将源文件test.c编译链接为可执行文件test</span><br></pre></td></tr></table></figure><h3 id="6-多文件编译"><a href="#6-多文件编译" class="headerlink" title="6.多文件编译"></a>6.多文件编译</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test1.c test2.c -o test</span><br></pre></td></tr></table></figure><h3 id="7-警告处理"><a href="#7-警告处理" class="headerlink" title="7.警告处理"></a>7.警告处理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -w test.c -o test  # 忽略编译时的警告</span><br><span class="line">gcc -Wall test.c -o test #编译后显示所有警告</span><br><span class="line">gcc -Werror test.c -o test #在产生警告的地方停止编译</span><br></pre></td></tr></table></figure><h2 id="1-3常用的GDB调试指令"><a href="#1-3常用的GDB调试指令" class="headerlink" title="1.3常用的GDB调试指令"></a>1.3常用的GDB调试指令</h2><h3 id="1-什么是GDB？"><a href="#1-什么是GDB？" class="headerlink" title="1.什么是GDB？"></a>1.什么是GDB？</h3><ul><li><p>GDB（GNU symbolic debugger）是 GNU Project 调试器</p></li><li><p>GNU操作系统是一种由自由软件构成的类 Unix 操作系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">gcc -g test.c -o test  #编译时生成debug有关的程序信息</span><br><span class="line">gdb test        #启动调试</span><br><span class="line">help #查看命令帮助，具体命令查询在gdb中输入help + 命令,简写h</span><br><span class="line">run #重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）,简写r</span><br><span class="line">start #单步执行，运行程序，停在第一执行语句</span><br><span class="line">list #查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）,简写l</span><br><span class="line">set #设置变量的值</span><br><span class="line">next #单步调试（逐过程，函数直接执行）,简写n</span><br><span class="line">step #单步调试（逐语句：跳入自定义函数内部执行）,简写s</span><br><span class="line">backtrace #查看函数的调用的栈帧和层级关系,简写bt</span><br><span class="line">frame #切换函数的栈帧,简写f</span><br><span class="line">info #查看函数内部局部变量的数值,简写i</span><br><span class="line">finish #结束当前函数，返回到函数调用点</span><br><span class="line">continue #继续运行,简写c</span><br><span class="line">print #打印值及地址,简写p</span><br><span class="line">quit #退出gdb,简写q</span><br><span class="line">break+num #在第num行设置断点,简写b</span><br><span class="line">info breakpoints #查看当前设置的所有断点</span><br><span class="line">delete breakpoints num #删除第num个断点,简写d</span><br><span class="line">display #追踪查看具体变量值</span><br><span class="line">undisplay #取消追踪观察变量</span><br><span class="line">watch #被设置观察点的变量发生修改时，打印显示</span><br><span class="line">i watch #显示观察点</span><br><span class="line">enable breakpoints #启用断点</span><br><span class="line">disable breakpoints #禁用断点</span><br><span class="line">x #查看内存x/20xw 显示20个单元，16进制，4字节每单元</span><br><span class="line">run argv[1] argv[2] #调试时命令行传参</span><br><span class="line">set follow-fork-mode child #Makefile项目管理：选择跟踪父子进程(fork())</span><br></pre></td></tr></table></figure></li></ul><h2 id="1-4常用的驱动开发指令"><a href="#1-4常用的驱动开发指令" class="headerlink" title="1.4常用的驱动开发指令"></a>1.4常用的驱动开发指令</h2><h3 id="1-加载-卸载驱动"><a href="#1-加载-卸载驱动" class="headerlink" title="1.加载&#x2F;卸载驱动"></a>1.加载&#x2F;卸载驱动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insmod/modprobe #加载驱动</span><br><span class="line">rmmod   #卸载驱动Linux驱动如何查看驱动模块中打印信息？</span><br></pre></td></tr></table></figure><h3 id="2-Linux驱动如何查看驱动模块中打印信息？"><a href="#2-Linux驱动如何查看驱动模块中打印信息？" class="headerlink" title="2.Linux驱动如何查看驱动模块中打印信息？"></a>2.Linux驱动如何查看驱动模块中打印信息？</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg</span><br></pre></td></tr></table></figure><h3 id="3-如何查看内核中已有的字符设备的信息？"><a href="#3-如何查看内核中已有的字符设备的信息？" class="headerlink" title="3.如何查看内核中已有的字符设备的信息？"></a>3.如何查看内核中已有的字符设备的信息？</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod 和modprobe：lsmod可以查看模块的依赖关系，modprobe在加载模块时会加载其他依赖的模块。</span><br></pre></td></tr></table></figure><h3 id="4-如何查看正在使用的有哪些中断号？"><a href="#4-如何查看正在使用的有哪些中断号？" class="headerlink" title="4.如何查看正在使用的有哪些中断号？"></a>4.如何查看正在使用的有哪些中断号？</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/interrupt</span><br></pre></td></tr></table></figure><h1 id="2-Uboot"><a href="#2-Uboot" class="headerlink" title="2.Uboot"></a>2.Uboot</h1><h3 id="2-1-什么是bootloader？"><a href="#2-1-什么是bootloader？" class="headerlink" title="2.1 什么是bootloader？"></a>2.1 什么是bootloader？</h3><ul><li>Linux系统要启动就必须需要一个 bootloader程序，也就说芯片上电以后先运行一段bootloader程序。这段 bootloader程序会先<strong>初始化时钟，看门狗，中断，SDRAM，等外设，然后将 Linux内核从 flash（NAND, NOR FLASH,SD,MMC等）拷贝到SDRAM中，最后启动Linux内核</strong>。当然了， bootloader的实际工作要复杂的多，但是它最主要的工作就是启动 Linux内核。</li><li>bootloader和 Linux内核的关系就跟PC上的BIOS和 Windows的关系一样，<strong>bootloader就相当于BIOS。总得来说，Bootloader就是一小段程序，它在系统上电时开始执行，初始化硬件设各、准备好软件环境，最后调用操作系统内核</strong>。</li></ul><h3 id="2-2-uboot启动过程中做了那些事？"><a href="#2-2-uboot启动过程中做了那些事？" class="headerlink" title="2.2 uboot启动过程中做了那些事？"></a>2.2 uboot启动过程中做了那些事？</h3><h4 id="1-第一阶段"><a href="#1-第一阶段" class="headerlink" title="1.第一阶段"></a>1.<strong>第一阶段</strong></h4><p>初始化时钟，关闭看门狗，关中断，启动ICACHE，关闭DCACHE和TLB，关闭MMU，初始化SDRAM，初始化NAND FLASH，重定位。</p><blockquote><p>Linux的看门狗（Watchdog）是一种硬件或软件机制，用于监视系统的运行状态，以防止系统出现故障或死机的情况。它能够检测到系统的异常情况并自动采取一些预设的措施，例如重启系统或发送警报信息。</p></blockquote><h4 id="2-第二阶段"><a href="#2-第二阶段" class="headerlink" title="2.第二阶段"></a>2.<strong>第二阶段</strong></h4><p>初始化一个串口，检测系统内存映射，将<strong>内核映象和根文件系统映象从Flash上读到SDRAM空间</strong>中，为内核设置启动参数，调用内核。</p><h3 id="2-3-uboot和内核如何完成参数传递？"><a href="#2-3-uboot和内核如何完成参数传递？" class="headerlink" title="2.3 uboot和内核如何完成参数传递？"></a>2.3 uboot和内核如何完成参数传递？</h3><ul><li>uboot启动后已经完成了基本的硬件初始化（如：内存、串口等），接下来，它的主要任务就是加载Linux内核到开发板的内存，然后跳转到Linux内核所在的地址运行。<br><em><strong>PS:只要问到uboot，面试官必问uboot和内核的参数传递，所以一定要知道！</strong></em><br>具体是如何跳转呢？做法很简单，直接修改PC寄存器的值为Linux内核所在的地址，这样CPU就会从Linux内核所在的地址去取指令，从而执行内核代码。</li></ul><h3 id="在前面我们已经知道，在跳转到内核以前，uboot需要做好以下三件事情："><a href="#在前面我们已经知道，在跳转到内核以前，uboot需要做好以下三件事情：" class="headerlink" title="在前面我们已经知道，在跳转到内核以前，uboot需要做好以下三件事情："></a>在前面我们已经知道，在跳转到内核以前，uboot需要做好以下三件事情：</h3><h4 id="1-CPU寄存器的设置"><a href="#1-CPU寄存器的设置" class="headerlink" title="1.CPU寄存器的设置"></a>1.<strong>CPU寄存器的设置</strong></h4><p>R0&#x3D;0<br>R1&#x3D;机器类型ID；对于ARM结构的CPU，其机器类型ID可以参见 linux&#x2F;arch&#x2F;arm tools&#x2F; mach-types<br>R2&#x3D;启动参数标记列表在RAM中起始基地址</p><h4 id="2-CPU工作模式"><a href="#2-CPU工作模式" class="headerlink" title="2.CPU工作模式"></a>2.CPU工作模式</h4><p>必须禁止中断（IRQs和FIQs）</p><p>CPU必须是SVC模式</p><h4 id="3-Cache和MMU的设置"><a href="#3-Cache和MMU的设置" class="headerlink" title="3.Cache和MMU的设置"></a>3.Cache和MMU的设置</h4><p>MMU必须关闭</p><p>指令Cache可以打开也可以关闭</p><p>数据Cache必须关闭</p><p>其中上面第一步CPU寄存器的设置中，就是通过R0，R1，R2三个参数给内核传递参数的。</p><h3 id="2-4-为什么要给内核传递参数呢？"><a href="#2-4-为什么要给内核传递参数呢？" class="headerlink" title="2.4 为什么要给内核传递参数呢？"></a>2.4 为什么要给内核传递参数呢？</h3><ul><li>在此之前，uboot已经完成了硬件的初始化，可以说已经”适应了“这块开发板。然而，内核并不是对于所有的开发板都能完美适配的（如果适配了，可想而知这个内核有多庞大，又或者有新技术发明了，可以完美的适配各种开发板），此时，对于开发板的环境一无所知。所以，要想启动Linux内核，uboot必须要给内核传递一些必要的信息来告诉内核<strong>当前所处的环境</strong>。</li></ul><h3 id="2-5-如何给内核传递参数？"><a href="#2-5-如何给内核传递参数？" class="headerlink" title="2.5 如何给内核传递参数？"></a>2.5 如何给内核传递参数？</h3><ul><li>uboot把<strong>机器ID通过R1传递给内核</strong>，Linux内核运行的时候，首先就从R1中读取机器ID来判断是否支持当前机器。这个机器ID实际上就是开发板<strong>CPU的ID</strong>，每个厂家生产出一款CPU的时候都会给它指定一个唯一的ID，大家可以到uboot源码的<code>arch\arm\include\asm\mach-type.h</code>文件中去查看。</li><li><img src="/./../images/v2-05f40fd62252ed704e07aa09b450735d_720w.webp" alt="img"></li><li><strong>R2存放的是块内存的基地址</strong>，这块内存中存放的是uboot给Linux内核的其他参数。这些参数有内存的<strong>起始地址、内存大小、Linux内核启动后挂载文件系统的方式</strong>等信息。很明显，参数有多个，不同的参数有不同的内容，为了让Linux内核能精确的解析出这些参数，双方在传递参数的时候要求参数在存放的时候需要按照<strong>双方规定的格式存放</strong>。</li><li>除了约定好参数存放的地址外，还要<strong>规定参数的结构</strong>。Linux2.4.x以后的内核都期望以<strong>标记列表</strong>（tagged_list）的形式来传递启动参数。标记，就是一种数据结构；标记列表，就是挨着存放的多个标记。标记列表以标记<code>ATAG_CORE</code>开始，以标记<code>ATAG_NONE</code>结束。</li><li>标记的数据结构为tag，它<strong>由一个tag_header结构和一个联合（union）组成</strong>。tag_header结构表示标记的类型及长度，比如是表示内存还是表示命令行参数等。对于不同类型的标记使用不同的联合（union），比如表示内存时使用tag_ mem32，表示命令行时使用 tag_cmdline。具体代码见<code>arch\arm\include\asm\setup.h</code>。</li><li><img src="/./../images/v2-29c0c35bd33589c2e82f11e54b9e5243_720w.webp" alt="img"></li><li>从上面可以看出，struct_tag结构体由structtag_header+联合体union构成，结构体struct tag_header用来描述每个tag的头部信息，如tag的类型，tag大小。联合体union用来描述每个传递给Linux内核的参数信息。</li></ul><h3 id="2-6-为什么uboot要关掉caches？"><a href="#2-6-为什么uboot要关掉caches？" class="headerlink" title="2.6 为什么uboot要关掉caches？"></a>2.6 为什么uboot要关掉caches？</h3><ul><li>caches是cpu内部的一个2级缓存，它的作用是将常用的数据和指令放在cpu内部。caches是通过 ARM处理器使用协处理器15（CP15）管理的，刚上电的时候，cpu还不能管理caches。上电的时候指令cache可关闭，也可不关闭，但<strong>数据cache一定要关闭</strong>，否则可能导致刚开始的代码里面，去取数据的时候，从cache里面取，而这时候<strong>RAM中数据还没有caches过来，导致数据预取异常</strong>。</li></ul><h1 id="3-文件系统"><a href="#3-文件系统" class="headerlink" title="3.文件系统"></a>3.文件系统</h1><h3 id="3-1-什么是根文件系统？"><a href="#3-1-什么是根文件系统？" class="headerlink" title="3.1 什么是根文件系统？"></a>3.1 什么是根文件系统？</h3><ul><li>根文件系统首先是一种文件系统，该文件系统不仅具有普通文件系统的存储数据文件的功能，但是相对于普通的文件系统，它的特殊之处在于，它是<strong>内核启动时所挂载（mount）的第一个文件系统</strong>，内核代码的映像文件保存在根文件系统中，系统引导启动程序会在根文件系统挂载之后从中把一些<strong>初始化脚本（如rcS、inittab）和服务</strong>加载到内存中去运行，里面包含了Linux系统能够运行<strong>所必需的应用程序、库</strong>等，比如可以给用户提供操作 Linux的控制界面的shell程序、动态连接的程序运行时需要的glibc库等。</li><li>文件系统和内核是完全独立的两个部分。在嵌入式中移植的内核下载到开发板上，是没有办法真正的启动Linux操作系统的，会出现无法加载文件系统的错误。</li></ul><h3 id="3-2-根文件系统为什么这么重要？"><a href="#3-2-根文件系统为什么这么重要？" class="headerlink" title="3.2 根文件系统为什么这么重要？"></a>3.2 根文件系统为什么这么重要？</h3><ul><li>根文件系统之所以在前面加一个“根”，说明它是加载其它文件系统的“根”，那么<strong>如果没有这个根，其它的文件系统也就没有办法进行加载的</strong>。根文件系统包含系统启动时<strong>所必须的目录和关键性的文件</strong>，以及使其他文件系统得以挂载（mount）所必要的文件。例如：<ul><li>init进程的应用程序必须运行在根文件系统上。</li><li>根文件系统提供了根目录“&#x2F;”。</li><li>linux挂载分区时所依赖的信息存放于根文件系统<code>/etc/fstab</code>这个文件中。</li><li>shell命令程序必须运行在根文件系统上，譬如<code>ls</code>、<code>cd</code>等命令。</li></ul></li><li>总结：一套linux体系，只有内核本身是不能工作的，必须要rootfs（上的etc目录下的配置文件、<code>/bin/sbin</code>等目录下的shell命令，还有&#x2F;lib目录下的库文件等）相配合才能工作。</li></ul><h3 id="3-3-可执行映像文件通常由几部分构成，它们有什么特点？"><a href="#3-3-可执行映像文件通常由几部分构成，它们有什么特点？" class="headerlink" title="3.3 可执行映像文件通常由几部分构成，它们有什么特点？"></a>3.3 可执行映像文件通常由几部分构成，它们有什么特点？</h3><p>可执行映像文件通常由以下几部分构成：</p><ul><li>一个或多个代码段，代码段的属性为只读。</li><li>零个或多个包含初始化数据的数据段，数据段的属性为可读写。</li><li>零个或多个不包含初始化数据的数据段，数据段的属性为可读写。</li></ul><h1 id="4-中断"><a href="#4-中断" class="headerlink" title="4.中断"></a>4.中断</h1><h3 id="4-1-硬中断-软中断是什么？有什么区别？"><a href="#4-1-硬中断-软中断是什么？有什么区别？" class="headerlink" title="4.1 硬中断 &#x2F; 软中断是什么？有什么区别？"></a>4.1 硬中断 &#x2F; 软中断是什么？有什么区别？</h3><h3 id="1-硬中断"><a href="#1-硬中断" class="headerlink" title="1.硬中断"></a>1.<strong>硬中断</strong></h3><ol><li>硬中断是由<strong>硬件</strong>产生的，比如，像磁盘，网卡，键盘，时钟等。<strong>每个设备或设备集都有它自己的IRQ</strong>（中断请求）。基于IRQ，CPU可以将相应的请求分发到对应的硬件驱动上（注：硬件驱动通常是内核中的一个子程序，而不是一个独立的进程）。</li><li>处理中断的驱动是需要运行在CPU上的，因此，当中断产生的时候，CPU会中断当前正在运行的任务，来处理中断。在有多核心的系统上，<strong>一个中断通常只能中断一颗CPU</strong>（也有一种特殊的情况，就是在大型主机上是有硬件通道的，它可以在没有主CPU的支持下，可以同时处理多个中断。）。</li><li><strong>硬中断可以直接中断CPU</strong>。它会引起内核中相关的代码被触发。对于那些需要花费一些时间去处理的进程，中断代码本身也可以被其他的硬中断中断。</li><li>对于时钟中断，内核调度代码会将当前正在运行的进程挂起，从而让其他的进程来运行。它的存在是为了让<strong>调度代码（或称为调度器）可以调度多任务</strong>。</li></ol><h3 id="2-软中断"><a href="#2-软中断" class="headerlink" title="2.软中断"></a>2.<strong>软中断</strong></h3><ol><li>软中断的处理非常像硬中断。然而，它们仅仅是由<strong>当前正在运行的进程</strong>所产生的。</li><li><strong>通常，软中断是一些对I&#x2F;O的请求</strong>。这些请求会调用内核中可以调度I&#x2F;O发生的程序。<strong>对于某些设备，I&#x2F;O请求需要被立即处理，而磁盘I&#x2F;O请求通常可以排队并且可以稍后处理</strong>。根据I&#x2F;O模型的不同，进程或许会被挂起直到I&#x2F;O完成，此时内核调度器就会选择另一个进程去运行。I&#x2F;O可以在进程之间产生。并且调度过程通常和磁盘I&#x2F;O的方式是相同。</li><li><strong>软中断仅与内核相联系</strong>。而内核主要负责对需要运行的任何其他的进程进行调度。一些内核允许设备驱动的一些部分存在于用户空间，并且当需要的时候内核也会调度这个进程去运行。<ol><li>软中断并不会直接中断CPU。也<strong>只有当前正在运行的代码（或进程）才会产生软中断</strong>。这种中断是一种<strong>需要内核为正在运行的进程去做一些事情</strong>（通常为I&#x2F;.O）的请求。有一个特殊的软中断是Yield调用，它的作用是请求内核调度器去查看是否有一些其他的进程可以运行。</li></ol></li></ol><blockquote><p>说人话就是只会影响内核去间接调度CPU，而不会直接中断CPU去处理中断服务程序</p></blockquote><h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3.区别"></a>3.区别</h3><ol><li>软中断是执行<strong>中断指令</strong>产生的，而硬中断是由<strong>外设</strong>引发的。</li><li>硬中断的中断号是由<strong>中断控制器</strong>提供的，软中断的中断号由指令直接指出，无需使用中断控制器。</li><li>硬中断是<strong>可屏蔽</strong>的，软中断不可屏蔽。</li><li>硬中断处理程序要确保它能<strong>快速</strong>地完成任务，这样程序执行时才不会等待较长时间，称为<strong>上半部</strong>。</li><li>软中断处理<strong>硬中断未完成的工作</strong>，是一种推后执行的机制，属于<strong>下半部</strong>。</li></ol><h3 id="4-2-中断为什么要区分上半部和下半部？"><a href="#4-2-中断为什么要区分上半部和下半部？" class="headerlink" title="4.2 中断为什么要区分上半部和下半部？"></a>4.2 中断为什么要区分上半部和下半部？</h3><ul><li>Linux中断分为硬件中断和内部中断（异常），调用过程：<strong>外部中断产生-&gt;发送中断信号到中断控制器-&gt;通知处理器产生中断的中断信号</strong>，让其进一步处理。</li><li>对于中断上半部和下半部的产生，为了中断处理过程中被新的中断打断，将中断处理一分为二，<strong>上半部登记新的中断，快速处理简单的任务，剩余复杂耗时的处理留给下半部处理，下半部处理过程中可以被中断，上半部处理时不可被中</strong>断。</li></ul><h3 id="4-3-中断下半部一般如何实现？"><a href="#4-3-中断下半部一般如何实现？" class="headerlink" title="4.3 中断下半部一般如何实现？"></a>4.3 中断下半部一般如何实现？</h3><ul><li><strong>软中断、tasklet、工作队列</strong></li><li>详细解释<a href="https://blog.csdn.net/qq_16933601/article/details/107239908?ops_request_misc=%7B%22request_id%22:%22161962026516780264032212%22,%22scm%22:%2220140713.130102334.pc_blog.%22%7D&request_id=161962026516780264032212&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-107239908.pc_v2_rank_blog_default&utm_term=%E4%B8%AD%E6%96%AD%E9%A1%B6%E5%8D%8A%E9%83%A8%E5%92%8C%E5%BA%95%E5%8D%8A%E9%83%A8%E7%9A%84%E7%90%86%E8%A7%A3">Linux内核中断顶半部和底半部的理解-CSDN博客</a></li></ul><h3 id="4-4-linux中断的响应执行流程？中断的申请及何时执行-何时执行中断处理函数-？"><a href="#4-4-linux中断的响应执行流程？中断的申请及何时执行-何时执行中断处理函数-？" class="headerlink" title="4.4 linux中断的响应执行流程？中断的申请及何时执行(何时执行中断处理函数)？"></a>4.4 linux中断的响应执行流程？中断的申请及何时执行(何时执行中断处理函数)？</h3><ul><li>中断的响应流程：<strong>cpu接受中断-&gt;保存中断上下文跳转到中断处理历程-&gt;执行中断上半部-&gt;执行中断下半部-&gt;恢复中断上下文</strong>。</li><li>中断的申请request_irq的正确位置：应该是在第一次打开、硬件被告知中断之前。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
            <tag> 系统编程 </tag>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell语法复习</title>
      <link href="/2024/08/07/shell%E8%AF%AD%E6%B3%95%E5%A4%8D%E4%B9%A0/"/>
      <url>/2024/08/07/shell%E8%AF%AD%E6%B3%95%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以下是完善后的 Markdown 文件内容，标题已添加超链接：</p><hr><h1 id="Linux硬件开发常用Shell指令笔记"><a href="#Linux硬件开发常用Shell指令笔记" class="headerlink" title="Linux硬件开发常用Shell指令笔记"></a>Linux硬件开发常用Shell指令笔记</h1><h2 id="一、系统信息查看"><a href="#一、系统信息查看" class="headerlink" title="一、系统信息查看"></a><a href="#%E4%B8%80%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%9F%A5%E7%9C%8B">一、系统信息查看</a></h2><ol><li><p><strong>查看系统信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统内核版本、主机名、硬件架构等详细信息。</li><li><strong>用途</strong>：确认系统环境是否符合开发要求。</li></ul></li><li><p><strong>查看CPU信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示CPU的详细信息，包括型号、核心数、主频等。</li><li><strong>用途</strong>：确认CPU性能是否满足需求。</li></ul></li><li><p><strong>查看内存信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/meminfo</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统的内存信息，包括总内存、可用内存等。</li><li><strong>用途</strong>：评估内存是否足够支持程序运行。</li></ul></li><li><p><strong>查看系统负载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uptime</span></span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统当前的负载情况，包括平均负载值。</li><li><strong>用途</strong>：监控系统运行状态，判断是否需要优化。</li></ul></li></ol><hr><h2 id="二、硬件设备检测"><a href="#二、硬件设备检测" class="headerlink" title="二、硬件设备检测"></a><a href="#%E4%BA%8C%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87%E6%A3%80%E6%B5%8B">二、硬件设备检测</a></h2><ol><li><p><strong>查看设备文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：列出系统中所有设备文件。</li><li><strong>用途</strong>：确认设备是否被正确识别。</li></ul></li><li><p><strong>查看USB设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsusb</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示当前连接的USB设备信息。</li><li><strong>用途</strong>：检测USB接口的硬件设备是否连接成功。</li></ul></li><li><p><strong>查看PCI设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统中所有PCI设备信息。</li><li><strong>用途</strong>：确认PCI接口的硬件设备是否被识别。</li></ul></li><li><p><strong>查看硬件信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lshw</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：详细列出系统中的硬件信息，包括CPU、内存、硬盘等。</li><li><strong>用途</strong>：全面了解硬件配置。</li></ul></li></ol><hr><h2 id="三、文件系统操作"><a href="#三、文件系统操作" class="headerlink" title="三、文件系统操作"></a><a href="#%E4%B8%89%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C">三、文件系统操作</a></h2><ol><li><p><strong>查看文件系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示文件系统的磁盘使用情况，包括挂载点、总容量、已用容量等。</li><li><strong>用途</strong>：确认存储空间是否足够。</li></ul></li><li><p><strong>查看文件类型</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file &lt;文件名&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示文件的类型信息。</li><li><strong>用途</strong>：确认文件格式是否符合要求。</li></ul></li><li><p><strong>挂载文件系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount &lt;设备&gt; &lt;挂载点&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：将设备挂载到指定的挂载点。</li><li><strong>用途</strong>：挂载外部存储设备。</li></ul></li><li><p><strong>卸载文件系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount &lt;挂载点&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：卸载指定的挂载点。</li><li><strong>用途</strong>：安全地卸载外部存储设备。</li></ul></li></ol><hr><h2 id="四、网络操作"><a href="#四、网络操作" class="headerlink" title="四、网络操作"></a><a href="#%E5%9B%9B%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C">四、网络操作</a></h2><ol><li><p><strong>查看网络接口</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示网络接口的配置信息，包括IP地址、子网掩码等。</li><li><strong>用途</strong>：确认网络接口是否正常。<strong>注意</strong>：在现代Linux系统中，<code>ip addr</code> 更常用。</li></ul></li><li><p><strong>查看网络连接</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示当前的网络连接状态。</li><li><strong>用途</strong>：调试网络通信问题。<strong>注意</strong>：在现代Linux系统中，<code>ss -an</code> 更常用。</li></ul></li><li><p><strong>网络测试</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping &lt;IP地址&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：测试与指定IP地址的网络连通性。</li><li><strong>用途</strong>：确认网络连接是否正常。</li></ul></li><li><p><strong>查看DNS配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/resolv.conf</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示DNS服务器的配置信息。</li><li><strong>用途</strong>：确认DNS配置是否正确。</li></ul></li></ol><hr><h2 id="五、系统管理"><a href="#五、系统管理" class="headerlink" title="五、系统管理"></a><a href="#%E4%BA%94%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86">五、系统管理</a></h2><ol><li><p><strong>查看进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统中所有进程的详细信息。</li><li><strong>用途</strong>：监控进程运行状态。</li></ul></li><li><p><strong>杀死进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> &lt;进程ID&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：终止指定的进程。</li><li><strong>用途</strong>：停止异常运行的进程。</li></ul></li><li><p><strong>查看日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/messages</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：查看系统日志文件。</li><li><strong>用途</strong>：调试系统运行中的问题。<strong>注意</strong>：在现代Linux系统中，<code>journalctl</code> 更常用。</li></ul></li><li><p><strong>更新系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get upgrade</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：更新系统软件包。</li><li><strong>用途</strong>：确保系统环境是最新的。适用于基于Debian&#x2F;Ubuntu的系统。</li></ul></li></ol><hr><h2 id="六、脚本与自动化"><a href="#六、脚本与自动化" class="headerlink" title="六、脚本与自动化"></a><a href="#%E5%85%AD%E8%84%9A%E6%9C%AC%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96">六、脚本与自动化</a></h2><ol><li><p><strong>运行Shell脚本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;脚本文件&gt;.sh</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：执行Shell脚本文件。</li><li><strong>用途</strong>：自动化执行一系列命令。</li></ul></li><li><p><strong>查看脚本权限</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l &lt;脚本文件&gt;.sh</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：查看脚本文件的权限。</li><li><strong>用途</strong>：确保脚本具有可执行权限。</li></ul></li><li><p><strong>设置脚本权限</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x &lt;脚本文件&gt;.sh</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：为脚本文件设置可执行权限。</li><li><strong>用途</strong>：确保脚本可以正常运行。</li></ul></li></ol><hr><h2 id="七、硬件调试"><a href="#七、硬件调试" class="headerlink" title="七、硬件调试"></a><a href="#%E4%B8%83%E7%A1%AC%E4%BB%B6%E8%B0%83%E8%AF%95">七、硬件调试</a></h2><ol><li><p><strong>查看串口设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep <span class="built_in">tty</span></span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示串口设备的初始化信息。</li><li><strong>用途</strong>：确认串口设备是否被正确识别。</li></ul></li><li><p><strong>查看GPIO状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/class/gpio/gpio&lt;号&gt;/value</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：查看指定GPIO引脚的状态。</li><li><strong>用途</strong>：调试GPIO相关的硬件问题。</li></ul></li><li><p><strong>设置GPIO状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> &lt;值&gt; &gt; /sys/class/gpio/gpio&lt;号&gt;/value</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：设置指定GPIO引脚的状态。</li><li><strong>用途</strong>：控制GPIO引脚。</li></ul></li><li><p><strong>查看I2C设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i2cdetect -y &lt;总线号&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：扫描I2C总线上的设备。</li><li><strong>用途</strong>：确认I2C设备是否被正确识别。</li></ul></li><li><p><strong>查看SPI设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev/spi*</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：列出SPI设备文件。</li><li><strong>用途</strong>：确认SPI设备是否被正确识别。</li></ul></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux命令 </tag>
            
            <tag> Shell脚本 </tag>
            
            <tag> 硬件调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2024/08/07/test/"/>
      <url>/2024/08/07/test/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="正点原子-Linux驱动学习笔记–11-Linux中断实验"><a href="#正点原子-Linux驱动学习笔记–11-Linux中断实验" class="headerlink" title="[正点原子]Linux驱动学习笔记–11.Linux中断实验"></a>[正点原子]Linux驱动学习笔记–11.Linux中断实验</h1><h1 id="1-Cortex-A7中断系统详解"><a href="#1-Cortex-A7中断系统详解" class="headerlink" title="1. Cortex-A7中断系统详解"></a>1. Cortex-A7中断系统详解</h1><h2 id="1-1-Cortex-A7中断系统简介"><a href="#1-1-Cortex-A7中断系统简介" class="headerlink" title="1.1 Cortex-A7中断系统简介"></a>1.1 Cortex-A7中断系统简介</h2><p>跟 STM32 一样， Cortex-A7 也有中断向量表，中断向量表也是在代码的最前面。 CortexA7 内核有 8 个异常中断，这 8 个异常中断的中断向量表如下所示：</p><p><img src="https://ahutxl.cn/images/2023/01/16/image51dbe76ff1870146.png" alt="image51dbe76ff1870146.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2024/08/06/2024-8-6(%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0)/"/>
      <url>/2024/08/06/2024-8-6(%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="测试测试"><a href="#测试测试" class="headerlink" title="测试测试"></a>测试测试</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法自带格式(如何写博客)</title>
      <link href="/2024/08/06/Markdown%E8%AF%AD%E6%B3%95%E8%87%AA%E5%B8%A6%E6%A0%BC%E5%BC%8F(%E5%A6%82%E4%BD%95%E5%86%99%E5%8D%9A%E5%AE%A2)/"/>
      <url>/2024/08/06/Markdown%E8%AF%AD%E6%B3%95%E8%87%AA%E5%B8%A6%E6%A0%BC%E5%BC%8F(%E5%A6%82%E4%BD%95%E5%86%99%E5%8D%9A%E5%AE%A2)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/./../images/bywind.png" alt="图"></p><p>用Typora软件更简单</p><p><a href="https://www.bilibili.com/video/BV1iHaTe9EZ3/?spm_id_from=333.337.search-card.all.click&vd_source=390e7ea253547d9c75882d502ff42a1b">Typora安装激活流程_哔哩哔哩_bilibili</a></p><p>Typora安装文件及下载地址~<br>链接:<a href="https://pan.baidu.com/s/17CunIoob5JbtQZ1N5ZIyfg?pwd=zspz">https://pan.baidu.com/s/17CunIoob5JbtQZ1N5ZIyfg?pwd=zspz</a> 提取码:zspz</p><p>一键3连 上传代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl&amp;&amp;hexo g&amp;&amp;hexo d</span><br></pre></td></tr></table></figure><h2 id="多级标题"><a href="#多级标题" class="headerlink" title="多级标题"></a>多级标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure><h2 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span>&gt;</span></span>5号字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>这里的背景色是：MistyRosen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure><h2 id="1-5-分割线"><a href="#1-5-分割线" class="headerlink" title="1.5 分割线"></a>1.5 分割线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><p>​分栏 tab</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><ol><li>Unique name :<ul><li>选项卡块标签的唯一名称，不带逗号。</li><li>将在#id中用作每个标签及其索引号的前缀。</li><li>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</li><li>仅当前帖子&#x2F;页面的URL必须是唯一的！</li></ul></li><li>[index]:<ul><li>活动选项卡的索引号。</li><li>如果未指定，将选择第一个标签（1）。</li><li>如果index为-1，则不会选择任何选项卡。</li><li>可选参数。</li></ul></li><li>[Tab caption]:<ul><li>当前选项卡的标题。</li><li>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</li><li>如果未指定标题，但指定了图标，则标题将为空。</li><li>可选参数。</li></ul></li><li>[@icon]:<ul><li>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</li><li>可以指定带空格或不带空格；</li><li>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</li><li>可选参数。</li></ul></li></ol><p>示例1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>示例2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line">**tab名字为第一个Tab**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line">**只有图标 没有Tab名字**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line">**名字+icon**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>示例1</p><p>.<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">test1 1</button><button type="button" class="tab">test1 2</button><button type="button" class="tab">test1 3</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>This is Tab 1.</strong></p></div><div class="tab-item-content"><p><strong>This is Tab 2.</strong></p></div><div class="tab-item-content"><p><strong>This is Tab 3.</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></p><p>示例2</p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">第一个Tab</button><button type="button" class="tab"><i class="fab fa-apple-pay"></i></button><button type="button" class="tab"><i class="fas fa-bomb"></i>炸弹</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>tab名字为第一个Tab</strong></p></div><div class="tab-item-content"><p><strong>只有图标 没有Tab名字</strong></p></div><div class="tab-item-content"><p><strong>名字+icon</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="音频-audio"><a href="#音频-audio" class="headerlink" title="音频 audio"></a>音频 audio</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">参数配置</button><button type="button" class="tab">示例代码</button><button type="button" class="tab">演示</button></div><div class="tab-contents"><div class="tab-item-content active"></div><div class="tab-item-content"></div><div class="tab-item-content"></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> 博客写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 写作技巧 </tag>
            
            <tag> 博客指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法碎片</title>
      <link href="/2024/08/06/%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E7%A2%8E%E7%89%87/"/>
      <url>/2024/08/06/%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E7%A2%8E%E7%89%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="蔡勒公式："><a href="#蔡勒公式：" class="headerlink" title="蔡勒公式："></a>蔡勒公式：</h1><p>计算星期几的常用方法之一是使用“<strong>蔡勒公式</strong>”（Zeller’s Congruence）。这个公式可以计算给定日期对应的星期几，具体步骤如下：</p><h1 id="蔡勒公式的步骤："><a href="#蔡勒公式的步骤：" class="headerlink" title="蔡勒公式的步骤："></a><strong>蔡勒公式的步骤</strong>：</h1><ol><li><p><strong>调整月份与年份</strong>：</p><ul><li>如果月份是1月（1）或2月（2），则将其视为前一年的13月或14月，并将年份减1。</li><li>对于其他月份，直接使用该月份和年份。</li></ul></li><li><p><strong>设定公式变量</strong>：</p><ul><li>设定以下变量：<ul><li>：日期（一个月中的日）</li><li>：月份（3-12代表3月到12月，1月和2月用13和14表示）</li><li>：年份的后两位（year % 100）</li><li>：年份的前两位（year &#x2F; 100）</li></ul></li></ul></li><li><p><strong>应用公式计算</strong>：</p><ul><li><p>使用公式计算： </p></li><li><p><img src="/2024/08/06/%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E7%A2%8E%E7%89%87/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20241113212816146.png" alt="image-20241113212816146"></p></li><li><p>其中，</p><p>的值代表星期：</p><ul><li>0 &#x3D; Saturday</li><li>1 &#x3D; Sunday</li><li>2 &#x3D; Monday</li><li>3 &#x3D; Tuesday</li><li>4 &#x3D; Wednesday</li><li>5 &#x3D; Thursday</li><li>6 &#x3D; Friday</li></ul></li></ul></li></ol><h2 id="示例C语言实现："><a href="#示例C语言实现：" class="headerlink" title="示例C语言实现："></a><strong>示例C语言实现</strong>：</h2><p>以下是使用蔡勒公式计算任何给定日期的星期几的示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getDayOfWeek</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (month &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        month += <span class="number">12</span>; <span class="comment">// 将1月和2月视为上一年的13月和14月</span></span><br><span class="line">        year--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> q = day;                       <span class="comment">// 日期</span></span><br><span class="line">    <span class="type">int</span> m = month;                     <span class="comment">// 月份</span></span><br><span class="line">    <span class="type">int</span> K = year % <span class="number">100</span>;                <span class="comment">// 年份的后两位</span></span><br><span class="line">    <span class="type">int</span> J = year / <span class="number">100</span>;                <span class="comment">// 年份的前两位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 蔡勒公式</span></span><br><span class="line">    <span class="type">int</span> h = (q + (<span class="number">13</span> * (m + <span class="number">1</span>)) / <span class="number">5</span> + K + (K / <span class="number">4</span>) + (J / <span class="number">4</span>) - <span class="number">2</span> * J) % <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h; <span class="comment">// 返回星期几</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> year = <span class="number">2024</span>;</span><br><span class="line">    <span class="type">int</span> month = <span class="number">10</span>; <span class="comment">// 例如10月</span></span><br><span class="line">    <span class="type">int</span> day = <span class="number">1</span>;    <span class="comment">// 例如1日</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> weekday = getDayOfWeek(year, month, day);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;日期 %d-%d-%d 是星期：%d\n&quot;</span>, year, month, day, weekday);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CopyInsert</p><p>运行这段代码可以计算给定日期（例如2024年10月1日）对应的星期几。在这个示例中，输出的星期会以数字形式显示，可以根据前面提到的对应关系来判断具体是哪一天。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程技巧 </tag>
            
            <tag> 代码优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CRAIC-2024目标射击学习过程</title>
      <link href="/2024/08/06/test/1/"/>
      <url>/2024/08/06/test/1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">  acc_lim_x: 1.5                #x方向的加速度极限，单位为 meters/sec^2 (double, default: 2.5)</span><br><span class="line">  acc_lim_y: 2.5                #                                  (double, default: 2.5)</span><br><span class="line">  acc_lim_th: 2.4               #角加速度极限，单位为 radians/sec^2 (double, default: 3.2)</span><br><span class="line"></span><br><span class="line">#The velocity when robot is moving in a straight line</span><br><span class="line">  max_vel_trans: 0.35           #机器人最大平移速度的绝对值 (double, default: 0.55)</span><br><span class="line">  min_vel_trans: 0.01           #                       (double, default: 0.1)</span><br><span class="line">  max_vel_theta: 0.8            #最大角速度的绝对值，单位为 rad/s (double, default: 1.0)</span><br><span class="line">  min_vel_theta: 0.15           #                             (double, default: 0.4)</span><br><span class="line"></span><br><span class="line">#Robot Configuration Parameters</span><br><span class="line">  max_vel_x: 0.35               #机器人在x方向的速度极限，单位为 meters/sec^2 (double, default: 0.55)</span><br><span class="line">  min_vel_x: -0.05               #                                        (double, default: 0.0)</span><br><span class="line"></span><br><span class="line">  max_vel_y: 0.1                #                                          (double, default: 0.1)</span><br><span class="line">  min_vel_y: -0.1               #                                          (double, default: -0.1)</span><br><span class="line"></span><br><span class="line">#Goal Tolerance Parametes </span><br><span class="line">  yaw_goal_tolerance: 0.03      #(double, default: 0.05)</span><br><span class="line">  xy_goal_tolerance: 0.07       #(double, default: 0.10)</span><br><span class="line">  latch_xy_goal_tolerance: true #如果锁定目标公差且机器人到达目标xy位置，机器人将简单地旋转到位，即使它在目标公差的范围内结束。</span><br><span class="line">                                 #(bool, default: false)</span><br><span class="line">#Forward Simulation Parameters</span><br><span class="line">  sim_time: 1.7                 #给定轨迹上的点之间的间隔尺寸，单位为 meters (double, default: 1.7)</span><br><span class="line">  sim_granularity: 0.025        # (double, default: 0.025)</span><br><span class="line">  vx_samples: 3                 #样本数 (integer, default: 3)</span><br><span class="line">  vy_samples: 10                 #(integer, default: 10)</span><br><span class="line">  vth_samples: 20               #角速度的样本数 (integer, default: 20)</span><br><span class="line">  controller_frequency: 20.0    #调用该控制器的频率 (double, default: 20.0)</span><br><span class="line"></span><br><span class="line">#Trajectory Scoring Parameters</span><br><span class="line">  path_distance_bias: 32.0      #控制器靠近给定路径的权重 (double, default: 32.0)</span><br><span class="line">  goal_distance_bias: 24.0      # 控制器尝试达到其本地目标and控制着速度的权重。(double, default: 24.0)</span><br><span class="line">  occdist_scale: 0.01           #控制器尝试避免障碍物的权重 (double, default: 0.01)</span><br><span class="line">  forward_point_distance: 0.325 #从机器人中心点到另一个得分点的距离 (double, default: 0.325)</span><br><span class="line">  stop_time_buffer: 0.2         #机器人在碰撞前必须停止的时间 (double, default: 0.2)</span><br><span class="line">  scaling_speed: 0.25           #缩放机器人足迹的速度的绝对值，单位为m/s (double, default: 0.25)</span><br><span class="line">  max_scaling_factor: 0.2       #缩放机器人足迹的最大因子 (double, default: 0.2)</span><br><span class="line">  publish_cost_grid: false      # (bool, default: false)</span><br><span class="line"></span><br><span class="line">#Oscillation Prevention Parameters</span><br><span class="line">  oscillation_reset_dist: 0.05  #机器人必须运动多少米远后才能复位震荡标记 (double, default: 0.05)</span><br><span class="line"></span><br><span class="line">#Debugging</span><br><span class="line">  publish_traj_pc : true        #将规划的轨迹在RVIZ上进行可视化</span><br><span class="line">  publish_cost_grid_pc: true    #将代价值进行可视化显示 (bool, default: false)</span><br><span class="line">  #是否发布规划器在规划路径时的代价网格.如果设置为true,那么就会在~/cost_cloud话题上发布sensor_msgs/PointCloud2类型消息</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里给部分参数的功能解读：<br>max_vel_x表示机器人最大线速度，单位是m&#x2F;s。<br>min_vel_x表示机器人最小线速度。<br>max_vel_y和min_vel_y对于两轮差分驱动机器人是无效的。<br>max_vel_theta表示机器人最大转动速度，单位是rad&#x2F;s。<br>min_vel_theta表示机器人最小转动速度。<br>acc_lim_x表示在x方向上最大的线加速度，单位是m&#x2F;s^2。<br>acc_lim_theta表示最大角加速度，单位是rad&#x2F;s^2。<br>yaw_goal_tolerance表示接近目标方向（就弧度来说）允许的误差（rad），此值太小会造成机器人在目标附近震荡。<br>xy_goal_tolerance表示接近目标允许的误差（m），此值设置太小，机器人会没完没了在目标位置周围做小调整，而且此值不能小于地图的分辨率。<br>sim_time表示规划器能看到未来多少秒。<br>dwa表示当模拟轨迹走向未来，是否使用动态窗口法。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vi学习</title>
      <link href="/2024/08/06/test/6/"/>
      <url>/2024/08/06/test/6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2024/08/06/test/6/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20240906200054194.png" alt="image-20240906200054194"></p><p>a  光标后一位插入  A 行尾插入</p><p>i   光标原位置插入 I行首插入</p><p>o 光标下一行插入 O 光标上一行插入</p><p><img src="/2024/08/06/test/6/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20240906200102904.png" alt="image-20240906200102904"></p><p>nyy 复制 ndd删除  p光标下边复制 P光标下边复制 u撤回</p><p><img src="/2024/08/06/test/6/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20240906200109699.png" alt="image-20240906200109699"></p><p><img src="/2024/08/06/test/6/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20240906200754220.png" alt="image-20240906200754220"></p><p>​      k（上）</p><p>​h（左）     l（右）</p><p>​j（下）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CRAIC-2024目标射击实践过程</title>
      <link href="/2024/08/06/test/CRAIC-2024%E7%9B%AE%E6%A0%87%E5%B0%84%E5%87%BB%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B/"/>
      <url>/2024/08/06/test/CRAIC-2024%E7%9B%AE%E6%A0%87%E5%B0%84%E5%87%BB%E5%AE%9E%E8%B7%B5%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CRAIC目标射击实践"><a href="#CRAIC目标射击实践" class="headerlink" title="CRAIC目标射击实践"></a>CRAIC目标射击实践</h1><h1 id="比赛介绍"><a href="#比赛介绍" class="headerlink" title="比赛介绍"></a>比赛介绍</h1><p>中国机器人及人工智能大赛是一项历史悠久、影响广泛的全国性学科竞赛。目前大赛已为我国培养了大量“能动手”、“敢创新”、“善协作”的复合型人才。大赛已列入中国高等教育学会发布的全国普通高等学校学科竞赛排行榜、全国普通高校大学生竞赛分析报告。为积极响应中国机器人及人工智能大赛组委会号召以及进一步发挥大赛培养学生主动学习、主动创新、主动创造的能力，激发广大学生探索、应用、创新、创造新技术的热情，有效推进相关专业人才培养。</p><h1 id="主要使用代码"><a href="#主要使用代码" class="headerlink" title="主要使用代码"></a>主要使用代码</h1><p>主目录运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">建图：  ./1-gmapping.sh </span><br><span class="line">保存：  roslaunch robot_slam save_map.launch</span><br><span class="line">射击： roslaunch abot_bringup shoot.launch   发射驱动程序</span><br><span class="line">rostopic pub /shoot  std_msgs/String &quot;data: &#x27;&#x27; &quot;   发布射击的空话题，等待发射</span><br><span class="line">识别：</span><br><span class="line">roslaunch usb_cam usb_cam_test.launch   打开相机</span><br><span class="line">rosrun rqt_image_view  rqt_image_view   可视化相机</span><br><span class="line">语音：</span><br><span class="line">连接蓝牙耳机WI-C200（在蓝牙设置中连接）</span><br><span class="line">roscore</span><br><span class="line">rosrun  robot_voice   tts_subscribe</span><br><span class="line">rostopic  pub /voiceWords std_msgs/String &quot;data: &#x27;1234&#x27; &quot;</span><br><span class="line"></span><br><span class="line">启动导航与识别：</span><br><span class="line">3-mission.sh 在这里</span><br><span class="line">roslaunch track_tag usb_cam_with_calibration.launch  打开相机节点</span><br><span class="line">roslaunch track_tag ar_track_camera.launch   启动二维码识别节点</span><br><span class="line">rosrun robot_voice tts_subscribe; exec bash  语音播报节点</span><br><span class="line">robot_slam/launch/multi_goal.launch  修改导航的目标点的坐标值（文件路径）</span><br><span class="line">robot_slam/scripts/ navigation_multi_goals.py  修改对应id分别走到哪个点（文件路径）</span><br><span class="line"></span><br><span class="line">射击相关：</span><br><span class="line">user_demo/param/mission.yaml    修改射击目标点的相关参数（文件路径）</span><br><span class="line">roslaunch usb_cam usb_cam_test.launch   打开相机</span><br><span class="line">roslaunch  find_object_2d  find_object_2d6.launch  启动识别程序</span><br><span class="line">rosrun  robot_slam   III.py   识别结果判断</span><br><span class="line">rostopic echo /object_position</span><br><span class="line">跟踪标签：在6-mission.sh里有 ，</span><br><span class="line">roslaunch  track_tag usb_cam_with_calibration.launch</span><br><span class="line">roslaunch  track_tag ar_track_camera.launch</span><br><span class="line">rostopic echo /ar_pose_marker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">启动代码前一定要插上炮台的USB串口线，不然运行就会报错没有串口 /dev/shoot，记得打开炮台开关</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看坐标点</span><br><span class="line">运行navigation.sh脚本前注释掉最后一行 ，在打开的地图里点击目标点前 运 rostopic echo /move_base_simple/goal</span><br><span class="line">在导航地图中使用RViz中的navigation goal标定目标后，到终端的输出查看pose 字段，里面有x,y目标点</span><br><span class="line">直接拿迟来量坐标比较快，单位是米，搞懂ros坐标系</span><br><span class="line"></span><br><span class="line">编译及运行--------------------------------------------------------------------</span><br><span class="line">catkin_make    </span><br><span class="line">catkin_make -DCATKIN_WHITELIST_PACKAGES=&quot;robot_slam&quot;</span><br><span class="line"></span><br><span class="line">source devel/setup.bash</span><br><span class="line">source /opt/ros/melodic/setup.bash</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="逻辑文件"><a href="#逻辑文件" class="headerlink" title="逻辑文件"></a>逻辑文件</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">#!/usr/bin/env python</span><br><span class="line">#coding: utf-8</span><br><span class="line"> </span><br><span class="line">import rospy</span><br><span class="line">from geometry_msgs.msg import Point, Twist</span><br><span class="line">import threading</span><br><span class="line">import actionlib</span><br><span class="line">import serial</span><br><span class="line">import time</span><br><span class="line">from actionlib_msgs.msg import GoalStatus</span><br><span class="line">from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal</span><br><span class="line">from geometry_msgs.msg import PoseWithCovarianceStamped</span><br><span class="line">from tf_conversions import transformations</span><br><span class="line">from ar_track_alvar_msgs.msg import AlvarMarkers</span><br><span class="line">from math import pi</span><br><span class="line">import subprocess</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class Navigation:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.set_pose_pub = rospy.Publisher(&#x27;/initialpose&#x27;, PoseWithCovarianceStamped, queue_size=5)</span><br><span class="line">        self.move_base = actionlib.SimpleActionClient(&quot;move_base&quot;, MoveBaseAction)</span><br><span class="line">        self.move_base.wait_for_server(rospy.Duration(60))</span><br><span class="line"> </span><br><span class="line">    def set_pose(self, p):</span><br><span class="line">        if self.move_base is None:</span><br><span class="line">            return False</span><br><span class="line">        x, y, th = p</span><br><span class="line">        pose = PoseWithCovarianceStamped()</span><br><span class="line">        pose.header.stamp = rospy.Time.now()</span><br><span class="line">        pose.header.frame_id = &#x27;map&#x27;</span><br><span class="line">        pose.pose.pose.position.x = x</span><br><span class="line">        pose.pose.pose.position.y = y</span><br><span class="line">        q = transformations.quaternion_from_euler(0.0, 0.0, th/180.0*pi)</span><br><span class="line">        pose.pose.pose.orientation.x = q[0]</span><br><span class="line">        pose.pose.pose.orientation.y = q[1]</span><br><span class="line">        pose.pose.pose.orientation.z = q[2]</span><br><span class="line">        pose.pose.pose.orientation.w = q[3]</span><br><span class="line">        self.set_pose_pub.publish(pose)</span><br><span class="line">        return True </span><br><span class="line"> </span><br><span class="line">    def _feedback_cb(self, feedback):</span><br><span class="line">        msg = feedback</span><br><span class="line">        #rospy.loginfo(&quot;[Navi] navigation feedback\r\n%s&quot;%feedback)</span><br><span class="line"> </span><br><span class="line">    def goto(self, p):</span><br><span class="line">        rospy.loginfo(&quot;[Navigation] goto %s&quot;%p)</span><br><span class="line">        goal = MoveBaseGoal()</span><br><span class="line">        goal.target_pose.header.frame_id = &#x27;map&#x27;</span><br><span class="line">        goal.target_pose.header.stamp = rospy.Time.now()</span><br><span class="line">        goal.target_pose.pose.position.x = p[0]</span><br><span class="line">        goal.target_pose.pose.position.y = p[1]</span><br><span class="line">        q = transformations.quaternion_from_euler(0.0, 0.0, p[2]/180.0*pi)</span><br><span class="line">        goal.target_pose.pose.orientation.x = q[0]</span><br><span class="line">        goal.target_pose.pose.orientation.y = q[1]</span><br><span class="line">        goal.target_pose.pose.orientation.z = q[2]</span><br><span class="line">        goal.target_pose.pose.orientation.w = q[3]</span><br><span class="line">        self.move_base.send_goal(goal, self._done_cb, self._active_cb, self._feedback_cb)</span><br><span class="line">        result = self.move_base.wait_for_result(rospy.Duration(60))</span><br><span class="line">        if not result:</span><br><span class="line">            self.move_base.cancel_goal()</span><br><span class="line">            rospy.loginfo(&quot;Timed out achieving goal&quot;)</span><br><span class="line">        else:</span><br><span class="line">            state = self.move_base.get_state()</span><br><span class="line">            if state == GoalStatus.SUCCEEDED:</span><br><span class="line">                rospy.loginfo(&quot;reach goal %s succeeded!&quot;%p)</span><br><span class="line">        return True</span><br><span class="line"> </span><br><span class="line">    def _done_cb(self, status, result):</span><br><span class="line">        rospy.loginfo(&quot;navigation done! status:%d result:%s&quot;%(status, result))</span><br><span class="line"> </span><br><span class="line">    def _active_cb(self):</span><br><span class="line">        rospy.loginfo(&quot;[Navi] navigation has be actived&quot;)</span><br><span class="line"> </span><br><span class="line">    def cancel(self):</span><br><span class="line">        self.move_base.cancel_all_goals()</span><br><span class="line">        return True</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class ARTracker:</span><br><span class="line">def __init__(self):</span><br><span class="line">self.ar_sub = rospy.Subscriber(&#x27;/ar_pose_marker&#x27;, AlvarMarkers, self.ar_cb)</span><br><span class="line">def ar_cb(self,data):</span><br><span class="line">global target_id</span><br><span class="line">global ar_x</span><br><span class="line">global ar_y</span><br><span class="line">global ar_z</span><br><span class="line">global ar_id</span><br><span class="line">for marker in data.markers:</span><br><span class="line">if  marker.id == target_id :</span><br><span class="line">ar_x = marker.pose.pose.position.x</span><br><span class="line">ar_y = marker.pose.pose.position.y</span><br><span class="line">ar_z = marker.pose.pose.position.z</span><br><span class="line">ar_id = marker.id</span><br><span class="line">#print(&#x27;AR Marker Position (x,y,z):&#x27;, ar_x, ar_y,ar_z)</span><br><span class="line">break</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">class Object_position:</span><br><span class="line">def __init__(self):</span><br><span class="line">    self.ar_sub = rospy.Subscriber(&#x27;/object_position&#x27;, Point, self.find_cb)</span><br><span class="line"> </span><br><span class="line">def find_cb(self,data):</span><br><span class="line">    global find_id </span><br><span class="line">    global find_x</span><br><span class="line">    global find_y     </span><br><span class="line">    point_msg = data</span><br><span class="line">    if(point_msg.z&gt;=1 and point_msg.z&lt;=5):</span><br><span class="line">        find_id = 1</span><br><span class="line">        find_x=point_msg.x</span><br><span class="line">        find_y=point_msg.y         </span><br><span class="line">    else:</span><br><span class="line">        find_id = 0</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">def process():</span><br><span class="line">    rospy.spin()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">find_id = 0 </span><br><span class="line">find_x=0.0</span><br><span class="line">find_y=0.0</span><br><span class="line">target_id = 0 </span><br><span class="line">ar_id = 0 </span><br><span class="line">ar_x =0.0</span><br><span class="line">ar_y =0.0</span><br><span class="line">ar_z =0.0</span><br><span class="line"> </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line"> </span><br><span class="line">    rospy.init_node(&#x27;navigation_demo&#x27;,anonymous=True)</span><br><span class="line">    ser = serial.Serial(port=&quot;/dev/shoot&quot;, baudrate=9600, parity=&quot;N&quot;, bytesize=8, stopbits=1)</span><br><span class="line">    pub = rospy.Publisher(&quot;/cmd_vel&quot;, Twist, queue_size=1000)</span><br><span class="line"> </span><br><span class="line">    goals = [  [1.1 , -0.37,0.0],</span><br><span class="line">            [1.1 , -1.45,.0],</span><br><span class="line">   [1.0 , -2.72,.0],</span><br><span class="line">            [0.07 , -2.72,.0]  ]</span><br><span class="line"> </span><br><span class="line">    object_position = Object_position()</span><br><span class="line">    ar_acker = ARTracker()</span><br><span class="line"> </span><br><span class="line">    executor_thread = threading.Thread(target=process).start()</span><br><span class="line"> </span><br><span class="line">    navi = Navigation()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    time.sleep(15)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># ------first--------------------------------------------------------</span><br><span class="line">    navi.goto(goals[0])</span><br><span class="line">    start=time.time()</span><br><span class="line">    is_shoot=0</span><br><span class="line">    while True:</span><br><span class="line">        if find_id == 1:</span><br><span class="line">            flog0 = find_x - 320</span><br><span class="line">            flog1 = abs(flog0)</span><br><span class="line">        print(flog0)</span><br><span class="line">            if abs(flog1) &gt;10:</span><br><span class="line">                msg = Twist()      </span><br><span class="line">                msg.angular.z = -0.01 * flog0 </span><br><span class="line">                pub.publish(msg)</span><br><span class="line">    print(msg.angular.z)</span><br><span class="line">            elif abs(flog1) &lt;= 10: </span><br><span class="line">                print(&#x27;1 is shoot&#x27;)       </span><br><span class="line">                ser.write(b&#x27;\x55\x01\x12\x00\x00\x00\x01\x69&#x27;) </span><br><span class="line">                time.sleep(0.2)       </span><br><span class="line">                ser.write(b&#x27;\x55\x01\x11\x00\x00\x00\x01\x68&#x27;) </span><br><span class="line">                time.sleep(2)</span><br><span class="line">        is_shoot=1</span><br><span class="line">                break</span><br><span class="line">        end=time.time()</span><br><span class="line">        if end-start&gt;12:</span><br><span class="line">            break</span><br><span class="line"> </span><br><span class="line">    if is_shoot==0:</span><br><span class="line">        ser.write(b&#x27;\x55\x01\x12\x00\x00\x00\x01\x69&#x27;) </span><br><span class="line">        time.sleep(0.2)       </span><br><span class="line">        ser.write(b&#x27;\x55\x01\x11\x00\x00\x00\x01\x68&#x27;) </span><br><span class="line">        time.sleep(2)</span><br><span class="line"> </span><br><span class="line">    #subprocess.run( [&#x27;rosnode&#x27;,&#x27;kill&#x27;,&#x27;find_object_2d&#x27;] )</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># ------sencond-----------------------------------------------------</span><br><span class="line">    navi.goto(goals[1])</span><br><span class="line">    target_id=1     </span><br><span class="line">    Yaw_th = 0.003</span><br><span class="line">    start=time.time()</span><br><span class="line">    is_shoot=0</span><br><span class="line">    while True:</span><br><span class="line">        if ar_id == target_id:</span><br><span class="line">            ar_x_abs = abs(ar_x)</span><br><span class="line">            print(&#x27;x:&#x27;,ar_x)</span><br><span class="line">            print(&#x27;z:&#x27;,ar_z)       </span><br><span class="line">            if ar_x_abs &gt;= Yaw_th: </span><br><span class="line">                msg = Twist()  </span><br><span class="line">                msg.angular.z = -1.5 * ar_x </span><br><span class="line">                pub.publish(msg)</span><br><span class="line">            elif ar_x_abs &lt; Yaw_th and (ar_z &gt;= 1.57 and ar_z &lt;=1.64):</span><br><span class="line">                print(&#x27;2 is shoot&#x27;) </span><br><span class="line">                ser.write(b&#x27;\x55\x01\x12\x00\x00\x00\x01\x69&#x27;) </span><br><span class="line">                time.sleep(0.1)       </span><br><span class="line">                ser.write(b&#x27;\x55\x01\x11\x00\x00\x00\x01\x68&#x27;)</span><br><span class="line">        is_shoot=1</span><br><span class="line">                break</span><br><span class="line">        end=time.time()</span><br><span class="line">        if end-start&gt;20:</span><br><span class="line">            break</span><br><span class="line"> </span><br><span class="line">    if is_shoot==0:</span><br><span class="line">        ser.write(b&#x27;\x55\x01\x12\x00\x00\x00\x01\x69&#x27;) </span><br><span class="line">        time.sleep(0.2)       </span><br><span class="line">        ser.write(b&#x27;\x55\x01\x11\x00\x00\x00\x01\x68&#x27;) </span><br><span class="line">        time.sleep(2)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># # --------------------third----------------------------------</span><br><span class="line">    navi.goto(goals[2])</span><br><span class="line">    target_id=2     # ------------------------------------------------------</span><br><span class="line">    Yaw_th = 0.002</span><br><span class="line">    start=time.time()</span><br><span class="line">    is_shoot=0</span><br><span class="line">    while True:</span><br><span class="line">        if ar_id == target_id:</span><br><span class="line">            ar_x_abs = abs(ar_x)</span><br><span class="line">        print(ar_x)       </span><br><span class="line">            if ar_x_abs &gt;= Yaw_th: </span><br><span class="line">                msg = Twist()  </span><br><span class="line">                msg.angular.z = -1.5 * ar_x  </span><br><span class="line">                pub.publish(msg)</span><br><span class="line">            elif ar_x_abs &lt; Yaw_th:</span><br><span class="line">                print(&#x27;3 is shoot&#x27;) </span><br><span class="line">                ser.write(b&#x27;\x55\x01\x12\x00\x00\x00\x01\x69&#x27;) </span><br><span class="line">                time.sleep(0.1)       </span><br><span class="line">                ser.write(b&#x27;\x55\x01\x11\x00\x00\x00\x01\x68&#x27;)</span><br><span class="line">        is_shoot=1 </span><br><span class="line">                break</span><br><span class="line"> </span><br><span class="line">        end=time.time()</span><br><span class="line">        if end-start&gt;12:</span><br><span class="line">            break</span><br><span class="line">    if is_shoot==0:</span><br><span class="line">        ser.write(b&#x27;\x55\x01\x12\x00\x00\x00\x01\x69&#x27;) </span><br><span class="line">        time.sleep(0.2)       </span><br><span class="line">        ser.write(b&#x27;\x55\x01\x11\x00\x00\x00\x01\x68&#x27;) </span><br><span class="line">        time.sleep(2)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># # -------------------------------------------------------------------------</span><br><span class="line"> </span><br><span class="line">    navi.goto(goals[3]) </span><br><span class="line">    #slowly</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    #rclpy.shutdown()</span><br><span class="line"> </span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="二维码识别"><a href="#二维码识别" class="headerlink" title="二维码识别"></a>二维码识别</h1><p>二维码识别部分，脚本放在abot_ws&#x2F;src&#x2F;robot_slam&#x2F;scripts&#x2F;ar_demo_s.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> ar_track_alvar_msgs.msg <span class="keyword">import</span> AlvarMarkers</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ARTracker</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 初始化ROS节点，命名为&#x27;ar_tracker_node&#x27;，并设置为匿名节点</span></span><br><span class="line">        rospy.init_node(<span class="string">&#x27;ar_tracker_node&#x27;</span>, anonymous=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 创建一个订阅者，订阅AR标记的消息，消息类型为AlvarMarkers，回调函数为ar_cb</span></span><br><span class="line">        <span class="variable language_">self</span>.sub = rospy.Subscriber(<span class="string">&#x27;/ar_pose_marker&#x27;</span>, AlvarMarkers, <span class="variable language_">self</span>.ar_cb)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 初始化AR标记的x和y坐标</span></span><br><span class="line">        <span class="variable language_">self</span>.ar_x_0 = <span class="number">0.0</span></span><br><span class="line">        <span class="variable language_">self</span>.ar_y_0 = <span class="number">0.0</span></span><br><span class="line">        <span class="comment"># 初始化AR标记的ID</span></span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">id</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># AR标记消息的回调函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ar_cb</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="comment"># 遍历接收到的所有AR标记</span></span><br><span class="line">        <span class="keyword">for</span> marker <span class="keyword">in</span> data.markers:</span><br><span class="line">            <span class="comment"># 如果AR标记的ID为0</span></span><br><span class="line">            <span class="keyword">if</span> marker.<span class="built_in">id</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 更新AR标记的x和y坐标</span></span><br><span class="line">                <span class="variable language_">self</span>.ar_x_0 = marker.pose.pose.position.x</span><br><span class="line">                <span class="variable language_">self</span>.ar_y_0 = marker.pose.pose.position.y</span><br><span class="line">                <span class="comment"># 更新AR标记的ID</span></span><br><span class="line">                <span class="variable language_">self</span>.<span class="built_in">id</span> = marker.<span class="built_in">id</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 打印检测到的AR标记的ID和位置信息</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;Detected AR Marker ID:&#x27;</span>, <span class="variable language_">self</span>.<span class="built_in">id</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;AR Marker Position (x,y):&#x27;</span>, <span class="variable language_">self</span>.ar_x_0, <span class="variable language_">self</span>.ar_y_0)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 创建ARTracker对象</span></span><br><span class="line">        ar_tracker = ARTracker()</span><br><span class="line">        <span class="comment"># 进入ROS事件循环</span></span><br><span class="line">        rospy.spin()</span><br><span class="line">    <span class="keyword">except</span> rospy.ROSInterruptException:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h1 id="二维码射击"><a href="#二维码射击" class="headerlink" title="二维码射击"></a>二维码射击</h1><p>二维码射击部分，脚本放在abot_ws&#x2F;src&#x2F;robot_slam&#x2F;scripts&#x2F;ar_shoot_demo.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 上面这行是为了告诉操作系统，这是一个Python脚本，可以直接运行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> ar_track_alvar_msgs.msg <span class="keyword">import</span> AlvarMarkers</span><br><span class="line"><span class="keyword">from</span> geometry_msgs.msg <span class="keyword">import</span> Twist</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义Yaw阈值</span></span><br><span class="line">Yaw_th = <span class="number">0.0045</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ARTracker</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 初始化ROS节点，命名为&#x27;ar_tracker_node&#x27;，并设置为匿名节点</span></span><br><span class="line">        rospy.init_node(<span class="string">&#x27;ar_tracker_node&#x27;</span>, anonymous=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 创建一个订阅者，订阅AR标记的消息，消息类型为AlvarMarkers，回调函数为ar_cb</span></span><br><span class="line">        <span class="variable language_">self</span>.sub = rospy.Subscriber(<span class="string">&#x27;/ar_pose_marker&#x27;</span>, AlvarMarkers, <span class="variable language_">self</span>.ar_cb)</span><br><span class="line">        <span class="comment"># 创建一个发布者，用于发布Twist类型的消息到/cmd_vel话题</span></span><br><span class="line">        <span class="variable language_">self</span>.pub = rospy.Publisher(<span class="string">&quot;/cmd_vel&quot;</span>, Twist, queue_size=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># AR标记消息的回调函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ar_cb</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="keyword">global</span> ar_x, ar_x_abs, Yaw_th</span><br><span class="line">        <span class="comment"># 获取所有AR标记</span></span><br><span class="line">        ar_markers = data</span><br><span class="line">        <span class="comment"># 遍历接收到的所有AR标记</span></span><br><span class="line">        <span class="keyword">for</span> marker <span class="keyword">in</span> data.markers:</span><br><span class="line">            <span class="comment"># 如果AR标记的ID为0</span></span><br><span class="line">            <span class="keyword">if</span> marker.<span class="built_in">id</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 获取AR标记的x坐标</span></span><br><span class="line">                ar_x = marker.pose.pose.position.x</span><br><span class="line">                <span class="comment"># 计算AR标记x坐标的绝对值</span></span><br><span class="line">                ar_x_abs = <span class="built_in">abs</span>(ar_x)</span><br><span class="line">                <span class="comment"># 如果AR标记的x坐标绝对值大于等于Yaw阈值</span></span><br><span class="line">                <span class="keyword">if</span> ar_x_abs &gt;= Yaw_th:</span><br><span class="line">                    <span class="comment"># 创建一个Twist消息</span></span><br><span class="line">                    msg = Twist()</span><br><span class="line">                    <span class="comment"># 设置消息的角速度为AR标记x坐标的相反值（*-1）</span></span><br><span class="line">                    msg.angular.z = -<span class="number">1.5</span> * ar_x</span><br><span class="line">                    <span class="comment"># 发布Twist消息</span></span><br><span class="line">                    <span class="variable language_">self</span>.pub.publish(msg)</span><br><span class="line">                <span class="comment"># 如果AR标记的x坐标绝对值小于Yaw阈值</span></span><br><span class="line">                <span class="keyword">elif</span> ar_x_abs &lt; Yaw_th:</span><br><span class="line">                    <span class="built_in">print</span> <span class="string">&quot;ok&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 创建ARTracker对象</span></span><br><span class="line">        ar_tracker = ARTracker()</span><br><span class="line">        <span class="comment"># 进入ROS事件循环</span></span><br><span class="line">        rospy.spin()</span><br><span class="line">    <span class="keyword">except</span> rospy.ROSInterruptException:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">、</span><br></pre></td></tr></table></figure><h1 id="图像识别"><a href="#图像识别" class="headerlink" title="图像识别"></a>图像识别</h1><p>图像识别部分，脚本放在abot_ws&#x2F;src&#x2F;robot_slam&#x2F;scripts&#x2F;find_demo_s.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># 上面这行是为了告诉操作系统，这是一个Python脚本，可以直接运行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> geometry_msgs.msg <span class="keyword">import</span> Point</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">object_position</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 初始化ROS节点，命名为&#x27;object_position_node&#x27;，并设置为匿名节点</span></span><br><span class="line">        rospy.init_node(<span class="string">&#x27;object_position_node&#x27;</span>, anonymous=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 创建一个订阅者，订阅/object_position话题，消息类型为Point，回调函数为find_cb</span></span><br><span class="line">        <span class="variable language_">self</span>.find_sub = rospy.Subscriber(<span class="string">&#x27;/object_position&#x27;</span>, Point, <span class="variable language_">self</span>.find_cb)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># /object_position话题的回调函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_cb</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="comment"># 获取接收到的Point消息</span></span><br><span class="line">        point_msg = data</span><br><span class="line">        <span class="comment"># 打印接收到的点的x坐标</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;x:&#x27;</span>, point_msg.x)</span><br><span class="line">        <span class="comment"># 打印接收到的点的y坐标</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;y:&#x27;</span>, point_msg.y)</span><br><span class="line">        <span class="comment"># 打印接收到的点的z坐标</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;z:&#x27;</span>, point_msg.z)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 创建object_position对象</span></span><br><span class="line">        object_position = object_position()</span><br><span class="line">        <span class="comment"># 进入ROS事件循环</span></span><br><span class="line">        rospy.spin()</span><br><span class="line">    <span class="keyword">except</span> rospy.ROSInterruptException:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="图像识别射击"><a href="#图像识别射击" class="headerlink" title="图像识别射击"></a>图像识别射击</h1><p>图像识别射击部分，脚本放在abot_ws&#x2F;src&#x2F;robot_slam&#x2F;scripts&#x2F;find_shoot_demo.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># 上面这行是为了告诉操作系统，这是一个Python脚本，可以直接运行</span><br><span class="line"></span><br><span class="line">import rospy</span><br><span class="line">from geometry_msgs.msg import Point, Twist</span><br><span class="line">import serial</span><br><span class="line">import time</span><br><span class="line">from std_msgs.msg import String</span><br><span class="line"></span><br><span class="line"># 设置串口和波特率</span><br><span class="line">serialPort = &quot;/dev/shoot&quot;</span><br><span class="line">baudRate = 9600</span><br><span class="line"></span><br><span class="line"># 打开串口</span><br><span class="line">ser = serial.Serial(port=serialPort, baudrate=baudRate, parity=&quot;N&quot;, bytesize=8, stopbits=1)</span><br><span class="line"></span><br><span class="line">class object_position:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 初始化ROS节点，命名为&#x27;object_position_node&#x27;，并设置为匿名节点</span><br><span class="line">        rospy.init_node(&#x27;object_position_node&#x27;, anonymous=True)</span><br><span class="line">        # 创建一个订阅者，订阅/object_position话题，消息类型为Point，回调函数为find_cb</span><br><span class="line">        self.find_sub = rospy.Subscriber(&#x27;/object_position&#x27;, Point, self.find_cb)</span><br><span class="line">        # 创建一个发布者，用于发布Twist类型的消息到/cmd_vel话题</span><br><span class="line">        self.pub = rospy.Publisher(&quot;/cmd_vel&quot;, Twist, queue_size=1000)</span><br><span class="line"></span><br><span class="line">    # /object_position话题的回调函数</span><br><span class="line">    def find_cb(self, data):</span><br><span class="line">        global flog0, flog1</span><br><span class="line">        # 获取接收到的Point消息</span><br><span class="line">        point_msg = data</span><br><span class="line">        # 计算目标点与图像中心的偏差</span><br><span class="line">        flog0 = point_msg.x - 320</span><br><span class="line">        # 计算偏差的绝对值</span><br><span class="line">        flog1 = abs(flog0)</span><br><span class="line">        # 如果偏差的绝对值大于0.5</span><br><span class="line">        if abs(flog1) &gt; 0.5:</span><br><span class="line">            # 创建一个Twist消息</span><br><span class="line">            msg = Twist()</span><br><span class="line">            # 设置消息的角速度为偏差乘以0.01</span><br><span class="line">            msg.angular.z = -0.01 * flog0</span><br><span class="line">            # 发布Twist消息</span><br><span class="line">            self.pub.publish(msg)</span><br><span class="line">        # 如果偏差的绝对值小于等于0.5</span><br><span class="line">        elif abs(flog1) &lt;= 0.5:</span><br><span class="line">            # 发送射击指令</span><br><span class="line">            ser.write(b&#x27;\x55\x01\x12\x00\x00\x00\x01\x69&#x27;)</span><br><span class="line">            print (&#x27;打印射击&#x27;)</span><br><span class="line">            # 等待0.1秒</span><br><span class="line">            time.sleep(0.08)</span><br><span class="line">            # 发送停止射击指令</span><br><span class="line">            ser.write(b&#x27;\x55\x01\x11\x00\x00\x00\x01\x68&#x27;)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    try:</span><br><span class="line">        # 创建object_position对象</span><br><span class="line">        object_position = object_position()</span><br><span class="line">        # 进入ROS事件循环</span><br><span class="line">        rospy.spin()</span><br><span class="line">    except rospy.ROSInterruptException:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="机器人移动方法1"><a href="#机器人移动方法1" class="headerlink" title="机器人移动方法1"></a>机器人移动方法1</h1><p>机器人循环移动，脚本放在abot_ws&#x2F;src&#x2F;robot_slam&#x2F;scripts&#x2F;move_demo.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding: utf-8</span></span><br><span class="line"><span class="comment"># 上面两行是为了告诉操作系统，这是一个Python脚本，并且使用UTF-8编码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> geometry_msgs.msg <span class="keyword">import</span> Twist</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义移动机器人的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move_robot</span>(<span class="params">linear_x, angular_z</span>):</span><br><span class="line">    <span class="comment"># 初始化ROS节点，命名为&#x27;move_robot_node&#x27;，并设置为匿名节点</span></span><br><span class="line">    rospy.init_node(<span class="string">&#x27;move_robot_node&#x27;</span>, anonymous=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 创建一个发布者，用于发布Twist类型的消息到/cmd_vel话题</span></span><br><span class="line">    velocity_publisher = rospy.Publisher(<span class="string">&#x27;/cmd_vel&#x27;</span>, Twist, queue_size=<span class="number">10</span>)</span><br><span class="line">    <span class="comment"># 设置ROS发布频率为10Hz</span></span><br><span class="line">    rate = rospy.Rate(<span class="number">10</span>)  </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个Twist消息，设置线速度和角速度</span></span><br><span class="line">    vel_msg = Twist()</span><br><span class="line">    vel_msg.linear.x = linear_x</span><br><span class="line">    vel_msg.angular.z = angular_z</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 循环发布消息，直到节点被关闭</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line">        velocity_publisher.publish(vel_msg)</span><br><span class="line">        rate.sleep()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 设置线速度和角速度</span></span><br><span class="line">        linear_x = <span class="number">0.2</span>   <span class="comment"># 线速度</span></span><br><span class="line">        angular_z = <span class="number">0.5</span>  <span class="comment"># 角速度</span></span><br><span class="line">        <span class="comment"># 调用move_robot函数，控制机器人移动</span></span><br><span class="line">        move_robot(linear_x, angular_z)</span><br><span class="line">    <span class="keyword">except</span> rospy.ROSInterruptException:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="机器人移动方法2"><a href="#机器人移动方法2" class="headerlink" title="机器人移动方法2"></a>机器人移动方法2</h1><p>机器人指定移动，脚本放在abot_ws&#x2F;src&#x2F;robot_slam&#x2F;scripts&#x2F;move_robot.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line">#coding: utf-8</span><br><span class="line"># 上面两行是为了告诉操作系统，这是一个Python脚本，并且使用UTF-8编码</span><br><span class="line"></span><br><span class="line">import rospy</span><br><span class="line">from geometry_msgs.msg import Twist</span><br><span class="line"></span><br><span class="line">class move_robot:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 初始化ROS节点，命名为&#x27;move_robot_node&#x27;，并设置为匿名节点</span><br><span class="line">        rospy.init_node(&#x27;move_robot_node&#x27;, anonymous=True)</span><br><span class="line">        # 创建一个发布者，用于发布Twist类型的消息到/cmd_vel话题</span><br><span class="line">        self.pub = rospy.Publisher(&quot;/cmd_vel&quot;, Twist, queue_size=1000)</span><br><span class="line"></span><br><span class="line">    # 控制机器人移动的回调函数</span><br><span class="line">    def move_cb(self):</span><br><span class="line">        global time</span><br><span class="line">        # 初始化时间变量</span><br><span class="line">        time = 0</span><br><span class="line">        # 创建一个Twist消息</span><br><span class="line">        msg = Twist()</span><br><span class="line">        msg.linear.x = 1.0</span><br><span class="line">        msg.linear.y = 0.0</span><br><span class="line">        msg.linear.z = 0.0</span><br><span class="line">        msg.angular.x = 0.0</span><br><span class="line">        msg.angular.y = 0.0</span><br><span class="line">        msg.angular.z = 0.0</span><br><span class="line">        # 控制机器人移动，持续1秒</span><br><span class="line">        while time &lt; 10:</span><br><span class="line">            self.pub.publish(msg)</span><br><span class="line">            rospy.sleep(0.1)</span><br><span class="line">            time += 1</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    try:</span><br><span class="line">        # 创建move_robot对象</span><br><span class="line">        move = move_robot()</span><br><span class="line">        # 调用move_cb函数，控制机器人移动</span><br><span class="line">        move.move_cb()</span><br><span class="line">    except rospy.ROSInterruptException:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">、</span><br></pre></td></tr></table></figure><h1 id="射击实现"><a href="#射击实现" class="headerlink" title="射击实现"></a>射击实现</h1><p>单独的射击脚本，放在abot_ws&#x2F;src&#x2F;robot_slam&#x2F;scripts&#x2F;shoot_demo.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">a#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># 上面这行指定了Python解释器路径，使得脚本可以直接在命令行中执行</span><br><span class="line">import rospy</span><br><span class="line">import serial</span><br><span class="line">import time</span><br><span class="line">from std_msgs.msg import String</span><br><span class="line"></span><br><span class="line"># 设置串口和波特率</span><br><span class="line">serialPort = &quot;/dev/shoot&quot;</span><br><span class="line">baudRate = 9600</span><br><span class="line"></span><br><span class="line"># 打开串口</span><br><span class="line">ser = serial.Serial(port=serialPort, baudrate=baudRate, parity=&quot;N&quot;, bytesize=8, stopbits=1)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    try:</span><br><span class="line">        # 发送射击指令</span><br><span class="line">        ser.write(b&#x27;\x55\x01\x12\x00\x00\x00\x01\x69&#x27;)</span><br><span class="line">        print (&#x27;打印射击&#x27;)</span><br><span class="line">        # 等待0.1秒</span><br><span class="line">        time.sleep(0.08)</span><br><span class="line">        # 发送停止射击指令</span><br><span class="line">        ser.write(b&#x27;\x55\x01\x11\x00\x00\x00\x01\x68&#x27;)</span><br><span class="line">        # 进入ROS的spin循环，保持节点持续运行</span><br><span class="line">        rospy.spin()</span><br><span class="line">    except:</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="导航文件"><a href="#导航文件" class="headerlink" title="导航文件"></a>导航文件</h1><p>有这么几个自主巡航赛道的导航文件，我们可以借鉴一下，放在abot_ws&#x2F;src&#x2F;robot_slam&#x2F;scripts&#x2F;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot; A couple of handy conversion utilities taken from the turtlebot_node.py script found in the</span><br><span class="line">    turtlebot_node ROS package at:</span><br><span class="line">    </span><br><span class="line">    http://www.ros.org/wiki/turtlebot_node</span><br><span class="line">    </span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">import PyKDL</span><br><span class="line">from math import pi</span><br><span class="line"></span><br><span class="line">def quat_to_angle(quat):</span><br><span class="line">    rot = PyKDL.Rotation.Quaternion(quat.x, quat.y, quat.z, quat.w)</span><br><span class="line">    return rot.GetRPY()[2]</span><br><span class="line">        </span><br><span class="line">def normalize_angle(angle):</span><br><span class="line">    res = angle</span><br><span class="line">    while res &gt; pi:</span><br><span class="line">        res -= 2.0 * pi</span><br><span class="line">    while res &lt; -pi:</span><br><span class="line">        res += 2.0 * pi</span><br><span class="line">    return res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="导航点调节"><a href="#导航点调节" class="headerlink" title="导航点调节"></a>导航点调节</h1><p>结合逻辑文件，调节射击阈值和导航点，以下是导航点的调节方式<br>导航点文件在abot_ws\src\robot_slam\launch\multi_goal_shoot.launch，注意，这个launch文件是根据multi_goal.launch生成的，因此记得需要在启动脚本中引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;launch&gt;</span><br><span class="line">  &lt;node name=&quot;multi_goal&quot; pkg=&quot;robot_slam&quot; type=&quot;你的逻辑文件&quot; output=&quot;screen&quot;&gt;</span><br><span class="line">      &lt;param name=&quot;goalListX&quot; value=&quot;  任务点1X,  任务点2X,以此类推&quot;/&gt;</span><br><span class="line">      &lt;param name=&quot;goalListY&quot; value=&quot; 任务点1Y, 任务点2Y,以此类推&quot;/&gt;</span><br><span class="line">      &lt;param name=&quot;goalListYaw&quot; value=&quot;任务点1旋转角度,  任务点2旋转角度, 以此类推&quot;/&gt;</span><br><span class="line">  &lt;/node&gt;</span><br><span class="line">&lt;/launch&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="射击点调节"><a href="#射击点调节" class="headerlink" title="射击点调节"></a>射击点调节</h1><p>A点颜色靶子</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if abs(flog1) &gt; 0.5:</span><br><span class="line">    # 创建一个Twist消息</span><br><span class="line">    msg = Twist()</span><br><span class="line">    # 设置消息的角速度为偏差乘以0.01</span><br><span class="line">    msg.angular.z = -0.01 * flog0</span><br><span class="line">    # 发布Twist消息</span><br><span class="line">    self.pub.publish(msg)</span><br><span class="line"># 如果偏差的绝对值小于等于0.5</span><br><span class="line">elif abs(flog1) &lt;= 0.5:</span><br><span class="line">    # 发送射击指令</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>B靶为环形旋转靶，需要调节部分为marker.id（射击哪个靶子）Max_y（靶子射击的最大高度）Min_y（靶子射击的最小高度）Yaw_th(B点射击精度)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if marker.id == 1 and case == 1:</span><br><span class="line">    ar_x_0 = marker.pose.pose.position.x</span><br><span class="line">ar_y_0 = marker.pose.pose.position.y</span><br><span class="line">    ar_x_0_abs = abs(ar_x_0)</span><br><span class="line">    ar_y_0_abs = abs(ar_y_0)</span><br><span class="line">    if ar_x_0_abs &gt;= Yaw_th:</span><br><span class="line">        msg = Twist()</span><br><span class="line">        msg.angular.z = -1.5 * ar_x_0</span><br><span class="line">        self.pub.publish(msg)</span><br><span class="line">    elif ar_y_0_abs &lt;= Max_y and ar_y_0_abs &gt;= Min_y and case ==1:</span><br><span class="line">        # 发送射击指令</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>C 靶为来回移动靶，需要调节部分为marker.id（射击哪个靶子），Yaw_th1(C点射击精度):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if marker.id == 0 and case == 2:</span><br><span class="line">    ar_x_0 = marker.pose.pose.position.x</span><br><span class="line">ar_y_0 = marker.pose.pose.position.y</span><br><span class="line">    ar_x_0_abs = abs(ar_x_0)</span><br><span class="line">    if ar_x_0_abs &gt;= Yaw_th1:</span><br><span class="line">        msg = Twist()</span><br><span class="line">        msg.angular.z = -1.5 * ar_x_0</span><br><span class="line">        self.pub.publish(msg)</span><br><span class="line">    elif ar_x_0_abs &lt; Yaw_th1 and case == 2:</span><br><span class="line">        # 发送射击指令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小车大小及膨胀系数调节"><a href="#小车大小及膨胀系数调节" class="headerlink" title="小车大小及膨胀系数调节"></a>小车大小及膨胀系数调节</h1><p>小车参数文件在”abot_ws\src\robot_slam\params\carto\costmap_common_params.yaml”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">obstacle_range: 3.0</span><br><span class="line">raytrace_range: 3.5</span><br><span class="line"></span><br><span class="line">footprint: [[X1, Y1], [X2, Y2], [X3, Y3], [X4, Y4]]#小车参数（目前是正方形）</span><br><span class="line">#robot_radius: 0.17</span><br><span class="line"></span><br><span class="line">inflation_radius: 膨胀系数</span><br><span class="line">cost_scaling_factor: 3.0</span><br><span class="line"></span><br><span class="line">map_type: costmap</span><br><span class="line">observation_sources: scan</span><br><span class="line">scan: &#123;sensor_frame: laser_link, data_type: LaserScan, topic: scan_filtered, marking: true, clearing: true&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="TF调节"><a href="#TF调节" class="headerlink" title="TF调节"></a>TF调节</h1><p>TF变换文件位置在:”abot_ws\src\abot_base\abot_bringup\launch\bringup_with_imu.launch”</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Makefileѧϰ</title>
      <link href="/2024/08/06/test/Makefile/"/>
      <url>/2024/08/06/test/Makefile/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以下是一些推荐的学习Makefile的网站和资源，可以帮助你快速掌握Makefile的常用规则、结构和示例：</p><ol><li><strong>廖雪峰的官方网站</strong><br>廖雪峰的Makefile教程从基础概念讲起，通过简单易懂的例子逐步深入，非常适合作为入门学习。<br>网址：<a href="https://liaoxuefeng.com/books/makefile/makefile-basic/">Makefile基础 - Makefile教程 - 廖雪峰的官方网站</a></li><li><strong>腾讯云技术文档</strong><br>腾讯云上有一篇关于Makefile的详细解释和示例，涵盖了从基础到进阶的内容，包括如何编写Makefile以及一些高级用法。<br>网址：<a href="https://cloud.tencent.com/developer/article/1065286">超清晰的makefile解释、编写与示例 - 腾讯云</a></li><li><strong>博客园 - Makefile语法总结</strong><br>这篇文章总结了Makefile的常用语法和规则，并通过具体示例进行解析，适合有一定基础的读者深入学习。<br>网址：<a href="https://www.cnblogs.com/zxdplay/p/17782281.html">Makefile语法详细总结及示例解析（快速掌握）</a></li><li><strong>CSDN博客 - Makefile教程</strong><br>CSDN上有许多关于Makefile的教程和示例，其中一些文章提供了详细的规则和实际项目中的Makefile模板。<br>网址：<a href="https://blog.csdn.net/weixin_46097907/article/details/135816235">makefile常用的命令总结及简单示例 - CSDN博客</a></li><li><strong>GitHub Pages - Makefile教程</strong><br>这是一个开源的Makefile教程，提供了从入门到高级的详细内容，并且包含了许多实用的示例。<br>网址：<a href="https://gavinliu6.github.io/Makefile-Tutorial-zh-CN/">Makefile 教程 - GitHub Pages</a></li><li><strong>CSDN博客 - 通用Makefile模板</strong><br>这篇文章提供了一个通用的Makefile模板，适用于C++项目的编译和链接，是一个很好的参考。<br>网址：<a href="https://blog.csdn.net/wg_cheeky/article/details/108014390">makeFile基本介绍, 语法, 示例,通用makefile - CSDN博客</a></li></ol><h3 id="Makefile-的基本概念"><a href="#Makefile-的基本概念" class="headerlink" title="Makefile 的基本概念"></a>Makefile 的基本概念</h3><ul><li><strong>定义</strong>：Makefile 是一个用于自动化编译和构建项目的文件，它描述了工程的编译、链接等规则，包括哪些源文件需要编译、如何编译、如何生成目标文件等。</li><li><strong>作用</strong>：通过编写 Makefile，可以使用 <code>make</code> 命令工具来自动化编译过程，避免手动输入繁琐的编译命令，提高开发效率。</li></ul><h3 id="Makefile-的基本结构"><a href="#Makefile-的基本结构" class="headerlink" title="Makefile 的基本结构"></a>Makefile 的基本结构</h3><ul><li><strong>变量定义</strong>：用于简化和统一文件名或命令的书写。例如：<ul><li><code>CC = gcc</code>：定义编译器为 gcc。</li><li><code>CFLAGS = -Wall -g</code>：定义编译选项，<code>-Wall</code> 显示所有警告，<code>-g</code> 启用调试信息。</li><li><code>TARGET = my_program</code>：定义目标文件名为 <code>my_program</code>。</li><li><code>OBJECTS = main.o utils.o</code>：定义目标文件列表。</li></ul></li><li><strong>规则定义</strong>：指定目标文件、依赖文件和生成目标文件的命令。基本格式如下：<ul><li><code>target: dependencies</code>：目标文件和依赖文件。</li><li><code>command</code>：生成目标文件的命令，必须以 Tab 键开始。</li></ul></li><li><strong>伪目标</strong>：用于执行一些特定的操作，如清理编译生成的文件。例如：<ul><li><code>.PHONY: clean</code>：声明 <code>clean</code> 是一个伪目标。</li><li><code>clean:</code>：定义清理操作的命令。</li></ul></li></ul><h3 id="Makefile-的基本语法"><a href="#Makefile-的基本语法" class="headerlink" title="Makefile 的基本语法"></a>Makefile 的基本语法</h3><ul><li><p><strong>目标和依赖</strong>：目标是要生成的文件，依赖是生成目标所需要的文件。基本格式如下：</p><ul><li><code>target: dependencies</code>：目标文件和依赖文件。</li><li><code>command</code>：生成目标文件的命令，必须以 Tab 键开始。</li></ul></li><li><p><strong>内置变量</strong>：Makefile 提供了一些内置变量，常用的包括：</p><ul><li><code>$@</code>：目标文件的名称。</li><li><code>$^</code>：所有依赖文件的名称。</li><li><code>$&lt;</code>：第一个依赖文件的名称。</li></ul><p>  <img src="/2024/08/06/test/Makefile/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20250423142456075.png" alt="image-20250423142456075"></p></li><li><p><strong>通配符</strong>：用于匹配文件名或文件路径中的多个字符，以便在规则中批量处理文件。常见的通配符有：</p><ul><li><code>*</code>：匹配零个或多个字符。</li><li><code>?</code>：匹配一个任意字符。</li><li><code>[...]</code>：匹配方括号内的任意一个字符。</li><li><code>[!...]</code>：匹配除了方括号内的字符之外的任意一个字符。</li></ul></li><li><p><strong>模式规则</strong>：用于定义一种模式，告诉 Make 工具如何将一类文件转换成另一类文件。例如：</p><ul><li><code>%.o: %.c</code>：表示所有以 <code>.c</code> 结尾的源文件都可以生成对应的 <code>.o</code> 目标文件。</li></ul></li><li><p><strong>自动化变量</strong>：在规则的命令中使用，代表了与规则相关联的文件名。常用的自动化变量包括：</p><ul><li><code>$@</code>：表示规则中的目标文件名。</li><li><code>$&lt;</code>：表示规则中的第一个依赖文件名。</li><li><code>$^</code>：表示规则中的所有依赖文件名，以空格分隔。</li></ul></li></ul><h3 id="Makefile-的实际应用"><a href="#Makefile-的实际应用" class="headerlink" title="Makefile 的实际应用"></a>Makefile 的实际应用</h3><ul><li><strong>简单示例</strong>：<ul><li>假设有一个简单的 C 项目，包含 <code>main.c</code> 和 <code>utils.c</code> 两个源文件 ，目标是生成可执行文件 <code>my_program</code>。Makefile 内容如下：<ul><li><pre><code class="makefile">CC = gccCFLAGS = -Wall -gTARGET = my_programOBJECTS = main.o utils.oall: $(TARGET)$(TARGET): $(OBJECTS)    $(CC) $(CFLAGS) -o $(TARGET) $(OBJECTS)main.o: main.c    $(CC) $(CFLAGS) -c main.cutils.o: utils.c    $(CC) $(CFLAGS) -c utils.c.PHONY: cleanclean:    rm -f $(TARGET) $(OBJECTS)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    - 在项目目录中执行 `make` 命令即可编译项目，执行 `make clean` 命令可以清理编译生成的文件。</span><br><span class="line">- **复杂项目**：</span><br><span class="line">    - 对于复杂的嵌入式 Linux 项目，可能包含多个源文件、头文件、汇编文件等，需要更复杂的 Makefile 来管理。例如：</span><br><span class="line">        - ```makefile</span><br><span class="line">          CROSS_COMPILE  ?= arm-linux-gnueabihf-</span><br><span class="line">          TARGET   ?= bsp</span><br><span class="line">          CC := $(CROSS_COMPILE)gcc</span><br><span class="line">          LD:= $(CROSS_COMPILE)ld</span><br><span class="line">          OBJCOPY := $(CROSS_COMPILE)objcopy</span><br><span class="line">          OBJDUMP := $(CROSS_COMPILE)objdump</span><br><span class="line">          INCDIRS := imx6ul \</span><br><span class="line">                             bsp/clk \</span><br><span class="line">                             bsp/led \</span><br><span class="line">                             bsp/delay</span><br><span class="line">          SRCDIRS:= project \</span><br><span class="line">                             bsp/clk \</span><br><span class="line">                             bsp/led \</span><br><span class="line">                             bsp/delay</span><br><span class="line">          INCLUDE:= $(patsubst %, -I %, $(INCDIRS))</span><br><span class="line">          SFILES:= $(foreach dir, $(SRCDIRS), $(wildcard $(dir)/*.S))</span><br><span class="line">          CFILES:= $(foreach dir, $(SRCDIRS), $(wildcard $(dir)/*.c))</span><br><span class="line">          SFILENDIR:= $(notdir  $(SFILES))</span><br><span class="line">          CFILENDIR:= $(notdir  $(CFILES))</span><br><span class="line">          SOBJS:= $(patsubst %, obj/%, $(SFILENDIR:.S=.o))</span><br><span class="line">          COBJS:= $(patsubst %, obj/%, $(CFILENDIR:.c=.o))</span><br><span class="line">          OBJS:= $(SOBJS) $(COBJS)</span><br><span class="line">          VPATH:= $(SRCDIRS)</span><br><span class="line">          .PHONY: clean</span><br><span class="line">          $(TARGET).bin : $(OBJS)</span><br><span class="line">              $(LD) -Timx6ul.lds -o $(TARGET).elf $^</span><br><span class="line">              $(OBJCOPY) -O binary -S $(TARGET).elf $@</span><br><span class="line">              $(OBJDUMP) -D -m arm $(TARGET).elf &gt; $(TARGET).dis</span><br><span class="line">          $(SOBJS) : obj/%.o : %.S</span><br><span class="line">              $(CC) -Wall -nostdlib -c -O2  $(INCLUDE) -o $@ $&lt;</span><br><span class="line">          $(COBJS) : obj/%.o : %.c</span><br><span class="line">              $(CC) -Wall -nostdlib -c -O2  $(INCLUDE) -o $@ $&lt;</span><br><span class="line">          clean:</span><br><span class="line">              rm -rf $(TARGET).elf $(TARGET).dis $(TARGET).bin $(COBJS) $(SOBJS)</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li>该 Makefile 使用了交叉编译工具链，支持多个源文件和汇编文件的编译，生成二进制可执行文件、ELF 格式文件和反汇编文件。</li></ul></li></ul><h3 id="Makefile-的调试"><a href="#Makefile-的调试" class="headerlink" title="Makefile 的调试"></a>Makefile 的调试</h3><ul><li><strong>查看 <code>make</code> 过程</strong>：使用 <code>make -n</code> 命令可以显示将会执行的命令，但不会实际执行。</li><li><strong>增加详细输出</strong>：使用 <code>make --debug</code> 命令可以提供详细的调试信息，帮助排查问题。</li></ul><h3 id="Makefile-的高级功能"><a href="#Makefile-的高级功能" class="headerlink" title="Makefile 的高级功能"></a>Makefile 的高级功能</h3><ul><li><p><strong>条件语句</strong>：可以根据不同的条件执行不同的规则或设置变量。常见的条件语句有 <code>ifeq</code>、<code>ifneq</code>、<code>ifdef</code>、<code>ifndef</code>。</p><ul><li>示例：根据操作系统设置不同的编译选项。<ul><li><pre><code class="makefile">CC = gccCFLAGS = -Wall -gifeq ($(OS),Windows_NT)    CFLAGS += -DWIN32else    CFLAGS += -DUNIXendifTARGET = my_programSRCS = main.c utils.call: $(TARGET)$(TARGET): $(SRCS)    $(CC) $(CFLAGS) -o $(TARGET) $(SRCS)clean:    rm -f $(TARGET)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">- **使用函数**：Makefile 提供了一些内建函数，帮助处理字符串和文件操作等任务。常用函数包括：</span><br><span class="line">    - `$(wildcard pattern)`：返回匹配模式的所有文件。</span><br><span class="line">    - `$(patsubst pattern,replacement,text)`：用指定的替换文本替换模式。</span><br><span class="line">    - `$(basename names)`：去除文件名的扩展名部分。</span><br><span class="line">    - `$(dir names)`：返回文件的目录路径。</span><br><span class="line">    - 示例：使用 `wildcard` 和 `patsubst`。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### **Makefile基础笔记**</span><br><span class="line"></span><br><span class="line">#### **1. Makefile概述**</span><br><span class="line">- **Makefile的作用**：</span><br><span class="line">  - 在Linux环境下，`make`命令会查找当前目录下的`Makefile`文件。</span><br><span class="line">  - 根据Makefile中定义的规则，`make`可以自动化地执行命令，例如编译源代码、生成目标文件等。</span><br><span class="line">  - Makefile的核心思想是通过定义规则来描述如何生成目标文件。</span><br><span class="line"></span><br><span class="line">- **基本逻辑示例**：</span><br><span class="line">  - 假设有文件`a.txt`、`b.txt`和`c.txt`，需要先合并`a.txt`和`b.txt`生成中间文件`m.txt`，再将`m.txt`与`c.txt`合并生成最终文件`x.txt`。</span><br><span class="line">  - Makefile通过规则定义这种依赖关系和生成过程。</span><br><span class="line"></span><br><span class="line">#### **2. Makefile规则的基本格式**</span><br><span class="line">- **规则格式**：</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>目标文件: 依赖文件1 依赖文件2 …<br>    命令1<br>    命令2<br>    …</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  - **目标文件**：需要生成的文件。</span><br><span class="line">  - **依赖文件**：生成目标文件所需的文件。</span><br><span class="line">  - **命令**：用于生成目标文件的具体命令，必须以Tab键开头。</span><br><span class="line"></span><br><span class="line">- **示例**：</span><br><span class="line">  </span><br><span class="line">  ```makefile</span><br><span class="line">  m.txt: a.txt b.txt</span><br><span class="line">      cat a.txt b.txt &gt; m.txt</span><br><span class="line">  </span><br><span class="line">  x.txt: m.txt c.txt</span><br><span class="line">      cat m.txt c.txt &gt; x.txt</span><br></pre></td></tr></table></figure><ul><li><code>m.txt</code>依赖于<code>a.txt</code>和<code>b.txt</code>，通过<code>cat</code>命令合并生成。</li><li><code>x.txt</code>依赖于<code>m.txt</code>和<code>c.txt</code>，同样通过<code>cat</code>命令生成。</li></ul></li></ul><h4 id="3-Makefile的执行逻辑"><a href="#3-Makefile的执行逻辑" class="headerlink" title="3. Makefile的执行逻辑"></a><strong>3. Makefile的执行逻辑</strong></h4><ul><li><p><strong>增量编译</strong>：</p><ul><li><code>make</code>会检查目标文件和依赖文件的修改时间。</li><li>如果目标文件的修改时间晚于所有依赖文件，则认为目标文件是最新的，不会重新生成。</li><li>如果依赖文件中的任何一个被修改，则会重新执行规则生成目标文件。</li></ul></li><li><p><strong>默认规则</strong>：</p><ul><li><code>make</code>默认执行Makefile中的第一条规则。</li><li>例如，如果要生成<code>x.txt</code>，<code>make</code>会先检查<code>m.txt</code>是否存在，如果不存在则先生成<code>m.txt</code>，然后再生成<code>x.txt</code>。</li></ul></li></ul><h4 id="4-伪目标（Phony-Target）"><a href="#4-伪目标（Phony-Target）" class="headerlink" title="4. 伪目标（Phony Target）"></a><strong>4. 伪目标（Phony Target）</strong></h4><ul><li><p><strong>定义</strong>：</p><ul><li>伪目标不是实际的文件名，而是用于执行特定任务的规则。</li><li>例如，<code>clean</code>规则通常用于删除生成的文件。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f m.txt x.txt</span><br></pre></td></tr></table></figure><ul><li>执行<code>make clean</code>会删除<code>m.txt</code>和<code>x.txt</code>。</li></ul></li><li><p><strong>避免冲突</strong>：</p><ul><li>如果存在名为<code>clean</code>的文件，<code>make clean</code>可能不会执行。</li><li>可以使用<code>.PHONY</code>声明伪目标：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f m.txt x.txt</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="5-执行多条命令"><a href="#5-执行多条命令" class="headerlink" title="5. 执行多条命令"></a><strong>5. 执行多条命令</strong></h4><ul><li><p><strong>独立命令</strong>：</p><ul><li>每条命令默认在独立的Shell环境中执行。</li><li>例如，<code>cd</code>命令不会影响后续命令的执行环境。</li></ul></li><li><p><strong>多条命令的写法</strong>：</p><ul><li>使用<code>;</code>分隔命令：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">    pwd; cd ..; pwd</span><br></pre></td></tr></table></figure></li><li>使用<code>\</code>换行：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">    pwd; \</span><br><span class="line">    cd ..; \</span><br><span class="line">    pwd</span><br></pre></td></tr></table></figure></li><li>使用<code>&amp;&amp;</code>确保命令顺序执行：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">    pwd &amp;&amp; cd .. &amp;&amp; pwd</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="6-控制命令输出"><a href="#6-控制命令输出" class="headerlink" title="6. 控制命令输出"></a><strong>6. 控制命令输出</strong></h4><ul><li><strong>隐藏命令输出</strong>：<ul><li>在命令前加<code>@</code>可以隐藏命令的打印输出，但命令仍然会执行。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">no_output:</span></span><br><span class="line">    @echo &#x27;not display&#x27;</span><br><span class="line">    echo &#x27;will display&#x27;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="7-错误处理"><a href="#7-错误处理" class="headerlink" title="7. 错误处理"></a><strong>7. 错误处理</strong></h4><ul><li><p><strong>默认行为</strong>：</p><ul><li>如果命令返回非0值，<code>make</code>会中断执行并报错。</li></ul></li><li><p><strong>忽略错误</strong>：</p><ul><li>在命令前加<code>-</code>可以忽略错误，继续执行后续命令。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ignore_error:</span></span><br><span class="line">    -rm zzz.txt</span><br><span class="line">    echo &#x27;ok&#x27;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h4><p>Makefile通过定义规则来自动化生成目标文件，核心在于描述目标文件与依赖文件之间的关系以及生成目标文件的具体命令。掌握以下要点：</p><ul><li>规则的基本格式：目标文件、依赖文件和命令。</li><li>增量编译的逻辑：基于文件的修改时间。</li><li>伪目标的使用：如<code>clean</code>。</li><li>多条命令的写法：使用<code>;</code>、<code>\</code>或<code>&amp;&amp;</code>。</li><li>控制命令输出：使用<code>@</code>。</li><li>错误处理：使用<code>-</code>忽略错误。</li></ul><hr><hr><h3 id="编译C程序-Makefile教程笔记"><a href="#编译C程序-Makefile教程笔记" class="headerlink" title="编译C程序 - Makefile教程笔记"></a><strong>编译C程序 - Makefile教程笔记</strong></h3><h4 id="1-C程序编译的基本步骤"><a href="#1-C程序编译的基本步骤" class="headerlink" title="1. C程序编译的基本步骤"></a><strong>1. C程序编译的基本步骤</strong></h4><p>编译C程序通常分为两步：</p><ol><li><strong>编译阶段</strong>：将每个<code>.c</code>文件编译为<code>.o</code>文件（目标文件）。</li><li><strong>链接阶段</strong>：将所有<code>.o</code>文件链接为最终的可执行文件。</li></ol><h4 id="2-示例项目结构"><a href="#2-示例项目结构" class="headerlink" title="2. 示例项目结构"></a><strong>2. 示例项目结构</strong></h4><p>假设一个简单的C项目，包含以下文件：</p><ul><li><code>hello.c</code>：定义了一个<code>hello</code>函数。</li><li><code>hello.h</code>：声明了<code>hello</code>函数。</li><li><code>main.c</code>：主程序，调用了<code>hello</code>函数。</li></ul><p><strong>文件内容</strong>：</p><ul><li>**<code>hello.c</code>**：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>**<code>hello.h</code>**：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li><li>**<code>main.c</code>**：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start...\n&quot;</span>);</span><br><span class="line">    hello();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-Makefile编写"><a href="#3-Makefile编写" class="headerlink" title="3. Makefile编写"></a><strong>3. Makefile编写</strong></h4><p>根据上述项目结构，Makefile可以定义如下规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 hello.c</span></span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">cc -c hello.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 main.c</span></span><br><span class="line"><span class="section">main.o: main.c hello.h</span></span><br><span class="line">cc -c main.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理生成的文件</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o world.out</span><br></pre></td></tr></table></figure><h4 id="4-Makefile执行逻辑"><a href="#4-Makefile执行逻辑" class="headerlink" title="4. Makefile执行逻辑"></a><strong>4. Makefile执行逻辑</strong></h4><ul><li><p><strong>增量编译</strong>：</p><ul><li><code>make</code>会根据文件的修改时间来判断是否需要重新编译。</li><li>如果<code>hello.c</code>被修改，<code>make</code>会重新编译<code>hello.c</code>生成<code>hello.o</code>，并重新链接生成<code>world.out</code>。</li><li>如果<code>hello.h</code>被修改，<code>make</code>会重新编译所有依赖<code>hello.h</code>的文件（如<code>main.c</code>），并重新链接生成<code>world.out</code>。</li></ul></li><li><p><strong>执行过程</strong>：</p><ul><li>初始运行<code>make</code>时，会依次执行以下步骤：<ol><li>编译<code>hello.c</code>生成<code>hello.o</code>。</li><li>编译<code>main.c</code>生成<code>main.o</code>。</li><li>链接<code>hello.o</code>和<code>main.o</code>生成<code>world.out</code>。</li></ol></li><li>如果修改了<code>hello.c</code>，再次运行<code>make</code>时，只会重新编译<code>hello.c</code>并重新链接<code>world.out</code>。</li><li>如果修改了<code>hello.h</code>，<code>make</code>会重新编译<code>main.c</code>并重新链接<code>world.out</code>。</li></ul></li></ul><h4 id="5-清理规则"><a href="#5-清理规则" class="headerlink" title="5. 清理规则"></a><strong>5. 清理规则</strong></h4><ul><li><strong><code>clean</code>规则</strong>：<ul><li>用于删除所有生成的文件，包括<code>.o</code>文件和可执行文件。</li><li>执行命令：<code>make clean</code>。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.o world.out</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="6-规则优化"><a href="#6-规则优化" class="headerlink" title="6. 规则优化"></a><strong>6. 规则优化</strong></h4><p>随着项目规模的扩大，手动维护Makefile中的规则会变得繁琐。后续可以学习如何使用变量、模式规则等高级特性来简化Makefile的编写。</p><h4 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a><strong>7. 小结</strong></h4><ul><li><strong>Makefile的作用</strong>：通过定义规则，<code>make</code>可以自动化编译C程序。</li><li><strong>规则的基本格式</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标文件: 依赖文件</span><br><span class="line">    命令</span><br></pre></td></tr></table></figure></li><li><strong>增量编译</strong>：<code>make</code>根据文件的修改时间来决定是否重新编译。</li><li><strong>清理规则</strong>：使用<code>clean</code>规则删除生成的文件，方便重新编译。</li></ul><p>以下是根据廖雪峰的《使用隐式规则》教程整理的笔记，主要介绍了Makefile中隐式规则的概念、使用方法以及其潜在问题。</p><hr><h3 id="使用隐式规则-Makefile教程笔记"><a href="#使用隐式规则-Makefile教程笔记" class="headerlink" title="使用隐式规则 - Makefile教程笔记"></a><strong>使用隐式规则 - Makefile教程笔记</strong></h3><h4 id="1-隐式规则的概念"><a href="#1-隐式规则的概念" class="headerlink" title="1. 隐式规则的概念"></a><strong>1. 隐式规则的概念</strong></h4><ul><li><p><strong>隐式规则（Implicit Rule）</strong>：</p><ul><li>Makefile中的一种特殊规则，用于自动推导目标文件的生成规则。</li><li>当Makefile中没有明确定义某个目标文件的规则时，<code>make</code>会尝试使用内置的隐式规则来生成该目标文件。</li></ul></li><li><p><strong>内置规则的作用</strong>：</p><ul><li>为了简化Makefile的编写，<code>make</code>为常见的编译任务（如C、C++、ASM等）提供了默认的隐式规则。</li><li>例如，对于C程序，<code>make</code>会自动应用以下隐式规则：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xyz.o: xyz.c</span><br><span class="line">    cc -c -o xyz.o xyz.c</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-示例：隐式规则的应用"><a href="#2-示例：隐式规则的应用" class="headerlink" title="2. 示例：隐式规则的应用"></a><strong>2. 示例：隐式规则的应用</strong></h4><p>假设有一个C项目，包含<code>hello.c</code>、<code>main.c</code>和<code>hello.h</code>，目标是生成可执行文件<code>world.out</code>。</p><p><strong>项目结构</strong>：</p><ul><li><code>hello.c</code>：定义了一个<code>hello</code>函数。</li><li><code>hello.h</code>：声明了<code>hello</code>函数。</li><li><code>main.c</code>：主程序，调用了<code>hello</code>函数。</li></ul><p><strong>Makefile</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只保留生成 world.out 的规则</span></span><br><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">    cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.o world.out</span><br></pre></td></tr></table></figure><p><strong>执行过程</strong>：</p><ul><li>执行<code>make</code>命令时，<code>make</code>会自动推导出<code>hello.o</code>和<code>main.o</code>的生成规则：<ul><li><code>hello.o</code>依赖于<code>hello.c</code>，使用<code>cc -c -o hello.o hello.c</code>生成。</li><li><code>main.o</code>依赖于<code>main.c</code>，使用<code>cc -c -o main.o main.c</code>生成。</li></ul></li><li>最后，<code>make</code>会链接<code>hello.o</code>和<code>main.o</code>生成<code>world.out</code>。</li></ul><p><strong>输出</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc    -c -o hello.o hello.c</span><br><span class="line">cc    -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure><h4 id="3-隐式规则的优势"><a href="#3-隐式规则的优势" class="headerlink" title="3. 隐式规则的优势"></a><strong>3. 隐式规则的优势</strong></h4><ul><li><strong>减少重复规则</strong>：<ul><li>隐式规则可以减少Makefile中大量重复的编译规则。</li><li>例如，对于多个<code>.c</code>文件，无需为每个文件单独编写<code>.o</code>文件的生成规则。</li></ul></li></ul><h4 id="4-隐式规则的潜在问题"><a href="#4-隐式规则的潜在问题" class="headerlink" title="4. 隐式规则的潜在问题"></a><strong>4. 隐式规则的潜在问题</strong></h4><ul><li><strong>无法跟踪头文件的修改</strong>：<ul><li>隐式规则的一个主要问题是无法自动跟踪头文件（如<code>.h</code>文件）的修改。</li><li>例如，如果修改了<code>hello.h</code>，隐式规则<code>main.o: main.c</code>不会自动检测到<code>hello.h</code>的修改，导致<code>main.c</code>不会被重新编译。</li><li>这可能导致生成的可执行文件中包含过时的代码。</li></ul></li></ul><h4 id="5-解决隐式规则的潜在问题"><a href="#5-解决隐式规则的潜在问题" class="headerlink" title="5. 解决隐式规则的潜在问题"></a><strong>5. 解决隐式规则的潜在问题</strong></h4><ul><li><p><strong>手动添加依赖</strong>：</p><ul><li>为了确保头文件的修改能够触发重新编译，需要手动在Makefile中添加头文件的依赖关系。</li><li>例如：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main.o: main.c hello.h</span></span><br><span class="line">    cc -c main.c</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>自动生成依赖文件</strong>：</p><ul><li>在实际项目中，可以通过工具（如<code>gcc -M</code>）自动生成依赖文件，并将其包含在Makefile中。</li><li>例如，使用<code>gcc -M</code>生成依赖文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -M main.c &gt; main.d</span><br></pre></td></tr></table></figure></li><li>然后在Makefile中包含这些依赖文件：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-include</span> main.d</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a><strong>6. 小结</strong></h4><ul><li><strong>隐式规则的作用</strong>：减少重复的编译规则，简化Makefile的编写。</li><li><strong>隐式规则的潜在问题</strong>：无法自动跟踪头文件的修改，可能导致生成的可执行文件包含过时代码。</li><li><strong>解决方法</strong>：手动添加头文件依赖或使用工具自动生成依赖文件。</li></ul><hr><p>以下是根据廖雪峰的《使用变量》教程整理的笔记，主要介绍了Makefile中变量的使用方法、内置变量和自动变量的概念。</p><hr><h3 id="使用变量-Makefile教程笔记"><a href="#使用变量-Makefile教程笔记" class="headerlink" title="使用变量 - Makefile教程笔记"></a><strong>使用变量 - Makefile教程笔记</strong></h3><h4 id="1-变量的作用"><a href="#1-变量的作用" class="headerlink" title="1. 变量的作用"></a><strong>1. 变量的作用</strong></h4><ul><li><strong>解决重复问题</strong>：<ul><li>在Makefile中，文件名或命令可能会重复出现多次，手动修改容易出错。</li><li>使用变量可以简化Makefile的编写，提高可维护性。</li></ul></li></ul><h4 id="2-定义和使用变量"><a href="#2-定义和使用变量" class="headerlink" title="2. 定义和使用变量"></a><strong>2. 定义和使用变量</strong></h4><ul><li><p><strong>定义变量</strong>：</p><ul><li>使用<code>变量名 = 值</code>或<code>变量名 := 值</code>定义变量。</li><li>通常变量名使用全大写，例如<code>TARGET</code>、<code>OBJS</code>等。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TARGET = world.out</span><br><span class="line">OBJS = hello.o main.o</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>引用变量</strong>：</p><ul><li>使用<code>$(变量名)</code>引用变量。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">    cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="3-动态生成变量"><a href="#3-动态生成变量" class="headerlink" title="3. 动态生成变量"></a><strong>3. 动态生成变量</strong></h4><ul><li><p><strong>使用<code>wildcard</code>函数</strong>：</p><ul><li><code>wildcard</code>函数可以匹配当前目录下的文件模式。</li><li>示例：<code>$(wildcard *.c)</code>会列出当前目录下所有<code>.c</code>文件。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用<code>patsubst</code>函数</strong>：</p><ul><li><code>patsubst</code>函数用于模式替换。</li><li>示例：<code>$(patsubst %.c,%.o,$(wildcard *.c))</code>会将所有<code>.c</code>文件名替换为<code>.o</code>文件名。</li><li>这样，每当添加新的<code>.c</code>文件时，<code>OBJS</code>变量会自动更新，无需手动修改Makefile。</li></ul></li></ul><h4 id="4-内置变量"><a href="#4-内置变量" class="headerlink" title="4. 内置变量"></a><strong>4. 内置变量</strong></h4><ul><li><p><strong>内置变量</strong>：</p><ul><li><code>make</code>提供了一些内置变量，例如<code>$(CC)</code>表示C编译器，默认值是<code>cc</code>。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>修改内置变量</strong>：</p><ul><li>可以重新定义内置变量的值。</li><li>示例：使用交叉编译器时，可以设置<code>CC = riscv64-linux-gnu-gcc</code>。</li></ul></li></ul><h4 id="5-自动变量"><a href="#5-自动变量" class="headerlink" title="5. 自动变量"></a><strong>5. 自动变量</strong></h4><ul><li><p><strong>自动变量</strong>：</p><ul><li>在规则中自动指向特定值的变量。</li><li>常用的自动变量：<ul><li><code>$@</code>：目标文件名。</li><li><code>$&lt;</code>：依赖列表中的第一个文件。</li><li><code>$^</code>：所有依赖文件。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">    @echo &#x27;$<span class="variable">$@</span> = <span class="variable">$@</span>&#x27; <span class="comment"># 目标文件名</span></span><br><span class="line">    @echo &#x27;$<span class="variable">$&lt;</span> = <span class="variable">$&lt;</span>&#x27; <span class="comment"># 第一个依赖文件</span></span><br><span class="line">    @echo &#x27;$<span class="variable">$^</span> = <span class="variable">$^</span>&#x27; <span class="comment"># 所有依赖文件</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>输出示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$@</span> = world.out</span><br><span class="line">$&lt; = hello.o</span><br><span class="line">$^ = hello.o main.o</span><br><span class="line">$(CC) -o world.out hello.o main.o</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-变量的调试"><a href="#6-变量的调试" class="headerlink" title="6. 变量的调试"></a><strong>6. 变量的调试</strong></h4><ul><li><strong>打印变量</strong>：<ul><li>使用<code>@echo</code>打印变量的值，便于调试。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">    @echo &#x27;$<span class="variable">$@</span> = <span class="variable">$@</span>&#x27;</span><br><span class="line">    @echo &#x27;$<span class="variable">$&lt;</span> = <span class="variable">$&lt;</span>&#x27;</span><br><span class="line">    @echo &#x27;$<span class="variable">$^</span> = <span class="variable">$^</span>&#x27;</span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="7-小结-1"><a href="#7-小结-1" class="headerlink" title="7. 小结"></a><strong>7. 小结</strong></h4><ul><li><strong>变量的作用</strong>：简化Makefile的编写，减少重复，提高可维护性。</li><li><strong>变量的定义和引用</strong>：使用<code>变量名 = 值</code>定义，使用<code>$(变量名)</code>引用。</li><li><strong>动态生成变量</strong>：使用<code>wildcard</code>和<code>patsubst</code>函数自动生成文件列表。</li><li><strong>内置变量</strong>：使用内置变量（如<code>$(CC)</code>）简化命令。</li><li><strong>自动变量</strong>：使用自动变量（如<code>$@</code>、<code>$&lt;</code>、<code>$^</code>）简化规则。</li></ul><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STUDY210(朱有鹏)</title>
      <link href="/2024/08/06/test/STUDY210(%E6%9C%B1%E6%9C%89%E9%B9%8F)/"/>
      <url>/2024/08/06/test/STUDY210(%E6%9C%B1%E6%9C%89%E9%B9%8F)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="隐藏文件与非隐藏文件"><a href="#隐藏文件与非隐藏文件" class="headerlink" title="隐藏文件与非隐藏文件"></a>隐藏文件与非隐藏文件</h1><p>Windows中：文件隐藏与不隐藏通过设置文件属性实现的，可以点击文件，右键属性，选择勾选隐藏选项来设置文件为隐藏文件。。在Windows中查看隐藏文件方法：菜单栏 工具-&gt;文件夹选项-&gt;查看-&gt;显示所有文件<br>和文件夹。<br>Linux中：linux中隐藏文件特点是文件名以.开头，跟文件属性无关。在linux中查看隐藏文件用ls -a命令（普通显示ls）</p><h1 id="相对路径与绝对路径"><a href="#相对路径与绝对路径" class="headerlink" title="相对路径与绝对路径"></a>相对路径与绝对路径</h1><p>什么是路径：路径是用来标识一个文件在操作系统的文件系统中存储位置的。pathname<br>举例：<br>D:\winshare\enum.c 全路径 pathname<br>D:\winshare路径 path<br>enum.c文件名name</p><p>绝对路径：路径是从绝对位置开始的。譬如Windows中从某一个盘符开始（C:\），linux中从根目录&#x2F;开始<br>相对路径：指明路径的时候，是从当前所在的位置开始的。</p><p>举例：<br>D:\我的文档\123\123.txt<br>D:\我的文档\abc\abc.txt<br>当前在123.txt，但是要去abc.txt<br>方式1：采用绝对路径。D:\我的文档\abc\abc.txt<br>方式2：采用相对路径。..&#x2F;abc&#x2F;abc.txt (..表示上一层)<br>从当前路径开始，往上走一层，再往下走一层（abc）就到了</p><p>测试：<br>&#x2F;abc&#x2F;123&#x2F;def.txt是linux绝对路径<br>abc&#x2F;123&#x2F;def.txt不是linux绝对路径<br>F:\abc\123\def.txt是windows绝对路径<br>abc\123\def.txt不是windows绝对路径</p><h1 id="linux内核、发行版"><a href="#linux内核、发行版" class="headerlink" title="linux内核、发行版"></a>linux内核、发行版</h1><p>linux本身指的是一个操作系统内核，只有内核是无法直接使用的。我们需要的，可以使用的操作系统是一个包含了内核和一批有用的应用程序的一个集合体，这个就叫linux发行版。<br>ubuntu、redhat就是linux的不同的发行版。</p><h1 id="GUI（图形用户界面）和cmdline（命令行）"><a href="#GUI（图形用户界面）和cmdline（命令行）" class="headerlink" title="GUI（图形用户界面）和cmdline（命令行）"></a>GUI（图形用户界面）和cmdline（命令行）</h1><p>GUI：grahics user interface，图形用户界面。<br>cmdline：command line，命令行。<br>人机交互：人和机器（计算机）进行交互，常用的有命令行和GUI。<br>Windows下既有GUI，又有命令行。linux中也是既有GUI，又有命令行。<br>但是，在linux中我们常用命令行(生产用)，在Windows中常用GUI（娱乐用）</p><h1 id="linux常用命令："><a href="#linux常用命令：" class="headerlink" title="linux常用命令："></a>linux常用命令：</h1><p>(1) ls（list，列表）<br>作用：使用列表把当前文件夹下所有文件显示出来<br>    ls -a显示所有文件，包括隐藏文件<br>    ls -l以详细信息显示<br>    ls -a -l<br>    ls -l -a<br>    ls -la<br>    ls -al四种方式都是可以的</p><p>man 作用：查询帮助信息</p><p>man 1 查询linux命令 </p><p>man2 查询api   </p><p>man3查询C库函数</p><p>(2)cd（change directory，更改目录）</p><p>作用：用来切换目录<br>涉及到相对路径和绝对路径<br>cd ....代表上一层目录<br>cd.   .代表当前目录</p><p>(3) pwd（print work directory，打印工作目录）<br>作用：打印出当前的绝对路径</p><p>(4) mkdir（make directory，创建文件夹）<br>作用：创建空文件夹<br>    mkdir -p 级联创建文件夹  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir runoob        #在工作目录下，建立一个名为 runoob 的子目录 </span><br><span class="line">mkdir -p runoob2/test   #在工作目录下的 runoob2 目录中，建立一个名为 test 的子目录。</span><br><span class="line">若 runoob2 目录原本不存在，则建立一个。（注：本例若不加 -p 参数，且原本 runoob2 目录不存在，则产生错误。）</span><br></pre></td></tr></table></figure><p>(5) mv（move，移动）<br>作用：在目录间移动文件，重命名文件<br>    mv 源文件pathname 目的文件pathname</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv source_file(文件) dest_file(文件) #将源文件名 source_file 改为目标文件名 dest_file</span><br><span class="line">mv source_file(文件) dest_directory(目录) #将文件 source_file 移动到目标目录 dest_directory 中</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一些liunx问题</title>
      <link href="/2024/08/06/test/%E4%B8%80%E4%BA%9Bliunx%E9%97%AE%E9%A2%98/"/>
      <url>/2024/08/06/test/%E4%B8%80%E4%BA%9Bliunx%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr><h3 id="1-内核空间与用户空间的区别"><a href="#1-内核空间与用户空间的区别" class="headerlink" title="1. 内核空间与用户空间的区别"></a>1. 内核空间与用户空间的区别</h3><h4 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h4><ul><li><strong>定义</strong>：内核空间是操作系统的核心部分，直接管理硬件资源和系统资源。</li><li><strong>稳定性与安全性</strong>：内核代码需要高度的稳定性和安全性，不能依赖于用户空间的库。</li><li><strong>特权模式</strong>：内核代码运行在特权模式下，可以直接访问硬件资源和系统内存。</li><li><strong>开发原则</strong>：内核开发中尽量避免使用用户空间的库，以减少复杂性和潜在的稳定性问题。</li></ul><h4 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h4><ul><li><strong>定义</strong>：用户空间是应用程序运行的环境，通常依赖于各种标准库（如 glibc）来实现复杂的功能。</li><li><strong>非特权模式</strong>：用户空间代码运行在非特权模式下，需要通过系统调用与内核交互。</li></ul><hr><h3 id="2-Linux-驱动开发中的库使用"><a href="#2-Linux-驱动开发中的库使用" class="headerlink" title="2. Linux 驱动开发中的库使用"></a>2. Linux 驱动开发中的库使用</h3><h4 id="内核提供的-API"><a href="#内核提供的-API" class="headerlink" title="内核提供的 API"></a>内核提供的 API</h4><p>Linux 内核本身提供了一套丰富的 API，用于驱动开发。这些 API 包括：</p><ul><li><strong>内存管理</strong>：<code>kmalloc</code>、<code>kfree</code> 等函数用于动态内存分配和释放。</li><li><strong>文件操作</strong>：<code>file_operations</code> 结构体用于实现设备文件的读写操作。</li><li><strong>中断处理</strong>：<code>request_irq</code>、<code>free_irq</code> 等函数用于注册和释放中断。</li><li><strong>定时器</strong>：<code>timer_setup</code>、<code>del_timer</code> 等函数用于定时器的创建和删除。</li><li><strong>设备树</strong>：在嵌入式 Linux 开发中，设备树（Device Tree）用于描述硬件设备的配置信息。</li></ul><p>这些 API 是内核的一部分，专门用于驱动开发，因此驱动代码通常不需要额外的用户空间库。</p><h4 id="硬件抽象层（HAL）"><a href="#硬件抽象层（HAL）" class="headerlink" title="硬件抽象层（HAL）"></a>硬件抽象层（HAL）</h4><p>在某些情况下，硬件供应商会提供硬件抽象层（HAL）库，用于简化硬件访问。这些库通常是内核模块的一部分，而不是用户空间库。例如，NXP 的 i.MX 系列处理器提供了专门的 HAL 库，用于访问硬件寄存器和外设。</p><hr><h3 id="3-为什么看起来像是“不用库”"><a href="#3-为什么看起来像是“不用库”" class="headerlink" title="3. 为什么看起来像是“不用库”"></a>3. 为什么看起来像是“不用库”</h3><h4 id="直接硬件访问"><a href="#直接硬件访问" class="headerlink" title="直接硬件访问"></a>直接硬件访问</h4><ul><li>在驱动开发中，开发者需要直接与硬件交互，因此会直接操作硬件寄存器，而不是通过复杂的用户空间库。</li><li>例如，访问 GPIO、定时器、中断控制器等硬件资源时，通常会直接使用内核提供的 API 或硬件寄存器操作。</li></ul><h4 id="轻量级开发"><a href="#轻量级开发" class="headerlink" title="轻量级开发"></a>轻量级开发</h4><ul><li>驱动代码通常需要轻量级和高效，以减少对系统资源的占用。使用内核提供的 API 可以实现这一点，而不需要依赖于复杂的用户空间库。</li></ul><h4 id="稳定性和安全性"><a href="#稳定性和安全性" class="headerlink" title="稳定性和安全性"></a>稳定性和安全性</h4><ul><li>内核代码需要保持高度的稳定性和安全性，避免引入用户空间库可能带来的潜在问题（如内存泄漏、线程安全问题等）。</li></ul><hr><h3 id="4-特殊情况"><a href="#4-特殊情况" class="headerlink" title="4. 特殊情况"></a>4. 特殊情况</h3><h4 id="用户空间驱动"><a href="#用户空间驱动" class="headerlink" title="用户空间驱动"></a>用户空间驱动</h4><ul><li>在某些情况下，驱动程序可以运行在用户空间，而不是内核空间。这种情况下，驱动程序可以使用用户空间的库（如 glibc）。</li><li>例如，某些 USB 设备驱动或网络设备驱动可以运行在用户空间。</li></ul><h4 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h4><ul><li>在某些复杂的驱动开发场景中，可能会使用第三方库来实现特定功能。例如，某些图形驱动可能会使用 OpenGL 或 DirectFB 等库。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Linux 驱动开发并不是完全不使用库，而是尽量减少对用户空间库的依赖，转而使用内核提供的 API 和硬件抽象层。这种做法可以提高驱动代码的稳定性和效率，同时减少对系统资源的占用。在某些特殊情况下，驱动开发可能会使用用户空间库或第三方库，但这取决于具体的开发需求和应用场景。</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux驱动模型详解</title>
      <link href="/2024/06/06/test/Linux%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/06/06/test/Linux%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>让所有很久很久以前都走到幸福结局的时刻</strong></p><h2 id="1-Linux-驱动模型"><a href="#1-Linux-驱动模型" class="headerlink" title="1.Linux 驱动模型"></a>1.Linux 驱动模型</h2><p>本节内容，重在理解。面试时，面试官很大可能会让你挑一个你熟悉的驱动讲讲，如何编写的？能回答出大概的驱动框架就可以。</p><h3 id="1-1-字符设备驱动模型"><a href="#1-1-字符设备驱动模型" class="headerlink" title="1.1 字符设备驱动模型"></a>1.1 字符设备驱动模型</h3><p>驱动初始化中涉及到一个设备描述结构的概念。在任何一种驱动模型中，设备都会用内核中的一种结构来描述，这种结构成为<strong>设备描述结构</strong>。字符设备在内核中使用<code>struct cdev</code>这种结构来描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span> <span class="comment">//设备操作集</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">dev_t</span> dev; <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count; <span class="comment">//设备数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>count表明该类型设备的数目，如有两个串口，则count的值为2。</p></li><li><p>dev是设备号，包含有主设备号和次设备号的信息。主设备号用于区分设备的类型，次设备号用于标记相同类型的设备的不同个体。如串口1和串口2使用同一驱动程序，则其主设备号相同，但次设备号不同。Linux内核中使用<code>dev_t</code>类型来定义设备号，<code>dev_t</code>这种类型其实质为32位的<code>unsigned int</code>，其中高12位为主设备号，低20位为次设备号。</p><ol><li>知道主设备号与次设备号，可通过<code>dev_t dev = MKDEV(主设备号，次设备号)</code> 获得设备号；</li><li>从设备号分解出主设备号：主设备号 &#x3D; <code>MAJOR(dev_t dev)</code></li><li>从设备号分解出次设备号：次设备号 &#x3D; <code>MINOR(dev_t dev)</code></li></ol></li><li><p>主设备号是一个重要的资源，可以通过静态申请和动态分配为设备分配一个主设备号：</p><ol><li>静态申请：开发者自己选择一个数字作为主设备号，然后通过函数<code>register_chrdev_region</code>向内核申请使用。这种方法的缺点是如果申请使用的设备号已经被内核中的其它驱动使用了，则申请失败。</li><li>动态分配：使用<code>alloc_chrdev_region</code>由内核分配一个可用的主设备号。因为内核知道哪些号已经被使用了，所以不会导致分配到已经被使用的号。既然设备号是一种资源，则设备驱动在退出后都应该释放该资源。使用<code>unregister_chrdev_region</code>函数释放这些设备号。</li></ol></li><li><p>ops是操作函数集。<code>file_operations</code>是一个很重要的结构，该结构的成员基本都是函数指针，并且是一些文件操作的函数的指针。</p></li><li><pre><code class="c">struct file_operations &#123;  struct module *owner;  loff_t(*llseek) (struct file *, loff_t, int);  ssize_t(*read) (struct file *, char __user *, size_t, loff_t *);  ssize_t(*aio_read) (struct kiocb *, char __user *, size_t, loff_t);  ssize_t(*write) (struct file *, const char __user *, size_t, loff_t *);  ssize_t(*aio_write) (struct kiocb *, const char __user *, size_t, loff_t);  int (*readdir) (struct file *, void *, filldir_t);  unsigned int (*poll) (struct file *, struct poll_table_struct *);  int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);  int (*mmap) (struct file *, struct vm_area_struct *);  int (*open) (struct inode *, struct file *);  int (*flush) (struct file *);  int (*release) (struct inode *, struct file *);  int (*fsync) (struct file *, struct dentry *, int datasync);  int (*aio_fsync) (struct kiocb *, int datasync);  int (*fasync) (int, struct file *, int);  int (*lock) (struct file *, int, struct file_lock *);  ssize_t(*readv) (struct file *, const struct iovec *, unsigned long, loff_t *);  ssize_t(*writev) (struct file *, const struct iovec *, unsigned long, loff_t *);  ssize_t(*sendfile) (struct file *, loff_t *, size_t, read_actor_t, void __user *);  ssize_t(*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);  unsigned long (*get_unmapped_area) (struct file *, unsigned long,unsigned long, unsigned long,unsigned long);&#125;;    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`struct file_operations`是一个函数指针的集合，定义能在设备上进行的操作。结构中的函数指针指向驱动中的函数，这些函数实现一个针对设备的操作, 对于不支持的操作则设置函数指针为 NULL。例如：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">struct file_operations dev_fops = &#123;</span><br><span class="line">    .llseek = NULL,</span><br><span class="line">    .read = dev_read,</span><br><span class="line">    .write = dev_write,</span><br><span class="line">    .ioctl = dev_ioctl,</span><br><span class="line">    .open = dev_open,</span><br><span class="line">    .release = dev_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>- 该结构体表示应用程序能够对设备文件使用函数`read()`, `write()`等，但不能使用函数`llseek()`。当执行到`read()`函数时，内核根据该结构体转移到驱动程序中的`dev_read`函数去执行。- 驱动初始化有四大步骤：  1.**分配**  - cdev变量的定义可以采用静态和动态两种办法：  - 静态分配：`struct cdev mdev`；  - 动态分配：`struct cdev *pdev = cdev_alloc()`；  2.**初始化**  - `struct cdev`的初始化使用`cdev_init`函数来完成。  - 原型：`cdev_init(struct cdev *cdev, const struct file_operations *fops)`  - 参数：    - `cdev`：待初始化的cdev结构    - `fops`：设备对应的操作函数集  3.注册  - 字符设备的注册使用`cdev_add`函数来完成。  - 原型：`cdev_add(struct cdev *p, dev_t dev, unsigned count)`  - 参数：    - `p`：待添加到内核的字符设备结构    - `dev`：设备号    - `count`：该类设备的设备个数  4.**硬件初始化**  - 根据相应硬件的数据手册完成初始化。</code></pre></li></ul><h3 id="1-2-实现设备操作"><a href="#1-2-实现设备操作" class="headerlink" title="1.2 实现设备操作"></a>1.2 实现设备操作</h3><p>由struct file_operations可以看出，要实现的操作并不少，这里只介绍一些重要的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*open)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *) <span class="comment">//打开设备，响应open系统调用</span></span><br><span class="line"><span class="type">int</span> (*release)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);<span class="comment">//关闭设备，响应close系统调用</span></span><br><span class="line"><span class="type">loff_t</span> (*llseek)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>) <span class="comment">//重定位读写指针，响应lseek系统调用</span></span><br><span class="line"><span class="type">ssize_t</span> (*read)(<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *) <span class="comment">//从设备读取数据，响应read系统调用</span></span><br><span class="line"><span class="type">ssize_t</span> (*write)(<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *) <span class="comment">//向设备写入数据，响应write系统调用</span></span><br></pre></td></tr></table></figure><ul><li><p>以上几个函数涉及到了<code>struct inode</code>和<code>struct file</code>这两种结构体。</p></li><li><p>在Linux系统中，每一个<strong>打开的文件</strong>，在内核中都会关联一个<code>struct file</code>结构体，它由内核在打开文件时创建，在文件关闭后释放。该结构体的重要成员有：</p></li><li><pre><code class="c">loff_t f_pos /*文件读写指针*/struct file_operations *f_op /*该文件所对应的操作*/<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">每一个存在于文件系统里面的文件都会关联一个`inode` 结构，该结构主要用来**记录文件物理上的信息**。因此，它和代表打开文件的file结构是不同的。一个文件**没有被打开时不会关联file结构，但是却会关联一个inode结构**。该结构体重要的成员有：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">dev_t i_rdev /*设备号*/</span><br></pre></td></tr></table></figure>- 一个设备支持的函数操作又称为设备方法。- `open`设备方法是驱动程序用来为以后的操作完成**初始化**准备工作的。在大部分驱动程序中，open完成如下工作：**标明次设备号、启动设备**。- `release`设备方法的作用与open相反，这个设备方法有时也称为close，它完成的工作是**关闭设备**。- `read`设备方法通常完成两件事情：从设备中**读取数据**(属于硬件访问类操作)，将读取到的数据**返回给应用程序**。- ```c  ssize_t (*read)(struct file *filp,char __user *buff,size_t count,loff_t *offp)  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 参数说明：</span><br><span class="line"></span><br><span class="line">  1. `filp`：与字符设备文件关联的file结构指针，由内核创建。</span><br><span class="line">  2. `buff`：从设备读取到的数据，需要**保存到的位置**。由read系统调用提供该参数。</span><br><span class="line">  3. `count`：请求传输的**数据量**，由read系统调用提供该参数。</span><br><span class="line">  4. `offp`：文件的**读写位置**，由内核从file结构中取出后(相当于读取指针)，传递进来。</span><br><span class="line"></span><br><span class="line">- 要注意的是，`buff`参数是来源于用户空间的指针，这类指针都**不能被内核代码直接引用**，必须使用专门的函数：</span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">  int copy_to_user(void __user *to, const void *from, int n)// 内核态-&gt;用户态</span><br><span class="line">  int copy_from_user(void *to, const void __user *from, int n)// 用户态-&gt;内核态</span><br></pre></td></tr></table></figure>    - 其中`copy_to_user()`用于将内核数据传送给用户空间；`copy_from_user()`用于将用户空间的数据传送给内核空间。    - `write`设备方法通常完成两件事情：**从应用程序提供的地址中取出数据，将数据写入设备**(属于硬件访问类操作)    - 函数原型：`ssize_t (*write)(struct file *, const char __user *, size_t, loff_t *)`    - 驱动注销：当我们从内核中卸载驱动程序的时候，需要使用`cdev_del`函数来完成字符设备的注销。    - 一个驱动程序范例：    - ```c      #include &lt;linux/module.h&gt;      #include &lt;linux/types.h&gt;      #include &lt;linux/fs.h&gt;      #include &lt;linux/errno.h&gt;      #include &lt;linux/init.h&gt;      #include &lt;linux/cdev.h&gt;      #include &lt;asm/uaccess.h&gt;      #include &lt;linux/slab.h&gt;             int dev1_registers[5];      int dev2_registers[5];             struct cdev cdev; // 字符驱动设备      dev_t devno;// 设备号             /*文件打开函数*/      int mem_open(struct inode *inode, struct file *filp)      &#123;          /*获取次设备号*/          int num = MINOR(inode-&gt;i_rdev);                 if (num==0)              filp-&gt;private_data = dev1_registers;          else if(num == 1)              filp-&gt;private_data = dev2_registers;          else              return -ENODEV;  //无效的次设备号                 return 0;       &#125;             /*文件释放函数*/      int mem_release(struct inode *inode, struct file *filp)      &#123;        return 0;      &#125;             /*读函数 返回读取了多少个数据*/      static ssize_t mem_read(struct file *filp, char __user *buf, size_t size, loff_t *ppos)      &#123;        unsigned long p =  *ppos;        unsigned int count = size;        int ret = 0;        int *register_addr = filp-&gt;private_data; /*获取设备的寄存器基地址*/               /*判断读位置是否有效*/        if (p &gt;= 5*sizeof(int))          return 0;        if (count &gt; 5*sizeof(int) - p)          count = 5*sizeof(int) - p;               /*读数据到用户空间 从基地址偏移p个(p为开始读的位置 即ppos描述的相对位置)*/        if (copy_to_user(buf, register_addr+p, count))        &#123;          ret = -EFAULT;        &#125;        else        &#123;          *ppos += count;          ret = count;        &#125;               return ret;      &#125;             /*写函数*/      static ssize_t mem_write(struct file *filp, const char __user *buf, size_t size, loff_t *ppos)      &#123;        unsigned long p =  *ppos;        unsigned int count = size;        int ret = 0;        int *register_addr = filp-&gt;private_data; /*获取设备的寄存器地址*/               /*分析和获取有效的写长度*/        if (p &gt;= 5*sizeof(int))          return 0;        if (count &gt; 5*sizeof(int) - p)          count = 5*sizeof(int) - p;               /*从用户空间写入数据*/        if (copy_from_user(register_addr + p, buf, count))          ret = -EFAULT;        else        &#123;          *ppos += count;          ret = count;        &#125;               return ret;      &#125;             /* seek文件定位函数 */      static loff_t mem_llseek(struct file *filp, loff_t offset, int whence)      &#123;           loff_t newpos;                 switch(whence) &#123;            case SEEK_SET:               newpos = offset;              break;                   case SEEK_CUR:               newpos = filp-&gt;f_pos + offset;              break;                   case SEEK_END:               newpos = 5*sizeof(int)-1 + offset;              break;                   default:               return -EINVAL;          &#125;          if ((newpos&lt;0) || (newpos&gt;5*sizeof(int)))              return -EINVAL;                 filp-&gt;f_pos = newpos;          return newpos;             &#125;             /*文件操作结构体*/      static const struct file_operations mem_fops =      &#123;        .llseek = mem_llseek,        .read = mem_read,        .write = mem_write,        .open = mem_open,        .release = mem_release,      &#125;;             /*设备驱动模块加载函数*/      static int memdev_init(void)      &#123;        /*初始化cdev结构*/        cdev_init(&amp;cdev, &amp;mem_fops);               /* 注册字符设备 */        alloc_chrdev_region(&amp;devno, 0, 2, &quot;memdev&quot;);        cdev_add(&amp;cdev, devno, 2);      &#125;             /*模块卸载函数*/      static void memdev_exit(void)      &#123;        cdev_del(&amp;cdev);   /*注销设备*/        unregister_chrdev_region(devno, 2); /*释放设备号*/      &#125;             MODULE_LICENSE(&quot;GPL&quot;);             module_init(memdev_init);      module_exit(memdev_exit);      <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">### 1.3 总线设备驱动模型</span><br><span class="line"></span><br><span class="line">- 自内核2.6版本开始，需要关注的是**总线、设备和驱动**这3个实体，总线将设备和驱动绑定。在Linux内核系统中注册一个设备的时候，会寻找与之对应驱动进行匹配；相反地，系统中注册一个驱动的时候，会去寻找一个对应的设备进行匹配。**匹配的的工作由总线来完成**。</span><br><span class="line"></span><br><span class="line">- **在Linux设备中有的是没有对应的物理总线的，但为了适配Linux的总线模型，内核针对这种没有物理总线的设备开发了一种虚拟总线——platform总线**。将设备和驱动独立开，驱动尽可能写的通用，当来了一个类似的设备后也可以使用这个驱动，让驱动程序可以重用。这体现了Linux驱动的软件架构设计的思想。</span><br><span class="line"></span><br><span class="line">- 按照这个思路，Linux中的设备和驱动都需要挂接在一种总线上，比如i2c总线上的eeprom，eeprom作为设备，**eeprom的驱动都挂接在i2c驱动上**。但是在嵌入式系统中，**soc系统一般都会集成独立的i2c控制器，控制器也是需要驱动的，但是再按照设备-总线-驱动模型进行设计，就会发现无法找到一个合适总线去挂接控制器设备和控制器驱动了（i2c控制器是挂接在CPU内部的总线上，而不是i2c总线）**，所以Linux发明了一种虚拟总线，称为platform总线，相应的设备称为**platform_device（控制器设备），对应的驱动为platform_driver（控制器驱动），用platform总线来承载这些相对特殊的系统**。</span><br><span class="line"></span><br><span class="line">- 注意：**所谓的platform_device并不是与字符设备、块设备和网络设备并列的概念，而是Linux系统提供的一种附加手段**。例如，在 S3C6410处理器中，把内部集成的I2C、RTC、SPI、LCD、看门狗等控制器都归纳为platform_device，而它们本身就是字符设备。我们要记住，platform 驱动只是在**字符设备驱动外套一层platform_driver 的外壳**。引入platform模型符合Linux 设备模型 —— 总线、设备、驱动，设备模型中配套的sysfs节点都可以用，方便我们的开发；**当然你也可以选择不用，不过就失去了一些platform带来的便利**。</span><br><span class="line"></span><br><span class="line">- 设备驱动中引入platform 概念，隔离BSP和驱动。在BSP中定义platform设备和设备使用的资源、设备的具体匹配信息，而在驱动中，只需要通过API去获取资源和数据，做到了板相关代码和驱动代码的分离，使得驱动具有更好的可扩展性和跨平台性。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  - **下面分析下总线设备驱动模型的匹配过程**</span><br><span class="line">    1. 一边的`device`结构体和另一边的`较稳定的 driver 代码`的联系：`device_add()`除将`device`结构放到 bus 的`dev 链表`之外，还会从另一边的`drv`链表中取表元即某个`driver`结构，用总线里的一个`（.match）`函数来作比较，看另一边的`driver`是否支持一边的`device`。若是能够支持，则接着调用软件驱动部分的`.probe`函数。`driver_register()`会将`bus_drv_dev`模型中的较稳定代码`driver`结构体放到虚拟总线的某个链表（drv 链表）中。从另一边的`dev`链表中取出每一个`device`结构用 bus 中的`.match`函数来作比较。</span><br><span class="line">    2. 若支持则调用`.probe`函数。左右两个注册就建立起来的一种机制。在`.probe`函数中做的事件由自已决定，打印一句话，或注册一个字符设备，再或注册一个`input_dev`结构体等等都是由自已决定。强制的把一个驱动程序分为左右两边这种机制而已，可以把这套东西放在任何地方，这里的`driver`只是个结构体不要被这个名字迷惑，`device`也只是个结构体，里面放什么内容都是由自已决定的。</span><br><span class="line"></span><br><span class="line">### 1.4 输入子系统模型</span><br><span class="line"></span><br><span class="line">每个硬件都有一个`input_dev`结构体，每个软件都有一个`input_handler`结构体。`input_dev`和`input_handler`分别通过`input_register_device()`，`input_register_handler()`向核心层注册硬件和软件。</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul><p>int input_register_device(struct input_dev *dev)   &#x2F;&#x2F;*dev:要注册的驱动设备<br>{<br> … …<br>       list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);   &#x2F;&#x2F;(1)放入链表中<br> … …<br>       list_for_each_entry(handler, &amp;input_handler_list, node)  &#x2F;&#x2F;(2)<br>       input_attach_handler(dev, handler);<br> … …<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 从`input_dev`方向分析：`input`设备在增加到`input_dev_list`链表上之后，会查找 `input_handler_list`事件处理链表上的`handler`进行匹配，这里的匹配方式与总线设备驱动模型的`device`和`driver`匹配过程很相似，所有的`input_device`都挂在`input_dev_list`上，所有类型的事件都挂在`input_handler_list`上，进行“匹配相亲”。如果匹配上了，就调用`input_handler`的`connect`函数进行连接。设备就是在此时注册的。</span><br><span class="line">- 从`input_handler`方向分析：将`handler`挂到链表`input_handler_list`下，然后遍历`input_dev_list`链表,查找并匹配输入设备对应的事件处理层，如果匹配上了，就调用`connect`函数进行连接，并创建`input_handle`结构。</span><br><span class="line">- 所以，不管新添加`input_dev`还是`input_handler`，都会进入`input_attach_handler()`判断两者id是否有支持, 若两者支持便进行连接。</span><br><span class="line"></span><br><span class="line">### 1.5 platform总线的匹配规则是什么？在具体应用上要不要先注册驱动再注册设备？有先后顺序没？</span><br><span class="line"></span><br><span class="line">- 匹配规则就是当有一个新的设备挂起时，总线被唤醒，`match`函数被调用，用`device`名字去跟本总线下的所有驱动名字去比较。相反就是用驱动的名字去`device`链表中和所有`device`的名字比较。如果匹配上，才会调用驱动中的`probe`函数，否则不调用。至于先后顺序，鉴于个人理解，**不会有影响**，不管谁先谁后，bus都会完成匹配工作。</span><br><span class="line">- 设备驱动模型的出现主要有三个好处：</span><br><span class="line">  1. 设备与驱动分离，驱动**可移植性增强**；</span><br><span class="line">  2. 设备驱动抽象结构以总线结构表示看起来更加**清晰明了**，谁是属于哪一条bus的；</span><br><span class="line">  3. 设备与驱动分离，很好的奠定了**热插拔**机制。</span><br><span class="line"></span><br><span class="line">## 2.Linux内核</span><br><span class="line"></span><br><span class="line">### 2.1 内核镜像格式有几种？分别有什么区别？</span><br><span class="line"></span><br><span class="line">1. uboot经过编译直接生成的elf格式的可执行程序是u-boot，这个程序类似于windows下的exe格式，在操作系统下是**可以直接执行**的。但是这种格式**不能用来烧录下载**。我们用来烧录下载的是u-boot.bin，这个东西是由u-boot使用arm-linux-objcopy工具进行加工（主要目的是去掉一些无用的东西）得到的。这个u-boot.bin就叫镜像（image），镜像就是用来烧录到iNand中执行的。</span><br><span class="line">2. linux内核经过编译后也会生成一个elf格式的可执行程序，叫**vmlinux或vmlinuz**，这个就是**原始的未经任何处理加工的原版内核elf文件**；嵌入式系统部署时烧录的一般不是这个vmlinuz/vmlinux，而是要用objcopy工具去制作成烧录镜像格式（就是u-boot.bin这种，但是内核没有.bin后缀），经过制作加工成烧录镜像的文件就叫**Image**（制作把78M大的精简成了7.5M，因此这个制作烧录镜像主要目的就是缩减大小，节省磁盘）。</span><br><span class="line">3. 原则上Image就可以直接被烧录到Flash上进行启动执行（类似于u-boot.bin），但是实际上并不是这么简单。实际上linux的作者们觉得Image还是太大了所以对Image进行了压缩，并且在image压缩后的文件的**前端附加了一部分解压缩代码**。构成了一**个压缩格式的镜像就叫zImage**。（因为当年Image大小刚好比一张软盘（软盘有2种，1.2M的和1.44MB两种）大，为了节省1张软盘的钱于是乎设计了这种压缩Image成zImage的技术）。</span><br><span class="line">4. uboot为了启动linux内核，还发明了一种内核格式叫uImage。**uImage是由zImage加工得到的**，uboot中有一个工具，可以将zImage加工生成uImage。注意：uImage不关linux内核的事，linux内核只管生成zImage即可，然后uboot中的mkimage工具再去由zImage加工生成uImage来给uboot启动。这个加工过程其实就是**在zImage前面加上64字节的uImage的头信息即可**。</span><br><span class="line">5. 原则上uboot启动时应该给他uImage格式的内核镜像，但是实际上uboot中也可以支持zImage，是否支持就看x210_sd.h中是否定义了LINUX_ZIMAGE_MAGIC这个宏。所以大家可以看出：有些uboot是支持zImage启动的，有些则不支持。但是**所有的uboot肯定都支持uImage启动**。</span><br><span class="line">6. 如果直接在kernel底下去`make uImage`会提供`mkimage command not found`。解决方案是去`uboot/tools`下`cp mkimage /usr/local/bin/`，复制mkimage工具到系统目录下。再去`make uImage`即可。</span><br><span class="line"></span><br><span class="line">&gt; 通过上面的介绍我们了解了内核镜像的各种格式，如果通过uboot启动内核，Linux必须为**uImage**格式。</span><br><span class="line"></span><br><span class="line">### 2.2 内核中申请内存有哪几个函数？有什么区别？</span><br><span class="line"></span><br><span class="line">1. **kmalloc**</span><br><span class="line"></span><br><span class="line">   ```c</span><br><span class="line">   void *kmalloc(size_t size, gfp_t flags)</span><br></pre></td></tr></table></figure><p>   <code>kmalloc</code>是内核中最常用的一种内存分配方式，它通过调用<code>kmem_cache_alloc</code>函数来实现。<code>kmalloc</code>一次最多能申请的内存大小由<code>include/linux/Kmalloc_size.h</code>的内容来决定，在默认的2.6.18内核版本中，kmalloc一次最多能申请大小为131702B也就是<strong>128KB</strong>字节的连续物理内存。测试结果表明，如果试图用kmalloc函数分配大于128KB的内存，编译不能通过。</p><ol start="2"><li><p><strong>vmalloc</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">vmalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br></pre></td></tr></table></figure><p>前面几种内存分配方式都是物理连续的，能保证较低的平均访问时间。但是在某些场合中，对内存区的请求不是很频繁，较高的内存访问时间也可以接受，这是就可以分配一段<strong>线性连续，物理不连续</strong>的地址，带来的好处是一次可以<strong>分配较大块的内存</strong>。图3-1表示的是<code>vmalloc</code>分配的内存使用的地址范围。<code>vmalloc</code>对一次能分配的内存大小没有明确限制。出于性能考虑，应谨慎使用<code>vmalloc</code>函数。在测试过程中，<strong>最大能一次分配1GB的空间</strong>。</p></li><li><p><strong>dma_alloc_coherent</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">dma_alloc_coherent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> size,<span class="type">ma_addr_t</span> </span></span><br><span class="line"><span class="params">*dma_handle, <span class="type">gfp_t</span> gfp)</span></span><br></pre></td></tr></table></figure><p>DMA(直接内存访问 Direct Memory Access)是一种硬件机制，允许外围设备和主存之间直接传输IO数据，而不需要CPU的参与，使用DMA机制能<strong>大幅提高与设备通信的吞吐量</strong>。DMA操作中，涉及到CPU<strong>高速缓存和对应的内存数据一致性</strong>的问题，必须保证两者的数据一致，在x86_64体系结构中，硬件已经很好的解决了这个问题，<code>dma_alloc_coherentget_free_pages</code>函数实现差别不大，前者实际是调用<code>alloc_pages</code>函数来分配内存，因此一次分配内存的大小限制和后者一样。<code>__get_free_pages</code>分配的内存同样可以用于DMA操作。测试结果证明，<code>dma_alloc_coherent</code>函数一次能分配的最大内存也为<strong>4M</strong>。</p></li><li><p><strong>ioremap</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">ioremap</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> offset, <span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br></pre></td></tr></table></figure><p><code>ioremap</code>是一种更直接的内存“分配”方式，使用时直接<strong>指定物理起始地址和需要分配内存</strong>的大小，然后将该段<strong>物理地址映射到内核地址空间</strong>。<code>ioremap</code>用到的物理地址空间都是事先确定的，和上面的几种内存分配方式并不太一样，并不是分配一段新的物理内存。<code>ioremap</code>多用于<strong>设备驱动</strong>，可以让CPU直接访问外部设备的IO空间。<code>ioremap</code>能映射的内存由原有的物理内存空间决定，所以没有进行测试。</p></li></ol><h3 id="2-3-什么是内核空间，用户空间？"><a href="#2-3-什么是内核空间，用户空间？" class="headerlink" title="2.3 什么是内核空间，用户空间？"></a>2.3 什么是内核空间，用户空间？</h3><ul><li>对 32 位操作系统而言，它的寻址空间（虚拟地址空间，或叫线性地址空间）为 4G（2的32次方）。也就是说一个进程的最大地址空间为 4G。</li><li>操作系统的核心是内核(kernel)，它独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证内核的安全，现在的操作系统一般都强制<strong>用户进程不能直接操作内核</strong>。具体的实现方式基本都是由<strong>操作系统将虚拟地址空间划分为两部分</strong>，一部分为内核空间，另一部分为用户空间。针对 Linux 操作系统而言，<strong>最高的 1G 字节</strong>(从虚拟地址 <code>0xC0000000</code> 到 <code>0xFFFFFFFF</code>)由内核使用，称为<strong>内核空间</strong>。而<strong>较低的 3G 字节</strong>(从虚拟地址 <code>0x00000000</code> 到 <code>0xBFFFFFFF</code>)由各个进程使用，称为用户空间。</li><li>对上面这段内容我们也可以这样理解：<br>每个进程的 4G 地址空间中，最高 1G 都是一样的，即内核空间。只有剩余的 3G 才归进程自己使用。换句话说就是，<strong>最高 1G 的内核空间是被所有进程共享的</strong>！</li><li>下图描述了每个进程 4G 地址空间的分配情况：</li></ul><h3 id="2-4-为什么需要区分内核空间与用户空间？"><a href="#2-4-为什么需要区分内核空间与用户空间？" class="headerlink" title="2.4 为什么需要区分内核空间与用户空间？"></a>2.4 为什么需要区分内核空间与用户空间？</h3><ul><li>在 CPU 的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，比如<strong>清内存、设置时钟</strong>等。如果允许所有的程序都可以使用这些指令，那么系统<strong>崩溃的概率将大大增加</strong>。</li><li>所以，CPU 将指令分为<strong>特权指令</strong>和<strong>非特权指令</strong>，对于那些危险的指令，只允许操作系统及其相关模块使用，普通应用程序只能使用那些不会造成灾难的指令。比如 Intel 的 CPU 将特权等级分为 4 个级别：Ring0~Ring3。</li><li>其实 Linux 系统只使用了 Ring0 和 Ring3 两个运行级别(Windows 系统也是一样的)。当进程运行在 Ring3 级别时被称为运行在用户态，而运行在 Ring0 级别时被称为运行在内核态。</li></ul><h3 id="2-5-什么是内核态和用户态？"><a href="#2-5-什么是内核态和用户态？" class="headerlink" title="2.5 什么是内核态和用户态？"></a>2.5 什么是内核态和用户态？</h3><ul><li><p>当进程<strong>运行在内核空间时</strong>就处于内核态，而进程<strong>运行在用户空间</strong>时则处于用户态。</p></li><li><p>在内核态下，进程运行在内核地址空间中，此时 CPU 可以执行任何指令。运行的代码也不受任何的限制，可以自由地访问任何有效地址，也可以直接进行端口的访问。</p></li><li><p>在用户态下，进程运行在用户地址空间中，被执行的代码要受到 CPU 的诸多检查，它们只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址，且只能对任务状态段(TSS)中 I&#x2F;O 许可位图(I&#x2F;O Permission Bitmap)中规定的可访问端口进行直接访问。</p></li><li><p>对于以前的 DOS 操作系统来说，是没有内核空间、用户空间以及内核态、用户态这些概念的。可以认为所有的代码都是运行在内核态的，因而，用户编写的应用程序代码可以很容易的让操作系统崩溃掉。</p></li><li><p>对于 Linux 来说，通过区分内核空间和用户空间的设计，<strong>隔离了操作系统代码</strong>(操作系统的代码要比应用程序的代码健壮很多)<strong>与应用程序代码</strong>。即便是单个应用程序出现错误，也不会影响到操作系统的稳定性，这样其它的程序还可以正常的运行(Linux 可是个多任务系统啊！)。所以，<strong>区分内核空间和用户空间本质上是要提高操作系统的稳定性及可用性</strong>。</p></li><li><h3 id="2-6-用户空间与内核通信方式有哪些？"><a href="#2-6-用户空间与内核通信方式有哪些？" class="headerlink" title="2.6 用户空间与内核通信方式有哪些？"></a>2.6 用户空间与内核通信方式有哪些？</h3></li></ul><ol><li><p><strong>使用API</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_user(x，ptr) <span class="comment">//在内核中被调用，获取用户空间指定地址的数值并保存到内核变量x中。</span></span><br><span class="line">put_user(x，ptr) <span class="comment">//在内核中被调用，将内核空间的变量x的数值保存到到用户空间指定地址处。</span></span><br><span class="line">copy_from_user()/copy_to_user() <span class="comment">//主要应用于设备驱动读写函数中，通过系统调用触发。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用proc文件系统</strong><br>和<code>sysfs</code>文件系统类似，也可以作为内核空间和用户空间交互的手段。<code>/proc</code> 文件系统是一种虚拟文件系统，通过他可以作为一种linux内核空间和用户空间的桥梁。与普通文件不同，这里的虚拟文件的内容都是动态创建的。使用<code>/proc</code>文件系统的方式很简单。调用<code>create_proc_entry</code>，返回一个<code>proc_dir_entry</code>指针，然后去填充这个指针指向的结构就好了。(相当于proc为用户空间的进程开了个口访问内核空间)</p></li><li><p><strong>使用sysfs文件系统+kobject</strong><br>每个在内核中注册的<code>kobject</code>都对应着<code>sysfs</code>系统中的一个目录。可以通过读取根目录下的<code>sys</code>目录中的文件来获得相应的信息。除了<code>sysfs</code>文件系统和<code>proc</code>文件系统之外，一些其他的虚拟文件系统也能同样达到这个效果。</p></li><li><p><strong>netlink</strong><br><code>netlink socket</code>提供了一组类似于BSD风格的API，用于用户态和内核态的IPC。相比于其他的用户态和内核态IPC机制，netlink有几个好处：1.使用自定义一种协议完成数据交换，不需要添加一个文件等。2.可以支持多点传送。3.支持内核先发起会话。4.异步通信，支持缓存机制。</p></li><li><p><strong>文件</strong><br>应该说这是一种比较笨拙的做法，不过确实可以这样用。当处于内核空间的时候，直接操作文件，将想要传递的信息写入文件，然后用户空间可以读取这个文件便可以得到想要的数据了。下面是一个简单的测试程序，在内核态中，程序会向<code>/home/melody/str_from_kernel</code>文件中写入一条字符串，然后我们在用户态读取这个文件，就可以得到内核态传输过来的数据了。</p></li><li><p><strong>使用mmap系统调用</strong><br>可以将内核空间的地址映射到用户空间。在以前做嵌入式的时候用到几次。一方面可以在<code>driver</code>中修改<code>Struct file_operations</code>结构中的<code>mmap</code>函数指针来重新实现一个文件对应的映射操作。另一方面，也可以直接打开<code>/dev/mem</code>文件，把物理内存中的某一页映射到进程空间中的地址上。其实，除了重写<code>Struct file_operations</code>中<code>mmap</code>函数，我们还可以重写其他的方法如<code>ioctl</code>等，来达到驱动内核空间和用户空间通信的方式。</p></li><li><p><strong>信号</strong><br>从内核空间向进程发送信号。这个倒是经常遇到，用户程序出现重大错误，内核发送信号杀死相应进程。</p></li></ol><h3 id="2-7-内核链表为什么具有通用性？"><a href="#2-7-内核链表为什么具有通用性？" class="headerlink" title="2.7 内核链表为什么具有通用性？"></a>2.7 内核链表为什么具有通用性？</h3><p>内核中由于要管理大量的设备，但是各种设备各不相同，必须将他们统一起来管理，于是内核设计者就想到了使用通用链表来处理，通用链表看似神秘，实际上就是<strong>双向循环链表</strong>，这个链表的每个节点都是只有指针域，没有任何数据域。</p><ul><li>使用通用链表的好处是：<ol><li>通用链表中每个节点中<strong>没有数据域</strong>，也就是说无论数据结构有多复杂在链表中只有前后级指针。</li><li>如果一个数据结构（即是描述设备的设备结构体）想要用通用链表管理，只需要在结构体中包含<strong>节点的字段</strong>即可。</li><li>双向链表可以从任意一个节点的前后遍历整个链表，<strong>遍历非常方便</strong>。</li><li>使用循环链表使得可以不断地循环遍历管理节点，像进程的调度：操作系统会把<strong>就绪的进程</strong>放在一个管理进程的就绪队列的通用链表中管理起来，循环不断地，为他们<strong>分配时间片</strong>，获得cpu进行周而复始的进程调度。</li></ol></li></ul><h3 id="2-8-应用程序中open-在linux中执行过程中是如何从用户空间到内核空间？"><a href="#2-8-应用程序中open-在linux中执行过程中是如何从用户空间到内核空间？" class="headerlink" title="2.8 应用程序中open()在linux中执行过程中是如何从用户空间到内核空间？"></a>2.8 应用程序中open()在linux中执行过程中是如何从用户空间到内核空间？</h3><ol><li>应用层调用<code>open</code>函数，在VFS层中找到<code>struct inode</code>结构体，判断是字符设备还是块设备，根据设备号，可以找到对应的驱动程序。</li><li>在驱动层中，每个字符设备都有一个<code>struct cdev</code>结构体，这个结构体通过<code>struct inode</code>结构体中的<code>i_cdev</code>把连接起VFS层和驱动层，<code>struct cdev</code>结构体描述了字符设备所有信息，其中最重要的一项就是字符设备的操作函数接口，即<code>const struct file_operations *ops</code></li><li><code>struct cdev</code>结构体中的<code>struct file</code>结构体记录了操作字符设备的一些函数，比如<code>open read write</code>函数等。<code>struct file</code>结构体其实是在VFS层的，通过<code>struct file</code>结构体指针指向驱动层的<code>struct file</code>结构体将驱动层函数和VFS层链接起来</li><li>任务完成，VFS层会给应用返回一个<strong>文件描述符（fd）</strong>。这个fd是和<code>struct file</code>结构体对应的。</li></ol><h2 id="3-设备驱动"><a href="#3-设备驱动" class="headerlink" title="3.设备驱动"></a>3.设备驱动</h2><h3 id="3-1-请简述主设备号和次设备号的用途"><a href="#3-1-请简述主设备号和次设备号的用途" class="headerlink" title="3.1 请简述主设备号和次设备号的用途"></a>3.1 请简述主设备号和次设备号的用途</h3><ul><li><strong>主设备号：主设备号标识设备对应的特定的驱动程序</strong>。虽然现代的linux内核允许多个驱动程序共享主设备号，但我们看待的大多数设备仍然按照“一个主设备对应一个驱动程序”的原则组织</li><li><strong>次设备号：次设备号由内核使用，用于确定由主设备号对应驱动程序中的各个设备</strong>。依赖于驱动程序的编写方式，我们可以通过次设备号获得一个指向内核设备的直接指针，也可将此设备号当作设备本地数组的索引。</li></ul><h3 id="3-2-字符型驱动设备怎么创建设备文件？"><a href="#3-2-字符型驱动设备怎么创建设备文件？" class="headerlink" title="3.2 字符型驱动设备怎么创建设备文件？"></a>3.2 字符型驱动设备怎么创建设备文件？</h3><ol><li>手动创建<br><code>mknod /dev/led c 250 0</code> ，其中<code>dev/led</code>为设备节点 ,<code>c</code> 代表字符设备, <code>250</code>代表主设备号, <code>0</code>代表次设备号。</li><li>自动创建<br><code>UDEV/MDEV</code>是运行在用户态的程序，可以动态管理设备文件，包括创建和删除设备文件，运行在用户态意味着系统要运行之后，在 <code>/etc/init.d/rcS</code> 脚本文件中会执行 <code>mdev -s</code> 自动创建设备节点。</li></ol><h3 id="3-3-设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义"><a href="#3-3-设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义" class="headerlink" title="3.3 设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义"></a>3.3 设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义</h3><ul><li><p>注册一个字符设备驱动有两种方法：</p><ol><li><code>void cdev_init(struct cdev *cdev, struct file_operations *fops)</code> 该注册函数可以将<code>cdev</code>结构嵌入到自己的设备特定的结构中。<code>cdev</code>是一个指向结构体<code>cdev</code>的指针，而<code>fops</code>是指向一个类似于 <code>file_operations</code>结构（可以是<code>file_operations</code>结构，但不限于该结构）的指针。</li><li><code>int register_chrdev(unsigned int major, const char *name, struct file operations *fops)</code>；该注册函数是早期的注册函数，<code>major</code>是设备的主设备号，<code>name</code>是驱动程序的名称，而<code>fops</code>是默认的<code>file_operations</code>结构（这是只限于<code>file_operations</code>结构）。对于<code>register_chrdev</code>的调用将为给定的主设备号注册0－255作为次设备号，并为每个设备建立一个对应的默认<code>cdev</code>结构。</li></ol><h3 id="3-4-dev-下面的设备文件是怎么创建出来的？"><a href="#3-4-dev-下面的设备文件是怎么创建出来的？" class="headerlink" title="3.4 &#x2F;dev&#x2F;下面的设备文件是怎么创建出来的？"></a>3.4 &#x2F;dev&#x2F;下面的设备文件是怎么创建出来的？</h3></li><li><p>普遍说法有三种方式，<strong>devfs机制</strong>，<strong>udev机制</strong>，再有一个就是<strong>手动创建</strong>设备节点。谈谈个人见解：</p></li></ul><ol><li><code>devfs</code>机制从来没用过，应该是2.6以前的内核使用的；</li><li><code>udev</code>：其实就是现在常用的<code>device_create()</code>、<code>class_create()</code>这一套接口，所谓<code>udev</code>是上层用户空间程序，是基于驱动中创建使用了这两个接口而起作用的，但是<code>udev</code>在日常开发中几乎接触不到，我们只需在驱动中调用创建节点的这两个API就ok了，剩下的工作就交给<code>udev</code>去做了，有想深究它具体实现原理的那就自己去研究吧，我觉得会用就行了；</li><li><code>mknod</code>：新手最常用的一种创建设备节点方法，但并非入门后就再没有用途，在某些情境下，或许有人不想使用<code>udev</code>机制，于是把节点创建工作写在脚本里，这样也是无可厚非的。</li></ol><h3 id="3-5-Linux设备中字符设备和块设备有什么主要区别？分别举例。"><a href="#3-5-Linux设备中字符设备和块设备有什么主要区别？分别举例。" class="headerlink" title="3.5 Linux设备中字符设备和块设备有什么主要区别？分别举例。"></a>3.5 Linux设备中字符设备和块设备有什么主要区别？分别举例。</h3><ul><li>Linux中I&#x2F;O设备分为两类：块设备和字符设备。两种设备本身没有严格限制，但是，基于不同的功能进行了分类。</li><li><strong>字符设备</strong>：提供<strong>连续</strong>的数据流，应用程序可以顺序读取，通常不支持随机存取。相反，此类设备支持<strong>按字节&#x2F;字符</strong>来读写数据。字符终端、串口、鼠标、键盘、摄像头、声卡和显卡等就是典型的字符设备。</li><li><strong>块设备</strong>：应用程序可以<strong>随机访问</strong>设备数据，程序可自行确定读取数据的位置。硬盘是典型的块设备，应用程序可以寻址磁盘上的<strong>任何位置</strong>，并由此读取数据。此外，数据的读写只能以块(通常是512B)的倍数进行。与字符设备不同，块设备并不支持基于字符的寻址。如：u盘，SD卡，磁盘等。</li></ul><h3 id="3-6-驱动中操作物理绝对地址为什么要先ioremap？"><a href="#3-6-驱动中操作物理绝对地址为什么要先ioremap？" class="headerlink" title="3.6 驱动中操作物理绝对地址为什么要先ioremap？"></a>3.6 驱动中操作物理绝对地址为什么要先ioremap？</h3><ul><li><code>ioremp</code>是内核中用来将外设寄存器物理地址映射到主存上去的接口，即将io地址空间映射到虚拟地址空间上去，便于操作。为什么非要映射呢，因为<strong>保护模式下的cpu只认虚拟地址，不认物理地址</strong>，给它物理地址它并不帮你做事，所以你要操作外设上的寄存器必须先映射到虚拟内存空间，拿着虚拟地址去跟cpu对接，从而操作寄存器。</li></ul><h3 id="3-7-insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？"><a href="#3-7-insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？" class="headerlink" title="3.7 insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？"></a>3.7 insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？</h3><ul><li>分别会执行<code>module_init()</code>和<code>module_exit()</code>指定的<code>init</code>函数和<code>exit</code>函数。要注意的就是，尽量使在<code>init</code>函数中出现的资源申请及使用，都要有对应的释放操作在<code>exit</code>中，即<code>init</code>申请，<code>eixt</code>释放。</li></ul><h3 id="3-8-NAND驱动的probe流程"><a href="#3-8-NAND驱动的probe流程" class="headerlink" title="3.8 NAND驱动的probe流程"></a>3.8 NAND驱动的probe流程</h3><ul><li><code>probe</code> 函数就会与NAND芯片进行，主要做的事情主要包括这几个方面：读取NAND芯片的ID ，然后查表得到这片NAND芯片的如厂商，page size，erase size以及chip size等信息，接着根据<code>struct nand_chip</code> 中<code>options</code>的值的不同，或者在NAND 芯片中的特定位置查找<code>bad block table</code>，或者scan整个NAND 芯片，并在内存中建立<code>bad block table</code>。说起来复杂，但其实所有的这些动作，都可以在MTD提供的一个叫做<code>nand_scan</code>的函数中完成。</li></ul><h3 id="3-9-Linux驱动开发中，常用的调试方法有哪些？"><a href="#3-9-Linux驱动开发中，常用的调试方法有哪些？" class="headerlink" title="3.9 Linux驱动开发中，常用的调试方法有哪些？"></a>3.9 Linux驱动开发中，常用的调试方法有哪些？</h3><ul><li><p>利用<code>printk</code>，查看OOP消息，利用<code>strace</code>，利用内核内置的<code>hacking</code>选项，利用<code>ioctl</code>方法，利用<code>/proc</code> 文件系统，使用<code>kgdb</code>。</p></li><li><p><code>strace</code> 是一个可用于诊断、调试和教学的 Linux 用户空间跟踪器，监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。</p></li><li><p><code>ioctl</code> 是设备驱动程序中设备控制接口函数，一个字符设备驱动通常会实现设备打开、关闭、读、写等功能，在一些需要细分的情境下，如果需要扩展新的功能，通常以增设<code>ioctl()</code>命令的方式实现。</p><blockquote><p>建议大家，亲手动手调试下。面试中，很大可能会问你，在写驱动过程中遇到了什么问题的，如何解决的？如果你能讲出以上几种调试方法中的一两种，一定会让面试官刮目相看！</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
            <tag> 内核编程 </tag>
            
            <tag> Linux系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2024/06/06/test/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/06/06/test/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>让所有很久很久以前都走到幸福结局的时刻</strong></p><h1 id="写嵌入式用的到数据结构吗？"><a href="#写嵌入式用的到数据结构吗？" class="headerlink" title="写嵌入式用的到数据结构吗？"></a>写嵌入式用的到数据结构吗？</h1><p>看下linux内核就知道了，一堆数据结构，不学习数据结构，linux内核就看不懂了</p><p>使用数据结构是为了使代码结构更清晰，更容易把握代码结构、逻辑。</p><p>几个应用场景</p><ol><li><p>“数组”。你肯定用过吧，属于数据结构“线性表”的一种形式。</p><p><img src="/2024/06/06/test/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20241112202136552.png" alt="image-20241112202136552" style="zoom:50%;"><img src="/2024/06/06/test/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20241112202215843.png" alt="image-20241112202215843" style="zoom:50%;"></p></li><li><p>“结构体”。学习过lwip可以知道从以太网上接收一堆数据后，把数据头的地址幅值给以太网包的数据结构定义的指针，可以直接使用此指针-&gt;成员变量的方式，使用接收到的数据。比使用一堆变量来利用接收到的数据方便太多了。</p></li><li><p>“队列”。热敏电阻测温，单片机用ADC测量电阻分压电压，然后对测量值用平滑均值滤波算法滤波，此时会用到“队列”，或用“环形队列”；</p></li><li><p>“树”。项目中经常会使用液晶屏作为显示，其中文本菜单有时用的比较多的一种方式，其中文本菜单常用“树”结构来实现。</p></li><li><p>“栈”。就不用说了，你已经用过了，不过不是你主动用的，它隐藏在你每次函数调用、中断调用中，可能你没有意识到。</p></li></ol><p>简单几个例子，说明了数据结构非常常见，这个是必须要学的，不过有些不常用，比如图。</p><h3 id="1-【简答题】请写出至少两种野指针的成因"><a href="#1-【简答题】请写出至少两种野指针的成因" class="headerlink" title="1.   【简答题】请写出至少两种野指针的成因"></a>1.   【简答题】请写出至少两种野指针的成因</h3><p>【答案】</p><p>（1）指针使用前未初始化</p><p>（2）指针越界访问</p><p>（3）指针指针已经释放的空间</p><h3 id="2-【简答题】非静态局部变量、全局变量、malloc-动态分配的内存分别存储在内存的什么区域。"><a href="#2-【简答题】非静态局部变量、全局变量、malloc-动态分配的内存分别存储在内存的什么区域。" class="headerlink" title="2.   【简答题】非静态局部变量、全局变量、malloc()动态分配的内存分别存储在内存的什么区域。"></a>2.   【简答题】非静态局部变量、全局变量、malloc()动态分配的内存分别存储在内存的什么区域。</h3><p>【答案】</p><p>（1）非静态局部变量存储在内存的栈区域。</p><p>（1）全局变量存储在内存的全局静态区。</p><p>（2）malloc()动态分配的内存存储在内存的堆区域。</p><h1 id="一、数据结构与算法的层次要求："><a href="#一、数据结构与算法的层次要求：" class="headerlink" title="一、数据结构与算法的层次要求："></a>一、数据结构与算法的层次要求：</h1><p>层次1：熟悉各种不同的数据结构：顺序表（一维数组）、链表、栈、队列；森林、树、二叉树；图等<br>      了解不同的数据结构的特点、如何存储、优缺点等</p><p>层次2：如何编写相关的代码，实现对应的数据结构。（需要考虑对应的增、删、改、查、长度、遍历等）</p><p>层次3：算法层面的训练。 —&gt; leetcode （力扣app）、牛客网等。 300+道打底</p><img src="https://s1.vika.cn/space/2024/11/12/bb5ee404f183423782032597b88580fc" alt="image-20241112200556715"><h1 id="二、针对于层次1："><a href="#二、针对于层次1：" class="headerlink" title="二、针对于层次1："></a>二、针对于层次1：</h1><ol><li><p>什么是数据结构？   datastructure   (D-&gt;S)</p><blockquote><p>数据 +  结构<br>数据：多个相同类型的数据或变量<br>结构：即关系<br>目的：为了更高效的访问数据</p></blockquote></li><li><p>数据结构中有哪些内容？即问研究方向？<br>研究方向1：数据之间的逻辑关系</p><blockquote><p>线性关系:（一对一的关系）。比如：顺序表、链表、栈、队列、数组、字符串、广义表等<br>非线性关系：集合关系、树形关系（一对多的关系）、图形关系（多对多的关系）</p></blockquote></li></ol><p>研究方向2：数据的存储结构（或物理结构）<br>    &gt; 基本的两种：顺序存储结构、链式存储结构<br>    &gt; 拓展的两种：索引存储结构、哈希存储结构(散列存储结构)<br>研究方向3：数据之间的运算：增、删、改、查(CRUD)</p><h1 id="三、具体的不同的数据结构的实现（对应着层次2）"><a href="#三、具体的不同的数据结构的实现（对应着层次2）" class="headerlink" title="三、具体的不同的数据结构的实现（对应着层次2）"></a>三、具体的不同的数据结构的实现（对应着层次2）</h1><ol><li><p>数组的实现和相关算法的封装。</p></li><li><p>链表的实现和相关算法的封装。</p><p>   ​                 优点                                      缺点</p><blockquote><p>数组 通过索引查找、修改效率高：O(1)  插入、删除的效率差：O(n)</p><p>​同样大小的内存，数组可以存储更多的数据  当数据存满时，需要考虑扩容</p></blockquote><blockquote><p>链表   插入、删除效率高：O(1) 通过索引查找、修改效率低：O(n)  </p><p>​ 不需要考虑扩容问题   同样大小的内存，链表存储的数据较数组少</p></blockquote></li></ol><h2 id="如何理解数据结构"><a href="#如何理解数据结构" class="headerlink" title="如何理解数据结构"></a>如何理解数据结构</h2><h4 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h4><p>1.数据结构定义：研究多个变量之间的结构，即数据与数据之间的关系。</p><p> 2.研究目的：高效地进行数据的操作，如增删改查。</p><h4 id="数据结构的主要内容"><a href="#数据结构的主要内容" class="headerlink" title="数据结构的主要内容"></a>数据结构的主要内容</h4><p>1.逻辑结构：研究数据之间的逻辑关系，分为集合关系、线性关系、树形关系和网状关系。 </p><p>2.存储结构：研究数据在实际编程语言中的存储方式，分为顺序存储和链式存储。 </p><p>3.运算：基于存储结构，研究数据的增删改查等操作。</p><h4 id="线性结构和非线性结构"><a href="#线性结构和非线性结构" class="headerlink" title="线性结构和非线性结构"></a>线性结构和非线性结构</h4><p>1.线性结构：如顺序表、链表、栈、队列、数组、广义表等。</p><p> 2.非线性结构：如集合、树、图等。</p><h4 id="存储结构的两种基本形式"><a href="#存储结构的两种基本形式" class="headerlink" title="存储结构的两种基本形式"></a>存储结构的两种基本形式</h4><p>1.顺序存储：将数据元素依次排列，通过数组等方式实现。 </p><p>2.链式存储：通过链表方式，每个元素包含指向下一个元素的指针。</p><p> 3.索引存储结构和哈希存储结构：基于顺序存储和链式存储的组合。</p><img src="https://s1.vika.cn/space/2024/11/12/ad74377b36704d109dd9765a42b58faa" alt="image-20241112202757865" style="zoom:50%;"><img src="/2024/06/06/test/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20241112202851334.png" alt="image-20241112202851334" style="zoom:50%;"><h1 id="线性结构之数组"><a href="#线性结构之数组" class="headerlink" title="线性结构之数组"></a>线性结构之数组</h1><p><strong>优</strong> <strong>点</strong></p><p>Ø 查找容易（通过下标），时间复杂度为O(1)。不需要额外申请或删除空间。</p><p>Ø 使用下标位置索引(index)十分高效的访问任意元素，修改快</p><p><img src="https://s1.vika.cn/space/2024/11/12/48ec67a0d691481bab93fce23ca5fb1f" alt="image-20241105203354020"></p><p><strong>缺</strong> <strong>点</strong></p><p>Ø 插入、删除元素难，效率低。（需要移动大量元素以使元素空间连续）。</p><p>Ø 插入操作平均需要移动n&#x2F;2个元素。</p><p>Ø 删除操作平均需要移动(n-1)&#x2F;2个元素。</p><p>​                             <img src="https://s1.vika.cn/space/2024/11/12/4dcfedcbb1a2444397856fa27a77c364" alt="image-20241105203403567">     </p><p>Ø 扩展相对繁琐。一方面需要确保能提供更大区域的连续内存空间，另一方面需要将原有数据复制到新的顺序表中。</p><p>1.1.1 功能定义</p><p>前文提到过数组这一数据结构的一个局限性是长度固定，本节我们来实现一个增强版的数组——可变长的动态数组，需要实现以下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化动态数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initDynamicArray</span><span class="params">(DynamicArray *<span class="built_in">array</span>, <span class="type">size_t</span> initialCapacity)</span></span><br><span class="line"><span class="comment">//释放动态数组内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyDynamicArray</span><span class="params">(DynamicArray *<span class="built_in">array</span>)</span></span><br><span class="line"><span class="comment">//调整动态数组内存大小</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">resizeDynamicArray</span><span class="params">(DynamicArray *<span class="built_in">array</span>, <span class="type">size_t</span> newCapacity)</span></span><br><span class="line"><span class="comment">//获取动态数组长度（元素个数）</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">getLength</span><span class="params">(<span class="type">const</span> DynamicArray *<span class="built_in">array</span>)</span></span><br><span class="line"><span class="comment">//在指定位置插入新元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertAt</span><span class="params">(DynamicArray *<span class="built_in">array</span>, <span class="type">size_t</span> index, <span class="type">int</span> element)</span></span><br><span class="line"><span class="comment">//在末尾插入新元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertEnd</span><span class="params">(DynamicArray *<span class="built_in">array</span>, <span class="type">int</span> element)</span></span><br><span class="line"><span class="comment">//删除指定位置的元素并返回被删除的元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteAt</span><span class="params">(DynamicArray *<span class="built_in">array</span>, <span class="type">size_t</span> index)</span></span><br><span class="line"><span class="comment">//删除末尾的元素并返回被删除的元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteEnd</span><span class="params">(DynamicArray *<span class="built_in">array</span>)</span></span><br><span class="line"><span class="comment">//遍历所有的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(DynamicArray *<span class="built_in">array</span>)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-1-1-实现原理"><a href="#1-1-1-实现原理" class="headerlink" title="1.1.1 实现原理"></a>1.1.1 实现原理</h2><p>可变长的动态数组是一种数据结构，它允许在运行时根据需要动态地调整数组的大小，而不需要提前指定固定的大小。这种动态数组通常被称为动态数组、动态分配数组、动态增长数组或动态内存数组。int arr[10];  </p><p>C语言中是通过使用指针和内存分配函数来实现动态数组，常见的内存分配函数是<code>malloc</code>、<code>realloc</code>和<code>free</code>。下面是一些相关的概念和操作：</p><p>（1）<strong>分配内存（malloc）：</strong> 在C语言中，可以使用<code>malloc</code>函数来分配一块指定大小的内存。例如，<code>int *arr = (int *)malloc(n * sizeof(int));</code> 将分配能够存储<code>n</code>个整数的内存空间。</p><p>（2）<strong>重新分配内存（realloc）：</strong> 如果需要改变动态数组的大小，可以使用<code>realloc</code>函数来重新分配内存。这允许你在保留原有数据的情况下扩展或缩小数组的大小。</p><p>（3）<strong>释放内存（free</strong>）： 当不再需要动态数组时，应使用<code>free</code>函数释放之前分配的内存，以避免内存泄露。à 内存溢出</p><p>代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态数组结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> *data;       <span class="comment">// 指向动态数组的指针</span></span><br><span class="line">    <span class="type">size_t</span> size;     <span class="comment">// 当前数组中的元素个数</span></span><br><span class="line">    <span class="type">size_t</span> capacity; <span class="comment">// 当前数组的容量（可以容纳的最大元素个数）</span></span><br><span class="line">&#125; DynamicArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化动态数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initDynamicArray</span><span class="params">(DynamicArray *<span class="built_in">array</span>, <span class="type">size_t</span> initialCapacity)</span></span><br><span class="line">&#123;     <span class="comment">//分配内存（malloc）</span></span><br><span class="line">    <span class="built_in">array</span>-&gt;data = (<span class="type">int</span> *)<span class="built_in">malloc</span>(initialCapacity * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配初始内存</span></span><br><span class="line">    <span class="built_in">array</span>-&gt;size = <span class="number">0</span>;       <span class="comment">// 初始化元素个数为0</span></span><br><span class="line">    <span class="built_in">array</span>-&gt;capacity = initialCapacity;     <span class="comment">// 设置初始容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放动态数组内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyDynamicArray</span><span class="params">(DynamicArray *<span class="built_in">array</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放内存（free）</span></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">array</span>-&gt;data);   <span class="comment">// 释放动态数组内存</span></span><br><span class="line">    <span class="built_in">array</span>-&gt;size = <span class="number">0</span>;     <span class="comment">// 重置元素个数为0</span></span><br><span class="line">    <span class="built_in">array</span>-&gt;capacity = <span class="number">0</span>; <span class="comment">// 重置容量为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整动态数组内存大小</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">resizeDynamicArray</span><span class="params">(DynamicArray *<span class="built_in">array</span>, <span class="type">size_t</span> newCapacity)</span></span><br><span class="line">&#123; <span class="comment">//重新分配内存（realloc）</span></span><br><span class="line">    <span class="built_in">array</span>-&gt;data = (<span class="type">int</span> *)<span class="built_in">realloc</span>(<span class="built_in">array</span>-&gt;data, newCapacity * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 调整数组内存大小  </span></span><br><span class="line">    <span class="built_in">array</span>-&gt;capacity = newCapacity;       <span class="comment">// 更新容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取动态数组长度（元素个数）</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">getLength</span><span class="params">(<span class="type">const</span> DynamicArray *<span class="built_in">array</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">array</span>-&gt;size; <span class="comment">// 返回数组中的元素个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置插入新元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertAt</span><span class="params">(DynamicArray *<span class="built_in">array</span>, <span class="type">size_t</span> index, <span class="type">int</span> element)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="built_in">array</span>-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 忽略无效的插入位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>-&gt;size &gt;= <span class="built_in">array</span>-&gt;capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> newCapacity = <span class="built_in">array</span>-&gt;capacity * <span class="number">2</span>; <span class="comment">// 如果容量不足，扩大容量</span></span><br><span class="line">        resizeDynamicArray(<span class="built_in">array</span>, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="built_in">array</span>-&gt;size; i &gt; index; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">array</span>-&gt;data[i] = <span class="built_in">array</span>-&gt;data[i - <span class="number">1</span>]; <span class="comment">// 后移元素以腾出插入位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">array</span>-&gt;data[index] = element; <span class="comment">// 在指定位置插入新元素</span></span><br><span class="line">    <span class="built_in">array</span>-&gt;size++;                <span class="comment">// 更新元素个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在末尾插入新元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertEnd</span><span class="params">(DynamicArray *<span class="built_in">array</span>, <span class="type">int</span> element)</span></span><br><span class="line">&#123;</span><br><span class="line">    insertAt(<span class="built_in">array</span>, <span class="built_in">array</span>-&gt;size, element); <span class="comment">// 在末尾插入新元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定位置的元素并返回被删除的元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteAt</span><span class="params">(DynamicArray *<span class="built_in">array</span>, <span class="type">size_t</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="built_in">array</span>-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 忽略无效的删除位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> deletedElement = <span class="built_in">array</span>-&gt;data[index]; <span class="comment">// 获取被删除的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = index; i &lt; <span class="built_in">array</span>-&gt;size - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">array</span>-&gt;data[i] = <span class="built_in">array</span>-&gt;data[i + <span class="number">1</span>]; <span class="comment">// 前移元素以填补删除位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">array</span>-&gt;size--; <span class="comment">// 更新元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> deletedElement; <span class="comment">// 返回被删除的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除末尾的元素并返回被删除的元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteEnd</span><span class="params">(DynamicArray *<span class="built_in">array</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> deleteAt(<span class="built_in">array</span>, <span class="built_in">array</span>-&gt;size - <span class="number">1</span>); <span class="comment">// 删除末尾的元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历所有的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(DynamicArray *<span class="built_in">array</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>-&gt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, <span class="built_in">array</span>-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    DynamicArray myArray; <span class="comment">// 声明动态数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化动态数组</span></span><br><span class="line">    initDynamicArray(&amp;myArray, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;初始化动态数组,初始容量为2\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向动态数组尾部插入元素</span></span><br><span class="line">    insertEnd(&amp;myArray, <span class="number">1</span>);</span><br><span class="line">    insertEnd(&amp;myArray, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;向动态数组尾部插入了2个元素\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印动态数组当前长度</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;动态数组当前长度:%zu\n&quot;</span>, getLength(&amp;myArray));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在索引1的位置插入元素3</span></span><br><span class="line">    insertAt(&amp;myArray, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;在索引1的位置插入元素3\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次打印动态数组当前长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;动态数组当前长度:%zu\n&quot;</span>, getLength(&amp;myArray));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除索引1的元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除索引1的元素,该元素是%d\n&quot;</span>, deleteAt(&amp;myArray, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除动态数组末尾元素</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除动态数组末尾元素,该元素是%d\n&quot;</span>, deleteEnd(&amp;myArray));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态数组内存</span></span><br><span class="line">    destroyDynamicArray(&amp;myArray);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;动态数组内存释放完成\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="1-1-线性结构之链表"><a href="#1-1-线性结构之链表" class="headerlink" title="1.1 线性结构之链表"></a>1.1 线性结构之链表</h1><p>1.1.1 链表是什么</p><p>链表的主要特点包括：</p><ol><li><strong>动态大小</strong>：链表可以根据需要动态调整大小，不需要预先分配固定的内存空间。</li><li><strong>插入和删除效率高</strong>：在已知位置插入或删除元素时，链表不需要移动其他元素，只需调整指针即可。</li><li><strong>顺序访问</strong>：链表不支持随机访问，要访问链表中的某个元素，必须从头节点开始逐个遍历。</li></ol><p>链表有几种常见的类型：</p><ul><li><strong>单向链表</strong>：每个节点只指向下一个节点。</li><li><strong>双向链表</strong>：每个节点有两个指针，分别指向前一个节点和后一个节点。</li><li><strong>循环链表</strong>：链表的最后一个节点指向第一个节点，形成一个环。</li></ul><p><img src="https://s1.vika.cn/space/2024/11/12/65ec27aa9d2548efbe0342f9a53b9878" alt="image-20241108184735610"></p><p><strong>相关概念</strong></p><p>n个结点离散分配，彼此通过指针相连，每个结点只有一个前驱结点，每个结点只有一个后续结点，头结点没有前驱结点，尾结点没有后续结点。确定一个链表我们只需要头指针，通过头指针就可以把整个链表都能推出来。</p><p>1）优点</p><p>（1）插入和删除操作效率高。</p><p>（2）动态扩展性能更好，链表不需要像数组那样预先指定固定的大小，而是可以随时动态的增长或缩小。链表是真正的动态数据结构，不需要处理固定容量的问题。</p><p>2）缺点</p><p>（1）查找慢。由于链表中的结点不是连续存储的，无法像数组一样根据索引直接计算出每个结点的地址。必须从头结点开始遍历链表，直到找到目标结点，这导致了链表的随机访问效率较低。</p><p>（2）额外的存储空间。链表的每个结点都需要存储指向下一个结点的指针，这会占用额外的存储空间。所以，相比于数组，链表需要更多的内存空间来存储相同数量的数据元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">初始化链表</span><br><span class="line"><span class="type">void</span> <span class="title function_">initLinkedList</span><span class="params">(LinkedList *<span class="built_in">list</span>)</span></span><br><span class="line">返回链表的长度</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">getLength</span><span class="params">(<span class="type">const</span> LinkedList *<span class="built_in">list</span>)</span></span><br><span class="line">在指定位置插入元素</span><br><span class="line"><span class="type">void</span> <span class="title function_">insertAt</span><span class="params">(LinkedList *<span class="built_in">list</span>, <span class="type">size_t</span> index, <span class="type">int</span> element)</span></span><br><span class="line">在末尾插入元素</span><br><span class="line"><span class="type">void</span> <span class="title function_">insertEnd</span><span class="params">(LinkedList *<span class="built_in">list</span>, <span class="type">int</span> element)</span></span><br><span class="line">删除指定位置的元素并返回被删除的元素</span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteAt</span><span class="params">(LinkedList *<span class="built_in">list</span>, <span class="type">size_t</span> index)</span></span><br><span class="line">删除末尾元素</span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteEnd</span><span class="params">(LinkedList *<span class="built_in">list</span>)</span></span><br><span class="line">获取指定位置的元素</span><br><span class="line"><span class="type">int</span> <span class="title function_">getElementAt</span><span class="params">(<span class="type">const</span> LinkedList *<span class="built_in">list</span>, <span class="type">size_t</span> index)</span></span><br><span class="line">修改指定位置的元素</span><br><span class="line"><span class="type">void</span> <span class="title function_">modifyAt</span><span class="params">(LinkedList *<span class="built_in">list</span>, <span class="type">size_t</span> index, <span class="type">int</span> newValue)</span></span><br><span class="line">释放链表内存</span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyLinkedList</span><span class="params">(LinkedList *<span class="built_in">list</span>)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">自定义链表结构</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义存储数据的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> data;          <span class="comment">// 存储的数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下个元素的指针</span></span><br><span class="line"></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义虚拟头结点的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> size;   <span class="comment">// 记录单链表中存储的数据的个数</span></span><br><span class="line">    Node *next; <span class="comment">// 指向保存数据的首元素</span></span><br><span class="line">&#125; LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 明确：在包含虚拟头结点的情况下，首个保存数据的结点的索引为0！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initLinkedList</span><span class="params">(LinkedList *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化LinkedList内部的成员</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回链表的长度</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">getLength</span><span class="params">(<span class="type">const</span> LinkedList *<span class="built_in">list</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置插入元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertAt</span><span class="params">(LinkedList *<span class="built_in">list</span>, <span class="type">size_t</span> index, <span class="type">int</span> element)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="built_in">list</span>-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入的index数据非法\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入数据的过程</span></span><br><span class="line">    <span class="comment">// 1. 将数据封装到Node结构体的变量中</span></span><br><span class="line">    Node *node = (Node *)<span class="built_in">malloc</span>(<span class="number">1</span> * <span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;data = element;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 找到index的位置进行插入操作</span></span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        node-&gt;next = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">        <span class="built_in">list</span>-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Node *currentNode = <span class="built_in">list</span>-&gt;next; <span class="comment">// 指向有数据的首元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; index - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            currentNode = currentNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node-&gt;next = currentNode-&gt;next;</span><br><span class="line">        currentNode-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在末尾插入元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertEnd</span><span class="params">(LinkedList *<span class="built_in">list</span>, <span class="type">int</span> element)</span></span><br><span class="line">&#123;</span><br><span class="line">    insertAt(<span class="built_in">list</span>, <span class="built_in">list</span>-&gt;size, element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定位置的元素并返回被删除的元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteAt</span><span class="params">(LinkedList *<span class="built_in">list</span>, <span class="type">size_t</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">list</span>-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入的index不合法\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> deleteElement;</span><br><span class="line">    Node *deleteNode;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        deleteNode = <span class="built_in">list</span>-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">list</span>-&gt;next = deleteNode-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取要删除的node的数据</span></span><br><span class="line">        deleteElement = deleteNode-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node *currentNode = <span class="built_in">list</span>-&gt;next; <span class="comment">// 指向有数据的首元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; index - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            currentNode = currentNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deleteNode = currentNode-&gt;next;</span><br><span class="line">        currentNode-&gt;next = deleteNode-&gt;next;</span><br><span class="line"></span><br><span class="line">        deleteElement = deleteNode-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(deleteNode); <span class="comment">// 释放node的内存空间</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">list</span>-&gt;size--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> deleteElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除末尾元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteEnd</span><span class="params">(LinkedList *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    deleteAt(<span class="built_in">list</span>,<span class="built_in">list</span>-&gt;size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定位置的元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getElementAt</span><span class="params">(<span class="type">const</span> LinkedList *<span class="built_in">list</span>, <span class="type">size_t</span> index)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">list</span>-&gt;size)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入的index不合法\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node * currentNode = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; index ;i++)&#123;</span><br><span class="line">        currentNode = currentNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> currentNode-&gt;data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改指定位置的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">modifyAt</span><span class="params">(LinkedList *<span class="built_in">list</span>, <span class="type">size_t</span> index, <span class="type">int</span> newValue)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt;= <span class="built_in">list</span>-&gt;size)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入的index不合法\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node * currentNode = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; index ;i++)&#123;</span><br><span class="line">        currentNode = currentNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentNode-&gt;data = newValue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放链表内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyLinkedList</span><span class="params">(LinkedList *<span class="built_in">list</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Node *currentNode = <span class="built_in">list</span>-&gt;next;  <span class="comment">//找到有数据的第1个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">list</span>-&gt;size;i++)&#123;</span><br><span class="line"></span><br><span class="line">        Node *tempNode = currentNode;</span><br><span class="line">        currentNode = currentNode-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(tempNode);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//辅助操作</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    LinkedList <span class="built_in">list</span>;</span><br><span class="line">    initLinkedList(&amp;<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    insertAt(&amp;<span class="built_in">list</span>,<span class="number">0</span>,<span class="number">10</span>);</span><br><span class="line">    insertAt(&amp;<span class="built_in">list</span>,<span class="number">0</span>,<span class="number">20</span>);</span><br><span class="line">    insertAt(&amp;<span class="built_in">list</span>,<span class="number">0</span>,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> count = getLength(&amp;<span class="built_in">list</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,count);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    getchar();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放链表内存-有什么用"><a href="#释放链表内存-有什么用" class="headerlink" title="释放链表内存 有什么用"></a>释放链表内存 有什么用</h3><p>释放链表内存”的主要用途在于管理动态分配的内存，确保程序运行期间不会造成内存泄漏。下面是这一过程的重要性和作用：</p><ol><li><strong>防止内存泄漏</strong>：在程序中动态申请的内存（例如，通过 <code>malloc</code>）需要在不再使用时及时释放。如果在不再需要链表时不释放内存，程序会占用不必要的内存资源，从而导致内存泄漏。</li><li><strong>优化内存使用</strong>：及时释放内存可以确保系统资源的有效使用，特别是在运行长时间的程序或需要频繁创建和销毁对象的情况下。</li><li><strong>防止悬挂指针</strong>：在释放链表内存的同时，设置指向链表的指针（如头指针）为 <code>NULL</code> 坏境，可以避免访问已释放内存的风险。这有助于防止程序在试图访问无效内存时造成的未定义行为。</li><li><strong>提高程序稳定性</strong>：良好的内存管理使得程序更加稳定和健壮，降低了崩溃的概率。</li></ol><h1 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h1><p>特点：<code>后进先出</code> (LIFO，Last In First Out)或<code>先进后出</code> (FILO，First In Last Out)的线性表。</p><p> 栈顶(Top)：允许进行插入、删除操作的一端，又称为<code>表尾</code>。栈顶由一个称为栈顶指针的位置指示器（其实就是一个变量）来指示，它是动态变化的。</p><p>- 栈底(Bottom)：是固定不变的，不允许进行插入和删除的一端，又称为<code>表头</code>。</p><p>- 空栈：不含任何元素的空表。</p><p>- 设栈S&#x3D;(a1,a2,…,an )，则a1称为栈底元素，an为栈顶元素，栈中元素按a1,a2,…,a_n的次序进栈(压栈、push)，出栈(弹栈，pop)的第一个元素应为栈顶元素，出栈顺序为：an,…,a2,a1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">初始化栈</span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(Stack *<span class="built_in">stack</span>, <span class="type">size_t</span> capacity)</span></span><br><span class="line">返回栈内元素个数</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">getSize</span><span class="params">(<span class="type">const</span> Stack *<span class="built_in">stack</span>)</span></span><br><span class="line">添加新元素</span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack *<span class="built_in">stack</span>, <span class="type">int</span> element)</span></span><br><span class="line">在末尾插入元素</span><br><span class="line"><span class="type">void</span> <span class="title function_">insertEnd</span><span class="params">(LinkedList *<span class="built_in">list</span>, <span class="type">int</span> element)</span></span><br><span class="line">栈顶元素出栈并返回</span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span></span><br><span class="line">释放栈内存</span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyStack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  自定义实现栈结构：使用顺序存储结构实现--&gt; 顺序栈</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储数据的指针</span></span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">    <span class="comment">//指明存储容器的容量</span></span><br><span class="line">    <span class="type">size_t</span> capacity;</span><br><span class="line">    <span class="comment">//指明存储容器中实际存储的数据量</span></span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initStack</span><span class="params">(Stack *<span class="built_in">stack</span>, <span class="type">size_t</span> capacity)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;data = (<span class="type">int</span> *)<span class="built_in">malloc</span>(capacity *<span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//动态内存分配</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stack</span>-&gt;data == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>-&gt;capacity = capacity;         </span><br><span class="line">    <span class="built_in">stack</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回栈内元素个数</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">getSize</span><span class="params">(<span class="type">const</span> Stack *<span class="built_in">stack</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack *<span class="built_in">stack</span>, <span class="type">int</span> element)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//考虑是否存满了</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stack</span>-&gt;size == <span class="built_in">stack</span>-&gt;capacity)&#123;</span><br><span class="line">        <span class="comment">//扩容</span></span><br><span class="line">        resizeCapacity(<span class="built_in">stack</span>,<span class="built_in">stack</span>-&gt;capacity + <span class="built_in">stack</span>-&gt;capacity &gt;&gt; <span class="number">1</span>); <span class="comment">//扩容为原来的1.5倍</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;容量已满，进行扩容操作\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;size] = element;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;size++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">resizeCapacity</span><span class="params">(Stack *<span class="built_in">stack</span>,<span class="type">int</span> newCapacity)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>-&gt;data = (<span class="type">int</span> *)<span class="built_in">realloc</span>(<span class="built_in">stack</span>-&gt;data,newCapacity * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">//扩容操作</span></span><br><span class="line">    <span class="built_in">stack</span>-&gt;capacity = newCapacity; <span class="comment">//指明新的容量值</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶元素出栈并返回</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//判断是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">stack</span>-&gt;size == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;当前栈为空,弹栈失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// int popElement = stack-&gt;data[stack-&gt;size-1];</span></span><br><span class="line">    <span class="comment">// stack-&gt;size--;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// return popElement;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[--<span class="built_in">stack</span>-&gt;size];<span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//这是一个前缀自减操作。它的作用是将 stack-&gt;size 的值减一，然后返回这个新的值。</span></span><br><span class="line"><span class="comment">//例如，如果 stack-&gt;size 原本是 3，经过 --stack-&gt;size 处理后，</span></span><br><span class="line"><span class="comment">//stack-&gt;size 会变为 2。这意味着我们将要弹出栈中索引为 2 的元素（即第三个元素，因为索引从 0 开始）。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放栈内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyStack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">stack</span>-&gt;data);</span><br><span class="line">    <span class="built_in">stack</span>-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;capacity = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历栈中的元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(Stack *<span class="built_in">stack</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="built_in">stack</span>-&gt;size;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,<span class="built_in">stack</span>-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明结构体变量</span></span><br><span class="line">    Stack myStack;</span><br><span class="line"></span><br><span class="line">    initStack(&amp;myStack,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    push(&amp;myStack,<span class="number">1</span>);</span><br><span class="line">    push(&amp;myStack,<span class="number">2</span>);</span><br><span class="line">    push(&amp;myStack,<span class="number">3</span>);</span><br><span class="line">    push(&amp;myStack,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈中元素的个数为：%d\n&quot;</span>,getSize(&amp;myStack));</span><br><span class="line"></span><br><span class="line">    print(&amp;myStack);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;弹栈，弹出的数据是：%d\n&quot;</span>,pop(&amp;myStack));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;弹栈，弹出的数据是：%d\n&quot;</span>,pop(&amp;myStack));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print(&amp;myStack);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线性结构之队列"><a href="#线性结构之队列" class="headerlink" title="线性结构之队列"></a>线性结构之队列</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>队列(Queue)：也是操作受限的线性表，限制为仅允许在表的一端进行插入(入队或进队），在表的另一端进行删除(出队或离队)操作。</p><p>- 队首(front) ：允许进行删除的一端称为队首。</p><p>- 队尾(rear)： 允许进行插入的一端称为队尾。</p><p>在空队列中依次加入元素a1,a2, …, an之后，a1是队首元素，an是队尾元素。显然退出队列的次序也只能是a1,a2, …, an。队列，是一种先进先出(First In First Out ，简称FIFO)的线性结构。类似于生活中的排队行为。</p><p><img src="https://s1.vika.cn/space/2024/11/12/b4e17e3fbd7d4f78815a4f01eb85cb5f" alt="image-20241111205010221"></p><p>队列中没有元素时，称为空队列。</p><h3 id="队列的存储结构"><a href="#队列的存储结构" class="headerlink" title="队列的存储结构"></a>队列的存储结构</h3><p>可用顺序表(数组)和链表来存储队列，队列按存储结构可分为顺序队列和链式队列两种。</p><h3 id="功能定义"><a href="#功能定义" class="headerlink" title="功能定义"></a>功能定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">初始化队列</span><br><span class="line"><span class="type">void</span> <span class="title function_">initQueue</span><span class="params">(Queue *<span class="built_in">queue</span>, <span class="type">size_t</span> capacity)</span></span><br><span class="line">返回队列内元素个数</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">getSize</span><span class="params">(<span class="type">const</span> Queue *<span class="built_in">queue</span>)</span></span><br><span class="line">添加新元素</span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span><span class="params">(Queue *<span class="built_in">queue</span>, <span class="type">int</span> element)</span></span><br><span class="line">元素出队列</span><br><span class="line"><span class="type">int</span> <span class="title function_">dequeue</span><span class="params">(Queue *<span class="built_in">queue</span>)</span></span><br><span class="line">释放队列内存</span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyQueue</span><span class="params">(Queue *<span class="built_in">queue</span>)</span></span><br><span class="line">遍历队列</span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Queue *<span class="built_in">queue</span>)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    自定义结构实现队列：使用循环队列</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明队列对应的结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *data;</span><br><span class="line">    <span class="type">int</span> capacity; <span class="comment">//记录存储的最大容量</span></span><br><span class="line">    <span class="type">int</span> size ; <span class="comment">//记录存储的元素的个数</span></span><br><span class="line">    <span class="type">int</span> front ;  <span class="comment">//记录要出队的索引位置</span></span><br><span class="line">    <span class="type">int</span> rear;  <span class="comment">//记录入队后的索引位置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initQueue</span><span class="params">(Queue *<span class="built_in">queue</span>, <span class="type">size_t</span> capacity)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;data = (<span class="type">int</span> *)<span class="built_in">malloc</span>(capacity * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;capacity = capacity;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回队列内元素个数</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">getSize</span><span class="params">(<span class="type">const</span> Queue *<span class="built_in">queue</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加新元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span><span class="params">(Queue *<span class="built_in">queue</span>, <span class="type">int</span> element)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>-&gt;size == <span class="built_in">queue</span>-&gt;capacity)&#123;</span><br><span class="line">        <span class="comment">//容量已满</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列已满，入队失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>-&gt;data[<span class="built_in">queue</span>-&gt;rear] = element;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size++;</span><br><span class="line">    <span class="comment">//queue-&gt;rear++; //存在问题，需要使用下面的方式替换</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = (<span class="built_in">queue</span>-&gt;rear + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素出队列</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dequeue</span><span class="params">(Queue *<span class="built_in">queue</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// if(queue-&gt;front == queue-&gt;rear);//此语句满足的情况：① 队列为空 ② 队列已满</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>-&gt;size == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空，出队失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dequeueData = <span class="built_in">queue</span>-&gt;data[<span class="built_in">queue</span>-&gt;front];</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size--;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = (<span class="built_in">queue</span>-&gt;front + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dequeueData;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放队列内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyQueue</span><span class="params">(Queue *<span class="built_in">queue</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>-&gt;data);</span><br><span class="line">    <span class="built_in">queue</span>-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;capacity = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printQueue</span><span class="params">(Queue *<span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="built_in">queue</span>-&gt;front,j = <span class="number">0</span>;j &lt; <span class="built_in">queue</span>-&gt;size;i++,j++)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,<span class="built_in">queue</span>-&gt;data[i % <span class="built_in">queue</span>-&gt;capacity]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Queue myQueue;</span><br><span class="line"></span><br><span class="line">    initQueue(&amp;myQueue,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    enqueue(&amp;myQueue,<span class="number">1</span>);</span><br><span class="line">    enqueue(&amp;myQueue,<span class="number">2</span>);</span><br><span class="line">    enqueue(&amp;myQueue,<span class="number">3</span>);</span><br><span class="line">    enqueue(&amp;myQueue,<span class="number">4</span>); <span class="comment">//已满，未入队</span></span><br><span class="line"></span><br><span class="line">    printQueue(&amp;myQueue);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出队，元素是：%d\n&quot;</span>,dequeue(&amp;myQueue));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出队，元素是：%d\n&quot;</span>,dequeue(&amp;myQueue));</span><br><span class="line"></span><br><span class="line">    printQueue(&amp;myQueue);</span><br><span class="line"></span><br><span class="line">    enqueue(&amp;myQueue,<span class="number">5</span>);</span><br><span class="line">    enqueue(&amp;myQueue,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    printQueue(&amp;myQueue);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p><img src="https://s1.vika.cn/space/2024/11/12/72fe34dc1658472cbf5d14212e1506e3" alt="image-20241112175354551"></p><p>假设一个 int 变量占 4个字节，则所需内存空间 &#x3D; 4 + 4 &#x3D; 8，则S(n) &#x3D; O(1)。</p><p><img src="https://s1.vika.cn/space/2024/11/12/4c26e3b872e54932aeac50b4e0cfc5b9" alt="image-20241112175523230"></p><p>假设一个 int 变量占 4个字节，则所需内存空间 &#x3D; 4 + 4n + 4 &#x3D; 4n + 8，则S(n) &#x3D; O(n)。</p><p><img src="https://s1.vika.cn/space/2024/11/12/18bb9907b97d432b83b835a8f999c8d4" alt="image-20241112175532793"></p><p><img src="https://s1.vika.cn/space/2024/11/12/2cb283d076a04171acfea6e1c3b8b96d" alt="image-20241112175538936"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找:"></a>顺序查找:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 顺序查找:</span><br><span class="line">int sequenceSearch(int arr[], int size, int target)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    for(int i = 0;i &lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(arr[i] == target)</span><br><span class="line">        &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return -1; //表示没有找到指定的元素 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int arr[] = &#123;23,45,76,44,22,88,9,12,22,5,80&#125;;</span><br><span class="line"></span><br><span class="line">    int size = sizeof(arr) / sizeof(int);</span><br><span class="line"></span><br><span class="line">    int target = 9;</span><br><span class="line"></span><br><span class="line">    int targetIndex = sequenceSearch(arr,size,target);</span><br><span class="line">    if(targetIndex == -1)&#123;</span><br><span class="line">        printf(&quot;未找到\n&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;找到了%d，对应的索引为%d\n&quot;,target,targetIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sizeof是运算符，返回 unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。<br>它的功能是：获得保证能容纳实现所建立的最大对象的字节大小</p><p>sizeof(ary) &#x2F; sizeof(int) &lt;&#x3D;&#x3D;&gt; sizeof(ary) &#x2F; sizeof(ary[0]) ; 得到 ary 内的元素的个数</p><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>二分查找（Binary Search）是一种高效的搜索算法，通常用于有序数据集中查找目标元素。其原理是通过将数据集划分为两半并与目标进行比较，以确定目标在哪一半中，从而逐步缩小搜索范围，直到找到目标元素或确定不存在。基本原理如下：</p><p>（1）<strong>选择中间元素：</strong> 在有序数据集中，选择数组的中间元素。</p><p>（1）<strong>比较目标：</strong> 将中间元素与目标元素进行比较。</p><p>（2）<strong>查找成功：</strong> 如果中间元素等于目标元素，则查找成功，返回中间元素的索引。</p><p>（3）<strong>缩小搜索范围：</strong> 对于一个升序的数据集，如果中间元素大于目标元素，说明目标可能在左半部分；如果中间元素小于目标元素，说明目标可能在右半部分。根据比较结果，将搜索范围缩小到一半，继续查找。</p><p>（4）<strong>重复步骤：</strong> 重复上述步骤，不断将搜索范围缩小，直到找到目标元素或搜索范围为空。</p><p>​                                   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    使用二分查找法，查找数组中的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> size,<span class="type">int</span> target)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> high = size - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> middle = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arr[middle] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> middle;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[middle] &gt; target)&#123;</span><br><span class="line">            high = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            low = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示未找到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">4</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">16</span>,<span class="number">19</span>,<span class="number">22</span>,<span class="number">28</span>,<span class="number">34</span>,<span class="number">57</span>,<span class="number">69</span>,<span class="number">78</span>,<span class="number">90</span>&#125;;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">12</span>;</span><br><span class="line">    target = <span class="number">91</span>;</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> targetIndex = binarySearch(arr,size,target);</span><br><span class="line">    <span class="keyword">if</span>(targetIndex == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;未找到\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到了%d，对应的索引为%d\n&quot;</span>,target,targetIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    冒泡排序:实现从小到大排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> size)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//外层循环：控制轮数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size - <span class="number">1</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//内层循环：依次比较相邻的两个元素的大小</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; size - <span class="number">1</span> - i;j++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//交互j 和 j+1索引位置的元素</span></span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">23</span>,<span class="number">45</span>,<span class="number">2</span>,<span class="number">46</span>,<span class="number">77</span>,<span class="number">2</span>,<span class="number">99</span>,<span class="number">-9</span>,<span class="number">-32</span>,<span class="number">0</span>,<span class="number">66</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line">    bubbleSort(arr,size);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    快速排序:实现从小到大排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    subSort(arr, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">subSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> base = arr[start];</span><br><span class="line">        <span class="type">int</span> low = start;</span><br><span class="line">        <span class="type">int</span> high = end + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (low &lt; end &amp;&amp; arr[++low] &lt;= base)</span><br><span class="line">                ; <span class="comment">// 找到从前往后第1个比base大的元素</span></span><br><span class="line">            <span class="keyword">while</span> (high &gt; start &amp;&amp; arr[--high] &gt;= base)</span><br><span class="line">                ; <span class="comment">// 找到从后往前第1个比base小的元素</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (low &lt; high)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 交换low和high位置的元素</span></span><br><span class="line">                <span class="type">int</span> temp = arr[low];</span><br><span class="line">                arr[low] = arr[high];</span><br><span class="line">                arr[high] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 交换start和high索引位置上的元素</span></span><br><span class="line">        <span class="type">int</span> temp1 = arr[start];</span><br><span class="line">        arr[start] = arr[high];</span><br><span class="line">        arr[high] = temp1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归调用</span></span><br><span class="line">        subSort(arr, start, high - <span class="number">1</span>); <span class="comment">// 前半段继续排序</span></span><br><span class="line">        subSort(arr, high + <span class="number">1</span>, end);   <span class="comment">// 后半段继续排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">23</span>, <span class="number">45</span>, <span class="number">2</span>, <span class="number">46</span>, <span class="number">77</span>, <span class="number">2</span>, <span class="number">99</span>, <span class="number">-9</span>, <span class="number">-32</span>, <span class="number">0</span>, <span class="number">66</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    quickSort(arr, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
