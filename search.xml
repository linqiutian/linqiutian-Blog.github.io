<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2025/06/25/test/RS485%E5%92%8Cmodbus/"/>
      <url>/2025/06/25/test/RS485%E5%92%8Cmodbus/</url>
      
        <content type="html"><![CDATA[<p>RS485是一种硬件接口标准，提供差分信号传输方式，具有长距离（可达1200米）、抗干扰能力强和多点通信（最多32个节点）的特点。它定义了设备之间的物理连接方式，但不涉及具体的数据协议。</p><p>Modbus是一种应用层协议，规定了设备间的数据传输格式和操作规则，支持多种版本（如RTU、TCP），主要实现主从通信模式。它依赖于RS485等物理接口进行数据传输，但也可以在其他接口上实现。</p><p>两者的关系是：RS485作为物理基础，为Modbus提供了硬件连接媒介；而Modbus则在RS485之上，实现标准化的数据通信和设备互操作。</p><p>在实际应用中，常见的组合是：设备通过RS485接口连接，再利用Modbus协议进行数据交换。这种协同工作极大简化了工业自动化系统的集成与维护，提升了系统的可靠性和扩展性。</p><p>简而言之，RS485是硬件基础，Modbus是通信协议，二者配合实现工业设备的高效、可靠通信。理解它们的区别和协作方式，有助于优化工业自动化控制方案。</p><h1 id="温湿度传感器怎么调试"><a href="#温湿度传感器怎么调试" class="headerlink" title="温湿度传感器怎么调试"></a>温湿度传感器怎么调试</h1><p>温湿度传感器作为现代环境监测系统中不可或缺的一部分，其准确性和稳定性直接影响到数据的可靠性与后续分析的精准度。因此，正确的调试过程对于确保传感器性能至关重要。以下将详细介绍温湿度传感器调试的步骤、注意事项及常见问题解决方案，帮助用户高效完成调试工作。</p><p>温湿度传感器怎么调试</p><p>　　一、调试前准备</p><p>　　1. 检查设备完整性</p><p>　　- 确保温湿度传感器及其配件(如连接线、固定支架等)完好无损，无明显的物理损伤或腐蚀。</p><p>　　- 检查传感器型号与所需应用场景是否匹配，确保精度、测量范围等参数符合需求。</p><p>　　2. 阅读并理解说明书</p><p>　　- 仔细阅读传感器附带的使用说明书，了解传感器的基本参数、性能指标、接线方式及调试步骤。</p><p>　　- 注意说明书中的安全警示，确保调试过程中的人身安全及设备安全。</p><p>　　3. 准备调试工具</p><p>　　- 准备必要的调试工具，如万用表、示波器(对于高级调试)、标准温湿度源(校准用)等。</p><p>　　- 确保所有工具均在有效期内，并校准至准确状态。</p><p>二、硬件连接与检查</p><p>　　1. 接线</p><p>　　- 按照说明书中的接线图正确连接传感器与数据采集系统或显示设备。注意区分电源线、信号线及可能的接地线，避免接错。</p><p>　　- 使用绝缘胶带或线束固定好接线，防止松动或短路。</p><p>　　2. 供电检查</p><p>　　- 确认传感器供电电压符合规格要求，使用万用表测量电源电压，确保稳定且无波动。</p><p>　　- 观察传感器指示灯(如果有的话)，确认其正常工作状态。</p><p>三、软件配置与调试</p><p>　　1. 初始化设置</p><p>　　- 通过数据采集软件或控制系统，对传感器进行初始化设置，包括地址配置(对于支持多传感器网络的系统)、采样频率、测量范围等。</p><p>　　- 设定报警阈值，以便在温湿度超出正常范围时及时发出警报。</p><p>　　2. 静态校准</p><p>　　- 使用标准温湿度源(如恒温恒湿箱)作为参考，将传感器置于其中，设置标准温湿度值。</p><p>　　- 等待传感器稳定后，读取并记录其输出值，与标准值进行比较，调整传感器内部的校准参数，直至输出值接近或等于标准值。</p><p>　　3. 动态测试</p><p>　　- 在不同温湿度条件下对传感器进行动态测试，观察其响应速度、稳定性及精度。</p><p>在我的项目中，我基于<strong>STM32F103C8T6单片机</strong>，集成<strong>TJA1050-CAN通信模块</strong>与<strong>DS18B20温度传感器</strong>，搭建了完整的CAN总线温度采集报警系统。</p><p><strong>具体做法如下：</strong><br>首先，我利用STM32F103C8T6的强大处理能力，实现DS18B20多点温度数据采集。通过TJA1050模块，将采集到的温度数据实时打包成CAN报文，按照设定的节点ID有序发送到总线。系统软件层面，我设计了温度阈值判断和多级报警逻辑，确保一旦某路温度超限，能立即触发声光报警，同时将报警信息通过CAN总线广播。<br>为方便调试与数据分析，我还通过USB-TTL（CH340）模块将STM32串口数据实时上传至电脑，配合串口调试助手进行数据监控和系统参数调整。</p><p><strong>项目成果：</strong><br>该系统投入现场后，温度异常检测准确率提升至99%，报警响应时间缩短50%，有效防止了设备过热导致的停机和损坏，显著提升了设备运行的安全性与稳定性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/06/16/test/BSP%E5%A4%A7%E4%BD%9C%E4%B8%9A/"/>
      <url>/2025/06/16/test/BSP%E5%A4%A7%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<p>BSP大作业</p><p> [BSP前置培养大作业.pdf](H:\123\新建文件夹\WeChat Files\wxid_m7uts4kc8omo22\FileStorage\TempFromPhone\BSP前置培养大作业.pdf) </p><h1 id="虚拟机配置Ubuntu20-04"><a href="#虚拟机配置Ubuntu20-04" class="headerlink" title="虚拟机配置Ubuntu20.04"></a>虚拟机配置Ubuntu20.04</h1><p><a href="https://www.bilibili.com/video/BV1DcoFYaEVq/?spm_id_from=333.337.top_right_bar_window_custom_collection.content.click&vd_source=390e7ea253547d9c75882d502ff42a1b">虚拟机配置Ubuntu20.04新手全流程【其他系统版本安装同理】_哔哩哔哩_bilibili</a></p><p>搭建qemu</p><p><a href="https://www.bilibili.com/video/BV1ZKwCe1EyY/?spm_id_from=333.337.search-card.all.click&vd_source=390e7ea253547d9c75882d502ff42a1b">无需开发板，8分钟通过qemu搭建嵌入式linux自学环境_哔哩哔哩_bilibili</a></p><p>配置完后 </p><p>安装qemu </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.qemu.org/qemu-9.2.4.tar.xz</span><br></pre></td></tr></table></figure><p> 解压</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xJf qemu-9.2.4.tar.xz.tar.xz</span><br></pre></td></tr></table></figure><p> 报错   安装gcc  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qq_38393271/article/details/141347415">ubuntu20.04源码编译安装qemu（qemu8.2）_either install ensurepip, or alleviate the need fo-CSDN博客</a></p><p>安装一些基础配置</p><p><a href="https://zhuanlan.zhihu.com/p/642830339">(35 封私信 &#x2F; 14 条消息) qemu源码编译（完整图文教程） - 知乎</a></p><p><img src="H:/Hexo-Blog/blog-demo/source/images/image-20250612135929025.png" alt="image-20250612135929025"></p><p><img src="H:/Hexo-Blog/blog-demo/source/images/image-20250612135943560.png" alt="image-20250612135943560"></p><h1 id="vscode-bear-clangd实现阅读代码精准跳转"><a href="#vscode-bear-clangd实现阅读代码精准跳转" class="headerlink" title="vscode+bear+clangd实现阅读代码精准跳转"></a>vscode+bear+clangd实现阅读代码精准跳转</h1><p>有其他版本吗 这个文件夹</p><p>1我已经准备好了  大概需要多久 已经在编译了</p><p>2也准备好了</p><p>3.编译完成了  qumu已经启动了</p><p>  做一个启动文件把  在这</p><p>qumu在&#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;</p><p>启动脚本 方式</p><p>qemu-system-aarch64 <br>    -machine virt <br>    -cpu cortex-a57 <br>    -m 2G <br>    -kernel &#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;linux&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;Image <br>    -initrd &#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;initramfs_arm64.img <br>    -append “console&#x3D;ttyAMA0 root&#x3D;&#x2F;dev&#x2F;ram rdinit&#x3D;&#x2F;sbin&#x2F;init” <br>    -fsdev local,id&#x3D;fsdev0,path&#x3D;&#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;hello,security_model&#x3D;none <br>    -device virtio-9p-pci,fsdev&#x3D;fsdev0,mount_tag&#x3D;hostshare <br>    -nographic</p><p>挂载共享空间</p><p>mkdir -p &#x2F;mnt&#x2F;share<br>mount -t 9p -o trans&#x3D;virtio,version&#x3D;9p2000.L hostshare &#x2F;mnt&#x2F;share</p><p>为了正确编译驱动模块，我需要知道QEMU虚拟机中v5.10内核的源代码路径。请提供以下信息：</p><ol><li>QEMU虚拟机中v5.10内核源代码的完整路径  &#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;linux</li></ol><p>是要在qemu make 还是在这里make</p><p>在主机环境为什么要编译内核环境？</p><h1 id="QEMU共享文件夹设置完整流程"><a href="#QEMU共享文件夹设置完整流程" class="headerlink" title="QEMU共享文件夹设置完整流程"></a>QEMU共享文件夹设置完整流程</h1><ol><li><p>主机端准备</p></li><li><p>创建共享目录：</p></li></ol><p>mkdir -p &#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;qemu_shared<br>cp -r &#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;helloDev&#x2F;*&#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;qemu_shared&#x2F;</p><ol start="2"><li>准备QEMU启动命令：</li></ol><p>qemu-system-x86_64 <br>    -kernel &#x2F;path&#x2F;to&#x2F;vmlinuz-5.10 <br>    -initrd &#x2F;path&#x2F;to&#x2F;initrd.img <br>    -append “root&#x3D;&#x2F;dev&#x2F;sda1 console&#x3D;ttyS0” <br>    -hda &#x2F;path&#x2F;to&#x2F;qemu-image.qcow2 <br>    -fsdev local,id&#x3D;share_dev,path&#x3D;&#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;qemu_shared,security_model&#x3D;none <br>    -device virtio-9p-pci,fsdev&#x3D;share_dev,mount_tag&#x3D;hostshare <br>    -nographic<br>注意：请替换&#x2F;path&#x2F;to&#x2F;为实际的路径。</p><ol start="2"><li><p>QEMU虚拟机内部操作</p></li><li><p>登录QEMU后创建挂载点：</p></li></ol><p>mkdir -p &#x2F;mnt&#x2F;hostshare<br>2. 挂载共享文件夹：</p><p>mount -t 9p -o trans&#x3D;virtio,version&#x3D;9p2000.L hostshare &#x2F;mnt&#x2F;hostshare<br>3. 验证挂载：</p><p>ls &#x2F;mnt&#x2F;hostshare<br>3. 编译内核模块</p><ol><li>进入共享目录：</li></ol><p>cd &#x2F;mnt&#x2F;hostshare<br>2. 清理之前的编译（如有需要）：</p><p>make clean<br>3. 编译模块：</p><p>make<br>4. 使用说明</p><ol><li><p>主机端修改文件会自动同步到QEMU中</p></li><li><p>编译生成的.ko文件也会出现在主机的共享目录中</p></li><li><p>卸载共享文件夹（退出QEMU前）：</p></li></ol><p>umount &#x2F;mnt&#x2F;hostshare3</p><p>&#x2F;mnt&#x2F;hostshare # mknod &#x2F;dev&#x2F;hello_dev c 511 0<br>&#x2F;mnt&#x2F;hostshare # chmod 666 &#x2F;dev&#x2F;hello_dev<br>&#x2F;mnt&#x2F;hostshare # echo “Test message” &gt; &#x2F;dev&#x2F;hello_dev<br>[  624.427209] Hello device opened<br>sh: write error: Invalid argument<br>[  624.437116] Hello device closed<br>&#x2F;mnt&#x2F;hostshare # dmesg | tail<br>[    0.969666]   with arguments:<br>[    0.969690]     &#x2F;sbin&#x2F;init<br>[    0.969712]   with environment:<br>[    0.969730]     HOME&#x3D;&#x2F;<br>[    0.969740]     TERM&#x3D;linux<br>[  485.529205] random: fast init done<br>[  489.339214] hello_dev: loading out-of-tree module taints kernel.<br>[  489.346637] Hello device registered with major number 511<br>[  624.427209] Hello device opened<br>[  624.437116] Hello device closed</p><p>从测试结果来看，内核模块基本工作正常，但存在一个问题：</p><ol><li>成功部分：</li></ol><p>设备节点创建成功 (&#x2F;dev&#x2F;hello_dev)<br>模块正确响应了open&#x2F;close操作<br>主设备号511正确注册<br>2. 问题部分：</p><p>写入时出现Invalid argument错误<br>这表明驱动程序的write操作没有正确处理输入<br>3. 原因分析：</p><p>可能是驱动中没有实现write操作<br>或者write操作返回了错误值<br>也可能是缓冲区处理有问题<br>4. 解决方案：</p><p>需要检查驱动代码中的write函数实现<br>确保正确处理用户空间数据</p><h1 id="需要使qemu有root权限，所以在启动时需要-使⽤sudo启动-arm64-root启动"><a href="#需要使qemu有root权限，所以在启动时需要-使⽤sudo启动-arm64-root启动" class="headerlink" title="需要使qemu有root权限，所以在启动时需要                        使⽤sudo启动  arm64   root启动"></a>需要使qemu有root权限，所以在启动时需要                        使⽤sudo启动  arm64   root启动</h1><p>sudo qemu-system-aarch64 <br>    -M virt <br>    -cpu cortex-a53 <br>    -kernel &#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;linux&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;Image.gz <br>    -initrd &#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;initramfs_arm64.img <br>    -nographic <br>    -serial mon:stdio <br>    -append “console&#x3D;ttyAMA0” <br>    -fsdev local,security_model&#x3D;passthrough,id&#x3D;fsdev0,path&#x3D;&#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;qemu_shared <br>    -device virtio-9p-pci,id&#x3D;fs0,fsdev&#x3D;fsdev0,mount_tag&#x3D;hostshare</p><p>2.0</p><p>sudo qemu-system-aarch64 <br>    -M virt <br>    -cpu cortex-a53 <br>    -kernel &#x2F;home&#x2F;wangbeiy&#x2F;workspace&#x2F;linux&#x2F;arch&#x2F;arm64&#x2F;boot&#x2F;Image.gz <br>    -initrd &#x2F;home&#x2F;wangbeiy&#x2F;workspace&#x2F;initramfs_arm64.img <br>    -nographic <br>    -serial mon:stdio <br>    -append “console&#x3D;ttyAMA0” <br>    -fsdev local,security_model&#x3D;passthrough,id&#x3D;fsdev0,path&#x3D;&#x2F;home&#x2F;wangbeiy&#x2F;workspace&#x2F;qemu_shared <br>    -device virtio-9p-pci,id&#x3D;fs0,fsdev&#x3D;fsdev0,mount_tag&#x3D;hostshare</p><h1 id="guest启动后需要⼿动mount该共享⽬录"><a href="#guest启动后需要⼿动mount该共享⽬录" class="headerlink" title="guest启动后需要⼿动mount该共享⽬录"></a>guest启动后需要⼿动mount该共享⽬录</h1><p>创建专用挂载点目录：</p><p>mkdir &#x2F;hostshare<br>2. 挂载宿主机共享目录：</p><p>mount -t 9p -o trans&#x3D;virtio,version&#x3D;9p2000.L hostshare &#x2F;hostshare<br>3. 验证挂载是否成功：</p><p>ls &#x2F;hostshare</p><p>要解决内核配置问题，请按照以下步骤操作：</p><ol><li>首先进入内核源代码目录：</li></ol><p>cd &#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;linux<br>2. 生成内核配置文件（使用当前运行内核的配置）：</p><p>make ARCH&#x3D;arm64 CROSS_COMPILE&#x3D;aarch64-linux-gnu- oldconfig<br>3. 准备内核编译环境：</p><p>make ARCH&#x3D;arm64 CROSS_COMPILE&#x3D;aarch64-linux-gnu- prepare<br>4. 现在可以返回模块目录重新编译：</p><p>cd &#x2F;path&#x2F;to&#x2F;module<br>make ARCH&#x3D;arm64 CROSS_COMPILE&#x3D;aarch64-linux-gnu- -C &#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;linux M&#x3D;$PWD modules</p><ol start="5"><li>如果仍然遇到配置问题，可能需要：</li></ol><p>从运行中的内核获取配置：<br>zcat &#x2F;proc&#x2F;config.gz &gt; &#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;linux&#x2F;.config<br>或使用默认配置：<br>make ARCH&#x3D;arm64 CROSS_COMPILE&#x3D;aarch64-linux-gnu- defconfig<br>注意：这些操作需要在内核源代码目录有写权限。</p><p>insmod helloDev.ko<br>[ 1108.216925] helloDev: loading out-of-tree module taints kernel.<br>[ 1108.225087] Hello: Module loaded successfully! Major number: 511<br>[ 1108.225324] Hello: Create device file with: mknod &#x2F;dev&#x2F;hello_dev c 511 0</p><p>. 模块已成功加载，显示”Module loaded successfully”和主设备号511</p><ol start="2"><li><p>内核日志提示需要创建设备文件</p></li><li><p>测试步骤需要：</p></li></ol><p>创建设备节点<br>测试设备访问<br>验证模块功能<br>4. 解决方案：</p><p>提供完整的设备测试流程<br>包括读写测试方法<br>恭喜模块加载成功！以下是完整的测试步骤：</p><ol><li>首先创建设备节点：</li></ol><p>sudo mknod &#x2F;dev&#x2F;hello_dev c 511 0<br>sudo chmod 666 &#x2F;dev&#x2F;hello_dev</p><ol start="2"><li>基本设备文件测试：</li></ol><p>ls -l &#x2F;dev&#x2F;hello_dev  # 应显示crw-rw-rw-权限<br>file &#x2F;dev&#x2F;hello_dev   # 应显示字符设备文件</p><ol start="3"><li>测试设备读写（根据您的驱动实现）：</li></ol><h1 id="写入测试"><a href="#写入测试" class="headerlink" title="写入测试"></a>写入测试</h1><p>echo “test message” &gt; &#x2F;dev&#x2F;hello_dev</p><h1 id="读取测试"><a href="#读取测试" class="headerlink" title="读取测试"></a>读取测试</h1><p>cat &#x2F;dev&#x2F;hello_dev<br>4. 检查内核日志：</p><p>dmesg | tail -n 10</p><h1 id="应该能看到驱动处理读写操作的日志"><a href="#应该能看到驱动处理读写操作的日志" class="headerlink" title="应该能看到驱动处理读写操作的日志"></a>应该能看到驱动处理读写操作的日志</h1><ol start="5"><li>压力测试（可选）：</li></ol><h1 id="连续写入测试"><a href="#连续写入测试" class="headerlink" title="连续写入测试"></a>连续写入测试</h1><p>for i in {1..10}; do echo “test $i” &gt; &#x2F;dev&#x2F;hello_dev; done</p><h1 id="连续读取测试"><a href="#连续读取测试" class="headerlink" title="连续读取测试"></a>连续读取测试</h1><p>for i in {1..10}; do cat &#x2F;dev&#x2F;hello_dev; done<br>6. 测试完成后清理：</p><p>sudo rm &#x2F;dev&#x2F;hello_dev<br>sudo rmmod helloDev</p><h1 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h1><p>当前已知信息：</p><p>目标：编译并加载helloDev.ko内核模块<br>系统架构：ARM64 (aarch64)<br>内核版本：5.10.0<br>模块源代码位置：~&#x2F;workspace&#x2F;helloDev&#x2F;<br>4. 需要采取的步骤：</p><p>清理之前的编译尝试<br>从基础步骤开始指导<br>确保每一步都清晰可执行<br>5. 解决方案：</p><p>提供从头开始的完整指导<br>分步骤验证每个环节当前已知信息：</p><p>目标：编译并加载helloDev.ko内核模块<br>系统架构：ARM64 (aarch64)<br>内核版本：5.10.0<br>模块源代码位置：~&#x2F;workspace&#x2F;helloDev&#x2F;<br>4. 需要采取的步骤：</p><p>清理之前的编译尝试<br>从基础步骤开始指导<br>确保每一步都清晰可执行<br>5. 解决方案：</p><p>提供从头开始的完整指导<br>分步骤验证每个环节</p><ol><li>准备工作：</li></ol><h1 id="安装交叉编译工具链"><a href="#安装交叉编译工具链" class="headerlink" title="安装交叉编译工具链"></a>安装交叉编译工具链</h1><p>sudo apt-get install gcc-aarch64-linux-gnu</p><h1 id="进入模块目录"><a href="#进入模块目录" class="headerlink" title="进入模块目录"></a>进入模块目录</h1><p>cd ~&#x2F;workspace&#x2F;helloDev</p><h1 id="清理之前的编译结果"><a href="#清理之前的编译结果" class="headerlink" title="清理之前的编译结果"></a>清理之前的编译结果</h1><p>make clean<br>3. 设置环境变量：</p><p>export ARCH&#x3D;arm64<br>export CROSS_COMPILE&#x3D;aarch64-linux-gnu-<br>4. 编译模块：</p><p>make -C &#x2F;home&#x2F;linqiutian&#x2F;workspace&#x2F;linux M&#x3D;$(pwd) modules<br>5. 验证结果：</p><h1 id="检查生成的模块"><a href="#检查生成的模块" class="headerlink" title="检查生成的模块"></a>检查生成的模块</h1><p>file helloDev.ko</p><h1 id="应该显示”ARM-aarch64”架构"><a href="#应该显示”ARM-aarch64”架构" class="headerlink" title="应该显示”ARM aarch64”架构"></a>应该显示”ARM aarch64”架构</h1><h1 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h1><p>sudo insmod helloDev.ko</p><h1 id="检查是否加载成功"><a href="#检查是否加载成功" class="headerlink" title="检查是否加载成功"></a>检查是否加载成功</h1><p>lsmod | grep helloDev<br>dmesg | tail</p><p>首先确保安装了ARM64交叉编译工具链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gcc-aarch64-linux-gnu</span><br></pre></td></tr></table></figure><p> <strong>关键注意事项：</strong></p><p>必须使用与运行内核(5.10.0)完全相同的源代码版本<br>确保内核配置(.config)匹配<br>编译环境变量设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ARCH=arm64</span><br><span class="line">export CROSS_COMPILE=aarch64-linux-gnu-</span><br></pre></td></tr></table></figure><p> 使用正确的架构参数重新编译模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -C /home/linqiutian/workspace/linux M=$PWD modules</span><br></pre></td></tr></table></figure><p>在qemu中测试字符驱动</p><p>  1.加载模块到内核：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insmod helloDev.ko</span><br></pre></td></tr></table></figure><ol start="2"><li>检查模块加载状态：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmod | grep helloDev</span><br></pre></td></tr></table></figure><ol start="3"><li>查看模块初始化输出：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | tail -n 10</span><br></pre></td></tr></table></figure><ol start="4"><li>卸载模块：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rmmod helloDev</span><br></pre></td></tr></table></figure><p>检查模块退出输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | tail -n 10</span><br></pre></td></tr></table></figure><p>首先创建设备节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mknod /dev/hello_dev c 511 0</span><br><span class="line">chmod 666 /dev/hello_dev</span><br></pre></td></tr></table></figure><p>基本设备文件测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -l /dev/hello_dev  # 应显示crw-rw-rw-权限</span><br><span class="line">file /dev/hello_dev   # 应显示字符设备文件</span><br></pre></td></tr></table></figure><p>测试设备读写（根据您的驱动实现）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 写入测试</span><br><span class="line">echo &quot;test message&quot; &gt; /dev/hello_dev</span><br><span class="line"># 读取测试</span><br><span class="line">cat /dev/hello_dev</span><br></pre></td></tr></table></figure><p>检查内核日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | tail -n 10</span><br></pre></td></tr></table></figure><p>测试完成后清理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rm /dev/hello_dev</span><br><span class="line">rmmod helloDev</span><br></pre></td></tr></table></figure><p>运行测试程序</p><p>首先在主机上交叉编译test.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aarch64-linux-gnu-gcc -static -o test test.c</span><br><span class="line">file test  # 确认输出为ARM aarch64架构</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将编译好的程序传输到QEMU中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp test /qemu_shared/</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">./test</span><br><span class="line">[  627.996160] Hello: Device opened</span><br><span class="line">[  627.996437] Hello: Received 22 characters from the user: Hello from user space!</span><br><span class="line">Wrote to device: Hello from user space!</span><br><span class="line">[  628.001305] Hello: Sent 22 characters to the user</span><br><span class="line">Read from device: Hello from user space!</span><br><span class="line">Data verification successful</span><br><span class="line">[  628.002348] Hello: Device closed</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试程序test已成功运行，并与内核模块helloDev交互</p><ol start="2"><li>从内核日志可见完整的设备操作流程：</li></ol><p>设备打开<br>用户空间写入数据<br>驱动接收并回传数据<br>设备关闭<br>3. 测试结果显示：</p><p>写入和读取操作都成功完成<br>数据验证通过，表明驱动功能正常<br>4. 结论：</p><p>驱动模块helloDev.ko工作正常<br>测试程序test验证了驱动的完整功能<br>测试结果分析：</p><p>✅ 驱动模块功能验证成功：</p><ol><li>设备操作流程完整：</li></ol><p>打开设备 (open)<br>写入数据 (write)<br>读取数据 (read)<br>关闭设备 (close)<br>2. 数据流验证：</p><p>用户空间写入: “Hello from user space!”<br>驱动正确接收: 22字符<br>驱动正确回传相同数据<br>用户空间成功读取并验证数据</p><ol start="3"><li>内核日志显示：</li></ol><p>[  627.996160] Hello: Device opened<br>[  627.996437] Hello: Received 22 chars<br>[  628.001305] Hello: Sent 22 chars<br>[  628.002348] Hello: Device closed<br>4. 用户空间输出：</p><p>Wrote to device: Hello from user space!<br>Read from device: Hello from user space!<br>Data verification successful</p><h1 id="在Ubuntu20-04虚拟机中加载（insmod）字符设备驱动，并⽤运⾏⽤⼾测试程序进⾏测试"><a href="#在Ubuntu20-04虚拟机中加载（insmod）字符设备驱动，并⽤运⾏⽤⼾测试程序进⾏测试" class="headerlink" title="在Ubuntu20.04虚拟机中加载（insmod）字符设备驱动，并⽤运⾏⽤⼾测试程序进⾏测试"></a>在Ubuntu20.04虚拟机中加载（insmod）字符设备驱动，并⽤运⾏⽤⼾测试程序进⾏测试</h1><p>先执行清理  重新编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make clean &amp;&amp; make all</span><br></pre></td></tr></table></figure><h2 id="加载模块：sudo-insmod-helloDev-ko"><a href="#加载模块：sudo-insmod-helloDev-ko" class="headerlink" title="加载模块：sudo insmod helloDev.ko"></a>加载模块：sudo insmod helloDev.ko</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo insmod helloDev.ko</span><br></pre></td></tr></table></figure><h2 id="创建设备节点：sudo-mknod-dev-hello-dev-c-major-0-major号会在加载时打印"><a href="#创建设备节点：sudo-mknod-dev-hello-dev-c-major-0-major号会在加载时打印" class="headerlink" title="创建设备节点：sudo mknod &#x2F;dev&#x2F;hello_dev c [major] 0 (major号会在加载时打印)"></a>创建设备节点：sudo mknod &#x2F;dev&#x2F;hello_dev c [major] 0 (major号会在加载时打印)</h2><p> 从dmesg输出可以看到内核模块已成功加载，主设备号为237</p><p>模块期望用户手动创建设备节点：mknod &#x2F;dev&#x2F;hello_dev c 237 0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mknod /dev/hello_dev c 237 0</span><br></pre></td></tr></table></figure><p>设置适当的权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 666 /dev/hello_dev</span><br></pre></td></tr></table></figure><h2 id="使用test和write程序测试设备"><a href="#使用test和write程序测试设备" class="headerlink" title="使用test和write程序测试设备"></a>使用test和write程序测试设备</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./test</span><br></pre></td></tr></table></figure><dl><dt>sudo .&#x2F;read<br>open file error<br>: No such file or directory<br>linqiutian@ubuntu:~&#x2F;workspace&#x2F;hello$ sudo .&#x2F;write<br>open file error</dt><dd>No such file or directory</dd></dl><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mknod /dev/hello c 237 0 &amp;&amp; sudo chmod 666 /dev/hello</span><br></pre></td></tr></table></figure><h1 id="helloDev-Linux字符设备驱动模块"><a href="#helloDev-Linux字符设备驱动模块" class="headerlink" title="helloDev - Linux字符设备驱动模块"></a>helloDev - Linux字符设备驱动模块</h1><h2 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h2><p>这是一个简单的Linux字符设备驱动模块，实现了基本的设备操作接口(open, read, write, close)。主要用于学习和演示Linux设备驱动开发。</p><h2 id="主要文件"><a href="#主要文件" class="headerlink" title="主要文件"></a>主要文件</h2><ul><li><code>helloDev.c</code>: 主驱动代码，实现设备操作</li><li><code>Makefile</code>: 构建脚本</li><li><code>test.c</code>: 综合测试程序</li><li><code>read.c</code>: 读取设备示例</li><li><code>write.c</code>: 写入设备示例</li></ul><h2 id="构建和安装"><a href="#构建和安装" class="headerlink" title="构建和安装"></a>构建和安装</h2><ol><li>确保已安装Linux内核头文件</li><li>执行构建命令:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure></li><li>加载内核模块:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> insmod helloDev.ko</span><br></pre></td></tr></table></figure></li><li>创建设备节点:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mknod</span> /dev/hello c 250 0</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 666 /dev/hello</span><br></pre></td></tr></table></figure>(注意: 主设备号250可能需要根据系统调整)</li></ol><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc write.c -o write</span><br><span class="line">./write</span><br></pre></td></tr></table></figure><h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc read.c -o <span class="built_in">read</span></span><br><span class="line">./read</span><br></pre></td></tr></table></figure><h3 id="综合测试"><a href="#综合测试" class="headerlink" title="综合测试"></a>综合测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o <span class="built_in">test</span></span><br><span class="line">./test</span><br></pre></td></tr></table></figure><h2 id="卸载模块"><a href="#卸载模块" class="headerlink" title="卸载模块"></a>卸载模块</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> rmmod helloDev</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /dev/hello</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>需要root权限加载&#x2F;卸载模块</li><li>确保主设备号不与系统其他设备冲突</li><li>测试程序可能需要根据实际系统调整</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/06/02/test/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/06/02/test/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="git学习笔记"><a href="#git学习笔记" class="headerlink" title="git学习笔记"></a>git学习笔记</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>嵌入式软件调试</title>
      <link href="/2025/06/01/test/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95/"/>
      <url>/2025/06/01/test/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="嵌入式软件调试理论基础"><a href="#嵌入式软件调试理论基础" class="headerlink" title="嵌入式软件调试理论基础"></a>嵌入式软件调试理论基础</h1><h2 id="•-什么是软件调试？"><a href="#•-什么是软件调试？" class="headerlink" title="• 什么是软件调试？"></a>• 什么是软件调试？</h2><p>• 英文software debug，又译软件侦错</p><p>• 软件调试过程，就是发现软件失效，定位软件错误并将其修复的过程</p><p><img src="/./../../images/image-20250602155046456-1748851517687-1.png" alt="image-20250602155046456"></p><h3 id="软件调试的重要性"><a href="#软件调试的重要性" class="headerlink" title="软件调试的重要性"></a>软件调试的重要性</h3><p>• 据统计：软件调试、 debug时间一般占软件开发周期的50%以上，是软件开发中耗时最多的一项活动</p><p>• 很多项目延期，往往就栽在不能定位的bug上。</p><p>• 随着软件、系统越来越复杂，软件调试技术需要与软件工程、开发技术同步升级</p><p>• 软件调试理论和知识尚未系统化，很多开发者对其基本原理知之甚少，不能根据实际情况融会贯通地去使用各种调试技巧，对于复杂问题、BUG往往一筹莫展、无能为力  </p><h3 id="软件调试的特点"><a href="#软件调试的特点" class="headerlink" title="软件调试的特点"></a>软件调试的特点</h3><p>• 是一项具有挑战性、很强技巧性的工作<br>• 复杂度高、难度大，必须通过现象，大量的分析，才能逐步接<br>近真相，犹如福尔摩斯探案，抓住蛛丝马迹，层层推理。<br>• 需要知识面广：设计到硬件、软件、操作系统、编译器等。<br>• 有些bug极难复现，定位困难。<br>• 是一项不受欢迎的工作<br>• 对心理影响：<br>– 打击人的自信、消磨工作热情、考验人的耐心和抗压能力、<br>怀疑人生、怀疑自己是不是这块料…<br>• 对生理影响：<br>– 脾气暴躁、上火、口腔溃疡、失眠…</p><h3 id="嵌入式软件调试特点"><a href="#嵌入式软件调试特点" class="headerlink" title="嵌入式软件调试特点"></a>嵌入式软件调试特点</h3><p>• 调试环境和运行环境不在一个平台上，增<br>加了调试的难度<br>• 嵌入式设备往往没有输出、打印终端，遇<br>到问题，只能看日志<br>• 考虑问题还要考虑硬件问题、时序问题，<br>需要软硬件结合去思考问题，增加了调试<br>的难度</p><h3 id="软件调试一些参考经验"><a href="#软件调试一些参考经验" class="headerlink" title="软件调试一些参考经验"></a>软件调试一些参考经验</h3><p>• 寻找类似的bug，一些常见的出错场景<br>• 使用版本管理工具查看最近代码的变化<br>• 打印有时候会失效：比如在打印之前程序已经crash<br>• 尽可能深入准确理解系统、不适当的改动可能使事情更糟<br>• 体力不支时、没思路时可以稍事休息，保持充沛精力<br>• 对于多模块系统，多沟通、多交流，而不是相互推诿</p><h3 id="常用的嵌入式软件调试工具"><a href="#常用的嵌入式软件调试工具" class="headerlink" title="常用的嵌入式软件调试工具"></a>常用的嵌入式软件调试工具</h3><p>• 软件<br>    • IAR、 ADS&#x2F;AXD、 Keil、 MDK、 RVDS、 Eclipse、 H-JTAG、 Trace32<br>    • GCC、 GDB、 KGDB、 JDB、<br>    • 性能分析工具、内存分析工具<br>• 硬件<br>    • 万用表、示波器、逻辑分析仪、仿真器<br>    • Jlink、 JTAG</p><h2 id="•-常用的软件调试技术"><a href="#•-常用的软件调试技术" class="headerlink" title="• 常用的软件调试技术"></a>• 常用的软件调试技术</h2><h3 id="软件调试技术分类"><a href="#软件调试技术分类" class="headerlink" title="软件调试技术分类"></a>软件调试技术分类</h3><p>• 按目标代码的执行方式<br>    • 脚本调试、托管调试、本地调试、混合调试<br>• 按目标代码的执行模式<br>    • 用户态调试、内核态调试<br>• 按软件所处的阶段<br>    • 开发期调试、产品期调试<br>• 按调试器和调试目标的相对位置<br>    • 本地调试、远程调试</p><h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><p>• 输出调试信息<br>    • 打印函数栈、变量值<br>    • 日志、文件转储</p><p>• 应用场合<br>    • 错误简单，直接打印比使用调试器方便<br>    • 难以使用调试器的环境、或者使用调试器无法重现</p><h3 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h3><p>• 断点<br>• 单步执行<br>• 事件追踪<br>• 栈回溯<br>• 反汇编<br>• 观察和修改寄存器、内存数据<br>• 控制被调试的进程或线程</p><h3 id="使用调试器有哪些优点"><a href="#使用调试器有哪些优点" class="headerlink" title="使用调试器有哪些优点"></a>使用调试器有哪些优点</h3><p>• 不需要预知错误在哪里</p><p>• 支持在线检查错误，不需要改代码、重新编译</p><p>• 可以看到运行时的各种数据：变量值、寄存器、内存数据…</p><p>• 单步</p><h3 id="调试器调试一般步骤"><a href="#调试器调试一般步骤" class="headerlink" title="调试器调试一般步骤"></a>调试器调试一般步骤</h3><p>• 定位出现错误的场景<br>• 分析错误、粗略定位可能出错的代码<br>• 设置初始断点<br>• 开始调试程序或者attach一个已经运行的<br>程序进程<br>• 在断点上观察数据各种数据：变量、寄存<br>器、调用栈、反汇编， dump有用的数据<br>• 单步执行、更新断点<br>• 结束调试器</p><h2 id="•-常见的错误类型"><a href="#•-常见的错误类型" class="headerlink" title="• 常见的错误类型"></a>• 常见的错误类型</h2><h3 id="编译型错误"><a href="#编译型错误" class="headerlink" title="编译型错误"></a>编译型错误</h3><p><strong>• 语法规则检查</strong><br>    • C语言的基本语法、关键字、运算符、表达式<br><strong>• 中英文符号</strong><br>    • 全角、半角的问题<br><strong>• 函数问题</strong><br>    • 函数声明与函数定义不匹配：函数参数、返回类型<br>    • 误认为形参改变会影响实参的值<br>    • 函数的实参和形参类型不一致<br><strong>• 函数未声明</strong><br>    • 有时候一个warning也是引起软件失效的诱因</p><h3 id="运行时错误"><a href="#运行时错误" class="headerlink" title="运行时错误"></a>运行时错误</h3><p><strong>• 对异常未做处理</strong><br>    • 打开的文件未找到<br>    • 磁盘空间不足<br>    • 内存不足<br>    • 网络异常<br>    • Scanf输入格式、忘记地址符<br><strong>• 堆栈溢出</strong><br><strong>• 空指针的引用</strong><br><strong>• 未初始化局部变量</strong><br><strong>• 数组问题</strong><br>    • 数组越界， C语言并不会对数组做边界检查<br>    • 数组下标<br>    • 混淆数组名与指针的区别、数组作为参数的无用</p><h3 id="逻辑错误"><a href="#逻辑错误" class="headerlink" title="逻辑错误"></a>逻辑错误</h3><p><strong>• 运算符</strong><br>    • &#x3D;和&#x3D;&#x3D;、 &amp;和&amp;&amp;、 |和||混用<br>    • 运算符的优先级和结合性<br><strong>• 循环条件设置问题</strong><br>    • 未注意int、 char类型的数值范围，导致死循环<br>    • 循环边界控制<br><strong>• 链表的头尾判断、空链表处理</strong><br><strong>• 业务逻辑错误</strong><br><strong>• 死锁</strong><br><strong>• 不良的编程习惯和代码风格</strong><br>    • 不该加分号的地方加了分号或者少加分号<br>    • 花括号忘记使用，导致错误的逻辑分支</p><h3 id="内存错误"><a href="#内存错误" class="headerlink" title="内存错误"></a>内存错误</h3><p><strong>• 内存溢出</strong></p><p><strong>• 内存泄露</strong></p><p><strong>• 内存踩踏</strong></p><h2 id="•-Debug文件和release文件的区别"><a href="#•-Debug文件和release文件的区别" class="headerlink" title="• Debug文件和release文件的区别"></a>• Debug文件和release文件的区别</h2><p><strong>目标文件的链接过程</strong>  </p><p><img src="/./../../images/image-20250602171053466.png" alt="image-20250602171053466"></p><p><strong>可执行文件的运行</strong>  </p><p><img src="./../../images/image-20250602171121938.png" alt="image-20250602171121938" style="zoom: 80%;"><img src="/./../../images/image-20250602171127068.png" alt="image-20250602171127068"></p><h3 id="•-调试符号"><a href="#•-调试符号" class="headerlink" title="• 调试符号"></a><strong>• 调试符号</strong></h3><p> <strong>什么是调试符号</strong></p><img src="./../../images/image-20250602172035917.png" alt="image-20250602172035917" style="zoom:67%;">    • 二进制代码与源程序联系的桥梁    • 很多调试必须依赖调试符号才能工作    • 如:源代码级调试、 栈回溯、按名称显示变量等**• 生成过程**    • 在编译过程中，编译器从源文件收集调试信息供开发者调试使用    • 这些信息以表格形式记录在符号表中，是对源程序的概括    • 包括变量、类型、函数、标号和源代码行等。**• 存储方式**    • 由编译器收集和提炼后，再由链接器或者专门工具保存到调试符号文件中。<p>​• 调试符号可存储在单独的文件，也可与目标文件共享一个文件</p><h3 id="•-调试信息的存储格式"><a href="#•-调试信息的存储格式" class="headerlink" title="• 调试信息的存储格式"></a><strong>• 调试信息的存储格式</strong></h3><p><strong>• COFF格式</strong><br>    • 二进制格式，用来存储可执行映像文件、目标文件、库文件<br><strong>• CodeView格式</strong><br>    • 与MSC编译器一起使用的调试器<br>    • CV格式的调试信息可以与映像文件保存在一起，也可单独存放<br><strong>• PDB格式</strong><br>    • PDB格式的调试信息需单独存储在一个文件中<br>    • 如VC++6.0中的.pdb文件<br><strong>• DWARF格式</strong><br>    • 公开的调试信息格式规范，主要用在Unix、 Linux发行系统中<br>    • GCC和GDB都支持这种格式</p><h3 id="•-目标文件中的调试信息"><a href="#•-目标文件中的调试信息" class="headerlink" title="• 目标文件中的调试信息"></a><strong>• 目标文件中的调试信息</strong></h3><img src="./../../images/image-20250602172333724.png" alt="image-20250602172333724" style="zoom: 67%;"><p><strong>• 目标文件</strong><br>    • 编译器用来存放目标代码的文件<br>    • VC使用COFF格式来存储目标文件<br><strong>• 目标文件格式</strong><br>    • 文件头结构<br>    • 节头部数据结构：<br>    • 三种数据： 原始数据、 重定位信息、 行<br>号信息<br>    • 节数据之后是调试符号表和字符串表<br><strong>• 重定位信息和行号信息</strong><br>    • 重定位信息：链接和加载映像文件时应<br>如何修改节数据、重定位的地址和方法<br>    • 行号信息： 用来描述源代码行和目标代<br>码的对应关系</p><h3 id="•-使用GCC编译debug目标文件"><a href="#•-使用GCC编译debug目标文件" class="headerlink" title="• 使用GCC编译debug目标文件"></a><strong>• 使用GCC编译debug目标文件</strong></h3><p><img src="/./../../images/image-20250602172457464.png" alt="image-20250602172457464"></p><h2 id="•-断点和单步是怎么实现的"><a href="#•-断点和单步是怎么实现的" class="headerlink" title="• 断点和单步是怎么实现的?"></a>• 断点和单步是怎么实现的?</h2><h3 id="•-CPU对调试的支持"><a href="#•-CPU对调试的支持" class="headerlink" title="• CPU对调试的支持"></a><strong>• CPU对调试的支持</strong></h3><p><strong>• CPU指令和指令集</strong><br>    • 为某一类CPU所支持的指令集被简称为指令集,根据指令集特征，<br>CPU可划分为两大阵营： RISC和CISC<br>    • RISC：通过减少指令集数量和简化指令格式来提高和优化CPU执行<br>指令效率。例如： ARM、 MIPS、 Alpha、 SPARC、 PowerPC<br>    • CISC： X86系列处理器</p><p><strong>• CPU对断点调试的支持</strong><br>    • 支持断点调试指令： INT 3指令<br>    • 标志寄存器： EFLAGS寄存器中的TF标志位<br>    • 1： CPU执行完一条指令都会产生调试异常， CPU转到<br>ISR中去，在该ISR中可以很多调试操作<br>    • 该标志是实现单步调试的基础<br>    • 调试寄存器： DR0~DR7<br>    • JTAG支持：单独靠软件无法调试的裸板、系统bringup调试</p><h3 id="•-操作系统对调试的支持"><a href="#•-操作系统对调试的支持" class="headerlink" title="• 操作系统对调试的支持"></a><strong>• 操作系统对调试的支持</strong></h3><p><strong>• 在内核层面提供支持</strong><br>    • 提供支持远程调试协议的通信模块<br>    • 提供断点设置函数<br>    • 提供软陷异常处理：调试功能<br><strong>• 对用户态调试器的支持</strong><br>    • 创建调试目标的系统函数<br>    • 在调试循环中处理调试事件的系统函数<br>    • 查看和修改调试目标的系统函数，这些系统函数用于调试事件<br>的处理过程中<br>    • 用户态调试器将这些系统函数与其它函数结合起来，从而提供<br>强大的功能</p><h3 id="•-在调试器中加入断点"><a href="#•-在调试器中加入断点" class="headerlink" title="• 在调试器中加入断点"></a><strong>• 在调试器中加入断点</strong></h3><p><img src="/./../../images/image-20250602173346493.png" alt="image-20250602173346493">.</p><h3 id="•-单步"><a href="#•-单步" class="headerlink" title="• 单步"></a><strong>• 单步</strong></h3><p><img src="/./../../images/image-20250602173432501.png" alt="image-20250602173432501"></p><h3 id="•-获取变量值"><a href="#•-获取变量值" class="headerlink" title="• 获取变量值"></a><strong>• 获取变量值</strong></h3><p> <strong>进程中可以以地址来标识变量、函数，但不知</strong><br><strong>道每个地址的含义、地址对应的名称</strong><br><strong>• 调试器使用符号表从地址获得变量名</strong><br><strong>• 调试信息的内容</strong><br>    • 地址对应的变量名、函数名<br>    • 指令对应的源文件及其行号<br>    • 数据结构的信息等<br><strong>• 调试信息的保存</strong><br>    • Debug版本程序：添加到目标文件中<br>    • Release版本：单独的符号文件<br>        • DBG文件<br>        • PDB文件<br>        • MAP文件</p><h3 id="•-读写寄存器"><a href="#•-读写寄存器" class="headerlink" title="• 读写寄存器"></a><strong>• 读写寄存器</strong></h3><p><strong>• CPU对调试的支持</strong><br>    • CPU自身提供的机制<br><strong>• ARM结构CPU寄存器</strong><br>    • JTAG扫描链电路+ARM 寄存器</p><p><img src="/./../../images/image-20250602173611273.png" alt="image-20250602173611273"></p><p><img src="/./../../images/image-20250602173614370.png" alt="image-20250602173614370"></p><h2 id="•-仿真器调试原理"><a href="#•-仿真器调试原理" class="headerlink" title="• 仿真器调试原理"></a>• 仿真器调试原理</h2><h3 id="•-嵌入式常用调试手段"><a href="#•-嵌入式常用调试手段" class="headerlink" title="• 嵌入式常用调试手段"></a>• 嵌入式常用调试手段</h3><p><strong>• 软件模拟器</strong><br>    • 在PC上模拟目标CPU并执行用户目标代码。如ARM仿真器： ARM<br>armulator，可以模拟运行ARM指令系统<br><strong>• 目标Monitor</strong><br>    • 将目标代码下载到用户目标板的存储器重，并增加一个monitor软<br>件，用来监听用户目标代码的执行。用户通过串口等调试端口，<br>通过PC进行调试。如ARM基于调试代理angel的调试<br>    • 缺点：耗费MCU、 CPU资源、目标系统必须是一个完整的系统、<br>无法在ROM区设置断点、对于存储受限的单片机等并不适用<br><strong>• 仿真器</strong><br>    • 一般会有一个仿真头、 代替目标系统中的MCU、 CPU， 并仿真其<br>运行，可以连接目标板，甚至不连接都可以。<br>    • 仿真器运行起来跟实际的目标处理器一样，增加了调试功能、支<br>持在线调试</p><h3 id="•-为什么要使用仿真器调试"><a href="#•-为什么要使用仿真器调试" class="headerlink" title="• 为什么要使用仿真器调试"></a>• 为什么要使用仿真器调试</h3><p><strong>• 在前期硬件验证上必须使用仿真器(目标系</strong><br><strong>统硬件不完整也可以运行)</strong><br><strong>• 硬件实际性能测试(电路、电容、电感等)</strong><br><strong>• 额外的优点</strong><br>    • Monitor要占用额外的存储和通信端口，仿真器不需要目标系<br>统或CPU资源<br>    • 硬件断点：调试ROM或者NOR 存储模式的目标系统毫无压力<br>    • 跟踪功能：能够记录所有的取指操作<br>    • 条件触发<br>    • 实时显示存储器、内存和I&#x2F;O内容<br>    • 硬件性能分析</p><h3 id="Trace32仿真器介绍"><a href="#Trace32仿真器介绍" class="headerlink" title="Trace32仿真器介绍"></a>Trace32仿真器介绍</h3><p>• 德国Lauterbach公司研发</p><p>• 通用性：更换仿真头子可以调试不同芯片  </p><p><img src="/./../../images/image-20250602174115438.png" alt="image-20250602174115438"></p><p><img src="/./../../images/image-20250602174118600.png" alt="image-20250602174118600"></p><h3 id="•-仿真器调试的缺点"><a href="#•-仿真器调试的缺点" class="headerlink" title="• 仿真器调试的缺点"></a>• 仿真器调试的缺点</h3><p><strong>仿真器的缺点</strong>  </p><p><strong>• 贵</strong><br>    • 仿真器有自己的目标CPU、 RAM甚至ROM以及软件<br><strong>• 通用性差</strong><br>    • 随着CPU不断发布、升级，需要同步升级。<br><strong>• 硬件仿真效果跟实际处理器还是有差异</strong><br>    • 仿真器中的CPU跟目标系统中的CPU电气特性不同<br>    • 不能反映实际时序</p><h2 id="•-JTAG和JLINK调试原理及区别"><a href="#•-JTAG和JLINK调试原理及区别" class="headerlink" title="• JTAG和JLINK调试原理及区别"></a>• JTAG和JLINK调试原理及区别</h2><h3 id="•-JTAG调试原理"><a href="#•-JTAG调试原理" class="headerlink" title="• JTAG调试原理"></a>• JTAG调试原理</h3><p><strong>• 测试接口标准化</strong><br>    • 在芯片内部定义一个标准的测试访问接口(TAP ),通过专用的<br>JTAG测试工具对芯片内部节点进行测试和调试<br><strong>• JTAG(Joint Test Action Group)</strong><br>    • 一种国际标准测试协议，主要用于芯片内部测试<br>    • 目前大多数芯片都支持JTAG协议： ARM、 DSP、 FPGA等<br><strong>• JTAG接口</strong><br>    • TMS：测试模式选择<br>    • TCK：测试时钟输入<br>    • TDI： 测试数据输入，数据通过TDI引脚输入JTAG接口<br>    • TDO：测试数据输出，数据通过TDO引脚从JTAG接口输出</p><h3 id="•-JTAG接口"><a href="#•-JTAG接口" class="headerlink" title="• JTAG接口"></a>• JTAG接口</h3><img src="./../../images/image-20250602174440435.png" alt="image-20250602174440435" style="zoom: 80%;"><img src="./../../images/image-20250602174445412.png" alt="image-20250602174445412" style="zoom:80%;"><img src="./../../images/image-20250602174447903.png" alt="image-20250602174447903" style="zoom:80%;"><p><strong>JTAG实物图</strong>  </p><p><img src="/./../../images/image-20250602174604503.png" alt="image-20250602174604503"></p><p><img src="/./../../images/image-20250602174607821.png" alt="image-20250602174607821"></p><p><img src="/./../../images/image-20250602174610282.png" alt="image-20250602174610282"></p><p><img src="/./../../images/image-20250602174713582.png" alt="image-20250602174713582"></p><h3 id="•-边界扫描电路"><a href="#•-边界扫描电路" class="headerlink" title="• 边界扫描电路"></a>• 边界扫描电路</h3><p><img src="/./../../images/image-20250602174740245.png" alt="image-20250602174740245"></p><p><img src="/./../../images/image-20250602174743608.png" alt="image-20250602174743608"></p><p><img src="/./../../images/image-20250602174825904.png" alt="image-20250602174825904"></p><h3 id="•-测试访问口TAP"><a href="#•-测试访问口TAP" class="headerlink" title="• 测试访问口TAP"></a>• 测试访问口TAP</h3><p><strong>• TAP</strong><br>    • Test Access Port<br>    • 是一个通用端口，通过该端口可以访问数据寄存器和指令寄存<br>器<br>    • 通过TAP控制器来对整个TAP端口的控制<br><strong>• 总结</strong><br>    • PC机对目标板的调试就是通过TAP接口完成对数据寄存器DR和<br>指令寄存器IR的访问。</p><h3 id="•-Jlink调试原理"><a href="#•-Jlink调试原理" class="headerlink" title="• Jlink调试原理"></a>• Jlink调试原理</h3><p><strong>• RDI调试接口</strong><br>    • ARM公司提出的调试接口标准，实现跨平台的硬件调试<br>    • 各大调试工具Keil、 ADS、 IAR等都使用RDI公共调试接口<br><strong>• RDI命令到JTAG协议的转换</strong><br>– 软件实现<br>    • 在PC写一个程序，将ADS&#x2F;Keil的RDI命令解析成JTAG协议，然后<br>通过物理转换接口(仅仅是电气物理层上的转换，像RS232)，发<br>送到目标板。如H-JTAG工具<br>– 硬件实现<br>    • 做一个电路板，直接接收来自Keil、 ADS等软件的调试命令，硬<br>件实现RDI到JTAG协议的转换，与目标板通信。如Jlink类似工具<br>• 相对于软件转换，硬件速度快，而且不需要装jtag解析软件</p><p>Jlink工具实物图</p><p><img src="/./../../images/image-20250602175114137.png" alt="image-20250602175114137"></p><h1 id="printf函数打印高阶技巧"><a href="#printf函数打印高阶技巧" class="headerlink" title="printf函数打印高阶技巧"></a>printf函数打印高阶技巧</h1><h2 id="•-输出重定向"><a href="#•-输出重定向" class="headerlink" title="• 输出重定向"></a>• 输出重定向</h2><h3 id="•-流的概念"><a href="#•-流的概念" class="headerlink" title="• 流的概念"></a>• 流的概念</h3><p><strong>• 程序输入或输出的一个连续的字节序列</strong><br>    • 设备(鼠标、键盘、打印机、屏幕…)的输入输出使用流来处理<br><strong>• 在C语言中，所有流均以文件的形式出现</strong><br>    • 统一了各种硬件操作接口带来的差异<br><strong>• C语言中提供的5中标准流</strong></p><table><thead><tr><th>名称</th><th>描述</th><th>文件描述符</th><th>例子</th></tr></thead><tbody><tr><td>stdin</td><td>标准输入</td><td>0</td><td>键盘、鼠标</td></tr><tr><td>stdout</td><td>标准输出</td><td>1</td><td>屏幕、 LCD</td></tr><tr><td>stderr</td><td>标准错误</td><td>2</td><td>屏幕、 LCD</td></tr><tr><td>stdprn</td><td>标准打印机</td><td>LPT1端口</td><td></td></tr><tr><td>stdaux</td><td>标准串行设备</td><td>COM1端口</td><td></td></tr></tbody></table><h3 id="•-利用shell的I-O进行输出重定向"><a href="#•-利用shell的I-O进行输出重定向" class="headerlink" title="• 利用shell的I&#x2F;O进行输出重定向"></a>• 利用shell的I&#x2F;O进行输出重定向</h3><p><strong>• 在Linux下，文本流和二进制流是相同的</strong><br>    • 文本流是由文本行组成的序列，以’\n’结尾(或有回车符换行符<br>代替)，二进制流由未经处理的字节组成</p><p><strong>• 流与文件的连接</strong><br>    • 打开一个流，该流将与一个文件连接起来，关闭流则断开连接<br>    • 指向该打开文件的指针记录了控制该流的信息<br>    • 程序执行时， 默认会打开stdin、 stdout和stderr三个文件<br><strong>• 重定向符</strong><br>    • 输出重定向： &gt;、 &gt;&gt;、 &gt;!<br>    • 输入重定向： &lt;</p><ul><li>**<code>&gt;</code>**：将输出写入文件，覆盖原有内容。</li><li>**<code>&gt;&gt;</code>**：将输出追加到文件，不覆盖原有内容。</li><li>**<code>&lt;</code>**：将文件内容作为程序的输入。</li><li>**<code>&gt;!</code>**：在某些shell中用于强制覆盖文件（但现代shell通常不需要）。</li></ul><p><strong>• 标准错误重定向</strong><br>    • 2&gt;：标准错误重定向到一个文件，并覆盖原来的文件(b-shell)<br>    • 2&gt;&gt;：标准错误重定向到一个文件(追加)。 1&gt;默认为&gt;<br>    • 2&gt;&amp;1：将标准错误重定向到标准输出<br>    • &gt;&amp;：将一个输出重定向到另一个句柄的输入中<br><strong>• 为什么要进行重定向</strong><br>    • 将屏幕输出的重要信息保存下来<br>    • 有时候不希望打印干扰屏幕<br>    • 正确和错误的信息需要分别输出时</p><h3 id="•-使用freopen重定向输入输出流"><a href="#•-使用freopen重定向输入输出流" class="headerlink" title="• 使用freopen重定向输入输出流"></a>• 使用freopen重定向输入输出流</h3><p><strong>• 输出重定向</strong></p><p><img src="/./../../images/image-20250602182244839.png" alt="image-20250602182244839"></p><p><strong>• 错误重定向</strong></p><p><img src="/./../../images/image-20250602182421018.png" alt="image-20250602182421018"></p><h2 id="•-打印文件名、函数名、行号"><a href="#•-打印文件名、函数名、行号" class="headerlink" title="• 打印文件名、函数名、行号"></a>• 打印文件名、函数名、行号</h2><p><strong>• ANSIC标准中的几个标准预定义宏</strong><br>    • __LINE__：在源代码中插入当前源代码行号<br>    • __FILE__：在源文件中插入当前源文件名<br>    • __FUNCTION__：函数名<br>    • __DATE__：在源文件中插入当前的编译日期<br>    • __TIME__：在源文件中插入当前编译时间<br>    • __STDC__：当程序严格遵循ANSI C标准时该标识被赋值为1<br>    • __func__： C99新增加的<br><strong>• C99新增的预定义宏</strong><br>    • __VA_ARGS__：用于支持不定参数的宏定义</p><h2 id="•-打印缓冲问题"><a href="#•-打印缓冲问题" class="headerlink" title="• 打印缓冲问题"></a>• 打印缓冲问题</h2><h2 id="•-打印开关控制"><a href="#•-打印开关控制" class="headerlink" title="• 打印开关控制"></a>• 打印开关控制</h2><h2 id="•-打印等级控制"><a href="#•-打印等级控制" class="headerlink" title="• 打印等级控制"></a>• 打印等级控制</h2>]]></content>
      
      
      <categories>
          
          <category> 嵌入式软件调试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式软件调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/05/30/test/c%E5%92%8Cc++/c++%E6%95%B4%E7%90%86/"/>
      <url>/2025/05/30/test/c%E5%92%8Cc++/c++%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="c-整理"><a href="#c-整理" class="headerlink" title="c++整理"></a><strong>c++整理</strong></h1><hr><h2 id="day1内容梳理"><a href="#day1内容梳理" class="headerlink" title="day1内容梳理"></a>day1内容梳理</h2><h3 id="一、标准输入输出"><a href="#一、标准输入输出" class="headerlink" title="一、标准输入输出"></a>一、标准输入输出</h3><p>cin</p><p>cout</p><p>用的少：</p><p>cerr</p><p>clog</p><p>中文显示乱码</p><p>1、c++</p><p>临时设置 一个文件 的编码  步骤：菜单栏里面-&gt; 编辑-&gt;select Encoding 。如果是编写 c++ 程序 选择 GBK 格式</p><p>2、qt</p><p>选择utf8 格式    </p><p>设置默认编码的方式： 菜单栏里面 -&gt; 工具栏</p><h3 id="二、内存分区模型"><a href="#二、内存分区模型" class="headerlink" title="二、内存分区模型"></a>二、内存分区模型</h3><p>在c++中内存主要分为</p><p><img src="/./../../../images/image-20250530192532696.png" alt="image-20250530192532696"></p><h3 id="三、命名空间-namespace"><a href="#三、命名空间-namespace" class="headerlink" title="三、命名空间 namespace"></a>三、命名空间 namespace</h3><h4 id="1、概念：命名空间是用户自定义的一个作用域"><a href="#1、概念：命名空间是用户自定义的一个作用域" class="headerlink" title="1、概念：命名空间是用户自定义的一个作用域"></a>1、概念：命名空间是用户自定义的一个作用域</h4><h4 id="2、作用：处理程序中常见的命名冲突"><a href="#2、作用：处理程序中常见的命名冲突" class="headerlink" title="2、作用：处理程序中常见的命名冲突"></a>2、作用：处理程序中常见的命名冲突</h4><h4 id="3、三种使用方式："><a href="#3、三种使用方式：" class="headerlink" title="3、三种使用方式："></a>3、三种使用方式：</h4><h5 id="全部引用"><a href="#全部引用" class="headerlink" title="全部引用"></a>全部引用</h5><p>语法：using  namespace +空间名字 +{内容}</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">using namespace student </span><br><span class="line">&#123;</span><br><span class="line">    int a ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="部分引用"><a href="#部分引用" class="headerlink" title="部分引用"></a>部分引用</h5><p>语法：using namespace 大的命名空间::命名空间（注意 后面只能是命名空间的名字）</p><p>例如：using namespace class2308::c_class;</p><h5 id="域调用"><a href="#域调用" class="headerlink" title="域调用"></a>域调用</h5><p>例如：cout &lt;&lt; class2308::c_class::str &lt;&lt; endl;&#x2F;&#x2F;域调用</p><h3 id="四、new-delete和malloc-free"><a href="#四、new-delete和malloc-free" class="headerlink" title="四、new&#x2F;delete和malloc&#x2F;free"></a>四、new&#x2F;delete和malloc&#x2F;free</h3><h4 id="1、new申请空间"><a href="#1、new申请空间" class="headerlink" title="1、new申请空间"></a>1、new申请空间</h4><p>申请时注意初始话的操作</p><p>int * p &#x3D; new int (10)&#x2F;&#x2F;(10)为初始化 </p><p>int * p &#x3D; new int [5]{0}&#x2F;&#x2F;申请数组并初始化为零</p><h4 id="2、delete释放空间"><a href="#2、delete释放空间" class="headerlink" title="2、delete释放空间"></a>2、delete释放空间</h4><p>delete p;&#x2F;&#x2F;释放</p><p>delete [ ]  p&#x2F;&#x2F;释放连续的空间（数组） </p><h4 id="3、指针置为空"><a href="#3、指针置为空" class="headerlink" title="3、指针置为空"></a>3、指针置为空</h4><p>p &#x3D; null;（不然容易出现野指针）</p><h4 id="4、区别（面试题）"><a href="#4、区别（面试题）" class="headerlink" title="4、区别（面试题）"></a>4、区别（面试题）</h4><p>C语言里面用于动态申请内存（堆区）</p><p>malloc 与 free 是 c 里面的库函数</p><p>malloc  返回类型 void*  因此我们使用的时候 需要强制类型转换  申请大小由程序员自己设定</p><p>释放的时候  使用 free    由谁申请就由谁释放!!</p><p>在c++ 里面 用于动态申请内存和释放内存</p><p>关键字 new 与 delete</p><p>new 它的返回类型  指定类型的指针（new 什么类型 就返回什么类型的指针，无需强制类型转换），申请大小 由系统自己计算</p><p>delete 用于内存释放</p><p>malloc 与 new 都是用于动态内存申请，free 与 delete 都用于 内存释放，那么 malloc 申请的空间能否使用delete 释放？</p><p>不可以！！虽然 new 它的底层是使用了 malloc 函数，但是它会调用构造函数，delete 调用析构函数。构造函数与析构函数是一对</p><p>因此无法 实现 malloc 申请的空间 使用delete 释放</p><h3 id="五、引用与指针"><a href="#五、引用与指针" class="headerlink" title="五、引用与指针"></a>五、引用与指针</h3><h5 id="1、概念："><a href="#1、概念：" class="headerlink" title="1、概念："></a>1、概念：</h5><p>就是给变量取别名（注意时变量，常量不行）</p><p>注意：一个变量可以有多个别名   同时还可以给别名取别名  也可以给 指针取别名，但是这两种操作非常少见！！</p><h5 id="2、语法："><a href="#2、语法：" class="headerlink" title="2、语法："></a>2、语法：</h5><p>数据类型 + &amp; +别名 &#x3D; 原名；</p><h5 id="3、相同与区别"><a href="#3、相同与区别" class="headerlink" title="3、相同与区别"></a>3、相同与区别</h5><h6 id="相同："><a href="#相同：" class="headerlink" title="相同："></a>相同：</h6><p>指针 -&gt; 对地址 或者说 对内存进行操作</p><p>引用 -&gt; 对内存进行操作</p><p>1、都对内存进行操作</p><p>2、都可以作为参数传递！</p><h6 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h6><p>1.引用不可以更改指向，从一而终！！</p><p>2.必须在定义的时候初始化，因为它从一而终，无法后续初始化！！</p><p>3.引用无法自增自减</p><p>5.引用不能为空！！</p><p>5.引用通常不会取用于动态内存的申请与释放！这个由指针去实现！！</p><p>在c++ 里面引用比指针使用起来安全</p><h6 id="在什么情况下只能使用指针"><a href="#在什么情况下只能使用指针" class="headerlink" title="在什么情况下只能使用指针"></a>在什么情况下只能使用指针</h6><p>参数类型为指针的时候 只能使用</p><h3 id="六、函数的默认参数"><a href="#六、函数的默认参数" class="headerlink" title="六、函数的默认参数"></a>六、函数的默认参数</h3><h4 id="函数默认参数的作用"><a href="#函数默认参数的作用" class="headerlink" title="函数默认参数的作用:"></a>函数默认参数的作用:</h4><p>当定义一个函数的时候，可以为参数列表最后面起的每一个参数指定默认值，当调用函数的时候</p><p>如果实际参数为空，则使用默认值！如果指定了值则忽略默认值</p><h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><p>1、函数默认参数只能左最右边开始给定，不能跳跃给</p><p>2、函数默认参数 在函数声明或者实现只能有一处拥有</p><h3 id="七、函数重载"><a href="#七、函数重载" class="headerlink" title="七、函数重载"></a>七、函数重载</h3><h4 id="1、概念：-1"><a href="#1、概念：-1" class="headerlink" title="1、概念："></a>1、概念：</h4><p>指在同一作用域内，可以有一组具有相同函数名、不同参数列表的函数。这组函数被称为重载函数。</p><p>通常用来声明几组功能相似的同名函数，但是这些同名函数的参数列表必须有所不同</p><h4 id="2、作用："><a href="#2、作用：" class="headerlink" title="2、作用："></a>2、作用：</h4><p>减少用户的复杂性；减少了函数名的数量，避免名字空间的污染，有利于程序的可读性</p><h4 id="3、满足条件"><a href="#3、满足条件" class="headerlink" title="3、满足条件"></a>3、满足条件</h4><p>同域(同一作用域)、同名（相同函数名）、不同表(参数列表不同 -&gt;参数个数不同、参数类型不同、参数类型顺序不同)</p><p>注意: 函数返回值是不能够作为 重载判断的依据</p><h3 id="八、函数二义性"><a href="#八、函数二义性" class="headerlink" title="八、函数二义性"></a>八、函数二义性</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><p>在调用函数时，编译器无法判断调用哪个函数，导致错误。</p><p>通常由函数重载引起、命名空间、引用等不当使用引起的</p><h3 id="九、extern-“C”"><a href="#九、extern-“C”" class="headerlink" title="九、extern “C”"></a>九、extern “C”</h3><h4 id="1、作用"><a href="#1、作用" class="headerlink" title="1、作用"></a>1、作用</h4><p>关键字 extern “C”</p><p>extern 在 C 里面 的作用：允许外部文件访问</p><p>在c++ 里面 extern “C” 的作用</p><p>c++ 他是基于 C 的一种编程语言，因此它可以使用c 语言的编译规则</p><p>extern “C”{ 内容} 里面的内容就会以C 语言恶的编译规则进行编译！！</p><p>extern “C” 强制编译器 以C 语言的编译规则 编译{ }里的内容！！</p><h3 id="十、类"><a href="#十、类" class="headerlink" title="十、类"></a>十、类</h3><h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><p>关键字 class 后接类名。类的主题是包含在一对花括号中。类的定义必须要以分号结尾</p><h4 id="2、权限"><a href="#2、权限" class="headerlink" title="2、权限"></a>2、权限</h4><p>​    有三个权限：公开的（public）、保护（protected）、私有的(private)</p><p>​    公开的: 在类内与类外都可以直接访问</p><p>​    保护的: 只能在类内访问，类外无法访问（派生类可以访问）</p><p>​    私有的: 只能在类内访问，类外无法访问(派生类无法访问)</p><p>如果想要在类外访问私有属性-》自定义函数接口</p><h4 id="3、封装"><a href="#3、封装" class="headerlink" title="3、封装"></a>3、封装</h4><p>C++ 之封装</p><p>封装作为C++ 的三大特性之一</p><p>定义：将属性和行为作为一个整体，并给予权限控制来表现生活中的万事万物</p><p>访问数据成员</p><p>对于类对象的公共数据成员 可以直接使用成员访问运算符 . 来访问</p><p>对于指针对象的公共数据成员 可以直接使用成员访问运算符 -&gt; 来访问</p><p>对于保护属性和私有属性 ，如果我们想去访问</p><p>方法1：在公共属性里面 书写自定义接口，来进行间接访问</p><p>方法2：使用友元！！</p><h4 id="4、友元"><a href="#4、友元" class="headerlink" title="4、友元"></a>4、友元</h4><h5 id="1、概念：-2"><a href="#1、概念：-2" class="headerlink" title="1、概念："></a>1、概念：</h5><p>在程序里，有些私有属性也想让类外的特殊的一些函数或者类进行访问，这就需要用到友元的技术，友元的目的就是让一个函数或者类访问另外一个类中的私有（private）或者保护（protected）成员。</p><h4 id="2、关键字："><a href="#2、关键字：" class="headerlink" title="2、关键字："></a>2、关键字：</h4><p>friend</p><h4 id="3、使用方法"><a href="#3、使用方法" class="headerlink" title="3、使用方法"></a>3、使用方法</h4><h5 id="1、全局函数作友元"><a href="#1、全局函数作友元" class="headerlink" title="1、全局函数作友元"></a>1、全局函数作友元</h5><p>声明这个函数是我的友元函数 它可以访问我的所有属性</p><p>语法：friend + 函数返回类型 + 函数名 + 函数参数列表</p><h5 id="2、类作友元"><a href="#2、类作友元" class="headerlink" title="2、类作友元"></a>2、类作友元</h5><p>这个类的所有的方法都可以访问我的私有属性</p><p>语法：friend + class + 类名</p><h5 id="3、类的成员函数作友元"><a href="#3、类的成员函数作友元" class="headerlink" title="3、类的成员函数作友元"></a>3、类的成员函数作友元</h5><p>只有这个类中特定的函数可以访问我的私有属性！！！</p><p>语法：friend + 函数返回类型 + 类名 + ::（域调用符） + 函数名 + 函数参数列表</p><h3 id="十一、struct-和-class-有什么区别"><a href="#十一、struct-和-class-有什么区别" class="headerlink" title="十一、struct 和 class 有什么区别"></a>十一、struct 和 class 有什么区别</h3><p>只有一个区别，就是默认权限不同！</p><p>struct 的默认权限是 public</p><p>class的默认权限是 private</p><h3 id="十二、this指针"><a href="#十二、this指针" class="headerlink" title="十二、this指针"></a>十二、this指针</h3><h4 id="1、概念-1"><a href="#1、概念-1" class="headerlink" title="1、概念"></a>1、概念</h4><p>this指针是一个指向当前对象的指针，不可更改指向，但是可以更改指向内容。</p><h4 id="2、使用注意事项"><a href="#2、使用注意事项" class="headerlink" title="2、使用注意事项"></a>2、使用注意事项</h4><p>1、this指针指向的是当前对象的地址</p><p>2、this指针是只能在成员函数中使用</p><p>3、this指针是作为成员函数的隐含参数，谁调用就指向谁</p><p>4、友元函数（全局函数）能否使用this指针？</p><p>不行；不是成员函数</p><h4 id="3、用处：当成员函数的形参与类中的成员属性名字相同时，需要用this指针来区分。"><a href="#3、用处：当成员函数的形参与类中的成员属性名字相同时，需要用this指针来区分。" class="headerlink" title="3、用处：当成员函数的形参与类中的成员属性名字相同时，需要用this指针来区分。"></a>3、用处：当成员函数的形参与类中的成员属性名字相同时，需要用this指针来区分。</h4><h3 id="十三、构造函数"><a href="#十三、构造函数" class="headerlink" title="十三、构造函数"></a>十三、构造函数</h3><h4 id="1、概念-2"><a href="#1、概念-2" class="headerlink" title="1、概念"></a>1、概念</h4><p>归属与类的成员函数，主要用来初始化类的属性。</p><h4 id="2、语法"><a href="#2、语法" class="headerlink" title="2、语法"></a>2、语法</h4><p>类内实现：类名（）+{}</p><p>类外实现：类内声明，类名+::+函数名（）+{}</p><p>如果是普通函数的类外实现</p><p>语法：</p><p>返回类型 +类名+：：+函数名+（）+{}；</p><h4 id="3、使用注意事项"><a href="#3、使用注意事项" class="headerlink" title="3、使用注意事项"></a>3、使用注意事项</h4><p>1、构造函数没有返回值，也不是void型。</p><p>2、构造函数函数名就是类名</p><p>3、构造函数可以有参数，也可以没有参数，因此可以发生函数重载、</p><p>4、构造函数在创建对象的时候，自动调用构造函数，每个对象最多且一定会调用一次构造函数</p><p>5、构造函数通常用于初始化属性的操作</p><p>6、当类中没有一个构造函数时，系统会自动提供一个空的无参构造函数。</p><h4 id="4、分类"><a href="#4、分类" class="headerlink" title="4、分类"></a>4、分类</h4><p>参数分类</p><p>分为有参构造函数、无参构造函数</p><p>类型分类</p><p>分为普通构造、拷贝构造</p><p>拷贝构造分为浅拷贝和深拷贝</p><h3 id="十四、析构函数"><a href="#十四、析构函数" class="headerlink" title="十四、析构函数"></a>十四、析构函数</h3><h4 id="1、概念-3"><a href="#1、概念-3" class="headerlink" title="1、概念"></a>1、概念</h4><p>归属于类的成员函数，主要用于回收资源，与构造函数是一对</p><h4 id="2、语法-1"><a href="#2、语法-1" class="headerlink" title="2、语法"></a>2、语法</h4><p>同样可以分为类内实现和类外实现</p><p>类内：~+类名+（）+{}</p><p>类外：类内先先声明，<del>+类名::+</del>+类名+（）+{}</p><h4 id="3、使用注意事项-1"><a href="#3、使用注意事项-1" class="headerlink" title="3、使用注意事项"></a>3、使用注意事项</h4><p>1、析构函数也没有返回值</p><p>2、析构函数的函数名 &#x3D; ~+类名</p><p>3、析构函数都没有参数，所有不会发生函数重载</p><p>4、析构函数在销毁对象时，系统自动调用，每个对象最多只能调用一次</p><p>5、析构函数通常用于回收资源</p><p>6、当类中没有一个析构函数时，系统会提供一个空的，默认无参的析构函数，如果没有析构函数，对象将无法被销毁。</p><p>7、手动调用析构函数，不会回收资源，他就只能当作一个普通函数</p><p>注意：默认的析构函数只能回收栈区的资源，对于new申请的堆区的资源，需要手动去释放回收</p><h3 id="十五、浅拷贝与深拷贝"><a href="#十五、浅拷贝与深拷贝" class="headerlink" title="十五、浅拷贝与深拷贝"></a>十五、浅拷贝与深拷贝</h3><p>两者同样属于构造函数</p><h4 id="1、浅拷贝"><a href="#1、浅拷贝" class="headerlink" title="1、浅拷贝"></a>1、浅拷贝</h4><p>不会new堆区</p><p>只是做简单的赋值，不会设计到动态内存的申请</p><h4 id="2、深拷贝"><a href="#2、深拷贝" class="headerlink" title="2、深拷贝"></a>2、深拷贝</h4><p>会重新申请一个堆区。</p><p>因此，当涉及到堆区，那就一定要写一个深拷贝。</p><h4 id="3、语法"><a href="#3、语法" class="headerlink" title="3、语法"></a>3、语法</h4><p>语法与构造函数一样。类名 +（）+{}</p><p>但要注意：</p><p>拷贝构造只能有一个参数const Person &amp;p，如果参数不止一个，或者别的，那么就不是拷贝构造了</p><ul><li><strong>浅拷贝</strong>：简单地复制成员变量的值，可能会导致动态分配内存的共享问题。</li><li><strong>深拷贝</strong>：为动态分配的内存分配新的副本，确保每个对象都有自己的数据副本，避免了共享内存的问题。</li></ul><h3 id="十六、构造函数的使用方法"><a href="#十六、构造函数的使用方法" class="headerlink" title="十六、构造函数的使用方法"></a>十六、构造函数的使用方法</h3><h4 id="括号法（常用）"><a href="#括号法（常用）" class="headerlink" title="括号法（常用）"></a>括号法（常用）</h4><p>person p1 无参函数</p><p>person p1（10,”zhangsan”）有参函数</p><p>person p1(p2)       拷贝构造</p><h4 id="显示引用"><a href="#显示引用" class="headerlink" title="显示引用"></a>显示引用</h4><p>person p1</p><p>person p1 &#x3D; person (10,”zhangsan”)</p><p>person p2 &#x3D; person (p1)</p><h4 id="隐式转换法"><a href="#隐式转换法" class="headerlink" title="隐式转换法"></a>隐式转换法</h4><p> Person p7 &#x3D; {10,”张三”};</p><p> 如果Person 里面就只有一个参数 int ;  Person p8 &#x3D; 10;</p><h3 id="十七、const的作用"><a href="#十七、const的作用" class="headerlink" title="十七、const的作用"></a>十七、const的作用</h3><h4 id="1、使用const修饰属性"><a href="#1、使用const修饰属性" class="headerlink" title="1、使用const修饰属性"></a>1、使用const修饰属性</h4><p>1.const修饰后的属性不可更改，必须初始化（定义的时候初始化，或者使用初始化列表）</p><h4 id="2、使用const修饰方法"><a href="#2、使用const修饰方法" class="headerlink" title="2、使用const修饰方法"></a>2、使用const修饰方法</h4><p>2.const修饰词，写在函数参数列表之后</p><p>3.const修饰的函数，声明和定义都必须要加const</p><p>4.const 修饰的成员函数可以和普通成员函数构成重载(重载的特例)</p><p>5.const 修饰的函数，对于非static 修饰的变量来说 只有读的权限而没有写的权限,而对satic 修饰的变量来说有读写的权限</p><p>6.const 修饰的函数，只能调用 const 修饰或者 static 修饰的函数，全局函数</p><p>7.普通函数可以调用常量函数（第6和7点，const修饰函数和普通函数的区别）</p><p>8.const 修饰的对象只能调用const修饰的函数，和static修饰的函数。</p><p>9.普通对象优先调用普通函数,但是也可以调用常量函数和静态函数（第8和9点，const修饰对象和普通对象的区别）</p><h3 id="十八、初始化列表"><a href="#十八、初始化列表" class="headerlink" title="十八、初始化列表"></a>十八、初始化列表</h3><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>初始化列表 可以初始化所有未被 static 修饰的本体属性，</p><p>当定义初始化和初始化列表同时出现时，以初始化列表为准。</p><h4 id="使用条件："><a href="#使用条件：" class="headerlink" title="使用条件："></a>使用条件：</h4><p>只能在构造函数里使用，在其余地方统统无法使用！！！初始化列表中也不能有this</p><h4 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h4><p>构造函数():变量1(值)，变量2（值2），变量3（）</p><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>对修改实施关闭（对之前的代码 原则上是不能修改的），对拓展实施开放（对你后面添加的代码可以修改）</p><h3 id="十九、静态成员static"><a href="#十九、静态成员static" class="headerlink" title="十九、静态成员static"></a>十九、静态成员static</h3><h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><p> static</p><p>tatic 修饰属性(可以记录函数的状态，比如说调用了多少次，或者说记录有多少个对象)</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>1、static 修饰的不占用类的空间，它存在全局的静态副本当中</p><p>2、只能在类外初始化，语法为 数据类型 + 类名 + :: + 变量名 &#x3D; 值</p><h4 id="static-修饰方法"><a href="#static-修饰方法" class="headerlink" title="static 修饰方法"></a>static 修饰方法</h4><p>3、static 修饰的函数只能调用 static 修饰的函数或者是全局函数</p><p>4、static 关键字要放在函数返回类型之前，只能在声明的时候 加上static ,在类外实现不可以加static</p><p>5、static 修饰的函数无法使用this 指针</p><p>6、static 修饰的函数只能访问static修饰的属性。而不能访问其他属性</p><h4 id="static-修饰的成员"><a href="#static-修饰的成员" class="headerlink" title="static 修饰的成员"></a>static 修饰的成员</h4><p>7、所有对象可以公用一个静态副本</p><p>8、static修饰的成员（属性和方法）不依赖于特定的对象存在，可以通过 类名 + :: + 成员名 直接调用</p><h4 id="static-修饰函数和普通成员函数的区别是什么？"><a href="#static-修饰函数和普通成员函数的区别是什么？" class="headerlink" title="static 修饰函数和普通成员函数的区别是什么？"></a>static 修饰函数和普通成员函数的区别是什么？</h4><p>static 修饰的函数可以不依赖于特定的对象，同时它还不能有this 指针</p><p>注意：每一个的类的静态副本都不同，但是同一个类的静态副本一定是一样的！！</p><h3 id="二十、运算符重载"><a href="#二十、运算符重载" class="headerlink" title="二十、运算符重载"></a>二十、运算符重载</h3><h4 id="1、概念-4"><a href="#1、概念-4" class="headerlink" title="1、概念"></a>1、概念</h4><p>对已有的运算符进行重新定义，赋予另外一种功能，以适应不同的数据类型</p><h4 id="2、语法-2"><a href="#2、语法-2" class="headerlink" title="2、语法"></a>2、语法</h4><p>函数的返回值 +函数名+参数列表；</p><p>operator + 重载的符号 </p><h4 id="3、运算符重载的形式"><a href="#3、运算符重载的形式" class="headerlink" title="3、运算符重载的形式"></a>3、运算符重载的形式</h4><p>1、重载为成员函数（大部分）</p><p>2、重载为全局函数</p><h4 id="4、不能重载的运算符（四类）"><a href="#4、不能重载的运算符（四类）" class="headerlink" title="4、不能重载的运算符（四类）"></a>4、不能重载的运算符（四类）</h4><p>1、成员访问运算符</p><p>.  -&gt;</p><p>2、成员指针访问运算符</p><p>.*  -&gt;*</p><p>3、域运算符</p><p>::</p><p>4、长度运算符</p><p>sizeof</p><p>5、预定义符</p><p>#。</p><h2 id="day3"><a href="#day3" class="headerlink" title="day3"></a>day3</h2><p>​    </p><h3 id="二十一、几类运算符重载"><a href="#二十一、几类运算符重载" class="headerlink" title="二十一、几类运算符重载"></a>二十一、几类运算符重载</h3><h4 id="1、概念-5"><a href="#1、概念-5" class="headerlink" title="1、概念"></a>1、概念</h4><p>对已有的运算符进行重新定义，赋予另外一种功能，以适应不同的数据类型。</p><h4 id="2、数据类型"><a href="#2、数据类型" class="headerlink" title="2、数据类型"></a>2、数据类型</h4><p>1、系统本身就有的（如：int  char ..）称为内置数据类型</p><p>2、系统没有的，由我们自己定义的 ，称自定义数据类型 如：类</p><h4 id="3、语法-1"><a href="#3、语法-1" class="headerlink" title="3、语法"></a>3、语法</h4><p>返回值 + operator + 被重载的运算符 （）+{}；</p><h4 id="4、分类-1"><a href="#4、分类-1" class="headerlink" title="4、分类"></a>4、分类</h4><p>重载可以重载为成员函数和全局函数</p><h4 id="5、注意事项"><a href="#5、注意事项" class="headerlink" title="5、注意事项"></a>5、注意事项</h4><p>注意返回值是否需要引用。</p><p>自己理解：</p><p>引用可以保护值不被修改</p><p>返回值是引用的话，返回出去的则是一个地址</p><p>没有引用，则只是一个值，再后续使用方面需要注意</p><h4 id="6、几类重载"><a href="#6、几类重载" class="headerlink" title="6、几类重载"></a>6、几类重载</h4><p>四则运算符重载</p><p>自增自减运算符</p><p>关系运算符重载</p><p>赋值运算符重载</p><p>【】重载</p><h4 id="7、仿函数"><a href="#7、仿函数" class="headerlink" title="7、仿函数"></a>7、仿函数</h4><p>（）括号运算符重载</p><p>由于重载之后，使用起来与函数非常相似，因此我们称 重载函数调用运算符的类 叫做仿函数</p><p>仿函数的写法非常灵活 ，返回类型，参数个数，参数类型，都可以按需求给</p><h3 id="二十二、继承"><a href="#二十二、继承" class="headerlink" title="二十二、继承"></a>二十二、继承</h3><p>c++ 三大特性之 继承</p><h4 id="1、为什么要有继承（优点）"><a href="#1、为什么要有继承（优点）" class="headerlink" title="1、为什么要有继承（优点）"></a>1、为什么要有继承（优点）</h4><p>1、继承作为C++ 三大特性之一，它允许我门用一个已存在的类去定义一个新的类，这使得创建和维护程序变得更容易</p><p>2、提高代码的复用率和执行效率</p><h4 id="2、继承有什么缺点呢？"><a href="#2、继承有什么缺点呢？" class="headerlink" title="2、继承有什么缺点呢？"></a>2、继承有什么缺点呢？</h4><p>1、继承是由侵入性的，只要继承，子类就会继承父类所有的属性和方法（除了父类的构造、析构、运算符重载、友元），让子类的自由世界多了约束</p><p>2、当父类的属性更改的时候，子类的属性会随之更改，如果缺乏了规范的环境，这种修改可能会导致整个项目崩盘！！</p><h4 id="3、怎么继承"><a href="#3、怎么继承" class="headerlink" title="3、怎么继承"></a>3、怎么继承</h4><p>已有的类-&gt; 父类也叫基类</p><p>新建类-&gt;子类 和 派生类！！</p><p>关系：子类会继承父类的所有的属性与方法（除了父类的构造、析构、运算符重载、友元）</p><p>注意：子类会继承父类的私有属性，但是没有权限去访问！！</p><h4 id="4、c"><a href="#4、c" class="headerlink" title="4、c"></a>4、c</h4><p>通过已有的human 创建一个子类 black_human</p><p>语法：class + 子类名称 : + 继承方式 + 父类名</p><p>类中的三个权限</p><p>public    -&gt; 类内  类外  派生类内 可以访问</p><p>protected -&gt; 类内  派生类内  可以访问</p><p>private   -&gt; 只能类内访问</p><h4 id="5、继承的三种方式"><a href="#5、继承的三种方式" class="headerlink" title="5、继承的三种方式"></a>5、继承的三种方式</h4><p>public    公开继承:父类 的属性和方法 处于什么权限，在子类这里就是什么权限</p><p>protected 保护继承:父类的公开属性和方法 在子类属于 保护权限。其余不变</p><p>privte    私有继承:父类公开的权限和保护的权限，在子类这里属于私有权限</p><p>注意：子类在创建对象的时候，会优先创建一个父类对象，（如果有多个父类，按继承的从左至右依次创建，如果类中与其他类成员，会从上到下依次创建）然后再创建本身，析构的时候 会先析构子类再析构父类</p><p>记住，析构的顺序 和 构造的顺序 无论何时都是相反的！！！</p><p>如果子类和父类拥有相同的属性或者方法的时候，会不会冲突呢？</p><p>不会冲突。使用域调用符区分开来</p><p>m.Human::age</p><h4 id="6、函数隐藏！！"><a href="#6、函数隐藏！！" class="headerlink" title="6、函数隐藏！！"></a>6、函数隐藏！！</h4><p>函数隐藏是在继承中，对子类中函数调用时，会优先调用子类中的函数，而父类中的函数会隐藏。（注意与多态的区别，多态有重写，基本涉及到重写就与多态有关）</p><p>访问父类函数的方法：</p><p>父类名 + ：：+函数。</p><h4 id="7、注意：针对上面问题"><a href="#7、注意：针对上面问题" class="headerlink" title="7、注意：针对上面问题"></a>7、注意：针对上面问题</h4><p>1、访问子类同名成员直接访问即可</p><p>2、访问父类同名成员需要加作用域 -&gt;m.Human::age</p><h4 id="8、继承中调用构造函数和析构函数的顺序"><a href="#8、继承中调用构造函数和析构函数的顺序" class="headerlink" title="8、继承中调用构造函数和析构函数的顺序"></a>8、继承中调用构造函数和析构函数的顺序</h4><p>1、注意：子类在创建对象的时候，会优先创建一个父类对象，然后再创建本身，析构的时候 会先析构子类再析构父类</p><p>如果类中有其他类成员的存在，则会按从上到下的顺序依次调用其他类的构造函数来构建，最后再创建本身。</p><p>2、记住，析构的顺序 和 构造的顺序 无论何时都是相反的！！！</p><h4 id="9、继承之多继承"><a href="#9、继承之多继承" class="headerlink" title="9、继承之多继承"></a>9、继承之多继承</h4><p>1、概念</p><p>多继承即一个子类可以有多个父类，它会继承所有父类的属性和方法（除了构造、析构、运算符重载、友元）。</p><p>2、语法</p><p>class 子类名: 继承方式1 父类1名字，继承方式2 父类2的名字，继承方式3 父类3的名字</p><p>多继承的父类的构造顺序: 根据继承的顺序从左到右</p><p>如果继承父类和子类拥有相同的属性和方法是，如何调用父类的属性和方法？ -&gt; 和单继承一样  子类对象.父类名:: 属性或者方法名</p><h4 id="10、菱形继承"><a href="#10、菱形继承" class="headerlink" title="10、菱形继承"></a>10、菱形继承</h4><p>1、概念</p><p>菱形继承：两个派生类继承同一个基类，又有某一个类A同时继承这两个派生类，这种继承我们成为菱形继承又叫钻石继承</p><p>2、多继承遇到的问题</p><p>会发生菱形继承和环形继承</p><p>只要会导致 类A 会有两份重复的数据，从而导致资源浪费</p><p>3、解决方法</p><p> 虚继承！！  -&gt; 代表我愿意共享我的父类</p><p>使用了虚继承的类 会拥有一个虚指针，这个虚指针 -&gt; 虚表 -&gt; 存放属性的地址</p><h4 id="11、环形继承"><a href="#11、环形继承" class="headerlink" title="11、环形继承"></a>11、环形继承</h4><p>与菱形继承一样，</p><h2 id="day4"><a href="#day4" class="headerlink" title="day4"></a>day4</h2><p>上午主要简述大作业</p><h3 id="二十三、多态"><a href="#二十三、多态" class="headerlink" title="二十三、多态"></a>二十三、多态</h3><h4 id="1、概念-6"><a href="#1、概念-6" class="headerlink" title="1、概念"></a>1、概念</h4><p>C++ 三大特性之多态</p><p>多态：多种形态多种姿态</p><p>在c++ 里面表达的意思就是，一个api 函数接口实现多种不同的功能</p><h4 id="2、分类"><a href="#2、分类" class="headerlink" title="2、分类"></a>2、分类</h4><p>多态分为两类</p><p>静态多态:地址早绑定，编译的时候就绑定了函数地址，比如说函数重载</p><p>动态多态:地址晚绑定，在运行的时候绑定地址。</p><h4 id="3、父类与子类指针的关系"><a href="#3、父类与子类指针的关系" class="headerlink" title="3、父类与子类指针的关系"></a>3、父类与子类指针的关系</h4><p>在学习多态之前</p><p>父类   : 父类指针指向子类  -&gt;合理合法  安全</p><p>子类   : 子类的指针指向父类 -&gt;不合法 不安全</p><p>如果非要子类的指针指向父类 -&gt; 强制类型转换！！</p><h4 id="4、多态满足的条件"><a href="#4、多态满足的条件" class="headerlink" title="4、多态满足的条件"></a>4、多态满足的条件</h4><p>动态多态的满足条件</p><p>1、必须要有继承，并且为公开继承！！</p><p>2、子类必须重写父类的虚函数（使用virtual 修饰的函数）</p><p>3、父类的指针或者引用指向子类(这个也是动态多态的使用条件！！)</p><h4 id="5、什么是函数重写"><a href="#5、什么是函数重写" class="headerlink" title="5、什么是函数重写"></a>5、什么是函数重写</h4><p>1、必须要有继承</p><p>2、父类必须存在vitrual 修饰的函数</p><p>3、子类重写父类的虚函数 必须保持 函数返回类型 函数名 函数参数列表一致！</p><h4 id="6、表达的形式"><a href="#6、表达的形式" class="headerlink" title="6、表达的形式"></a>6、表达的形式</h4><p>通过父类的对象 去调用子类的重写方法！！</p><h4 id="7、override关键字"><a href="#7、override关键字" class="headerlink" title="7、override关键字"></a>7、override关键字</h4><p>检测该函数是否被重写了，如果没有重写那就报错</p><h4 id="8、使用多态遇到的问题"><a href="#8、使用多态遇到的问题" class="headerlink" title="8、使用多态遇到的问题"></a>8、使用多态遇到的问题</h4><p>如果子类中含有堆区属性，那么父类指针再释放的时候无法调用子类的析构函数，因此可能会导致内存泄漏</p><p>解决方法：在父类中 添加虚析构或者纯虚析构</p><p>原理：使用虚析构 会使得父类对象指针被释放的时候，优先释放其子类的空间</p><h4 id="经典例子："><a href="#经典例子：" class="headerlink" title="经典例子："></a>经典例子：</h4><p><img src="/./../../../images/5562df21114bd7ab5510a99693833179.png" alt="在这里插入图片描述"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">案例-电脑组装</span></span><br><span class="line"><span class="comment">描述：电脑主要组成部件为CPU(用于计算)、显卡（用于显示）、内存条（用于存储），</span></span><br><span class="line"><span class="comment">将每个零件封装出抽象类，并且提供不同的厂商生产不同的零件，例如inter 厂商和Lenovo 厂商，</span></span><br><span class="line"><span class="comment">创建电脑类提供让电脑工作的函数，并调用每个零件工作的接口，测试的时候要组装三台不同的电脑进行组装</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPU</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CPU</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;CPU 的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">CPU</span>() = <span class="number">0</span>;<span class="comment">//如果使用了纯虚析构 那就只能在类外实现析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">cpu_work</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//cpu 工作函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CPU::~<span class="built_in">CPU</span>()</span><br><span class="line">&#123;</span><br><span class="line">      cout &lt;&lt; <span class="string">&quot;CPU 的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MemmoryCadr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MemmoryCadr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MemmoryCadr 的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">MemmoryCadr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;MemmoryCadr 的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">MemmoryCadr_work</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//内存条 工作函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DisPlayCard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DisPlayCard</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;DisPlayCard 的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">DisPlayCard</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;DisPlayCard 的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">DisPlayCard_work</span><span class="params">()</span> </span>= <span class="number">0</span>;<span class="comment">//显卡的 工作函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Lenovo</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lenovo_MemmoryCadr</span>:<span class="keyword">public</span> MemmoryCadr</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Lenovo_MemmoryCadr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Lenovo_MemmoryCadr 的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Lenovo_MemmoryCadr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Lenovo_MemmoryCadr 的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MemmoryCadr_work</span><span class="params">()</span><span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;联想的 内存条 开始存储了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lenovo_DisPlayCard</span>:<span class="keyword">public</span> DisPlayCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Lenovo_DisPlayCard</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Lenovo_DisPlayCard 的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Lenovo_DisPlayCard</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Lenovo_DisPlayCard 的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DisPlayCard_work</span><span class="params">()</span><span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;联想的 显卡 开始显示了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lenovo_cpu</span>:<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Lenovo_cpu</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Lenovo_cpu 的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Lenovo_cpu</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Lenovo_cpu 的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cpu_work</span><span class="params">()</span><span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;联想的 cpu 开始计算了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Inter</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inter_MemmoryCadr</span>:<span class="keyword">public</span> MemmoryCadr</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Inter_MemmoryCadr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Inter_MemmoryCadr 的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Inter_MemmoryCadr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Inter_MemmoryCadr 的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">MemmoryCadr_work</span><span class="params">()</span><span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;因特尔的 内存条 开始存储了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inter_DisPlayCard</span>:<span class="keyword">public</span> DisPlayCard</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Inter_DisPlayCard</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Inter_DisPlayCard 的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Inter_DisPlayCard</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Inter_DisPlayCard 的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DisPlayCard_work</span><span class="params">()</span><span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;</span></span><br><span class="line"><span class="string">            因特尔的 显卡 开始显示了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inter_cpu</span>:<span class="keyword">public</span> CPU</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Inter_cpu</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Inter_cpu 的构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Inter_cpu</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Inter_cpu 的析构函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cpu_work</span><span class="params">()</span><span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;因特尔的 cpu 开始计算了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算机组装类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">computer</span>(CPU *cpu,MemmoryCadr *mem,DisPlayCard *dis)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cpu = cpu;</span><br><span class="line">        <span class="keyword">this</span>-&gt;mem = mem;</span><br><span class="line">        <span class="keyword">this</span>-&gt;dis = dis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">computer_work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;cpu-&gt;<span class="built_in">cpu_work</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;dis-&gt;<span class="built_in">DisPlayCard_work</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;mem-&gt;<span class="built_in">MemmoryCadr_work</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CPU *cpu;</span><br><span class="line">    MemmoryCadr *mem;</span><br><span class="line">    DisPlayCard *dis;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用多态会遇到的问题</span></span><br><span class="line"><span class="comment">//如果子类中含有堆区属性，那么父类指针再释放的时候无法调用子类的析构函数，因此可能会导致内存泄漏</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方法：再父类中 添加虚析构或者纯虚析构</span></span><br><span class="line"><span class="comment">//纯虚析构和虚析构的作用一致</span></span><br><span class="line"><span class="comment">//原理：使用虚析构 会使得父类对象指针被释放的时候，优先释放其子类的空间，如果子类的空间全部被释放完毕，才会释放父类的空间</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//联想的三个零件</span></span><br><span class="line">    CPU *lev_cpu = <span class="keyword">new</span> Lenovo_cpu;</span><br><span class="line">    MemmoryCadr *lev_mem = <span class="keyword">new</span> Lenovo_MemmoryCadr;</span><br><span class="line">    DisPlayCard *lev_dis = <span class="keyword">new</span> Lenovo_DisPlayCard;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Inter 的三个零件</span></span><br><span class="line">    CPU *int_cpu = <span class="keyword">new</span> Inter_cpu;</span><br><span class="line">    MemmoryCadr *int_mem = <span class="keyword">new</span> Inter_MemmoryCadr;</span><br><span class="line">    DisPlayCard *int_dis = <span class="keyword">new</span> Inter_DisPlayCard;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;--------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//制作一台纯联想的</span></span><br><span class="line">    <span class="function">computer <span class="title">c1</span><span class="params">(lev_cpu,lev_mem,lev_dis)</span></span>;</span><br><span class="line">    c<span class="number">1.</span><span class="built_in">computer_work</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------------------联想电脑已启动---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//制作一台纯因特尔的</span></span><br><span class="line">    <span class="function">computer <span class="title">c2</span><span class="params">(int_cpu,int_mem,int_dis)</span></span>;</span><br><span class="line">    c<span class="number">2.</span><span class="built_in">computer_work</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------------------因特尔电脑已启动---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//制作一台混动的</span></span><br><span class="line">    <span class="function">computer <span class="title">c3</span><span class="params">(int_cpu,lev_mem,int_dis)</span></span>;</span><br><span class="line">    c<span class="number">3.</span><span class="built_in">computer_work</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;----------------------------混装电脑已启动---------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------------------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> lev_cpu;</span><br><span class="line">    <span class="keyword">delete</span> lev_mem;</span><br><span class="line">    <span class="keyword">delete</span> lev_dis;</span><br><span class="line">    <span class="keyword">delete</span> int_cpu;</span><br><span class="line">    <span class="keyword">delete</span> int_mem;</span><br><span class="line">    <span class="keyword">delete</span> int_dis;</span><br><span class="line">    lev_cpu = <span class="literal">NULL</span>;</span><br><span class="line">    lev_mem = <span class="literal">NULL</span>;</span><br><span class="line">    lev_dis = <span class="literal">NULL</span>;</span><br><span class="line">    int_cpu = <span class="literal">NULL</span>;</span><br><span class="line">    int_mem = <span class="literal">NULL</span>;</span><br><span class="line">    int_dis = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二十四、抽象类"><a href="#二十四、抽象类" class="headerlink" title="二十四、抽象类"></a>二十四、抽象类</h3><h4 id="1、纯虚函数"><a href="#1、纯虚函数" class="headerlink" title="1、纯虚函数"></a>1、纯虚函数</h4><p>通过上一节 可以发现  父类的虚函数的作用 就是提供一个接口让子类重写实现动态多态，里面的内容无关紧要</p><p>因此我们可以将虚函数变成纯虚函数</p><p>虚函数的语法: virtual + 函数返回类型 + 函数名+ 函数参数列表{}</p><p>纯虚函数:virtual + 函数返回类型 + 函数名+ 函数参数列表 &#x3D; 0;</p><p>如果父类是纯虚函数，我们可以不去实现它！！</p><h4 id="2、概念"><a href="#2、概念" class="headerlink" title="2、概念"></a>2、概念</h4><p>抽象类：含有纯虚函数的类，我们称为抽象类</p><h4 id="3、特点"><a href="#3、特点" class="headerlink" title="3、特点"></a>3、特点</h4><p>特点1、无法实例化具体的对象</p><p>特点2、如果子类继承了一个抽象类，并且子类没有重写父类所有的纯虚函数，那么子类也是一个抽象类，无法实例化对象</p><h4 id="4、因此纯虚函数存在的意义为？"><a href="#4、因此纯虚函数存在的意义为？" class="headerlink" title="4、因此纯虚函数存在的意义为？"></a>4、因此纯虚函数存在的意义为？</h4><p>强制子类重写父类的纯虚函数，用来实现动态多态，否则将毫无意义！</p><h3 id="二十五、文本文件输入输出流"><a href="#二十五、文本文件输入输出流" class="headerlink" title="二十五、文本文件输入输出流"></a>二十五、文本文件输入输出流</h3><p>为了保持数据的持久化  我们需要将数据保存在文件当中</p><h4 id="1、文件类型"><a href="#1、文件类型" class="headerlink" title="1、文件类型"></a>1、文件类型</h4><p>文本文件、二进制文件</p><p>c++ 中如何要对文件操作 必须包含一个头文件 <fstream> 文件流</fstream></p><p>在此头文件里面有</p><h4 id="2、文件操作三大类"><a href="#2、文件操作三大类" class="headerlink" title="2、文件操作三大类"></a>2、文件操作三大类</h4><p>ofstream: 写操作 -&gt; 将数据从内存 输出到 文件当中</p><p>ifsteam :读操作  -&gt; 将数据从文件里面读取到内存当中</p><p>fstream :读写操作</p><h4 id="3、文本文件的写入"><a href="#3、文本文件的写入" class="headerlink" title="3、文本文件的写入"></a>3、文本文件的写入</h4><p>1、添加头文件 <fstream></fstream></p><p>2、创建流对象 ofstream ofs;</p><p>3、打开文件: ofs.open(“文件路径”,打开方式)</p><p>4、写数据: ofs &lt;&lt; “写入数据”</p><p>5、关闭文件: ofs.close</p><h4 id="打开方式："><a href="#打开方式：" class="headerlink" title="打开方式："></a>打开方式：</h4><p> * ios:: in  以只读的方式打开文件</p><p> * ios::out  以只写的方式打开头文件   以覆盖的方式写入</p><p> * ios::ate  初始位置:文件尾部</p><p> * ios::app  以追加的方式写入文件</p><p> * ios::trunc 如果文件存在 则销毁再创建</p><p> * ios::binary 以二进制的形式打开文件</p><p> * 如果你想多个打开方式组合</p><p> * ios::in | ios::out  以读写的方式打开</p><h4 id="4、文本文件的读取"><a href="#4、文本文件的读取" class="headerlink" title="4、文本文件的读取"></a>4、文本文件的读取</h4><p>1、添加头文件 <fstream></fstream></p><p>2、创建流对象 ifstream ifs;</p><p>3、打开文件: ofs.open(“文件路径”,打开方式)</p><p>4、判断是否打开成功，因为读取中如果没有找到是不会创建文件的，因此必须判断 ifs.is_open()  成功返回 true</p><p>5、读取数据  -&gt; 四种形式</p><p>6、关闭文件</p><h4 id="写入方式"><a href="#写入方式" class="headerlink" title="写入方式"></a>写入方式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ofstream ofs;</span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;E:\\woke\\C++_XHL\\2308\\Day4\\text_file_write\\class2308.txt&quot;</span>,ios::out);</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;你吃饭了没 张老师&quot;</span> &lt;&lt; endl;;</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;没吃 还没下班，下班再吃&quot;</span>&lt;&lt;endl;</span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;E:\\woke\\C++_XHL\\2308\\Day4\\text_file_write\\Person.txt&quot;</span>,ios::out);</span><br><span class="line">    Person p1;</span><br><span class="line">    p<span class="number">1.</span>name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">    p<span class="number">1.</span>age = <span class="number">10</span>;</span><br><span class="line">    ofs &lt;&lt; p1;</span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h4 id="读取方式"><a href="#读取方式" class="headerlink" title="读取方式"></a>读取方式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例1：读取刚刚写入的Person</span></span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;E:\\woke\\C++_XHL\\2308\\Day4\\text_file_write\\Person.txt&quot;</span>,ios::in);</span><br><span class="line">    <span class="comment">//判断是否打开成功</span></span><br><span class="line">    <span class="keyword">if</span>(! ifs.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取数据</span></span><br><span class="line">    Person p1;</span><br><span class="line">    ifs &gt;&gt; p1;<span class="comment">//需要重载输入运算符</span></span><br><span class="line">    cout &lt;&lt;  p<span class="number">1.</span>name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt;  p<span class="number">1.</span>age&lt;&lt; endl;</span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、案例2</span></span><br><span class="line"></span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;E:\\woke\\C++_XHL\\2308\\Day4\\text_file_write\\class2308.txt&quot;</span>,ios::in);</span><br><span class="line">    <span class="comment">//判断是否打开成功</span></span><br><span class="line">    <span class="keyword">if</span>(! ifs.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取方式2</span></span><br><span class="line">    <span class="comment">//char buf[1024] = &#123;0&#125;;</span></span><br><span class="line">    <span class="comment">//while(ifs &gt;&gt; buf)//遇到空格或者回车 就代表读取成功一次，直至全部读取完毕</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">       <span class="comment">// cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取方式3</span></span><br><span class="line"><span class="comment">//    char buf[1024] = &#123;0&#125;;</span></span><br><span class="line"><span class="comment">//    while(ifs.getline(buf,sizeof(buf)))//按行读取</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; buf&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四种方式</span></span><br><span class="line"><span class="comment">//    string str;</span></span><br><span class="line"><span class="comment">//    while(getline(ifs,str))//按行读取</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        cout &lt;&lt; str &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第五种方式 按字符读取</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>( (c = ifs.<span class="built_in">get</span>()) != EOF ) <span class="comment">//到EOF 代表到文件尾部了</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; c;<span class="comment">//此处不可以换行</span></span><br><span class="line">    &#125;</span><br><span class="line">    ifs.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="day5"><a href="#day5" class="headerlink" title="day5"></a>day5</h2><h3 id="二十六、二进制文本文件读写"><a href="#二十六、二进制文本文件读写" class="headerlink" title="二十六、二进制文本文件读写"></a>二十六、二进制文本文件读写</h3><p>以二进制的方式对文件进行读写操作，那么打开方式就要指定为 ios::binary</p><p>写文件 -&gt; write(const char *buffer,int len)</p><p>读文件 -&gt; read(char* buffer,int len)</p><p>其他操作与 普通文本文件一样</p><h3 id="二十七、模板"><a href="#二十七、模板" class="headerlink" title="二十七、模板"></a>二十七、模板</h3><h4 id="1、概念-7"><a href="#1、概念-7" class="headerlink" title="1、概念"></a>1、概念</h4><p>模板就是建立通用的摸具，大大提高代码的一个复用性</p><p>但是模板我们不能直接使用，需要往里面插入实际的内容</p><h4 id="2、模板分为两类"><a href="#2、模板分为两类" class="headerlink" title="2、模板分为两类"></a>2、模板分为两类</h4><p>函数模板、类模板</p><h4 id="3、函数模板"><a href="#3、函数模板" class="headerlink" title="3、函数模板"></a>3、函数模板</h4><h5 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h5><p>建立一个通用的函数，其函数返回类型 和 函数参数类型 不具体制定，使用一个虚拟的类型来表示</p><h5 id="总结1"><a href="#总结1" class="headerlink" title="总结1"></a>总结1</h5><p>模板利用的关键字 template</p><p>函数模板的使用方式:</p><p>自动类型推导和显示指定类型（推导出的类型会将默认参数类型给覆盖）</p><p>模板为了提高代码的复用率，将类型参数 模板化</p><p>每次声明创建函数模板的时候，下面只可以跟一个函数，每多写一个就要多使用template 声明一次</p><p>注意事项:自动类型，必须推导出唯一了类型T 才可以；2、使用模板的时候必须要确定T的类型才可以使用！！</p><h5 id="函数模板和普通函数有什么区别呢？"><a href="#函数模板和普通函数有什么区别呢？" class="headerlink" title="函数模板和普通函数有什么区别呢？"></a>函数模板和普通函数有什么区别呢？</h5><p>函数模板和普通函数有什么区别呢？</p><p>1、普通函数 可以发生隐式类型转换</p><p>函数模板： 自动类型推导的时候  可以隐式类型转换么？ 不可以！！！</p><p>函数模板： 显示指定类型  可以发生隐式类型转换</p><p>2、如果函数模板和普通函数都可以实现，并且都符合传递参数（即不需要作任何类型转换）,优先调用普通函数</p><p>3、如果非要使用模板 就是使用空 模板参数列表</p><p>4、函数模板也可以发生重载</p><p>5、如果函数模板可以产生更好的匹配（普通函数需要隐式类型转换而模板不需要的时候），优先调用模板</p><h4 id="4、类模板"><a href="#4、类模板" class="headerlink" title="4、类模板"></a>4、类模板</h4><h5 id="类模板的作用："><a href="#类模板的作用：" class="headerlink" title="类模板的作用："></a>类模板的作用：</h5><p>建立一个通用的类，类中的成员数据类型可以不具体制定，用一个虚拟的类型代替</p><p>函数模板与类模板的区别！！！</p><h5 id="类模板使用方式"><a href="#类模板使用方式" class="headerlink" title="类模板使用方式:"></a>类模板使用方式:</h5><p>显示指定类型</p><p>函数模板默认参数无意义，类模板可以使用默认参数</p><p>类模板的默认参数  他的规则和普通函数默认参数一样</p><p>使用时一定要加&lt;&gt;,来确定显示类型。</p><h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><p>类模板的成员函数，是在调用时候才创建。</p><p>1、当子类继承了一个模板类，子类在声明的时候，需要指定出父类中的类型T,如果不指定，编译器无法给与子类分配内存</p><p>2、如果想灵活的指定出父类中的类型T,则将子类也变成一个模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>,<span class="keyword">class</span> <span class="title class_">T1</span> = string&gt;</span><br><span class="line"><span class="keyword">class</span> Human:<span class="keyword">public</span> Person&lt;T&gt;<span class="comment">//指定出T的类型</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="类模板作为参数传递（三种方式）"><a href="#类模板作为参数传递（三种方式）" class="headerlink" title="类模板作为参数传递（三种方式）"></a>类模板作为参数传递（三种方式）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">model_t</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T p;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我是模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">abc</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T p;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我是模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="方式1-指定传入类型-指定类中的-T-只能传入model-t"><a href="#方式1-指定传入类型-指定类中的-T-只能传入model-t" class="headerlink" title="方式1: 指定传入类型  -&gt; 指定类中的 T : 只能传入model_t"></a>方式1: 指定传入类型  -&gt; 指定类中的 T : 只能传入model_t<int></int></h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">model_t</span>&lt;<span class="type">int</span>&gt; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; p.p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="方式2：参数模板化-包含了方式1-只要是model-t-的模板类型即可"><a href="#方式2：参数模板化-包含了方式1-只要是model-t-的模板类型即可" class="headerlink" title="方式2：参数模板化 : 包含了方式1  只要是model_t 的模板类型即可"></a>方式2：参数模板化 : 包含了方式1  只要是model_t 的模板类型即可</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">model_t</span>&lt;T&gt; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; p.p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="方式三：整个类模板化"><a href="#方式三：整个类模板化" class="headerlink" title="方式三：整个类模板化  :"></a>方式三：整个类模板化  :</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func3</span><span class="params">(T p)</span><span class="comment">//只要这个类型 T 中 含有func函数即可调用！！</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p.<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类模板和函数模板的区别"><a href="#类模板和函数模板的区别" class="headerlink" title="类模板和函数模板的区别"></a>类模板和函数模板的区别</h4><p>1、类模板是显示指定类型</p><p>函数模板是自动推导类型和显示指定类型</p><p>2、函数的默认参数可以被自动类型推导覆盖掉（可以说函数默认参数没有意义）</p><p>​      类模板的默认参数是不可被覆盖的</p><h4 id="类模板分文件编写"><a href="#类模板分文件编写" class="headerlink" title="类模板分文件编写"></a>类模板分文件编写</h4><p>类模板的成员函数创建时机在调用阶段，分文件  导致编译的时候 链接不到</p><p>解决方法1：包含模板的.cpp 文件</p><p>解决方法2：将声明与实现写在一个文件  成为.hpp 文件&#x2F;&#x2F;.hpp 文件 代表这个文件里面是模板！！</p><h4 id="一个选择排序算法"><a href="#一个选择排序算法" class="headerlink" title="一个选择排序算法"></a>一个选择排序算法</h4><p><img src="/./../../../images/1699067753836-8825f02e-17a6-4b98-a2d3-5a59327ed1b9-1748605414697-1.jpeg" alt="img"></p><p>例子:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换数据模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_t</span><span class="params">(T &amp;a,T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//习题2</span></span><br><span class="line"><span class="comment">//完成一个 排序的函数模板</span></span><br><span class="line"><span class="comment">//1、实现通用对数组（int 数组、char 数组等）进行排序的函数模板</span></span><br><span class="line"><span class="comment">//2、从小到大</span></span><br><span class="line"><span class="comment">//3、选择排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort_slect</span><span class="params">(T arry[],<span class="type">int</span> length)</span><span class="comment">//size 数组长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> min = <span class="number">0</span>;<span class="comment">//最小数的  下标</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; length<span class="number">-1</span>;i++)</span><br><span class="line">   &#123;</span><br><span class="line">       min = i;<span class="comment">//假设第i 数为最小的</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j = i<span class="number">+1</span>;j &lt; length;j++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//这一个循环走完可以得到一个最小的下标</span></span><br><span class="line">           <span class="keyword">if</span>(arry[min] &gt; arry[j])<span class="comment">//代表 下标j 的数更小，此时更换最小下标</span></span><br><span class="line">           &#123;</span><br><span class="line">               min = j;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(min != i)<span class="comment">//有了更换。更改 i 和 min 的数据</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">swap_t</span>(arry[min],arry[i]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> arr1[] = &#123;<span class="number">1</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">67</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">sort_slect</span>(arr1,(<span class="built_in">sizeof</span> (arr1)/<span class="built_in">sizeof</span> (<span class="type">int</span>)));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="built_in">sizeof</span> (arr1)/<span class="built_in">sizeof</span> (<span class="type">int</span>));i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt;arr1[i] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="type">char</span> arry2[] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;f&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;x&#x27;</span>&#125;;</span><br><span class="line">    <span class="built_in">sort_slect</span>(arry2,(<span class="built_in">sizeof</span> (arry2)/<span class="built_in">sizeof</span> (<span class="type">char</span>)));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="built_in">sizeof</span> (arry2)/<span class="built_in">sizeof</span> (<span class="type">char</span>));i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt;arry2[i] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二十七、C-泛型编程之STL-标准模板库"><a href="#二十七、C-泛型编程之STL-标准模板库" class="headerlink" title="二十七、C++ 泛型编程之STL  -&gt;标准模板库"></a>二十七、C++ 泛型编程之STL  -&gt;标准模板库</h3><h4 id="1、STL-的基本概念"><a href="#1、STL-的基本概念" class="headerlink" title="1、STL 的基本概念"></a>1、STL 的基本概念</h4><p>1、STL(Standard Template Library,标准模板库)</p><p>2、STL6大组件:容器、算法、迭代器，适配器，空间配置，仿函数</p><p>3、STL 中几乎所有的代码，都是使用的模板编写（函数模板和类模板）</p><h4 id="2、针对于6大组件"><a href="#2、针对于6大组件" class="headerlink" title="2、针对于6大组件"></a>2、针对于6大组件</h4><p>1、容器：存放的各种数据结构，比如说 链表、数组、栈、队列</p><p>2、算法：各种常用的算法，比如说排序、遍历、查找等等（用于解决问题的有序数列）</p><p>3、迭代器：算法与容器的桥梁</p><p>4、仿函数：作为算法的某种策略</p><p>5、适配器：一种用来修饰容器或者仿函数或者迭代器接口的东西</p><p>6、空间配置器：用于空间的申请与释放</p><h4 id="3、STL-容器、算法、迭代器"><a href="#3、STL-容器、算法、迭代器" class="headerlink" title="3、STL 容器、算法、迭代器"></a>3、STL 容器、算法、迭代器</h4><h5 id="1、容器"><a href="#1、容器" class="headerlink" title="1、容器"></a>1、容器</h5><p>容器分类：序列式容器和关联式容器</p><p>序列式容器:强调先手顺序，比如说 1 7 2 3 4 存进去就是 1 7 2 3 4 不会给你排序</p><p>关联式容器：底层使用了二叉树结构，各个元素之前没有严格上的物理顺序关系。通过指针存放；会将容器里面元素排序（默认升序排序）</p><h5 id="2、算法"><a href="#2、算法" class="headerlink" title="2、算法"></a>2、算法</h5><p>算法的分类: 质变算法和 非质变算法</p><p>质变算法：指运算过程中，会修改容器里面的元素  -&gt;排序、删除、替换、拷贝等等</p><p>非质变算法：指运算过程中不会修改容器里面的元素 -&gt;查找、遍历、计数等等</p><h5 id="3、迭代器"><a href="#3、迭代器" class="headerlink" title="3、迭代器"></a>3、迭代器</h5><p>迭代器 -&gt;iterator</p><p>每一个容器的迭代器都是独一无二的</p><p>提供一种方法，使其能狗依序寻访容器所含的各个元素，而又无需暴露容器内部的表达方式</p><p>迭代器的使用类似于指针（指针怎么用迭代器就怎么用）</p><p>迭代器的分类</p><p>&#x2F;*</p><p> 1、输入迭代器        对数据只读的访问                支持++ &#x3D;&#x3D;  ！&#x3D;</p><p> 2、输出迭代器        对数据只写的访问                支持++</p><p> 3、向前迭代器        对数据的读写操作                支持++ &#x3D;&#x3D; ！&#x3D;</p><p> 4、双向迭代器        对数据的读写操作                支持++ –</p><p> 5、随机访问迭代器     对数据读写操作，可以跳跃式访问    支持++、–、+n、-n</p><p> 容器中最牛逼迭代器：随机访问迭代器其次就是双向迭代器</p><p>在c++ 11 中 常用容器的迭代器种类通常为 随机访问迭代器和双向迭代器</p><p> *&#x2F;</p><h2 id="day6"><a href="#day6" class="headerlink" title="day6"></a>day6</h2><p>作业：1、当有堆区属性时，一定要自己写析构函数，去释放堆区属性</p><p>​    2、参数模板化 template <class t>使用时要注意，当一个template只能模板一个函数或者类</class></p><p>当模板化一个类时，类的成员函数可以使用，但全局函数得重新定义一个template</p><h3 id="二十八、STl中的容器-vector"><a href="#二十八、STl中的容器-vector" class="headerlink" title="二十八、STl中的容器 vector"></a>二十八、STl中的容器 vector</h3><h4 id="1、头文件"><a href="#1、头文件" class="headerlink" title="1、头文件"></a>1、头文件</h4><p>在STL 中，你使用什么容器 就需要添加什么头文件，如include <vector></vector></p><p>vector,可以理解为数组</p><h4 id="2、vector详讲"><a href="#2、vector详讲" class="headerlink" title="2、vector详讲"></a>2、vector详讲</h4><h5 id="1、插入"><a href="#1、插入" class="headerlink" title="1、插入"></a>1、插入</h5><p>尾插法:(有库函数)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector v1</span><br><span class="line">v<span class="number">1.</span><span class="built_in">push_back</span>(<span class="type">int</span> value)</span><br></pre></td></tr></table></figure><h5 id="2、删除"><a href="#2、删除" class="headerlink" title="2、删除"></a>2、删除</h5><p>尾删法。（与尾插法同理）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector v1</span><br><span class="line">v<span class="number">1.</span><span class="built_in">pop_back</span>();</span><br></pre></td></tr></table></figure><h5 id="3、遍历"><a href="#3、遍历" class="headerlink" title="3、遍历"></a>3、遍历</h5><h6 id="三种方式"><a href="#三种方式" class="headerlink" title="三种方式"></a>三种方式</h6><p>容器的遍历一共有三种方式    </p><p>在容器里面有两个迭代器类型 : 起始迭代器，末尾迭代器    </p><p>起始迭代器 -&gt; 指向容器里面的第一个元素    </p><p>末尾迭代器 -&gt; 指向容器里面最后一个元素的下一个位置</p><p>注意：在容器中，除非特定指定int 其他用来访问容器的元素下标都是迭代器</p><p> 且迭代器的使用与指针一样</p><p>将迭代器作为一个指针  那么vector<T>  -&gt; 这个指针就是T 类型的指针</T></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it_beg = v<span class="number">1.</span><span class="built_in">begin</span>();<span class="comment">//起始迭代器</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it_end = v<span class="number">1.</span><span class="built_in">end</span>();<span class="comment">//末尾迭代器</span></span><br></pre></td></tr></table></figure><h6 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h6><p>while 循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it_beg = v<span class="number">1.</span><span class="built_in">begin</span>();<span class="comment">//起始迭代器</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it_end = v<span class="number">1.</span><span class="built_in">end</span>();<span class="comment">//末尾迭代器</span></span><br><span class="line"><span class="keyword">while</span>(it_beg != it_end)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *it_beg &lt;&lt; endl;</span><br><span class="line">    it_beg++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h6><p>for循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it = v<span class="number">1.</span><span class="built_in">begin</span>();it != v<span class="number">1.</span><span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="方式三："><a href="#方式三：" class="headerlink" title="方式三："></a>方式三：</h6><p>for_each函数，主要要加头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_val</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">for_each</span><span class="params">(beg,end,_Func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(it = beg;it != end;it++)</span><br><span class="line">    &#123;</span><br><span class="line">        _Func(*it);<span class="comment">//_Func 打印函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h6><p>1、vector 可以当作一个数组来使用，也是一个类模板，使用模板时，注意一定要加模板参数列表，指定好明确的类型</p><p>2、vector 可以当作一个二维数组使用，里面可以嵌套一个vector组成二维数组使用，但是注意在遍历时需要可以类比二维数组，使用两次for循环来遍历打印</p><h3 id="二十九：两个容器"><a href="#二十九：两个容器" class="headerlink" title="二十九：两个容器"></a>二十九：两个容器</h3><h4 id="1、string容器"><a href="#1、string容器" class="headerlink" title="1、string容器"></a>1、string容器</h4><h5 id="1、构造函数"><a href="#1、构造函数" class="headerlink" title="1、构造函数"></a>1、构造函数</h5><ul><li>string() 无参构造 -&gt; 空串 </li><li>string(const char* s)&#x2F;&#x2F;有参构造 </li><li>string(const string &amp; str) </li><li>string(int n,char c) 使用 n个字符 c 去创建一个字符串</li></ul><h5 id="2、赋值函数"><a href="#2、赋值函数" class="headerlink" title="2、赋值函数"></a>2、赋值函数</h5><ul><li>string &amp; operator &#x3D; (const char *s) </li><li>string &amp; operator &#x3D; (char c) </li><li>string &amp; operator &#x3D; (const string &amp;str) </li><li>string &amp; assign(const char *s) </li><li>string &amp; assign(const char *s,int n)&#x2F;&#x2F;把字符串s的前n个字符，赋值给string </li><li>string &amp; assign(const string &amp;str) </li><li>string &amp; assing(int n,char c)&#x2F;&#x2F;使用n个字符c 赋值给字符串</li></ul><h5 id="3、字符串拼接"><a href="#3、字符串拼接" class="headerlink" title="3、字符串拼接"></a>3、字符串拼接</h5><ul><li>string &amp; operator+&#x3D;(const char *s) </li><li>string &amp; operator+&#x3D;(const string &amp;str) </li><li>string &amp; operator+&#x3D;(char c) </li><li>string &amp; append(const char *s) </li><li>string &amp; append(const char *s,int n)把字符串前n个字符拼接到string 后面 </li><li>string &amp; append(const string &amp;str) </li><li>string &amp; append(const string &amp;str,int pos,int n)字符串从pos开始的n个字符，拼接到string 中</li></ul><h5 id="4、查找与替换（找到了返回下标位置，未找到返回-1）"><a href="#4、查找与替换（找到了返回下标位置，未找到返回-1）" class="headerlink" title="4、查找与替换（找到了返回下标位置，未找到返回-1）"></a>4、查找与替换（找到了返回下标位置，未找到返回-1）</h5><ul><li>int find(const string &amp;str,int pos &#x3D; 0);从下标pos 开始 寻找 str 第一次出现的位置 </li><li>int find(const char *s,int pos &#x3D; 0);从下标pos 开始 寻找 s 第一次出现的位置 </li><li>int find(const char*s,int pos,int n)从下标pos开始寻找 s前n个字符出现的第一位置 </li><li>int find(cosnt char c.int pos &#x3D; 0);查找字符c第一次出现的位置</li></ul><h5 id="5、从右往左找"><a href="#5、从右往左找" class="headerlink" title="5、从右往左找"></a>5、从右往左找</h5><ul><li>int rfind(const string &amp;str,int pos &#x3D; 0);从下标pos 开始 寻找 str 第一次出现的位置<br>int rfind(const char <em>s,int pos &#x3D; 0);从下标pos 开始 寻找 s 第一次出现的位置<br>int rfind(const char</em>s,int pos,int n)从下标pos开始寻找 s前n个字符出现的第一位置<br>int rfind(cosnt char c.int pos &#x3D; 0);查找字符c第一次出现的位置<br>find 与 rfind 的区别就是 find 是从左往右，rfind 是从右往左<br>如果找不到全部都是返回-1<br>string &amp;replace(int ipos,int n,const string &amp;s);&#x2F;&#x2F;从ipos起的n个字符替换成s<br>string &amp;replace(int ipos,int n,const char* s); &#x2F;&#x2F;替换可以一换多 也可以多换1</li></ul><h5 id="6、字符串比较"><a href="#6、字符串比较" class="headerlink" title="6、字符串比较"></a>6、字符串比较</h5><ul><li>bool operator&#x3D;&#x3D;(const string &amp;str)</li><li>bool operator&#x3D;&#x3D;(const char *s)</li><li>如果相等返回真，不相等返回假</li><li></li><li>int commpara(const string &amp;str)</li><li>int commpara(const char *s)</li><li>如果str 比较大就返回-1，str 比较小返回1，如果相等返回0</li></ul><h5 id="7、字符串的存取"><a href="#7、字符串的存取" class="headerlink" title="7、字符串的存取"></a>7、字符串的存取</h5><ul><li>可以通过下标访问单个字符</li><li>char &amp; operator[](int n)</li><li>char &amp; at(int n)</li></ul><h5 id="8、插入和删除"><a href="#8、插入和删除" class="headerlink" title="8、插入和删除"></a>8、插入和删除</h5><ul><li>string &amp;insert(int pos,const char *s) 在pos位置插入s</li><li>string &amp;insert(int pos,const string &amp;s)</li><li>string &amp;insert(int pos,int n,char c)在pos的位置插入n个字符c</li><li>string &amp;erase(int pos,int n &#x3D; npos)&#x2F;&#x2F;删除从pos位开始的n个字符。如果你想使用这个默认参数，则这个函数就变成</li><li>保留前pos个字符</li></ul><h5 id="9、string-获取子串"><a href="#9、string-获取子串" class="headerlink" title="9、string 获取子串"></a>9、string 获取子串</h5><ul><li>string substr(int pos,int n &#x3D; npos)&#x2F;&#x2F;返回由pos开始的 n个字符组成的字符串</li></ul><h4 id="2、vector容器"><a href="#2、vector容器" class="headerlink" title="2、vector容器"></a>2、vector容器</h4><p>vector 的数据结构类似于数组，也被称为单端数组</p><p>vector 与普通数组不同的是，普通数组是属于静态控件，vector可以动态拓展</p><p>动态拓展：并不是在原有的空间上进行拓展，而是找更大的空间，然后将原来的数据拷贝过去后，将原来的空间释放，然后更改指向！！</p><p>vector的迭代器 随机访问迭代器</p><p>注意点：vector 的迭代器在插入或者删除后，将会失效</p><h5 id="1、构造函数："><a href="#1、构造函数：" class="headerlink" title="1、构造函数："></a>1、构造函数：</h5><p>vector<T>v 无参构造  </T></p><p>vector<T>v1(v.begin,v.end);将容器v的，[begin,end)里面的数组拷贝给 v1  vector<T>v(int n,T elem)将 n个elem 放入容器v里面 </T></T></p><p>vector<T>v(const vector<T> &amp;v) 拷贝</T></T></p><h5 id="2、赋值运算"><a href="#2、赋值运算" class="headerlink" title="2、赋值运算"></a>2、赋值运算</h5><p>vector<T>&amp; operator&#x3D;(const vector<T> &amp;vec)</T></T></p><p>assgin(beg,end);  将[beg,end)区域里面的数据赋值给 vec，切记 所有的 beg与 end都是迭代器类型  </p><p>assgin(int n,T elem)  将n个 elem 赋值给vec</p><h5 id="3、容量和大小"><a href="#3、容量和大小" class="headerlink" title="3、容量和大小"></a>3、容量和大小</h5><p>bool empty() 判断容器是否为空，如果为空返回真，否则返回假  </p><p>int capacity() 判断容器容量  int size()判断容器里面元素的个数  </p><p>void resize(int num)</p><p>重新指定容器的长度，如果容器变长，则以默认值填充新位置，如果变短，则超出的元素被删除  </p><p>void resize(int num,T elem)</p><p>重新指定容器的长度，如果容器变长，则以elem填充新位置，如果变短，则超出的元素被删除</p><h5 id="4、插入和删除"><a href="#4、插入和删除" class="headerlink" title="4、插入和删除"></a>4、插入和删除</h5><p>push_back(T elem)  </p><p>pop_back()  </p><p>void insert(pos,elem);pos 为迭代器类型，在指定位置插入元素elem  void insert(pos,n,elem);在pos位置插入n 个elem  </p><p>void erase(pos);删除指定位置的元素  pos迭代器类型  </p><p>void erase(beg,end);删除[beg,end)区域里面的元素  </p><p>void clear();&#x2F;&#x2F;删除容器内所有元素</p><h5 id="5、元素的存取"><a href="#5、元素的存取" class="headerlink" title="5、元素的存取"></a>5、元素的存取</h5><p>T&amp; at(int ipos)  </p><p>T&amp; operator[](int ipos)  </p><p>T&amp; front();&#x2F;&#x2F;返回容器里面第一个元素  </p><p>T&amp; back();&#x2F;&#x2F;返回容器里面最后一个元素</p><h5 id="6、容器互换"><a href="#6、容器互换" class="headerlink" title="6、容器互换"></a>6、容器互换</h5><h6 id="1、概念-8"><a href="#1、概念-8" class="headerlink" title="1、概念"></a>1、概念</h6><p>容器互换 void swap(vector<T>&amp; vec);&#x2F;&#x2F;将vec与本身容器元素互换</T></p><p>实际应用：收缩内存</p><h6 id="2、例子"><a href="#2、例子" class="headerlink" title="2、例子"></a>2、例子</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容器互换 void swap(vector&lt;T&gt;&amp; vec);//将vec与本身容器元素互换</span></span><br><span class="line"><span class="comment">//实际应用：收缩内存</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">v1</span>(<span class="number">10000</span>,<span class="number">9527</span>);</span><br><span class="line">    v<span class="number">1.</span><span class="built_in">resize</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;元素个数为&quot;</span> &lt;&lt; v<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\t容器容量为&quot;</span> &lt;&lt;v<span class="number">1.</span><span class="built_in">capacity</span>()&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v1).<span class="built_in">swap</span>(v1);<span class="comment">//收缩n内存</span></span><br><span class="line">    <span class="comment">//vector&lt;int&gt;v3(v1) -&gt; 拷贝了v1的数据的v3</span></span><br><span class="line">    <span class="comment">//vector&lt;int&gt;(v1) 拷贝了v1的匿名对象 -&gt;生存周期为当行代码</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;元素个数为&quot;</span> &lt;&lt; v<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;\t容器容量为&quot;</span> &lt;&lt;v<span class="number">1.</span><span class="built_in">capacity</span>()&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3、原理"><a href="#3、原理" class="headerlink" title="3、原理"></a>3、原理</h6><p><img src="/./../../../images/1699262011023-0cda881c-e2a9-4f45-8bf0-6f9fe141c946-1748605414697-3.png" alt="img"></p><h5 id="7、预留空间"><a href="#7、预留空间" class="headerlink" title="7、预留空间"></a>7、预留空间</h5><h6 id="1、概念-9"><a href="#1、概念-9" class="headerlink" title="1、概念"></a>1、概念</h6><h6 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h6><p>预留空间</p><p>作用：减少vector在动态扩容时次数</p><p>reserve(int size);为容器预留size个位置，预留位置不出初始化！！，元素不可访问</p><h6 id="3、例子"><a href="#3、例子" class="headerlink" title="3、例子"></a>3、例子</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预留空间</span></span><br><span class="line"><span class="comment">//作用：减少vector在动态扩容时次数</span></span><br><span class="line"><span class="comment">//reserve(int size);为容器预留size个位置，预留位置不出初始化！！，元素不可访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">    <span class="comment">//v.reserve(100000);</span></span><br><span class="line">    v.<span class="built_in">resize</span>(<span class="number">100000</span>);</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> *ptr = <span class="literal">NULL</span>;<span class="comment">//ptr -&gt;指向容器首地址的指针</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;<span class="comment">//动态扩容的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">100000</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i<span class="number">+1</span>);</span><br><span class="line">        <span class="keyword">if</span>(ptr != &amp;v[<span class="number">0</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果指针不等于容器的首地址，那么就代表进行了一次动态扩容</span></span><br><span class="line">            ptr = &amp;v[<span class="number">0</span>];</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; v[<span class="number">100000</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;动态扩了 &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4、reserve与resize"><a href="#4、reserve与resize" class="headerlink" title="4、reserve与resize"></a>4、reserve与resize</h6><p>两者的作用都是对容器空间大小的改变</p><p>reserve 只能预留空间，对空间的扩充</p><p>resize    可以重新设置容器空间的大小，但是可以设置增大或者减少</p><p>最主要的区别：resize一定会初始化（默认为零）</p><p>   reserve是预留size个位置，但不会初始化，且元素不可访问。</p><h2 id="day7"><a href="#day7" class="headerlink" title="day7"></a>day7</h2><h4 id="3、deque容器"><a href="#3、deque容器" class="headerlink" title="3、deque容器"></a>3、deque容器</h4><p>双端数组，可以对两端进行插入和删除</p><h5 id="1、deque和vector的区别"><a href="#1、deque和vector的区别" class="headerlink" title="1、deque和vector的区别"></a>1、deque和vector的区别</h5><p>1、vector属于单数组，deque属于双端数组</p><p>2、对于vector 来说，遍历数组比较高效，因为vector是连续的一片空间，可以直接遍历，而deque需要通过中控器去先访问缓冲地址，在访问真实数据。</p><p>3、对于deque来说，插入和删除比较高效，因为deque有一个中控器可以实现动态的扩容，来实现插入和删除，而vector 需要把大量的数组挪动。</p><p>4、deque的内存近似连续，vector的内存是连续的· </p><p>产生这些区别的原因</p><p><img src="/./../../../images/1699321058892-7c07c039-40fb-42f7-99bf-f16e54e1a8ca-1748605414697-2.png" alt="img"></p><p>这是deque的工作原理导致的，deque 内部有一个中控器，deque的内存因为中控器的存在，使得其内存近似连续</p><p>deque 也是随机访问迭代器</p><p>deque 的迭代器如果进行的插入和删除 那么原先的迭代器将会失效，需要重新赋值</p><p>如何判断迭代器时随机访问还是双向呢？</p><p>vector<int>::iterator it;  如果 it +&#x3D; 5没有报错代表为随机访问迭代器，如果报错基本上就是双向迭代器</int></p><p>注意：容器都是可以嵌套的</p><h5 id="2、构造函数"><a href="#2、构造函数" class="headerlink" title="2、构造函数"></a>2、构造函数</h5><p>deque<T>d; </T></p><p>deque<T>(beg,end); </T></p><p>euqe<T>(n,elem);使用n个elem 来构造</T></p><p>deque deque<T>(const deque<T> &amp;de);&#x2F;&#x2F;拷贝构造</T></T></p><h5 id="3、赋值操作"><a href="#3、赋值操作" class="headerlink" title="3、赋值操作"></a>3、赋值操作</h5><p>deque<T>&amp; operator&#x3D;(const deque<T> &amp;de) </T></T></p><p>assgin(beg,end);&#x2F;&#x2F;将[beg,end)区域的数据拷贝至deque里面。注意可以使用其他类型的迭代器对其进行赋值 </p><p>assgin(n,elem)</p><h5 id="4、大小"><a href="#4、大小" class="headerlink" title="4、大小"></a>4、大小</h5><p>由于deque的内存近似连续，因此它没有容量这一说法 </p><p>bool empty();&#x2F;&#x2F;判空 空返回真 </p><p>int size();&#x2F;&#x2F;返回容器内部元素个数 </p><p>resize(int len)重新指定容器的长度，如果变长了，超出的部分以默认值填充，变短了 舍去超出部分 </p><p>resize(int len,T elem)</p><h5 id="5、插入和删除"><a href="#5、插入和删除" class="headerlink" title="5、插入和删除"></a>5、插入和删除</h5><p> push_back(T val)</p><p> push_front(T val)</p><p> pop_back()</p><p> pop_front()</p><p> insert(pos,elem)&#x2F;&#x2F;在pos位置插入元素elem  pos 为迭代器类型</p><p> insert(pos,int n,T elem)</p><p> insert(pos,beg,end);&#x2F;&#x2F;在pos位置，将[beg,end)区域内的元素拷贝过来插入到pos位置</p><p> clear()清空</p><p> erase(pos) 删除指定位置元素</p><p> erase(beg,end) 删除区域内元素</p><h5 id="6、-存取"><a href="#6、-存取" class="headerlink" title="6、 存取"></a>6、 存取</h5><p>T &amp;at(int ipos) </p><p>T &amp;operator[](int ipos) </p><p>T &amp;front() </p><p>T &amp;back()</p><h5 id="7、排序"><a href="#7、排序" class="headerlink" title="7、排序"></a>7、排序</h5><p>sort(beg,end,_func)默认排序为升序。_func 是排序规则 </p><p>将[beg,end)里面元素进行一个排序 </p><p>注意：使用STL 算法库里面的排序算法，容器必须拥有随机访问迭代器，否则将无法使用此排序算法</p><h5 id="8、例子："><a href="#8、例子：" class="headerlink" title="8、例子："></a>8、例子：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">    <span class="comment">//设置随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));<span class="comment">//根据时间的不同 设置不同的随机数种子</span></span><br><span class="line">    <span class="comment">//注意：随机数种子不要写在循环里面</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> val = <span class="built_in">rand</span>()%<span class="number">100</span>;<span class="comment">//生成0-99 的随机数</span></span><br><span class="line">        v.<span class="built_in">push_back</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用vector构造deque</span></span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;<span class="built_in">d</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(deque&lt;<span class="type">int</span>&gt;::iterator it = d.<span class="built_in">begin</span>();it != d.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用算法 对容器进行排序</span></span><br><span class="line">    <span class="comment">//sort(beg,end,_func)默认排序为升序。_func 是排序规则</span></span><br><span class="line">    <span class="built_in">sort</span>(d.<span class="built_in">begin</span>(),d.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(deque&lt;<span class="type">int</span>&gt;::iterator it = d.<span class="built_in">begin</span>();it != d.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、list容器"><a href="#4、list容器" class="headerlink" title="4、list容器"></a>4、list容器</h4><h5 id="1、概念-10"><a href="#1、概念-10" class="headerlink" title="1、概念"></a>1、概念</h5><p>list 是一种物理存储单元非连续的存储结构，元素更具逻辑顺序使用指针连接来实现，将数据进行链式存储 链表通过一个个节点组成，节点由数据域和指针域组成 在STL 中，list 容器里面装的双向循环链表，由于链表不是一个连续的空间，因此他是属于双向迭代器 </p><h5 id="2、优缺点"><a href="#2、优缺点" class="headerlink" title="2、优缺点"></a>2、优缺点</h5><p>lsit优点：采用动态分配，不会造成内存的浪费和溢出，插入删除操作方便，修改指针即可，不需要移动大量元素 </p><p>list缺点：空间（指针域）和时间（遍历）额外耗费较大</p><h5 id="3、构造函数"><a href="#3、构造函数" class="headerlink" title="3、构造函数"></a>3、构造函数</h5><p>list<T>l </T></p><p>list<T>l(beg,end) </T></p><p>list<T>l(n,elem) </T></p><p>list<T>l(const list<T>&amp; lis)</T></T></p><h5 id="4、-赋值操作"><a href="#4、-赋值操作" class="headerlink" title="4、 赋值操作"></a>4、 赋值操作</h5><p>list &amp; operator(const list<T>&amp; lis) </T></p><p>assign(beg,end) </p><p>assing(n,elem)</p><h5 id="5、容器的互换"><a href="#5、容器的互换" class="headerlink" title="5、容器的互换"></a>5、容器的互换</h5><p>swap(list<T>&amp;l)  几乎所有的容器，都有swap这个方法，但是swap只能交换相同种类的容器</T></p><h5 id="6、-大小操作"><a href="#6、-大小操作" class="headerlink" title="6、 大小操作"></a>6、 大小操作</h5><p>bool empty() </p><p>int size()获取元素个数 </p><p>resize(int len) </p><p>resize(int len, T elem)</p><h5 id="7、插入和删除"><a href="#7、插入和删除" class="headerlink" title="7、插入和删除"></a>7、插入和删除</h5><p>push_front(T val) </p><p>push_back(T val) </p><p>pop_back() </p><p>pop_front() </p><p>insert(pos,T elem);</p><p>pos 为迭代器类型 </p><p>insert(pos,n,elem) </p><p>insert(pos,beg,end);</p><p>在pos 将[beg,end)里面的元素插入到容器的pos位置 </p><p>clear() </p><p>erase(pos) </p><p>erase(beg,end) </p><p>remove(T elem)&#x2F;&#x2F;删除容器里面所有 elem元素</p><h5 id="8、存取方式"><a href="#8、存取方式" class="headerlink" title="8、存取方式"></a>8、存取方式</h5><p>T &amp;front() </p><p>T &amp;back()</p><h5 id="9、排序"><a href="#9、排序" class="headerlink" title="9、排序"></a>9、排序</h5><p>sort();&#x2F;&#x2F;链表排序 </p><p>sort(排序函数);</p><p>void 类型 reverse()反转链表</p><h5 id="10、例子"><a href="#10、例子" class="headerlink" title="10、例子"></a>10、例子</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_val</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">    <span class="comment">//设置随机数种子</span></span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));<span class="comment">//根据时间的不同 设置不同的随机数种子</span></span><br><span class="line">    <span class="comment">//注意：随机数种子不要写在循环里面</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> val = <span class="built_in">rand</span>()%<span class="number">100</span>;<span class="comment">//生成0-99 的随机数</span></span><br><span class="line">        v.<span class="built_in">push_back</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;<span class="built_in">d</span>(<span class="number">10</span>,<span class="number">999</span>);</span><br><span class="line">    list&lt;<span class="type">int</span>&gt;<span class="built_in">l</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">    for_each(l.<span class="built_in">begin</span>(),l.<span class="built_in">end</span>(),print_val);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    l.<span class="built_in">sort</span>();</span><br><span class="line">    for_each(l.<span class="built_in">begin</span>(),l.<span class="built_in">end</span>(),print_val);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    l.<span class="built_in">reverse</span>();</span><br><span class="line">    for_each(l.<span class="built_in">begin</span>(),l.<span class="built_in">end</span>(),print_val);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、stack（栈）（特殊容器）"><a href="#5、stack（栈）（特殊容器）" class="headerlink" title="5、stack（栈）（特殊容器）"></a>5、stack（栈）（特殊容器）</h4><h5 id="1、概念-11"><a href="#1、概念-11" class="headerlink" title="1、概念"></a>1、概念</h5><p>是一个先进后出的数据结构，它只有一个出口，栈中只有一个元素可以访问（栈顶元素），因此这个数据结构不支持遍历算法                              </p><h5 id="2、构造函数-1"><a href="#2、构造函数-1" class="headerlink" title="2、构造函数"></a>2、构造函数</h5><p>stack<T> stk                                                                         </T></p><p>stack<T> stk(const stack<T> &amp; s)                                                                                                                                         </T></T></p><h5 id="3、赋值操作-1"><a href="#3、赋值操作-1" class="headerlink" title="3、赋值操作"></a>3、赋值操作</h5><p>stack<T>&amp; operator&#x3D;(const stack<T> &amp; s)                                                                                                                             </T></T></p><h5 id="4、数据的存取"><a href="#4、数据的存取" class="headerlink" title="4、数据的存取"></a>4、数据的存取</h5><p>push(elem)                                                                           </p><p>pop()                                                                                </p><p>T&amp; top()返回栈顶元素                                                                                                                                                      </p><h5 id="5、大小"><a href="#5、大小" class="headerlink" title="5、大小"></a>5、大小</h5><p>empty() 是空返回真                                                                        </p><p>size()    </p><h5 id="6、例子"><a href="#6、例子" class="headerlink" title="6、例子"></a>6、例子</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line">    s.<span class="built_in">top</span>() = <span class="number">999</span>;</span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、queue（队列）（特殊容器）queue-是一个先进先出的数据结构，双端受限"><a href="#6、queue（队列）（特殊容器）queue-是一个先进先出的数据结构，双端受限" class="headerlink" title="6、queue（队列）（特殊容器）queue 是一个先进先出的数据结构，双端受限"></a>6、queue（队列）（特殊容器）queue 是一个先进先出的数据结构，双端受限</h4><h5 id="1、概念-12"><a href="#1、概念-12" class="headerlink" title="1、概念"></a>1、概念</h5><ul><li>队列只允许一段插入，一段排出</li><li>入队从队尾入队 push</li><li>出队从对头出队 pop</li><li>作为队列，我们只能访问队头和队尾元素，因此也不支持遍历算法</li></ul><h5 id="2、构造函数-2"><a href="#2、构造函数-2" class="headerlink" title="2、构造函数"></a>2、构造函数</h5><ul><li>queueq;</li><li>queueq(const queue&amp; que)</li></ul><h5 id="3、赋值操作-2"><a href="#3、赋值操作-2" class="headerlink" title="3、赋值操作"></a>3、赋值操作</h5><ul><li>queue&amp; operator&#x3D;(const queue&amp; que)</li></ul><h5 id="4、数据的存取-1"><a href="#4、数据的存取-1" class="headerlink" title="4、数据的存取"></a>4、数据的存取</h5><ul><li>push（elem）</li><li>pop()</li><li>T &amp;front() 返回队头元素</li><li>T &amp;back() 返回队尾元素</li></ul><h5 id="5、大小-1"><a href="#5、大小-1" class="headerlink" title="5、大小"></a>5、大小</h5><ul><li>empty()</li><li>size()</li></ul><h4 id="7、set与multiset（关联式容器）上面都是序列式容器"><a href="#7、set与multiset（关联式容器）上面都是序列式容器" class="headerlink" title="7、set与multiset（关联式容器）上面都是序列式容器"></a>7、set与multiset（关联式容器）上面都是序列式容器</h4><h5 id="1、概念-13"><a href="#1、概念-13" class="headerlink" title="1、概念"></a>1、概念</h5><p>set（类似集合）</p><ul><li>set&#x2F;multiset  关联式容器，底层由二叉树构成</li><li>所有元素都会在插入的时候自动排序</li><li>set 不会有重复的元素，multiset 可以有重复的元素</li><li>set 在插入元素的时候，会对其进行检测，使用insert 进行插入，会返回一个 pair&lt;iterator,bool&gt;</li><li>第一个元素使用first 访问，是元素插入的位置，第二个元素为bool类型，如果插入成功，返回真，否则为假</li><li>但是对multiset 进行插入的时候，不会有返回值</li></ul><h5 id="2、构造函数-3"><a href="#2、构造函数-3" class="headerlink" title="2、构造函数"></a>2、构造函数</h5><ul><li>set&lt;T,排序规则（默认为升序）&gt;s</li><li>set(const set &amp; s)</li></ul><h5 id="3、赋值"><a href="#3、赋值" class="headerlink" title="3、赋值"></a>3、赋值</h5><ul><li>set &amp;operator&#x3D;(const set &amp; s)</li></ul><h5 id="4、插入和删除-1"><a href="#4、插入和删除-1" class="headerlink" title="4、插入和删除"></a>4、插入和删除</h5><ul><li>insert(T elem)</li><li>clear()</li><li>erase(pos)通过迭代器，删除指定位置元素</li><li>erase(beg,end)</li><li>erase(elem) 删除所有 elem元素</li></ul><h5 id="5、迭代器类型为双向迭代器"><a href="#5、迭代器类型为双向迭代器" class="headerlink" title="5、迭代器类型为双向迭代器"></a>5、迭代器类型为双向迭代器</h5><ul><li>set 的大小和交换</li><li>empty()</li><li>size()</li><li>swap(set &amp;s)</li></ul><h5 id="6、查找和统计"><a href="#6、查找和统计" class="headerlink" title="6、查找和统计"></a>6、查找和统计</h5><ul><li>find(key) 查找 key 是否存在，如果存在返回该元素所在位置的迭代器，否则返回end 末尾迭代器</li><li>count(key) 统计 key 元素的个数，对set来说 不是0 就是 1，对于multiset 来说可能大于1</li></ul><h5 id="7、例子"><a href="#7、例子" class="headerlink" title="7、例子"></a>7、例子</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_val</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s.<span class="built_in">insert</span>(<span class="built_in">rand</span>()%<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    for_each(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),print_val);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    pair&lt;set&lt;<span class="type">int</span>&gt;::iterator,<span class="type">bool</span>&gt; flag = s.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>( flag.second )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;成功插入元素&quot;</span> &lt;&lt; * (flag.first) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;插入失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    for_each(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),print_val);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    multiset&lt;<span class="type">int</span>&gt;s1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">9991</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    for_each(s<span class="number">1.</span><span class="built_in">begin</span>(),s<span class="number">1.</span><span class="built_in">end</span>(),print_val);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    s<span class="number">1.</span><span class="built_in">erase</span>(<span class="number">9991</span>);</span><br><span class="line">    for_each(s<span class="number">1.</span><span class="built_in">begin</span>(),s<span class="number">1.</span><span class="built_in">end</span>(),print_val);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">find</span>(<span class="number">-1</span>) != s.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;已找到元素&quot;</span> &lt;&lt; *(s.<span class="built_in">find</span>(<span class="number">-1</span>)) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8、map与mulitimap（关联式容器）-map-关联式容器-底层由二叉树构成"><a href="#8、map与mulitimap（关联式容器）-map-关联式容器-底层由二叉树构成" class="headerlink" title="8、map与mulitimap（关联式容器）*map 关联式容器 底层由二叉树构成"></a>8、map与mulitimap（关联式容器）*map 关联式容器 底层由二叉树构成</h4><h5 id="1、概念-14"><a href="#1、概念-14" class="headerlink" title="1、概念"></a>1、概念</h5><ul><li>首先 map 里面存放的数据类型 pair&lt;T1,T2&gt;,</li><li>pair 对组：成对出现的数据，利用队组可以返回两个数据</li></ul><h5 id="2、对组的创建方式"><a href="#2、对组的创建方式" class="headerlink" title="2、对组的创建方式"></a>2、对组的创建方式</h5><ul><li>pair&lt;T1,T2&gt;p(key,val)</li><li>pair&lt;T1,T2&gt; p &#x3D; make_pair(key,val)</li><li>key 代表索引值，val 代表实值</li></ul><h5 id="3、map-特点："><a href="#3、map-特点：" class="headerlink" title="3、map 特点："></a>3、map 特点：</h5><p>(map的数据都是成对出现的，不可以能单一出现)</p><ul><li>1、map 里面存放的数据类型为对组</li><li>2、map 里面存放的数据，会根据key值的大小来排序</li><li>3、map 里面不能存在重复的key值，但是multimap 可以。原因同set一致</li><li>4、可以通过key值快速索引value</li></ul><h5 id="4、构造函数"><a href="#4、构造函数" class="headerlink" title="4、构造函数"></a>4、构造函数</h5><ul><li>map&lt;T1,T2,_compare&gt;m</li><li>map&lt;T1,T2,*compare&gt;(const map&lt;T1,T2,*compare&gt;&amp; m)</li></ul><h5 id="5、赋值"><a href="#5、赋值" class="headerlink" title="5、赋值"></a>5、赋值</h5><ul><li>map&lt;T1,T2,*compare&gt;&amp; operator&#x3D;(const map&lt;T1,T2,*compare&gt;&amp; m)</li><li>大小和交换</li><li>size() 元素个数</li><li>empty() 判空</li><li>swap(m)容器交换</li></ul><h5 id="6、插入删除"><a href="#6、插入删除" class="headerlink" title="6、插入删除"></a>6、插入删除</h5><ul><li>insert(elem) elem 为pair&lt;T1,T2&gt; 类型</li><li>clear()</li><li>erase(pos)</li><li>erase(beg,end)删除[beg,end)区域内的元素</li><li>erase(key)&#x2F;&#x2F;删除容器种 关键字为 key的元素</li></ul><h5 id="7、map的存取"><a href="#7、map的存取" class="headerlink" title="7、map的存取"></a>7、map的存取</h5><ul><li>operator-&gt;得到我想要的value</li><li>at(key)</li></ul><h5 id="8、查找和统计"><a href="#8、查找和统计" class="headerlink" title="8、查找和统计"></a>8、查找和统计</h5><ul><li>find(key) 查找key 是否存在，如果存在返回该元素位置的迭代器，否则返回end</li><li>count(key) 统计 key 的个数，对于map 来说不是0就是1，对于multimap来说可能大于1</li></ul><h5 id="9、map的排序。"><a href="#9、map的排序。" class="headerlink" title="9、map的排序。"></a>9、map的排序。</h5><p>对于内置数据来说 -&gt; 使用仿函数，同set一样</p><ul><li>对于自定义数据类型来说  -&gt; 重载 &lt; 运算符或者使用仿函数！！</li></ul><h5 id="10、例子-1"><a href="#10、例子-1" class="headerlink" title="10、例子"></a>10、例子</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">info</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">info</span>()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">info</span>(<span class="type">int</span> a,string ad,string p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;adress = ad;</span><br><span class="line">        <span class="keyword">this</span>-&gt;Phone_num = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string adress;</span><br><span class="line">    string Phone_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp; out,<span class="type">const</span> info &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; p.age &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; p.adress &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; p.Phone_num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;string,info&gt;m;</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;张志豪&quot;</span>,<span class="built_in">info</span>(<span class="number">18</span>,<span class="string">&quot;长沙市岳麓区辰态科技园D座&quot;</span>,<span class="string">&quot;0734110&quot;</span>)));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;李乐&quot;</span>,<span class="built_in">info</span>(<span class="number">18</span>,<span class="string">&quot;长沙市岳麓区辰态科技园A座&quot;</span>,<span class="string">&quot;0734119&quot;</span>)));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;李小乐&quot;</span>,<span class="built_in">info</span>(<span class="number">18</span>,<span class="string">&quot;长沙市岳麓区辰态科技园B座&quot;</span>,<span class="string">&quot;0734120&quot;</span>)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(map&lt;string,info&gt;::iterator it = m.<span class="built_in">begin</span>();it != m.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt;it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过key 值快速索引到value值  -&gt; multimap 不支持！！因为它可能由多个重复的key</span></span><br><span class="line">    cout &lt;&lt; m[<span class="string">&quot;李小乐&quot;</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; m.<span class="built_in">at</span>(<span class="string">&quot;李乐&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; m[<span class="string">&quot;张豪&quot;</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三十、算法"><a href="#三十、算法" class="headerlink" title="三十、算法"></a>三十、算法</h3><h4 id="1、一些名词概念"><a href="#1、一些名词概念" class="headerlink" title="1、一些名词概念"></a>1、一些名词概念</h4><h5 id="1、函数对象"><a href="#1、函数对象" class="headerlink" title="1、函数对象"></a>1、函数对象</h5><h6 id="1、概念-15"><a href="#1、概念-15" class="headerlink" title="1、概念"></a>1、概念</h6><p>重载了函数调用运算符的类，其对象就是函数对象，函数对象使用重载的() 时。行为类似函数调用，也叫仿函数</p><p>本质：仿函数不是一个函数，而是一个类</p><h6 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h6><p>函数对象使用，可以像普通函数一样，可以有参数，也可以有函数返回类型</p><p>函数对象可以作为参数传递（类作为参数传递）</p><h5 id="3、例子-1"><a href="#3、例子-1" class="headerlink" title="3、例子"></a>3、例子</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myadd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(Myadd p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">p</span>(<span class="number">10</span>,<span class="number">20</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Myadd</span>()(<span class="number">10</span>,<span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">    Myadd p;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">p</span>(<span class="number">10</span>,<span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2、谓词"><a href="#2、谓词" class="headerlink" title="2、谓词"></a>2、谓词</h5><h5 id="1、概念-16"><a href="#1、概念-16" class="headerlink" title="1、概念"></a>1、概念</h5><p>谓词</p><p>返回类型为bool类型的 仿函数称为谓词</p><p>如果operator()接受一个参数，一元谓词</p><p>如果operator()接受一个参数，二元谓词</p><p>谓词一定是仿函数，但是仿函数不一定时谓词！！</p><h5 id="2、STL-常用算法-了解"><a href="#2、STL-常用算法-了解" class="headerlink" title="2、STL 常用算法-&gt;了解"></a>2、STL 常用算法-&gt;了解</h5><p>1、算法主要是由头文件<algrothim>,<functional>,<numeric></numeric></functional></algrothim></p><p>2、<algrothim>是STL 头文件种最大的一个，涉及比较广，比较、交换、查找、遍历、拷贝、替换等等</algrothim></p><p>3、<functional>定义了一些模板类，用以声明函数对象</functional></p><p>4、<numeric>体积很小，只包括几个在序列上面进行简单的数学运算的模板函数</numeric></p><h5 id="3、例子-2"><a href="#3、例子-2" class="headerlink" title="3、例子"></a>3、例子</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">examp1_1</span><span class="comment">//谓词</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">examp1_2</span><span class="comment">//一元谓词</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">examp1_3</span><span class="comment">//二元谓词</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a，<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">examp1_4</span><span class="comment">//仿函数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a，<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello World!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、算法-1"><a href="#2、算法-1" class="headerlink" title="2、算法"></a>2、算法</h4><h5 id="1、遍历算法"><a href="#1、遍历算法" class="headerlink" title="1、遍历算法"></a>1、遍历算法</h5><p>1、for_each(beg,end,_func) 遍历[beg,end)里面的元素</p><p>_func 返回值通常为void _func(T val) 容器里面存放什么类型，T 就是什么类型</p><p>对于mpa来说，void _func(pair&lt;T1,T2&gt; val)</p><h5 id="2、搬运算法"><a href="#2、搬运算法" class="headerlink" title="2、搬运算法"></a>2、搬运算法</h5><p>1、transform(beg,end,traget_beg,_func);会覆盖目标容器原来的值</p><p>作用：将容器里面[beg,end)里面的元素，按照_func的规则，搬运到目标容器 traget里面</p><p>_func 函数对象或者函数</p><p>注意：使用这个算法 需要为目标容器开辟空间，开辟空间的方式我们有两种    </p><p>resize -&gt;会初始化    </p><p>reserve -&gt;不会初始化</p><p>一般使用resize初始化的开辟空间</p><p>例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">tans</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  val<span class="number">+50</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_val</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;d;</span><br><span class="line">    </span><br><span class="line">    d.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line">    for_each(d.<span class="built_in">begin</span>(),d.<span class="built_in">end</span>(),print_val);</span><br><span class="line">     cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">transform</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),d.<span class="built_in">begin</span>(),tans);</span><br><span class="line">    for_each(d.<span class="built_in">begin</span>(),d.<span class="built_in">end</span>(),print_val);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3、查找和统计算法"><a href="#3、查找和统计算法" class="headerlink" title="3、查找和统计算法"></a>3、查找和统计算法</h5><h6 id="1、查找"><a href="#1、查找" class="headerlink" title="1、查找"></a>1、查找</h6><ul><li>find(beg,end,key) 查找元素,在[beg,end)区域范围内，查找key值，找到了返回其元素的迭代器，否则返回end 末尾迭代器</li><li>find_if(beg,end,<em>Pred)</em> 按条件查找元素*。在[beg,end)*里面，根据Pred（谓词）的规则查找元素，找到了，返回第一个元素位置的迭代器</li><li>adjacent_find(beg,end) 查找[beg,end)里面相邻的重复元素！！返回相邻元素第一个位置的迭代器</li><li>bool binary_seach(beg,end,value),在容器里面使用二分法查找元素，但是容器内部必须有序，否则可能查找失败，必须有序</li><li></li></ul><h6 id="2、统计"><a href="#2、统计" class="headerlink" title="2、统计"></a>2、统计</h6><ul><li>count(beg,end,key) 统计在[beg,end)区域范围内，key值的个数</li><li>count_if(beg,end,<em>Pred) 按条件统计元素。在[beg,end)里面，根据</em>Pred（谓词）的规则统计元素，将总数返回出来</li></ul><h6 id="3、例子-3"><a href="#3、例子-3" class="headerlink" title="3、例子"></a>3、例子</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a,string n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Person &amp;p)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age &lt; p.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Person &amp;p)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> (<span class="keyword">this</span>-&gt;age == p.age &amp;&amp; <span class="keyword">this</span>-&gt;name == p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">find_com</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person &amp;p)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> p.name == <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">count_com</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person &amp;p)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> p.age&gt;<span class="number">18</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    multiset&lt;Person&gt;s;</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Person</span>(<span class="number">18</span>,<span class="string">&quot;李四&quot;</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Person</span>(<span class="number">19</span>,<span class="string">&quot;李四&quot;</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Person</span>(<span class="number">21</span>,<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Person</span>(<span class="number">65</span>,<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">    s.<span class="built_in">insert</span>(<span class="built_in">Person</span>(<span class="number">6</span>,<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">    set&lt;Person&gt;::iterator it = <span class="built_in">find</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),<span class="built_in">Person</span>(<span class="number">18</span>,<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span>(it != s.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;已找到&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt;it-&gt;name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; it-&gt;age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set&lt;Person&gt;::iterator it_1 = <span class="built_in">find_if</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),<span class="built_in">find_com</span>());</span><br><span class="line">    <span class="keyword">while</span>(it_1 != s.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; it_1-&gt;name &lt;&lt; endl;</span><br><span class="line">        it_1 = <span class="built_in">find_if</span>(++it_1,s.<span class="built_in">end</span>(),<span class="built_in">find_com</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-----------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;查找相邻的重复元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    set&lt;Person&gt;::iterator it_2 = <span class="built_in">adjacent_find</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span>(it_2 == s.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没有相邻重复元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(it_2 != s.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; it_2-&gt;name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; it_2-&gt;age &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; (++it_2)-&gt;name &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; it_2-&gt;age &lt;&lt; endl;</span><br><span class="line">        it_2 = <span class="built_in">adjacent_find</span>(it_2,s.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">13</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());<span class="comment">//默认升序</span></span><br><span class="line">    <span class="type">bool</span> flag = <span class="built_in">binary_search</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">count</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),<span class="built_in">Person</span>(<span class="number">18</span>,<span class="string">&quot;李四&quot;</span>)) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">count_if</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),<span class="built_in">find_com</span>()) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4、排序算法"><a href="#4、排序算法" class="headerlink" title="4、排序算法"></a>4、排序算法</h5><h6 id="0、随机数种子"><a href="#0、随机数种子" class="headerlink" title="0、随机数种子"></a>0、随机数种子</h6><p>很多地方使用的随机数都是伪随机数，伪随机数使程序计算出来的，并不是真正的随机数。</p><p>在c语言中的rand函数中有一个定义叫做种子，rand函数是通过对这个种子进行一系列的运算来模拟出一个随机数的。我们直接调用rand函数，并不指定种子，系统就会调用默认的种子：1，来产生随机数。因为每次重新运行时的种子都是1，运行出来的结果自然就还是这几个数啦。</p><p>所有为了使随机数每次都不相同，就需要每次都改变随机数种子，</p><p>最常用的是时间种子，记得包含头文件&lt;time.h&gt;</p><p>还有一种用法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> random = rand（）%<span class="number">4</span>  表示在出现的随机数全在<span class="number">0</span><span class="number">-4</span>之间。</span><br></pre></td></tr></table></figure><h6 id="1、排序"><a href="#1、排序" class="headerlink" title="1、排序"></a>1、排序</h6><ul><li>sort(beg,end,<em>Pred) 对容器内元素进行排序，根据</em>Pred 的规则。默认为升序</li><li>注意：sort 只能给随机访问迭代器使用！！</li></ul><h6 id="2、洗牌"><a href="#2、洗牌" class="headerlink" title="2、洗牌"></a>2、洗牌</h6><ul><li>random_shuffle(beg,end) 打乱容器的排序</li><li>注意：需要给随机数种子，否则将随机打乱的顺序不会改变</li></ul><h6 id="3、反转"><a href="#3、反转" class="headerlink" title="3、反转"></a>3、反转</h6><ul><li>reverse(beg,end) 反转容器的元素</li></ul><h6 id="4、合并"><a href="#4、合并" class="headerlink" title="4、合并"></a>4、合并</h6><ul><li>merge(beg1,end1,beg2,end2,traget_beg,_Pred) 将容器1的元素和容器2的元素合并给目标容器</li><li>注意：1、记得个目标容器使用resize 拓展空间 2、如果容器1和容器2都是按同样规则排序的，那么目标容器也会排好序,_pred 要和容器1 2的规则一样</li><li>如果你想要目标容器有序，那么你必须要使得v1 ，v2 使用相同规则排序，同时还需要使得_pred（谓词）和 容器1 2 的谓词一致</li><li><em>pred 默认升序，如果是升序，</em>pred 可以不用给值</li></ul><p>排序算法一整个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pinrt_val</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">com</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val1,<span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  val1 &gt; val2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">//从大到小排序</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="built_in">com</span>());</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),pinrt_val);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">random_shuffle</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),pinrt_val);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">reverse</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());</span><br><span class="line">    for_each(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),pinrt_val);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">v1</span>(v);</span><br><span class="line">    <span class="comment">//sort(v.begin(),v.end(),com());</span></span><br><span class="line">    <span class="built_in">sort</span>(v<span class="number">1.</span><span class="built_in">begin</span>(),v<span class="number">1.</span><span class="built_in">end</span>(),<span class="built_in">com</span>());</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;v3;</span><br><span class="line">    v<span class="number">3.</span><span class="built_in">resize</span>(v<span class="number">1.</span><span class="built_in">size</span>()+v.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">merge</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),v<span class="number">1.</span><span class="built_in">begin</span>(),v<span class="number">1.</span><span class="built_in">end</span>(),v<span class="number">3.</span><span class="built_in">begin</span>(),<span class="built_in">com</span>());</span><br><span class="line">    for_each(v<span class="number">3.</span><span class="built_in">begin</span>(),v<span class="number">3.</span><span class="built_in">end</span>(),pinrt_val);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5、拷贝算法"><a href="#5、拷贝算法" class="headerlink" title="5、拷贝算法"></a>5、拷贝算法</h5><p>copy(beg,end,target_beg) 将容器内[beg,end)里面的元素，拷贝至目标容器中</p><ul><li>注意：会覆盖旧元素<br>replace(beg,end,T oldVal,T NewVal); 将[beg,end)所有的oldVal 替换成NewVal<br>replace_if(beg,end,_Pred,T val) 将[beg,end)里面所有满足条件的元素，替换成val</li><li>swap(c1,c2) 替换c1 与 c2 ,但是c1 与 c2 必须为同类型的容器</li></ul><p>例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_val</span><span class="params">(<span class="type">int</span> avl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; avl &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将所有 &gt; 5 的元素替换成666</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">re_if</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  val &gt; <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v.<span class="built_in">push_back</span>(i<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt;l;</span><br><span class="line">    l.<span class="built_in">resize</span>(v.<span class="built_in">size</span>());</span><br><span class="line">    <span class="built_in">copy</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),l.<span class="built_in">begin</span>());</span><br><span class="line">    for_each(l.<span class="built_in">begin</span>(),l.<span class="built_in">end</span>(),print_val);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    l.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    l.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    l.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    l.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">replace</span>(l.<span class="built_in">begin</span>(),l.<span class="built_in">end</span>(),<span class="number">10</span>,<span class="number">9527</span>);</span><br><span class="line">    for_each(l.<span class="built_in">begin</span>(),l.<span class="built_in">end</span>(),print_val);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">replace_if</span>(l.<span class="built_in">begin</span>(),l.<span class="built_in">end</span>(),<span class="built_in">re_if</span>(),<span class="number">666</span>);</span><br><span class="line">    for_each(l.<span class="built_in">begin</span>(),l.<span class="built_in">end</span>(),print_val);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6、算数生成算法"><a href="#6、算数生成算法" class="headerlink" title="6、算数生成算法"></a>6、算数生成算法</h5><p>算数生成算法属于小型算法，包含的头文件为<numeric></numeric></p><h6 id="1、累加算法"><a href="#1、累加算法" class="headerlink" title="1、累加算法"></a>1、累加算法</h6><p>accumulate(beg,end,init_val)</p><p>计算容器元素累积总和，init_val 初始值,从 init_val开始累加</p><h6 id="2、填充算法"><a href="#2、填充算法" class="headerlink" title="2、填充算法"></a>2、填充算法</h6><p>fill(beg,end,value);将容器内部[beg,end)的元素，使用value填充&#x2F;&#x2F;这个函数主要用于后期填充，但是我们需要使用resize制定大小，否则无法填充</p><p>如果原来的容器里面有数据了，我们使用fill，会将原来的元素覆盖，因此在后期填充的时候</p><p>一定要确定好填充的内容！！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">100</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">        v<span class="number">1.</span><span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    sum = <span class="built_in">accumulate</span>(v<span class="number">1.</span><span class="built_in">begin</span>(),v<span class="number">1.</span><span class="built_in">end</span>(),<span class="number">1000</span>);</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">fill</span>(v<span class="number">1.</span><span class="built_in">begin</span>(),v<span class="number">1.</span><span class="built_in">end</span>(),<span class="number">666</span>);</span><br><span class="line">    cout &lt;&lt; v1[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7、集合算法"><a href="#7、集合算法" class="headerlink" title="7、集合算法"></a>7、集合算法</h5><ul><li>集合算法</li><li>set_intersection(beg1,end1,beg2,end2,traget_beg,_Pred) 求交集</li><li>set_union(beg1,end1,beg2,end2,traget_beg,_Pred) 求并集</li><li>set_difference(beg1,end1,beg2,end2,traget_beg,_Pred)求差集</li><li>所有集合算法的注意事项</li><li>traget_beg 目标容器 要申请空间</li><li>返回交集中最后一个元素的迭代器</li><li>容器1与容器2必须有序,排序规则还需要一致</li><li>如果都是升序那么 pred 可以不写，但是如果不是默认升序，那么Pred 必须和容器1与容器2的一致</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">com_</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val1,<span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_val</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;v2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v<span class="number">1.</span><span class="built_in">push_back</span>(i<span class="number">+1</span>);</span><br><span class="line">        v<span class="number">2.</span><span class="built_in">push_back</span>(i<span class="number">+5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//random_shuffle(v2.begin(),v2.end());</span></span><br><span class="line">    <span class="built_in">sort</span>(v<span class="number">2.</span><span class="built_in">begin</span>(),v<span class="number">2.</span><span class="built_in">end</span>(),<span class="built_in">com_</span>());</span><br><span class="line">    <span class="built_in">sort</span>(v<span class="number">1.</span><span class="built_in">begin</span>(),v<span class="number">1.</span><span class="built_in">end</span>(),<span class="built_in">com_</span>());</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1 与 v2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    for_each(v<span class="number">1.</span><span class="built_in">begin</span>(),v<span class="number">1.</span><span class="built_in">end</span>(),print_val);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    for_each(v<span class="number">2.</span><span class="built_in">begin</span>(),v<span class="number">2.</span><span class="built_in">end</span>(),print_val);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;v3;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1 与 v2的差集&quot;</span> &lt;&lt; endl;</span><br><span class="line">    v<span class="number">3.</span><span class="built_in">resize</span>(<span class="built_in">min</span>(v<span class="number">1.</span><span class="built_in">size</span>(),v<span class="number">2.</span><span class="built_in">size</span>()));</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it_end = <span class="built_in">set_intersection</span>(v<span class="number">1.</span><span class="built_in">begin</span>(),v<span class="number">1.</span><span class="built_in">end</span>(),v<span class="number">2.</span><span class="built_in">begin</span>(),v<span class="number">2.</span><span class="built_in">end</span>(),v<span class="number">3.</span><span class="built_in">begin</span>(),<span class="built_in">com_</span>());</span><br><span class="line">    <span class="comment">//返回交集中最后一个元素的迭代器</span></span><br><span class="line">    for_each(v<span class="number">3.</span><span class="built_in">begin</span>(),it_end,print_val);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1 与 v2 的并集&quot;</span>&lt;&lt; endl;</span><br><span class="line">    v<span class="number">3.</span><span class="built_in">resize</span>(v<span class="number">1.</span><span class="built_in">size</span>()+v<span class="number">2.</span><span class="built_in">size</span>());</span><br><span class="line">    it_end = <span class="built_in">set_union</span>(v<span class="number">1.</span><span class="built_in">begin</span>(),v<span class="number">1.</span><span class="built_in">end</span>(),v<span class="number">2.</span><span class="built_in">begin</span>(),v<span class="number">2.</span><span class="built_in">end</span>(),v<span class="number">3.</span><span class="built_in">begin</span>(),<span class="built_in">com_</span>());</span><br><span class="line">    for_each(v<span class="number">3.</span><span class="built_in">begin</span>(),it_end,print_val);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v1 与 v2 的差集&quot;</span> &lt;&lt; endl;</span><br><span class="line">    v<span class="number">3.</span><span class="built_in">resize</span>(<span class="built_in">max</span>(v<span class="number">1.</span><span class="built_in">size</span>(),v<span class="number">2.</span><span class="built_in">size</span>()));</span><br><span class="line">    it_end = <span class="built_in">set_difference</span>(v<span class="number">1.</span><span class="built_in">begin</span>(),v<span class="number">1.</span><span class="built_in">end</span>(),v<span class="number">2.</span><span class="built_in">begin</span>(),v<span class="number">2.</span><span class="built_in">end</span>(),v<span class="number">3.</span><span class="built_in">begin</span>(),<span class="built_in">com_</span>());</span><br><span class="line">    for_each(v<span class="number">3.</span><span class="built_in">begin</span>(),it_end,print_val);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;v2 与 v1 的差集&quot;</span> &lt;&lt; endl;</span><br><span class="line">    it_end = <span class="built_in">set_difference</span>(v<span class="number">2.</span><span class="built_in">begin</span>(),v<span class="number">2.</span><span class="built_in">end</span>(),v<span class="number">1.</span><span class="built_in">begin</span>(),v<span class="number">1.</span><span class="built_in">end</span>(),v<span class="number">3.</span><span class="built_in">begin</span>(),<span class="built_in">com_</span>());</span><br><span class="line">    for_each(v<span class="number">3.</span><span class="built_in">begin</span>(),it_end,print_val);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三十一、智能指针"><a href="#三十一、智能指针" class="headerlink" title="三十一、智能指针"></a>三十一、智能指针</h3><h6 id="1、传统指针（普通指针）的问题"><a href="#1、传统指针（普通指针）的问题" class="headerlink" title="1、传统指针（普通指针）的问题"></a>1、传统指针（普通指针）的问题</h6><ul><li>1、释放后没有初始化，成为野指针</li><li>2、容易发生内存泄漏</li><li>3、需要手动申请与释放</li><li>因此为了解决传统指针的问题。智能指针出生了。但是智能指针不能百分百确定一定不会发生内存泄漏</li><li>智能指针实际上就是对传统指针的一个封装，但是并不是所有的传统指针都可以封装成智能指针</li></ul><h6 id="2、智能指针的分类："><a href="#2、智能指针的分类：" class="headerlink" title="2、智能指针的分类："></a>2、智能指针的分类：</h6><ul><li>1、auto_ptr:属于c++98 ,c++11 就不用了，因为其不能对数组使用</li><li>2、unique_ptr:独占指针，独自管理一片空间</li><li>3、share_ptr:共享指针，也叫计数指针。可以由多个指针管理一片空间，其内部含有一个计数的方法，可以记录当前有多少个指针管理这片空间</li><li>4、weak_ptr:会对一个对象产生弱引用，主要是对共享指针的一个补充。使用场景非常的少。需要通过share_ptr 来创建</li><li>在c++ 中，指针分为两类，一个是传统指针一个就是智能指针，使用最多的就是传统指针，然后就是独占指针和共享指针</li><li>注意：使用智能指针，你必须包含头文件<memory></memory></li></ul><h6 id="3、独占指针-unique-ptr-创建方式"><a href="#3、独占指针-unique-ptr-创建方式" class="headerlink" title="3、独占指针- unique_ptr 创建方式"></a>3、独占指针- unique_ptr 创建方式</h6><ul><li>1、通过已有的原始指针（传统指针）来创建</li><li>2、通过new来创建</li><li>3、使用 make_unique来创建，此方法不是c++11 的，属于c++13</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1、创建独占指针</span></span><br><span class="line">        Person *p = <span class="keyword">new</span> Person;</span><br><span class="line">        <span class="function">unique_ptr&lt;Person&gt; <span class="title">smart_p1</span><span class="params">(p)</span></span>;</span><br><span class="line">        <span class="comment">//第2种方式</span></span><br><span class="line">        <span class="function">unique_ptr&lt;Person&gt; <span class="title">smart_p2</span><span class="params">(<span class="keyword">new</span> Person)</span></span>;</span><br><span class="line">        unique_ptr&lt;Person&gt; smart_p3 = <span class="built_in">make_unique</span>&lt;Person&gt;();<span class="comment">//此方法属于c++14</span></span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;---------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">        smart_p2 = <span class="literal">nullptr</span>;<span class="comment">//智能析构方式1</span></span><br><span class="line">        smart_p<span class="number">3.</span><span class="built_in">reset</span>();<span class="comment">//智能析构方式2</span></span><br><span class="line">        cout &lt;&lt;<span class="string">&quot;---------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//智能指针的使用和传统指针相差不大，几乎是一样的</span></span><br><span class="line">        smart_p1-&gt;age =<span class="number">20</span>;</span><br><span class="line">        cout &lt;&lt; smart_p1-&gt;<span class="built_in">func</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1\t&quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;2\t&quot;</span> &lt;&lt; smart_p<span class="number">1.</span><span class="built_in">get</span>() &lt;&lt; endl;<span class="comment">// smart_p1.get() 获取指针地址</span></span><br><span class="line"></span><br><span class="line">        unique_ptr&lt;Person&gt; smart_p4 = <span class="built_in">move</span>(smart_p1);<span class="comment">//将smart_p1 管理权限移交给 smart_p4</span></span><br><span class="line">        cout &lt;&lt; smart_p4-&gt;<span class="built_in">func</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;3\t&quot;</span> &lt;&lt; smart_p<span class="number">4.</span><span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; smart_p1-&gt;age &lt;&lt; endl;<span class="comment">//奔溃了，因为你没有权力去访问了，你已经将权力移交了</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;啊，终于结束了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4、shared-ptr-称为共享指针，"><a href="#4、shared-ptr-称为共享指针，" class="headerlink" title="4、shared_ptr 称为共享指针，"></a>4、shared_ptr 称为共享指针，</h6><p>也叫计数指针，它内部有一个计数器，可以记录有多少个指针对象正在管理这片空间</p><ul><li>独占指针只能move不能copy，但是 共享指针可以copy，创建方式和独占指针一样</li><li>use_count 每copy一次++，每析构一次–</li><li>同时，我们可以使用move的方式，将独占指针变为共享指针</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        Person *p = <span class="keyword">new</span> Person;</span><br><span class="line">        shared_ptr&lt;Person&gt;<span class="built_in">smart_p1</span>(p);</span><br><span class="line">        shared_ptr&lt;Person&gt;<span class="built_in">smart_p2</span>(<span class="keyword">new</span> Person);</span><br><span class="line">        shared_ptr&lt;Person&gt;smart_p3 = <span class="built_in">make_shared</span>&lt;Person&gt;();</span><br><span class="line">        <span class="comment">//与独占指针不同的是，它可以多人管理一片空间</span></span><br><span class="line">        <span class="comment">//计数器</span></span><br><span class="line">        cout &lt;&lt; smart_p<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">        shared_ptr&lt;Person&gt;smart_p4 = smart_p1;</span><br><span class="line">        shared_ptr&lt;Person&gt;smart_p5 = smart_p1;</span><br><span class="line">        shared_ptr&lt;Person&gt;smart_p6 = smart_p1;</span><br><span class="line">        shared_ptr&lt;Person&gt;smart_p7 = smart_p1;</span><br><span class="line">        shared_ptr&lt;Person&gt;smart_p8 = smart_p1;</span><br><span class="line">        shared_ptr&lt;Person&gt;smart_p9 = smart_p1;</span><br><span class="line">        shared_ptr&lt;Person&gt;smart_p10 = smart_p1;</span><br><span class="line">        shared_ptr&lt;Person&gt;smart_p11 = smart_p1;</span><br><span class="line">        shared_ptr&lt;Person&gt;smart_p12 = smart_p1;</span><br><span class="line">        cout &lt;&lt; smart_p<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl;<span class="comment">//10</span></span><br><span class="line">        cout &lt;&lt; smart_p<span class="number">10.</span><span class="built_in">use_count</span>() &lt;&lt; endl;<span class="comment">//10</span></span><br><span class="line">        <span class="comment">//use_count 每copy一次++，每析构一次--</span></span><br><span class="line">        smart_p<span class="number">10.</span><span class="built_in">reset</span>();</span><br><span class="line">        cout &lt;&lt; smart_p<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl;<span class="comment">//9</span></span><br><span class="line">        cout &lt;&lt; smart_p<span class="number">10.</span><span class="built_in">use_count</span>() &lt;&lt; endl;<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//同时，我们可以使用move的方式，将独占指针变为共享指针</span></span><br><span class="line">        unique_ptr&lt;Person&gt;<span class="built_in">smart_p13</span>(<span class="keyword">new</span> Person);</span><br><span class="line">        <span class="comment">//使用move的方式，将其转变为共享指针</span></span><br><span class="line">        shared_ptr&lt;Person&gt;smart_p14 = <span class="built_in">move</span>(smart_p13);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*************************************************&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;我马上就结束了&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;*************************************************&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;我结束了&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三十二、异常处理"><a href="#三十二、异常处理" class="headerlink" title="三十二、异常处理"></a>三十二、异常处理</h3><p>异常处理：可以将程序以平缓的方式结束，就算程序即将崩溃，也不会闪退，会给你提示后然后再退出</p><p>在程序里面</p><p>try 检测里面的代码，从而降低工作效率</p><p>{</p><p>将你认为可能出现问题的代码放入里面</p><p>比如</p><p>求三角形面积的函数</p><p>func(a,b,c);0 0 1-&gt;无法创建三角形，他会throw 一个异常</p><p>}</p><p>catch(exception &amp; e)</p><p>{</p><p>​cout &lt;&lt; ERRor: &lt;&lt;  why? &lt;&lt; endl;</p><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/05/30/test/c%E5%92%8Cc++/c++%E9%97%AE%E7%AD%94/"/>
      <url>/2025/05/30/test/c%E5%92%8Cc++/c++%E9%97%AE%E7%AD%94/</url>
      
        <content type="html"><![CDATA[<h1 id="c-三大特性"><a href="#c-三大特性" class="headerlink" title="c++三大特性"></a>c++三大特性</h1><p>c++三大特性之一，<strong>封装</strong></p><p>c++三大特性之二，<strong>继承</strong></p><p>c++三大特性之三，<strong>多态</strong></p><ol><li><p><strong>封装</strong>：</p><ul><li>封装就像是把东西装进盒子里。在C++中，封装意味着将数据（变量）和操作这些数据的代码（函数）打包在一起，形成一个类（Class）。这样，数据就被保护起来，不被外部直接访问，只能通过类提供的方法来操作。这有助于保护数据不被错误地修改，也使得代码更加模块化和易于管理。</li></ul></li><li><p><strong>继承</strong>：</p><ul><li>继承就像是孩子从父母那里继承特性。在C++中，继承允许一个类（子类）继承另一个类（父类或基类）的属性和方法。这样，子类就可以重用父类的代码，同时也可以添加自己的新特性或修改继承来的特性。继承有助于代码的复用和组织，使得代码结构更加清晰。</li></ul></li><li><p><strong>多态</strong>：</p><ul><li>多态就像是同一个接口可以有不同的实现方式。在C++中，多态允许不同的类以自己的方式实现相同的接口（即方法）。这意味着你可以使用一个统一的接口来调用不同类的方法，而这些方法的具体实现会根据对象的实际类型来决定。多态使得代码更加灵活和可扩展，也支持了代码的动态绑定。</li></ul><p>简单来说，封装是保护和隐藏数据，继承是复用和扩展代码，而多态是统一接口下的多种实现。这三大特性使得C++成为一种强大且灵活的编程语言。</p></li></ol><h1 id="c-问答"><a href="#c-问答" class="headerlink" title="c++问答"></a><strong>c++问答</strong></h1><h2 id="一、c-强制类型转化"><a href="#一、c-强制类型转化" class="headerlink" title="一、c++强制类型转化"></a>一、c++强制类型转化</h2><h3 id="1、C强制转换与C-强制转换"><a href="#1、C强制转换与C-强制转换" class="headerlink" title="1、C强制转换与C++强制转换"></a>1、C强制转换与C++强制转换</h3><p><a href="https://so.csdn.net/so/search?q=c%E8%AF%AD%E8%A8%80%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2&spm=1001.2101.3001.7020">c语言强制类型转换</a>主要用于基础的数据类型间的转换，语法为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(type-id)expression<span class="comment">//转换格式1</span></span><br><span class="line">type-<span class="built_in">id</span>(expression)<span class="comment">//转换格式2</span></span><br></pre></td></tr></table></figure><p>c++除了能使用c语言的<a href="https://so.csdn.net/so/search?q=%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2&spm=1001.2101.3001.7020">强制类型转换</a>外，还新增了四种强制类型转换：static_cast、dynamic_cast、const_cast、reinterpret_cast，主要运用于继承关系类间的强制转化，语法为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">static_cast</span>&lt;new_type&gt;      (expression)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;new_type&gt;     (expression) </span><br><span class="line"><span class="built_in">const_cast</span>&lt;new_type&gt;       (expression) </span><br><span class="line"><span class="built_in">reinterpret_cast</span>&lt;new_type&gt; (expression)</span><br></pre></td></tr></table></figure><h3 id="2、C-四种强制类型转换"><a href="#2、C-四种强制类型转换" class="headerlink" title="2、C++四种强制类型转换"></a>2、C++四种强制类型转换</h3><h4 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">double</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(a);</span><br></pre></td></tr></table></figure><p>static_cast相当于传统的C语言里的强制转换，该运算符把expression转换为new_type类型，用来强迫隐式转换，例如non-const对象转为const对象，编译时检查，用于非多态的转换，可以转换指针及其他，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：</p><p>①用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。</p><p>进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；</p><p>进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。</p><p>②用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。</p><p>③把空指针转换成目标类型的空指针。</p><p>④把任何类型的表达式转换成void类型。</p><p>注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。</p><h4 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic_cast</span>&lt;type*&gt;(e)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;type&amp;&gt;(e)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;type&amp;&amp;&gt;(e)</span><br></pre></td></tr></table></figure><p>type必须是一个类类型，在第一种形式中，type必须是一个有效的指针，在第二种形式中，type必须是一个左值，在第三种形式中，type必须是一个右值。在上面所有形式中，e的类型必须符合以下三个条件中的任何一个：e的类型是是目标类型type的公有派生类、e的类型是目标type的共有基类或者e的类型就是目标type的的类型。如果一条dynamic_cast语句的转换目标是指针类型并且失败了，则结果为0。如果转换目标是引用类型并且失败了，则dynamic_cast运算符将抛出一个std::bad_cast异常(该异常定义在typeinfo标准库头文件中)。e也可以是一个空指针，结果是所需类型的空指针。</p><p>dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换（cross cast）。</p><p>在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；</p><p>在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全，向下转型的前提必须是安全的，要借助 RTTI 进行检测，所有只有一部分能成功。dynamic_cast是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。</p><p>dynamic_cast 与 static_cast 是相对的，dynamic_cast 是“动态转换”的意思，static_cast 是“静态转换”的意思。dynamic_cast 会在程序运行期间借助 RTTI 进行类型转换，这就要求基类必须包含虚函数；static_cast 在编译期间完成类型转换，能够更加及时地发现错误。</p><h4 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h4><p>const_cast，用于修改类型的const或volatile属性。</p><p>该运算符用来修改类型的const(唯一有此能力的C++style转型操作符)或volatile属性。除了const 或volatile修饰之外， new_type和expression的类型是一样的。</p><p>①常量指针被转化成非常量的指针，并且仍然指向原来的对象；</p><p>②常量引用被转换成非常量的引用，并且仍然指向原来的对象；</p><p>③const_cast一般用于修改底指针。如const char *p形式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> * p = &amp;a;</span><br><span class="line">    <span class="type">int</span> *q;</span><br><span class="line">    q = <span class="built_in">const_cast</span>&lt;<span class="type">int</span> *&gt;(p);</span><br><span class="line">    *q = <span class="number">20</span>;    <span class="comment">//fine</span></span><br><span class="line">    cout &lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*p&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;*q&lt;&lt;endl;</span><br><span class="line">        cout &lt;&lt;&amp;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;p&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;q&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">20</span></span><br><span class="line"><span class="number">002</span>CFAF4 <span class="number">002</span>CFAF4 <span class="number">002</span>CFAF4</span><br></pre></td></tr></table></figure><h4 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *a = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="type">double</span> *d = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">double</span> *&gt;(a)</span><br></pre></td></tr></table></figure><p>new_type必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，再把该整数转换成原类型的指针，还可以得到原先的指针值）。</p><p>reinterpret_cast意图执行低级转型，实际动作（及结果）可能取决于编辑器，这也就表示它不可移植。</p><p>举一个错误使用reintepret_cast例子，将整数类型转换成函数指针后，vc++在执行过程中会报”…中的 0xxxxxxxxx 处有未经处理的异常: 0xC0000005: Access violation”错误：</p><p>另外，static_cast和reinterpret_cast的区别主要在于多重继承，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">   <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">   <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;&#125;;</span><br></pre></td></tr></table></figure><p>那么对于以下代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C c;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p, %p, %p&quot;</span>, &amp;c, <span class="built_in">reinterpret_cast</span>&lt;B*&gt;(&amp;c), <span class="keyword">static_cast</span> &lt;B*&gt;(&amp;c));</span><br></pre></td></tr></table></figure><p>前两个的输出值是相同的，最后一个则会在原基础上偏移4个字节，这是因为static_cast计算了父子类指针转换的偏移量，并将之转换到正确的地址（c里面有m_a,m_b，转换为B*指针后指到m_b处），而reinterpret_cast却不会做这一层转换。</p><p>　因此, 你需要谨慎使用 reinterpret_cast。</p><h4 id="3、-c-强制转换注意事项"><a href="#3、-c-强制转换注意事项" class="headerlink" title="3、 c++强制转换注意事项"></a>3、 c++强制转换注意事项</h4><p>新式转换较旧式转换更受欢迎。 原因有二，一是新式转型较易辨别，能简化“找出类型系统在哪个地方被破坏”的过程； 二是各转型动作的目标愈窄化，编译器愈能诊断出错误的运用。</p><p>尽量少使用转型操作，尤其是dynamic_cast，耗时较高，会导致性能的下降，尽量使用其他方法替代。</p><h1 id="c-常见错误收集"><a href="#c-常见错误收集" class="headerlink" title="c++常见错误收集"></a><strong>c++常见错误收集</strong></h1><h3 id="1、没加命名空间，导致string报红不认识"><a href="#1、没加命名空间，导致string报红不认识" class="headerlink" title="1、没加命名空间，导致string报红不认识"></a>1、没加命名空间，导致string报红不认识</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这样写就是错的,编译通不过</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> string x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//改成这样就 OK:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> string x;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//或者这样:</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> std::string x;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//原因 就是 string 是标准库,C++标准引入了命名空间namespace，标准库的空间是std</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/05/30/test/c%E5%92%8Cc++/%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B%20%E7%BA%BF%E6%80%A7%E8%A1%A8%20%E5%87%BD%E6%95%B0%20%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E6%8C%87%E9%92%88%E4%B8%93%E9%A2%98/"/>
      <url>/2025/05/30/test/c%E5%92%8Cc++/%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B%20%E7%BA%BF%E6%80%A7%E8%A1%A8%20%E5%87%BD%E6%95%B0%20%E3%80%81%E6%95%B0%E7%BB%84%E3%80%81%E6%8C%87%E9%92%88%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a><strong>存储类型</strong></h1><p>在C语言中，存储类型（或存储类别）定义了变量的<strong>作用域</strong>（即它可以在哪里被访问）和生命周期（即它存在多久）。以下是C语言中的几种存储类型：</p><ol><li><strong>自动存储类型（Auto）</strong>自动存储类型是所有局部变量的默认存储类型。这些变量在函数开始时被创建，并在函数结束时被销毁。它们通常存储在栈内存中。可以使用 auto 关键字显式声明，但这很少见。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">int</span> x = <span class="number">1</span>;  <span class="comment">// 自动存储类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>静态存储类型（Static）</strong>静态变量仅在程序的执行期间被初始化一次，之后它们保持其值，直到程序终止。可以使用 static 关键字来声明静态变量。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x = <span class="number">0</span>;  <span class="comment">// 静态存储类型</span></span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>寄存器存储类型（Register）</strong>寄存器变量被存储在CPU的寄存器中，而不是RAM中，以便更快地访问。可以使用 register 关键字来声明寄存器变量。但是，这只是一个建议，编译器可以选择忽略它。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> x = <span class="number">0</span>;  <span class="comment">// 寄存器存储类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>外部存储类型（Extern）</strong>外部变量是在所有文件中共享的变量。它们是在一个文件中定义的，可以在其他文件中使用。可以使用 extern 关键字来声明外部变量。 extern int x; &#x2F;&#x2F; 外部存储类型，x是在另一个文件中定义的</li></ol><p>除了这些，还有 typedef 关键字，它不是存储类别，但它允许你创建类型的别名，这可以使代码更易于阅读和维护。<br>注意，存储类型关键字只能应用于变量和函数，而不能应用于类型定义或其他语言元素。</p><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a><strong>线性表</strong></h1><p>顺序表<br>编写一个顺序表通常包括定义一个结构来存储元素及其有关的属性，如数组和当前大小，以及一系列操作顺序表的函数，如插入、删除和搜索。下面是一个简单的C语言实现示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义最大容量为100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义顺序表结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE]; <span class="comment">// 存储元素的数组</span></span><br><span class="line">    <span class="type">int</span> length;         <span class="comment">// 当前顺序表的长度</span></span><br><span class="line">&#125; SeqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化顺序表</span></span><br><span class="line">SeqList* <span class="title function_">initSeqList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 分配内存空间，并将长度初始化为0</span></span><br><span class="line">    SeqList* <span class="built_in">list</span> = (SeqList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqList));</span><br><span class="line">    <span class="built_in">list</span>-&gt;length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">insertSeqList</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="type">int</span> pos, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查位置是否合法和顺序表是否已满</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;length &gt;= MAX_SIZE || pos &lt; <span class="number">0</span> || pos &gt; <span class="built_in">list</span>-&gt;length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从后往前，将元素向后移动，以创建空位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">list</span>-&gt;length; i &gt; pos; i--) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;data[i] = <span class="built_in">list</span>-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在指定位置插入新元素</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;data[pos] = value;</span><br><span class="line">    <span class="comment">// 增加顺序表的长度</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteSeqList</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="type">int</span> pos)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查位置是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span> || pos &gt;= <span class="built_in">list</span>-&gt;length) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从前往后，将元素向前移动，覆盖待删除的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pos; i &lt; <span class="built_in">list</span>-&gt;length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;data[i] = <span class="built_in">list</span>-&gt;data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 减少顺序表的长度</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">findSeqList</span><span class="params">(SeqList* <span class="built_in">list</span>, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历顺序表，查找给定值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;data[i] == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">// 如果找到，返回索引</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 如果未找到，返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">displaySeqList</span><span class="params">(SeqList* <span class="built_in">list</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历并打印所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">list</span>-&gt;length; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">list</span>-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">// 在打印完所有元素后换行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化顺序表</span></span><br><span class="line">    SeqList* <span class="built_in">list</span> = initSeqList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    insertSeqList(<span class="built_in">list</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    insertSeqList(<span class="built_in">list</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    insertSeqList(<span class="built_in">list</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示当前顺序表的内容</span></span><br><span class="line">    displaySeqList(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除索引为1的元素</span></span><br><span class="line">    deleteSeqList(<span class="built_in">list</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示当前顺序表的内容</span></span><br><span class="line">    displaySeqList(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找值为3的元素</span></span><br><span class="line">    <span class="type">int</span> index = findSeqList(<span class="built_in">list</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (index != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Element found at index: %d\n&quot;</span>, index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Element not found\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放顺序表所占用的内存空间</span></span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中：<br>我们首先定义了一个SeqList结构体，它有一个数组来存储元素和一个整数来存储列表的当前长度。<br>initSeqList函数初始化一个新的顺序表。<br>insertSeqList函数在指定位置插入一个新元素。<br>deleteSeqList函数删除指定位置的元素。<br>findSeqList函数查找给定值的元素。<br>displaySeqList函数显示列表的所有元素。<br>注意，这个示例没有包含错误检查和恢复代码来处理如内存分配失败这样的错误条件。在真实的代码中，你应该添加适当的错误检查和处理代码。</p><h1 id="函数-、数组、指针专题"><a href="#函数-、数组、指针专题" class="headerlink" title="函数 、数组、指针专题"></a><strong>函数 、数组、指针专题</strong></h1><h2 id="一、数组指针和指针数组"><a href="#一、数组指针和指针数组" class="headerlink" title="一、数组指针和指针数组"></a>一、数组指针和指针数组</h2><p>在C语言中，”数组指针”和”指针数组”是两种不同的概念。下面我将解释这两者的区别：<br><strong>数组指针 ： 本质是指针，是一个指向数组的指针 用于指针指向多维数组的时候</strong><br><strong>指针数组：本质是数组， 是一个存放指针数组</strong></p><h3 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h3><p>数组指针是一个指针，它指向一个数组。通常它是指向数组中的第一个元素的指针，或者指向一个多维数组。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> (*ptr_to_arr)[<span class="number">3</span>] = &amp;arr;</span><br></pre></td></tr></table></figure><p>在这个示例中，<strong>ptr_to_arr</strong>是一个指针，它指向一个具有3个整数的数组。</p><h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><p>指针数组则是一个数组，它的每个元素都是指针。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr_arr[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>在这个示例中，<strong>ptr_arr</strong>是一个数组，它包含3个整数指针。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li><strong>数据类型</strong>：</li></ol><ul><li>数组指针：是一个指针，它指向一个数组。</li><li>指针数组：是一个数组，它包含多个指针。</li></ul><ol><li><strong>内存分布</strong>：</li></ol><ul><li>数组指针：它本质上是一个指针，占用的内存大小是指针的大小（通常是4或8字节，取决于系统的架构）。</li><li>指针数组：它是一个数组，占用的内存大小是数组中所有指针的大小之和。</li></ul><ol><li><strong>声明方式</strong>：</li></ol><ul><li>数组指针：使用圆括号来改变优先级，例如：**int (*ptr_to_arr)[3]*。</li><li>指针数组：使用方括号来定义数组的大小，例如：**int *ptr_arr[3]*。</li></ul><h2 id="1-数组指针"><a href="#1-数组指针" class="headerlink" title="1. 数组指针"></a>1. 数组指针</h2><p>数组指针是一个指针，它指向一个数组。它常用于指向多维数组的情况。数组指针的定义和使用如下：</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>数组指针的定义需要指明数组的类型和大小。例如，如果我们有一个含有3个整数的数组，我们可以定义一个指向该数组的数组指针如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*array_ptr)[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>在这里：</p><ul><li><strong>int</strong>：表示数组中元素的类型是整数。</li><li>**(*array_ptr)*：是一个指向数组的指针。</li><li>**[3]**：表示数组的大小是3。</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>我们可以通过获取数组的地址来初始化数组指针：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span> (*array_ptr)[<span class="number">3</span>] = &amp;<span class="built_in">array</span>;</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用数组指针访问数组中的元素时，我们可以使用下标语法，就像我们在数组中做的那样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (*array_ptr)[<span class="number">0</span>]); <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure><p>在这里：</p><ul><li>**(*array_ptr)*：解引用数组指针以获取数组。</li><li>**[0]**：访问数组的第一个元素。</li></ul><p>注意，在定义数组指针时，我们使用了括号来确保*是数组指针名的一部分，而不是类型的一部分。这是因为数组和指针在C语言中有不同的优先级，所以我们需要使用括号来表明我们是在定义一个数组指针，而不是一个指针数组。</p><h2 id="2-指针数组"><a href="#2-指针数组" class="headerlink" title="2. 指针数组"></a>2. 指针数组</h2><p>“指针数组”是一个数组，它的每一个元素都是指针。这种结构可以用来存储多个指针，每个指针可以指向不同的数据或结构。以下是一个关于如何定义和使用指针数组的说明：</p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>你可以如下定义一个指针数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr_array[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><strong>int</strong> * 表示数组中的元素是指向整数的指针。</li><li><strong>ptr_array[3]</strong> 表示这是一个可以存储3个指针的数组。</li></ul><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>你可以通过将指针分配给数组中的各个元素来初始化指针数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> *ptr_array[<span class="number">3</span>] = &#123;&amp;a, &amp;b, &amp;c&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>你可以通过索引来访问指针数组中的各个指针，并通过解引用来访问它们所指向的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *ptr_array[<span class="number">0</span>]); <span class="comment">// 输出 1</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *ptr_array[<span class="number">1</span>]); <span class="comment">// 输出 2</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *ptr_array[<span class="number">2</span>]); <span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure><p>在上面的代码中：</p><ul><li><strong>ptr_array[0]<strong>、</strong>ptr_array[1]</strong> 和 <strong>ptr_array[2]</strong> 分别是数组中的三个指针。</li><li>使用 * 运算符（解引用运算符）来访问这些指针所指向的值。</li></ul><h2 id="二、指针访问二维数组"><a href="#二、指针访问二维数组" class="headerlink" title="二、指针访问二维数组"></a>二、指针访问二维数组</h2><p>访问二维数组有几种方法，你可以通过数组名称直接访问，也可以通过指针进行访问。下面我将介绍如何通过指针访问二维数组：</p><h3 id="方法1-指向数组的指针"><a href="#方法1-指向数组的指针" class="headerlink" title="方法1: 指向数组的指针"></a>方法1: 指向数组的指针</h3><p>当你有一个二维数组时，你可以创建一个指向数组的指针来指向这个二维数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*ptr)[<span class="number">3</span>] = arr; <span class="comment">// ptr是一个指向含有3个整数的数组的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过指针访问二维数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ptr[i][j]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="方法2-双重指针"><a href="#方法2-双重指针" class="headerlink" title="方法2: 双重指针."></a>方法2: 双重指针.</h3><p>你还可以使用双重指针来访问二维数组。但是这需要数组是动态分配的，或者是指针数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *arr[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">     arr[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">         arr[i][j] = i * <span class="number">3</span> + j + <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> **ptr = arr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过双重指针访问二维数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ptr[i][j]);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="方法3-一级指针与算术运算"><a href="#方法3-一级指针与算术运算" class="headerlink" title="方法3: 一级指针与算术运算"></a>方法3: 一级指针与算术运算</h3><p>你可以使用一个一级指针和指针算术来访问二维数组的元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">    &#123;<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *ptr = &amp;arr[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过指针和算术运算访问二维数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(ptr + i * <span class="number">3</span> + j));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>注意，你需要确切地知道二维数组的行和列大小，以便正确地计算索引。</p><h2 id="三、函数指针和指针函数"><a href="#三、函数指针和指针函数" class="headerlink" title="三、函数指针和指针函数"></a>三、函数指针和指针函数</h2><p>“指针函数”和“函数指针”也是两个常见的容易混淆的概念。让我们来详细解释它们的定义和区别：</p><h3 id="1-函数指针"><a href="#1-函数指针" class="headerlink" title="1. 函数指针"></a>1. 函数指针</h3><p>函数指针是一个指针变量，它指向一个函数。函数指针可以被用来调用指向的函数，也可以被用来作为参数传递给其他函数。函数指针的定义和使用如下：</p><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>return_type (*pointer_name)(parameter_list);</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">greeting</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Hello, World!\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">void</span> (*func_ptr)() = greeting; <span class="comment">// 定义一个函数指针并将其初始化为greeting函数的地址</span></span><br><span class="line">     func_ptr(); <span class="comment">// 调用通过函数指针指向的函数</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，func_ptr 是一个指向 greeting 函数的函数指针。</p><h3 id="2-指针函数（Pointer-Function）"><a href="#2-指针函数（Pointer-Function）" class="headerlink" title="2. 指针函数（Pointer Function）"></a>2. 指针函数（Pointer Function）</h3><p>“指针函数”是一个通常造成混淆的术语，实际上是指返回指针的函数。指针函数的定义和使用如下：</p><h4 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h4><p>return_type* function_name(parameter_list);</p><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">get_value</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">static</span> <span class="type">int</span> value = <span class="number">42</span>;</span><br><span class="line">     <span class="keyword">return</span> &amp;value;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> *val_ptr = get_value(); <span class="comment">// 调用返回指针的函数</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Value: %d\n&quot;</span>, *val_ptr); <span class="comment">// 解引用指针来获取值</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，get_value 是一个返回整数指针的函数，也就是所谓的“指针函数”。</p><h3 id="区别与联系："><a href="#区别与联系：" class="headerlink" title="区别与联系："></a>区别与联系：</h3><ol><li><strong>函数指针</strong>是一个变量，它存储了一个函数的地址，可以被用来间接调用这个函数。</li><li><strong>指针函数</strong>是一个函数，它返回一个指针。</li><li>两者的主要区别在于，一个是变量（指向函数的指针），而另一个是函数（返回指针）。</li><li>它们都涉及到指针的概念，但在实践中用于不同的目的和场景。</li></ol><p>希望这能帮到你！</p><h1 id="指针常量和常量指针"><a href="#指针常量和常量指针" class="headerlink" title="指针常量和常量指针"></a><strong>指针常量和常量指针</strong></h1><h2 id="常量指针"><a href="#常量指针" class="headerlink" title="常量指针"></a>常量指针</h2><h3 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h3><p> 又叫常指针，可以理解为常量的指针，也即这个是指针，但指向的是个常量，这个常量是指针的值（地址），而不是地址指向的值。</p><h3 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h3><p>1.常量指针指向的对象不能通过这个指针来修改，可是仍然可以通过原来的声明修改；</p><p>2.常量指针可以被赋值为变量的地址，之所以叫常量指针，是限制了通过这个指针修改变量的值；</p><p>3.指针还可以指向别处，因为指针本身只是个变量，可以指向任意地址；</p><h3 id="代码形式："><a href="#代码形式：" class="headerlink" title="代码形式："></a>代码形式：</h3><p>int const* p;  const int* p;</p><h2 id="指针常量"><a href="#指针常量" class="headerlink" title="指针常量"></a>指针常量</h2><h3 id="定义：-3"><a href="#定义：-3" class="headerlink" title="定义："></a>定义：</h3><p>本质是一个常量，而用指针修饰它。指针常量的值是指针，这个值因为是常量，所以不能被赋值。</p><h3 id="关键点：-1"><a href="#关键点：-1" class="headerlink" title="关键点："></a>关键点：</h3><p>1.它是个常量！</p><p>2.指针本身是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化；</p><h3 id="代码形式：-1"><a href="#代码形式：-1" class="headerlink" title="代码形式："></a>代码形式：</h3><p>int* const p;</p><p>指向常量的常指针</p><p>定义：指向常量的指针常量就是一个常量，且它指向的对象也是一个常量。</p><p>代码形式：</p><p>const int* const p;</p><p>那如何区分这几类呢? 带两个const的肯定是指向常量的常指针，很容易理解，主要是如何区分常量指针和指针常量:</p><p>一种方式是看 * 和 const 的排列顺序，比如</p><p>int const* p;    &#x2F;&#x2F;const * 即常量指针</p><p>const int* p;    &#x2F;&#x2F;const * 即常量指针</p><p>int* const p;    &#x2F;&#x2F;* const 即指针常量</p><p>还一种方式是看const离谁近，即从右往左看，比如</p><p>int const* p;    &#x2F;&#x2F;const修饰的是<em>p，即</em>p的内容不可通过p改变，但p不是const，p可以修改，*p不可修改；</p><p>const int* p;    &#x2F;&#x2F;同上</p><p>const int* const p;  &#x2F;&#x2F;*P 和p都不可修改</p><p>int* const p;    &#x2F;&#x2F;const修饰的是p，p是指针，p指向的地址不能修改，p不能修改，但*p可以修改；</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>&#x2F;&#x2F;——-常量指针——-</p><p>const int *p1 &#x3D; &a;</p><p>a &#x3D; 300;     &#x2F;&#x2F;OK,仍然可以通过原来的声明修改值，</p><p>&#x2F;&#x2F;*p1 &#x3D; 56;  &#x2F;&#x2F;Error,*p1是const int的，不可修改，即常量指针不可修改其指向地址</p><p>p1 &#x3D; &b;     &#x2F;&#x2F;OK,指针还可以指向别处，因为指针只是个变量，可以随意指向；</p><p>&#x2F;&#x2F;——-指针常量——-&#x2F;&#x2F;</p><p>int*  const p2 &#x3D; &a;</p><p>a &#x3D; 500;     &#x2F;&#x2F;OK,仍然可以通过原来的声明修改值，</p><p>*p2 &#x3D; 400;   &#x2F;&#x2F;OK,指针是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化</p><p>&#x2F;&#x2F;p2 &#x3D; &b;     &#x2F;&#x2F;Error,因为p2是const 指针，因此不能改变p2指向的内容</p><p>&#x2F;&#x2F;——-指向常量的常量指针——-&#x2F;&#x2F;</p><p>const int* const p3 &#x3D; &a;</p><p>&#x2F;&#x2F;*p3 &#x3D; 1;    &#x2F;&#x2F;Error</p><p>&#x2F;&#x2F;p3 &#x3D; &b;    &#x2F;&#x2F;Error</p><p>a &#x3D; 5000;    &#x2F;&#x2F;OK,仍然可以通过原来的声明修改值</p><p>在实际应用中，常量指针要比指针常量用的多，比如常量指针经常用在函数传参中，以避免函数内部修改内容。</p><p>size_t strlen(const char* src); &#x2F;&#x2F;常量指针，src的值不可改变；</p><p>char a[] &#x3D; “hello”;</p><p>char b[] &#x3D; “world”;</p><p>size_t a1 &#x3D; strlen(a);</p><p>size_t b1 &#x3D; strlen(b);</p><p>虽然a、b是可以修改的，但是可以保证在strlen函数内部不会修改a、b的内容。</p><p>1.一个指针常量，指向的是一个指针对象；</p><p>2.它指向的指针对象且是一个常量，即它指向的对象不能变化；</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/05/30/test/%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/"/>
      <url>/2025/05/30/test/%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="系统移植"><a href="#系统移植" class="headerlink" title="系统移植"></a><strong>系统移植</strong></h1><h4 id="（一）应用层开发和嵌入式底层开发的区别"><a href="#（一）应用层开发和嵌入式底层开发的区别" class="headerlink" title="（一）应用层开发和嵌入式底层开发的区别"></a>（一）应用层开发和嵌入式底层开发的区别</h4><h5 id="1》嵌入式是什么？"><a href="#1》嵌入式是什么？" class="headerlink" title="1》嵌入式是什么？"></a>1》嵌入式是什么？</h5><p>官方：嵌入式是以应用为中心，以计算机技术为基础，软硬件可剪裁的计算机系统。</p><p>嵌入式系统的特点：成本，体积，可靠性，功耗都有严格要求。</p><p>解读：</p><p>1，计算机系统</p><p>2，针对某个应用的，也就是通常所说的“专用的”</p><p>说白了，就是针对某个应用的计算机系统</p><h5 id="2》应用层开发和嵌入式底层开发的区别"><a href="#2》应用层开发和嵌入式底层开发的区别" class="headerlink" title="2》应用层开发和嵌入式底层开发的区别"></a>2》应用层开发和嵌入式底层开发的区别</h5><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">编程思路：</span><br><span class="line">编译:gcc运行</span><br><span class="line">hello.c  ----------------&gt;  hello(可执行文件) -----------&gt; ./hello </span><br><span class="line">  || x86</span><br><span class="line"> C库:比如：printf   链接C库</span><br></pre></td></tr></table></figure><p>inux内核开发——驱动</p><figure class="highlight plaintext"><figcaption><span>Text</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">编程思路： </span><br><span class="line">         (交叉编译器---可以把程序编程成指定平台的程序  ------&gt; ./hello ARM)</span><br><span class="line">编译：交叉编译器  加载</span><br><span class="line">hello_drv.c ------------------------&gt;hello_drv.ko  --------------&gt; insmod  hello_drv.ko </span><br><span class="line">|| |</span><br><span class="line">linux内核源码和内核源码一起编译内核模块将驱动加载到系统(开发板)中</span><br></pre></td></tr></table></figure><h4 id="（二）开发板介绍"><a href="#（二）开发板介绍" class="headerlink" title="（二）开发板介绍"></a>（二）开发板介绍</h4><p>​STM32MP157A 是基于 Cortex-A7 32bit RISC核心加 Cortex-M4 32bit RISC 核心的高性能双核心处理器，最高工作频率为 800MHz。Cortex-A7 处理器为每个 CPU 内置一个 32 kbyte L1 指令缓存，一个 32 kbyte L1 数据缓存为每个 CPU 内置一个 256 kbyte 2 级缓存。同时 Cortex-A7 处理器是一个低功耗的应用处理器，旨在为高端可穿戴设备以及其他低功耗嵌入式和消费应用提供丰富的性能。它提供了比 Cortex-A5 多20%的单线程性能。</p><h4 id="（三）linux系统的芯片的启动模式"><a href="#（三）linux系统的芯片的启动模式" class="headerlink" title="（三）linux系统的芯片的启动模式"></a>（三）linux系统的芯片的启动模式</h4><h5 id="1》单片机是怎么启动的？"><a href="#1》单片机是怎么启动的？" class="headerlink" title="1》单片机是怎么启动的？"></a>1》单片机是怎么启动的？</h5><p>STM32单片机，通常在MDK，IAR，集成IDE上编写程序，可以直接烧写到硬件单片机上内部flash中，使用起来是非常方便且简单的。因为一般单片机的程序不会超过2MB，单片机的内部flash也不会超过8MB。</p><h5 id="2》linux系统的芯片的启动模式"><a href="#2》linux系统的芯片的启动模式" class="headerlink" title="2》linux系统的芯片的启动模式"></a>2》linux系统的芯片的启动模式</h5><p>​1）Linux系统很大，Linux系统镜像一般情况下都能达到几十，上百M。如果功能很强大，很可能就上GB了。因此Linux芯片，需要借助外部flash存放它是的镜像。</p><p>​2）能够存放镜像的外部flash：SD卡，EMMC，Nand flash，NOR flash ，SPI flash 等。所以当我们将Linux系统做好以后，要将它烧写到这些外部flash中去。</p><p>​3）不同的半导体厂商会提供相应的烧写工具</p><p>​4）一款芯片有可能会同时支持多种flash启动</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/05/29/test/liunx%E9%A9%B1%E5%8A%A8/Linux%E9%A9%B1%E5%8A%A8/"/>
      <url>/2025/05/29/test/liunx%E9%A9%B1%E5%8A%A8/Linux%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux驱动"><a href="#Linux驱动" class="headerlink" title="Linux驱动"></a><strong>Linux驱动</strong></h1><p>内容</p><p>​1、内核模块框架</p><p>​2、一个完完整驱动的组成</p><p>​3、led设备驱动</p><p>准备工作：</p><p>1、将linux源码拷贝一份到Windows下</p><p>2、在Windows下的linux源码目录下新建一个 source insight 文件夹</p><p>3、打开source insight 软件，新建一个工程，工程保存到刚新建的source insight 文件夹下</p><p>4、将Linux源码导入到source insight的工程中，并同步<br>    同步方法如下：<br>    在右边project文件栏下按鼠标右键-》点击Synchronize files-》勾选force all files to be re-parsed-》点击start</p><h1 id="一）内核模块框架"><a href="#一）内核模块框架" class="headerlink" title="一）内核模块框架"></a>一）内核模块框架</h1><h3 id="1》内核模块组成"><a href="#1》内核模块组成" class="headerlink" title="1》内核模块组成"></a>1》内核模块组成</h3><p>​1、在fs_mp157a&#x2F;driver&#x2F;2308&#x2F;1day&#x2F;新建一个drv_hello.c 文件<br>​2、头文件<br>​#include &lt;linux&#x2F;init.h&gt;<br>​#include &lt;linux&#x2F;module.h&gt;<br>​3、加载函数——模块加载后运行的第一个函数<br>​static int __init drv_hello_init(void)&#x2F;&#x2F;加载函数<br>​{<br>​int ret&#x3D;0;<br>​printk(“—%s—\r\n”,<strong>FUNCTION</strong>);<br>​return ret;<br>​}<br>​4、卸载函数——模块卸载时，会调用这个函数<br>​static void __exit drv_hello_exit(void)&#x2F;&#x2F;卸载函数<br>​{<br>​printk(“—%s—\r\n”,<strong>FUNCTION</strong>);<br>​}<br>​5、函数声明和认证<br>​module_init(drv_hello_init);<br>​module_exit(drv_hello_exit);<br>​MODULE_LICENSE(“GPL”);</p><h3 id="2》编写Makefile文件"><a href="#2》编写Makefile文件" class="headerlink" title="2》编写Makefile文件"></a>2》编写Makefile文件</h3><p>​&#x2F;&#x2F;指定内核源码路径</p><p>​KERNEL_DIR &#x3D; &#x2F;home&#x2F;linux&#x2F;fs_mp157a&#x2F;kernel&#x2F;stm32mp1-openstlinux-5.4-dunfell-mp1-20-06-24&#x2F;sources&#x2F;arm-ostl-linux-gnueabi&#x2F;linux-stm32mp-5.4.31-r0&#x2F;linux-5.4.31</p><p>​CUR_DIR &#x3D; ${shell pwd}</p><p>​all:</p><p>​&#x2F;&#x2F;将当前目录下的源码和内核源码一起编译，编译成.ko文件</p><p>​make -C $(KERNEL_DIR) M&#x3D;$(CUR_DIR) modules</p><p>​clean:</p><p>​&#x2F;&#x2F;清除将上面编译生成的文件</p><p>​make -C $(KERNEL_DIR) M&#x3D;$(CUR_DIR) clean</p><p>​install:</p><p>​&#x2F;&#x2F;将当前目录下的所有.ko文件拷贝到根文件系统中</p><p>​sudo cp *.ko &#x2F;opt&#x2F;rootfs&#x2F;drivers</p><p>​&#x2F;&#x2F;指定要编译的源文件</p><p>​obj-m &#x3D; drv_hello.o</p><h3 id="3》编译make"><a href="#3》编译make" class="headerlink" title="3》编译make"></a>3》编译make</h3><p>​make -C &#x2F;home&#x2F;linux&#x2F;fs_mp157a&#x2F;kernel&#x2F;stm32mp1-openstlinux-5.4-dunfell-mp1-20-06-24&#x2F;sources&#x2F;arm-ostl-linux-gnueabi&#x2F;linux-stm32mp-5.4.31-r0&#x2F;linux-5.4.31 M&#x3D;&#x2F;home&#x2F;linux&#x2F;fs_mp157a&#x2F;drivers&#x2F;2308&#x2F;1day modules</p><p>​make[1]: Entering directory ‘&#x2F;home&#x2F;linux&#x2F;fs_mp157a&#x2F;kernel&#x2F;stm32mp1-openstlinux-5.4-dunfell-mp1-20-06-24&#x2F;sources&#x2F;arm-ostl-linux-gnueabi&#x2F;linux-stm32mp-5.4.31-r0&#x2F;linux-5.4.31’</p><p>​  CC [M]  &#x2F;home&#x2F;linux&#x2F;fs_mp157a&#x2F;drivers&#x2F;2308&#x2F;1day&#x2F;drv_hello.o</p><p>​  Building modules, stage 2.</p><p>​  MODPOST 1 modules</p><p>​  CC [M]  &#x2F;home&#x2F;linux&#x2F;fs_mp157a&#x2F;drivers&#x2F;2308&#x2F;1day&#x2F;drv_hello.mod.o</p><p>​  LD [M]  &#x2F;home&#x2F;linux&#x2F;fs_mp157a&#x2F;drivers&#x2F;2308&#x2F;1day&#x2F;drv_hello.ko</p><p>​make[1]: Leaving directory ‘&#x2F;home&#x2F;linux&#x2F;fs_mp157a&#x2F;kernel&#x2F;stm32mp1-openstlinux-5.4-dunfell-mp1-20-06-24&#x2F;sources&#x2F;arm-ostl-linux-gnueabi&#x2F;linux-stm32mp-5.4.31-r0&#x2F;linux-5.4.31’</p><h3 id="4》加载内核模块"><a href="#4》加载内核模块" class="headerlink" title="4》加载内核模块"></a>4》加载内核模块</h3><p>​1、在&#x2F;opt&#x2F;rootfs&#x2F;下新建一个drivers文件夹</p><p>​2、执行 make install 将.ko文件拷贝到根文件系统中</p><p>​3、打开开发板，加载内核模块  (insmod 加载函数，rmmod 卸载函数，lsmod 查看)</p><p>​[root@fsmp1a ]# cd drivers&#x2F; &#x2F;&#x2F;进入模块文件夹</p><p>​[root@fsmp1a drivers]# ls&#x2F;&#x2F;查看文件夹内容</p><p>​drv_hello.ko</p><p>​[root@fsmp1a drivers]# insmod drv_hello.ko&#x2F;&#x2F;加载内核模块</p><p>​[ 8213.458054] —drv_hello_init—</p><p>​[root@fsmp1a drivers]# lsmod&#x2F;&#x2F;查看系统中加载的模块</p><p>​drv_hello 16384 0 - Live 0xbf000000 (OE)</p><p>​[root@fsmp1a drivers]# rmmod drv_hello.ko&#x2F;&#x2F;卸载已经加载的模块</p><p>​[ 8338.518719] —drv_hello_exit—</p><h1 id="二-一个完整驱动的组成"><a href="#二-一个完整驱动的组成" class="headerlink" title="(二)一个完整驱动的组成"></a>(二)一个完整驱动的组成</h1><h3 id="1》设备号"><a href="#1》设备号" class="headerlink" title="1》设备号"></a>1》设备号</h3><h4 id="1、设备号的概念"><a href="#1、设备号的概念" class="headerlink" title="1、设备号的概念"></a>1、设备号的概念</h4><p>​是用一个32位的正数表示，分成两部分： 主设备号和次设备号</p><p>​主设备号：用32位正数的高12位表示，表示一类设备(一类设备)</p><p>​次设备号：用32位正数的低20位表示，表示具体的设备编号（具体的某一个）</p><h4 id="2、申请设备号："><a href="#2、申请设备号：" class="headerlink" title="2、申请设备号："></a>2、申请设备号：</h4><p>​static inline int register_chrdev(unsigned int major, const char *name,const struct file_operations *fops)</p><p>​&#x2F;&#x2F;参数1申请设备号的方式：major&#x3D;0，表示动态申请主设备号</p><p>​      major&gt;0,表示静态指定一个主设备号</p><p>​&#x2F;&#x2F;参数2字符串，表示描述信息，自定义</p><p>​&#x2F;&#x2F;参数3struct file_operations结构体指针</p><p>​&#x2F;&#x2F;返回指如果参数1为0，成功返回主设备号，失败返回错误码</p><p>​如果参数1不为0，成功返回0，失败返回错误码</p><p>static inline void unregister_chrdev(unsigned int major, const char *name) &#x2F;&#x2F; 释放设备号.</p><h4 id="3、编译，在开发板中加载驱动，并查看主设备号"><a href="#3、编译，在开发板中加载驱动，并查看主设备号" class="headerlink" title="3、编译，在开发板中加载驱动，并查看主设备号"></a>3、编译，在开发板中加载驱动，并查看主设备号</h4><p>​[root@fsmp1a drivers]# insmod drv_hello.ko</p><p>​[ 1985.156434] —drv_hello_init—</p><p>​[root@fsmp1a drivers]# cat &#x2F;proc&#x2F;devices</p><p>​Character devices:</p><p>​  1 mem</p><p>​  2 pty</p><p>​  3 ttyp</p><p>​  4 &#x2F;dev&#x2F;vc&#x2F;0</p><p>​  4 tty</p><p>​  5 &#x2F;dev&#x2F;tty</p><p>​  5 &#x2F;dev&#x2F;console</p><p>​  5 &#x2F;dev&#x2F;ptmx</p><p>​  5 ttyRPMSG</p><p>​  7 vcs</p><p>​ 10 misc</p><p>​ 13 input</p><p>​ 21 sg</p><p>​ 29 fb</p><p>​ 89 i2c</p><p>​ 90 mtd</p><p>​100 drv_hello  &#x2F;&#x2F;加载驱动申请的主设号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span><span class="comment">//头文件固定的两个</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">drv_hello_open</span>  <span class="params">(<span class="keyword">struct</span> inode * node, <span class="keyword">struct</span> file * fp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">printk(<span class="string">&quot;---%s---&quot;</span>,__FUNCTION__);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">drv_hello_release</span> <span class="params">(<span class="keyword">struct</span> inode * node, <span class="keyword">struct</span> file * fp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;L</span><br><span class="line"><span class="title function_">printk</span><span class="params">(<span class="string">&quot;---%s---&quot;</span>,__FUNCTION__)</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fopt</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">.open = drv_hello_open,</span><br><span class="line">.release = drv_hello_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//加载函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">drv_hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">printk(<span class="string">&quot;---%s---&quot;</span>, __FUNCTION__);</span><br><span class="line"><span class="comment">//申请设备号</span></span><br><span class="line">ret = register_chrdev(<span class="number">111</span>, <span class="string">&quot;hello&quot;</span>, &amp;fopt);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果没有</span></span><br><span class="line">printk(<span class="string">&quot;register_chrdev erro&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">drv_hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">printk(<span class="string">&quot;---%s---&quot;</span>, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数声明和认证</span></span><br><span class="line">module_init(drv_hello_init);</span><br><span class="line">module_exit(drv_hello_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);<span class="comment">//必须要加，表示开源的意思s</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/05/29/test/c%E5%92%8Cc++/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/2025/05/29/test/c%E5%92%8Cc++/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<p>编码规范</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试知识</title>
      <link href="/2025/05/05/test/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/"/>
      <url>/2025/05/05/test/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="C-C-题目"><a href="#C-C-题目" class="headerlink" title="C&#x2F;C++ 题目"></a>C&#x2F;C++ 题目</h1><p>一个保险柜，密码是由 <code>NOMONEY</code> 组成的 7 位数字。每个字母对应的数字隐藏在下面的 10 进制加法算式中，相同的字母对应相同的数字，不同的字母对应不同的数字，数字范围 0-9，并且已知密码中没有 4。请解码密码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">G I V E</span><br><span class="line">+ M O R E</span><br><span class="line"></span><br><span class="line">  M O N E Y</span><br></pre></td></tr></table></figure><ul><li><p><strong>M &#x3D; 1</strong>（因两四位数相加得五位数，最高位必为1）</p></li><li><p><strong>G &#x3D; 9</strong>（9 + 1 &#x3D; 10，产生进位，满足五位数）</p></li><li><p><strong>O &#x3D; 0</strong>（千位相加：9 + 1 + 0 &#x3D; 10，进位后万位为1）</p></li><li><p><strong>E &#x3D; 8</strong>（个位：6 + 6 &#x3D; 12 → Y &#x3D; 2，进位1）</p></li><li><p><strong>Y &#x3D; 6</strong>（由E &#x3D; 8推导）</p></li><li><p><strong>V &#x3D; 5，R &#x3D; 2</strong>（十位：7 + 5 + 进位1 &#x3D; 13 → 进位1，E &#x3D; 6）  </p></li><li><p><strong>I &#x3D; 3</strong>（百位：8 + 进位1 &#x3D; 9 → N &#x3D; 9，但需调整后最终得出N &#x3D; 2）</p></li><li><p><strong>N &#x3D; 7</strong>（实际验证后调整）</p><p>答案不对 题目错了</p></li></ul><h4 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h4><p><strong>题目描述：</strong> 请用 C 语言写一个函数，实现如下功能：输入年、月、日，返回这一天是这一年的第几天？请注意算法的效率（空间时间）。</p><p><strong>答案：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dayOfYear</span><span class="params">(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">    <span class="type">int</span> daysInMonth[] = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; <span class="number">2</span> &amp;&amp; (y % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">100</span> != <span class="number">0</span> || y % <span class="number">400</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">        daysInMonth[<span class="number">1</span>] = <span class="number">29</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> day = d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        day += daysInMonth[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h4><p><strong>题目描述：</strong> 什么样的代码是优美的？哪些好的习惯有助于提高代码质量？</p><p><strong>答案：</strong> 优美的代码通常具有以下特点：</p><ol><li><strong>可读性</strong>：代码结构清晰，命名规范，注释充分。</li><li><strong>简洁性</strong>：代码简洁，避免冗余，使用合适的数据结构和算法。</li><li><strong>可维护性</strong>：模块化设计，易于理解和修改。</li><li><strong>健壮性</strong>：代码能够处理异常情况，进行错误检查和处理。</li></ol><p>提高代码质量的好习惯包括：</p><ol><li><strong>代码审查</strong>：定期进行代码审查，发现并修复潜在问题。</li><li><strong>单元测试</strong>：编写单元测试，确保代码的正确性和稳定性。</li><li><strong>持续重构</strong>：定期重构代码，保持代码的简洁和可维护性。</li><li><strong>遵循编码规范</strong>：遵循团队或项目的编码规范，保持代码风格的一致性。</li></ol><h4 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h4><p><strong>题目描述：</strong> C 和 C++ 有哪些主要区别？</p><p><strong>答案：</strong> C 和 C++ 的主要区别包括：</p><ol><li><strong>面向过程 vs 面向对象</strong>：C 是面向过程的语言，而 C++ 支持面向对象编程。</li><li><strong>类和对象</strong>：C++ 支持类和对象，可以进行封装、继承和多态。</li><li><strong>标准模板库（STL）</strong>：C++ 提供了标准模板库，支持容器、算法和迭代器。</li><li><strong>异常处理</strong>：C++ 支持异常处理机制，而 C 使用错误码。</li><li><strong>命名空间</strong>：C++ 支持命名空间，避免命名冲突。</li><li><strong>构造函数和析构函数</strong>：C++ 支持构造函数和析构函数，进行资源管理。</li></ol><h4 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h4><p><strong>题目描述：</strong> 请从下面三个问题任选一个（15 分） a) 请描述 C++ 中各种智能指针（shared_ptr、auto_ptr、unique_ptr、weak_ptr）的适用场景及注意事项。 b) 请简述一下 Linux 中几种多路复用机制（select&#x2F;poll&#x2F;epoll）的优缺点对比。</p><p><strong>答案：</strong> a) C++ 中各种智能指针的适用场景及注意事项：</p><ul><li><strong>shared_ptr</strong>：适用于多个指针需要共享所有权的场景。注意事项：循环引用可能导致内存泄漏。</li><li><strong>auto_ptr</strong>：已在 C++11 中被弃用，不推荐使用。</li><li><strong>unique_ptr</strong>：适用于独占所有权的场景。注意事项：不能被复制，只能被移动。</li><li><strong>weak_ptr</strong>：用于解决 shared_ptr 的循环引用问题。注意事项：需要与 shared_ptr 配合使用。</li></ul><p>b) Linux 中几种多路复用机制的优缺点对比：</p><ul><li><strong>select</strong>：优点：简单易用。缺点：文件描述符数量有限，性能较差。</li><li><strong>poll</strong>：优点：没有文件描述符数量限制。缺点：性能仍然较差，尤其是在大量文件描述符的情况下。</li><li><strong>epoll</strong>：优点：性能优异，支持大量文件描述符。缺点：实现复杂，需要内核支持。</li></ul><h4 id="题目5"><a href="#题目5" class="headerlink" title="题目5"></a>题目5</h4><p><strong>题目描述：</strong> 翻译：When developing embedded software, you must consider the following:</p><ul><li>Understand the default compilation tool behavior and the target environment so that you appreciate the steps necessary to move from a debug or development build to a fully standalone production version of the application.</li><li>Some C library functionality executes by using debug environment resources. If used, you must implement this functionality to make use of target hardware.</li><li>The toolchain has no inherent knowledge of the memory map of any given target. You must tailor the image this functionality has no inherent knowledge of the memory map of the target hardware.</li><li>An embedded application must perform some initialization, such as stack and heap initialization, before the application can be run. A complete initialization sequence requires code that you implement in addition to the Arm Compiler C library initialization routines.</li></ul><p><strong>答案：</strong> 在开发嵌入式软件时，必须考虑以下几点：</p><ul><li>了解默认编译工具的行为和目标环境，以便理解从调试或开发版本迁移到完全独立的生产版本应用程序所需的步骤。</li><li>一些 C 库功能通过使用调试环境资源来执行。如果使用这些功能，您必须实现这些功能以利用目标硬件。</li><li>工具链对任何给定目标的内存映射没有固有的知识。您必须调整该功能对目标硬件内存映射的了解。</li><li>嵌入式应用程序必须执行一些初始化，例如堆栈和堆初始化，然后才能运行应用程序。完整的初始化序列需要您实现的代码，以补充 Arm 编译器 C 库初始化例程。</li></ul><h4 id="题目6"><a href="#题目6" class="headerlink" title="题目6"></a>题目6</h4><p><strong>题目描述：</strong> 找出下面代码中所有的错误以及不合理的地方，并请说明原因。（20 分）</p><ol><li><p>找出下面代码中所有的错误以及不合理的地方，并请说明原因。（20 分）</p><p>c</p><p>复制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    A() &#123; m_jCount = <span class="number">0</span>; &#125;</span><br><span class="line">    ~A() &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> m_jCount;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    B() : A() &#123; m_jCount = <span class="number">1</span>; &#125;</span><br><span class="line">    ~B()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    A* a = new B();</span><br><span class="line">    FILE* f;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">        n = argv[<span class="number">0</span>];</span><br><span class="line">    <span class="type">char</span>* stuff = new <span class="type">char</span>[n];</span><br><span class="line">    f = fopen(<span class="string">&quot;c:\\abc\\aa.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fread(f, n, stuff);</span><br><span class="line">    n = <span class="built_in">strlen</span>(stuff);</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(stuff, <span class="number">0</span>, <span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line">    fwrite(f, <span class="number">1</span>, n, stuff);</span><br><span class="line">    delete stuff;</span><br><span class="line">    delete a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stuff;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>答案：</strong> 代码中的错误和不合理之处包括：</p><ol><li><code>A* a = new B();</code>：<code>new B()</code> 应该使用 <code>new B</code>，而不是 <code>new B()</code>。</li><li><code>int m;</code>：变量 <code>m</code> 未初始化，可能导致未定义行为。</li><li><code>if (argc &gt; 1)</code>：如果 <code>argc</code> 小于等于 1，程序会直接返回 -1，没有进行任何处理。</li><li><code>char* stuff = new char[n];</code>：<code>new char[n]</code> 应该使用 <code>new char[n+1]</code>，并在最后添加一个空字符 <code>\0</code>。</li><li><code>memset(stuff, 0, 20, 10);</code>：<code>memset</code> 的第三个参数应该是要设置的字节数，而不是重复次数。</li><li><code>delete stuff;</code>：<code>delete</code> 应该使用 <code>delete[] stuff;</code>，因为 <code>stuff</code> 是一个数组。</li><li><code>cout &lt;&lt; stuff;</code>：<code>stuff</code> 可能包含未初始化的内存，直接输出可能导致未定义行为。</li></ol><p>这些错误和不合理之处需要修正以确保程序的正确性和稳定性。</p><h1 id="Uboot-引导嵌入式Linux操作系统启动的大概顺序是？"><a href="#Uboot-引导嵌入式Linux操作系统启动的大概顺序是？" class="headerlink" title="Uboot 引导嵌入式Linux操作系统启动的大概顺序是？"></a>Uboot 引导嵌入式Linux操作系统启动的大概顺序是？</h1><p>第一阶段：ROM code（芯片厂商内置的代码）初始化一些基本的时钟，从选定的设备中去加载FSBL的代码，并启动FSBL代码</p><p>第二阶段：FSBL first stage boot loader 完成时钟的初始化，初始化DDR，从选定的设备中去加载SSBL的代码，并启动SSBL代码</p><p>第三阶段：从外部储存或者网络中加载linux系统，通过启动动画向用户反馈启动过程，启动linux内核</p><p>第四阶段：linux内核初始化，挂载根文件系统，启动用户空间的init程序</p><p>最后进入到linux用户空间</p><h3 id="第一阶段：ROM-Code（芯片厂商内置的代码）"><a href="#第一阶段：ROM-Code（芯片厂商内置的代码）" class="headerlink" title="第一阶段：ROM Code（芯片厂商内置的代码）"></a>第一阶段：ROM Code（芯片厂商内置的代码）</h3><ul><li><strong>比喻</strong>：就像你刚睁开眼睛，身体还在床上，但你已经开始动脑子思考下一步要做什么。</li><li><strong>实际操作</strong>：计算机刚开机时，芯片里有一些预先写好的代码（ROM Code），这些代码会做一些最基本的事情，比如检查硬件是否正常，设置一些基本的时钟（就像你调整闹钟一样），然后从某个地方（比如硬盘或者USB）找到一个叫做FSBL（First Stage Boot Loader）的程序，并把它加载到内存里，然后开始运行这个程序。</li></ul><h3 id="第二阶段：FSBL（First-Stage-Boot-Loader）"><a href="#第二阶段：FSBL（First-Stage-Boot-Loader）" class="headerlink" title="第二阶段：FSBL（First Stage Boot Loader）"></a>第二阶段：FSBL（First Stage Boot Loader）</h3><ul><li><strong>比喻</strong>：你从床上爬起来，开始穿衣服，准备出门。</li><li><strong>实际操作</strong>：FSBL程序接手后，会做一些更具体的事情，比如初始化DDR（一种内存，就像你整理书包一样），设置更精确的时钟（就像你调整手表时间），然后从某个地方找到SSBL（Second Stage Boot Loader）的代码，加载到内存里，并开始运行SSBL。</li></ul><h3 id="第三阶段：加载Linux系统"><a href="#第三阶段：加载Linux系统" class="headerlink" title="第三阶段：加载Linux系统"></a>第三阶段：加载Linux系统</h3><ul><li><strong>比喻</strong>：你出门去学校，路上可能会看看风景，听听音乐，这些都是你在路上的“启动动画”。</li><li><strong>实际操作</strong>：SSBL程序会从外部存储设备（比如硬盘）或者网络中找到Linux系统的代码，加载到内存里。在这个过程中，可能会有一些启动动画显示给用户，让用户知道计算机正在启动，就像你在路上看到的风景一样。最后，Linux内核（计算机的大脑）开始运行。</li></ul><h3 id="第四阶段：Linux内核初始化"><a href="#第四阶段：Linux内核初始化" class="headerlink" title="第四阶段：Linux内核初始化"></a>第四阶段：Linux内核初始化</h3><ul><li><strong>比喻</strong>：你到了学校，开始上课，老师开始讲解课程内容。</li><li><strong>实际操作</strong>：Linux内核开始运行后，会初始化各种系统功能，比如挂载根文件系统（就像老师准备好教材一样），然后启动用户空间的init程序（就像老师开始讲解课程内容）。这个init程序就像是计算机的“老师”，它会启动其他各种程序和服务，让计算机能够正常工作。</li></ul><h3 id="最后：进入Linux用户空间"><a href="#最后：进入Linux用户空间" class="headerlink" title="最后：进入Linux用户空间"></a>最后：进入Linux用户空间</h3><ul><li><strong>比喻</strong>：你开始认真听讲，参与课堂活动。</li><li><strong>实际操作</strong>：当init程序启动完成后，计算机就进入了用户空间，这意味着用户可以开始使用计算机了，就像你开始参与课堂活动一样。用户可以打开各种应用程序，进行各种操作。</li></ul><h1 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h1><p>1、栈区是系统自动申请自动释放，且空间较小</p><p>2、堆区是需要手动申请，手动释放，空间较大</p><p>3、栈区常用来存放局部变量等</p><p>4、堆区常用来存放全局变量等</p><p>5、栈的空间是连续的，而堆不是</p><h3 id="1-栈区（Stack）"><a href="#1-栈区（Stack）" class="headerlink" title="1. 栈区（Stack）"></a>1. 栈区（Stack）</h3><ul><li><strong>比喻</strong>：想象你有一个书桌，书桌上有一个固定的区域用来放书本和文具。每次你写作业的时候，就会在这个区域放一些书本、笔记本和铅笔。写完作业后，你就会把这些东西收起来，这个区域又变得干净了。</li><li><strong>实际操作</strong>：<ul><li><strong>自动申请和释放</strong>：栈区是由系统自动管理的。当你在函数中定义局部变量（比如<code>int a = 5;</code>）时，系统会自动在栈区分配一小块空间来存储这个变量。当函数执行完毕后，系统会自动清理这块空间。</li><li><strong>空间较小</strong>：栈区的空间相对较小，通常只有几MB。</li></ul></li></ul><h3 id="2-堆区（Heap）"><a href="#2-堆区（Heap）" class="headerlink" title="2. 堆区（Heap）"></a>2. 堆区（Heap）</h3><ul><li><strong>比喻</strong>：想象你有一个大仓库，这个仓库可以用来放各种各样的东西，比如家具、玩具、书籍等。你需要的时候可以随时往里面放东西，用完之后也可以随时拿出来。</li><li><strong>实际操作</strong>：<ul><li><strong>手动申请和释放</strong>：堆区是由程序员手动管理的。当你需要一个较大的空间来存储数据（比如一个大的数组或者一个复杂的数据结构）时，你需要手动申请这块空间（比如用<code>malloc</code>函数）。用完之后，也需要手动释放这块空间（比如用<code>free</code>函数）。</li><li><strong>空间较大</strong>：堆区的空间相对较大，通常可以达到几百MB甚至更多。</li><li><strong>用途</strong>：堆区常用来存放动态分配的变量，比如全局变量、动态数组等。</li></ul></li></ul><h3 id="3-栈区常用来存放局部变量"><a href="#3-栈区常用来存放局部变量" class="headerlink" title="3. 栈区常用来存放局部变量"></a>3. 栈区常用来存放局部变量</h3><ul><li><strong>比喻</strong>：你在书桌上写作业，每次写作业都会用到一些书本和文具，这些就是局部变量。写完作业后，这些书本和文具就被收起来了。</li><li><strong>实际操作</strong>：在函数中定义的变量（局部变量）通常存放在栈区。这些变量在函数执行期间有效，函数执行完毕后，这些变量就会被自动清理。</li></ul><h3 id="4-堆区常用来存放全局变量等"><a href="#4-堆区常用来存放全局变量等" class="headerlink" title="4. 堆区常用来存放全局变量等"></a>4. 堆区常用来存放全局变量等</h3><ul><li><strong>比喻</strong>：你在仓库里放了一些家具和玩具，这些是你长期需要的东西，不会轻易拿出来。这些就是全局变量。</li><li><strong>实际操作</strong>：全局变量和动态分配的变量（比如用<code>malloc</code>分配的内存）通常存放在堆区。这些变量在程序的整个运行过程中都有效，直到你手动释放它们。</li></ul><h3 id="5-栈的空间是连续的，而堆不是"><a href="#5-栈的空间是连续的，而堆不是" class="headerlink" title="5. 栈的空间是连续的，而堆不是"></a>5. 栈的空间是连续的，而堆不是</h3><ul><li><strong>比喻</strong>：你的书桌是一个固定的区域，所有的东西都放在一起，空间是连续的。而仓库里的东西可以放在不同的地方，空间是不连续的。</li><li><strong>实际操作</strong>：<ul><li><strong>栈区</strong>：栈区的空间是连续的，系统会自动管理这块空间，确保每次分配和释放都是连续的。</li><li><strong>堆区</strong>：堆区的空间是不连续的，因为堆区是由程序员手动管理的，每次申请和释放的空间可能在不同的位置。</li></ul></li></ul><h1 id="什么是野指针，产后的原因是什么"><a href="#什么是野指针，产后的原因是什么" class="headerlink" title="什么是野指针，产后的原因是什么"></a>什么是野指针，产后的原因是什么</h1><p>1、野指针是指向位置是随机的且不正确的</p><p>2、产生原因  定义时未初始化，指向位置随机</p><p>或者在释放时没有指向null，从而指向垃圾内存</p><h3 id="1-什么是野指针？"><a href="#1-什么是野指针？" class="headerlink" title="1. 什么是野指针？"></a>1. 什么是野指针？</h3><p><strong>比喻</strong>：想象你手里拿着一张地图，但地图上的地址是乱写的，或者地图根本就没有地址，你按照这个地图去寻找某个地方，很可能就会迷失方向，甚至走到一个完全错误的地方。</p><p><strong>实际操作</strong>：</p><ul><li><strong>野指针</strong>：在编程中，指针是一个变量，它用来存储另一个变量的内存地址。如果一个指针指向了一个随机的、不正确的内存地址，或者指向了一个已经被释放的内存地址，这个指针就被称为“野指针”。</li><li><strong>野指针的危害</strong>：野指针可能会导致程序访问到错误的内存区域，从而引发程序崩溃、数据损坏等不可预测的问题。</li></ul><h3 id="2-产生原因"><a href="#2-产生原因" class="headerlink" title="2. 产生原因"></a>2. 产生原因</h3><h4 id="1-定义时未初始化"><a href="#1-定义时未初始化" class="headerlink" title="1. 定义时未初始化"></a>1. 定义时未初始化</h4><p><strong>比喻</strong>：你手里拿着一张地图，但地图上没有写地址，你不知道它指向哪里，所以你可能会走到一个完全错误的地方。</p><p><strong>实际操作</strong>：</p><ul><li><p>当你定义了一个指针变量，但没有给它一个具体的地址时，这个指针变量的值是随机的。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr; <span class="comment">// 没有初始化，ptr的值是随机的</span></span><br></pre></td></tr></table></figure></li><li><p>这个随机的值可能指向一个完全错误的内存地址，这就是野指针。</p></li></ul><h4 id="2-释放后未指向NULL"><a href="#2-释放后未指向NULL" class="headerlink" title="2. 释放后未指向NULL"></a>2. 释放后未指向NULL</h4><p><strong>比喻</strong>：你手里拿着一张地图，地图上写了一个地址，但这个地址的房子已经被拆掉了。你按照这个地图去寻找，可能会走到一个空地，或者一个完全不同的地方。</p><p><strong>实际操作</strong>：</p><ul><li><p>当你用<code>malloc</code>等函数分配了一块内存，并用一个指针变量指向它，然后释放了这块内存，但没有把指针变量设置为<code>NULL</code>，这个指针变量就会变成野指针。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配内存</span></span><br><span class="line"><span class="built_in">free</span>(ptr); <span class="comment">// 释放内存</span></span><br><span class="line"><span class="comment">// 此时ptr仍然指向原来的内存地址，但这块内存已经被释放了</span></span><br></pre></td></tr></table></figure></li><li><p>如果你继续使用<code>ptr</code>，它就会指向一个已经被释放的内存地址，这就是野指针。</p></li></ul><h2 id="如何避免野指针的问题"><a href="#如何避免野指针的问题" class="headerlink" title="如何避免野指针的问题"></a>如何避免野指针的问题</h2><h3 id="1-初始化指针"><a href="#1-初始化指针" class="headerlink" title="1. 初始化指针"></a>1. 初始化指针</h3><p><strong>建议</strong>：在定义指针时，始终初始化指针为<code>NULL</code>或指向一个有效的地址。</p><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="literal">NULL</span>; <span class="comment">// 初始化为NULL</span></span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;value; <span class="comment">// 初始化为一个有效的地址</span></span><br></pre></td></tr></table></figure><p><strong>解释</strong>：初始化为<code>NULL</code>可以让你在后续使用指针时，通过检查是否为<code>NULL</code>来避免使用未初始化的指针。</p><h3 id="2-释放内存后将指针置为NULL"><a href="#2-释放内存后将指针置为NULL" class="headerlink" title="2. 释放内存后将指针置为NULL"></a>2. 释放内存后将指针置为<code>NULL</code></h3><p><strong>建议</strong>：在释放动态分配的内存后，立即将指针置为<code>NULL</code>。</p><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用ptr</span></span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">ptr = <span class="literal">NULL</span>; <span class="comment">// 释放内存后将指针置为NULL</span></span><br></pre></td></tr></table></figure><p><strong>解释</strong>：这样可以避免指针继续指向已经被释放的内存，从而防止野指针的产生。</p><h3 id="3-检查指针是否为NULL"><a href="#3-检查指针是否为NULL" class="headerlink" title="3. 检查指针是否为NULL"></a>3. 检查指针是否为<code>NULL</code></h3><p><strong>建议</strong>：在使用指针之前，始终检查指针是否为<code>NULL</code>。</p><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用ptr</span></span><br><span class="line">*ptr = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">ptr = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：通过检查指针是否为<code>NULL</code>，可以避免对未初始化或已经释放的指针进行操作。</p><h3 id="4-使用智能指针（C-）"><a href="#4-使用智能指针（C-）" class="headerlink" title="4. 使用智能指针（C++）"></a>4. 使用智能指针（C++）</h3><p><strong>建议</strong>：如果你使用的是C++，尽量使用智能指针（如<code>std::unique_ptr</code>或<code>std::shared_ptr</code>）来管理动态内存。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 使用ptr</span></span><br></pre></td></tr></table></figure><p><strong>解释</strong>：智能指针会自动管理内存的分配和释放，避免手动管理内存带来的风险。</p><h3 id="5-避免重复释放"><a href="#5-避免重复释放" class="headerlink" title="5. 避免重复释放"></a>5. 避免重复释放</h3><p><strong>建议</strong>：确保内存只被释放一次，避免重复释放。</p><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用ptr</span></span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">ptr = <span class="literal">NULL</span>; <span class="comment">// 释放内存后将指针置为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免重复释放</span></span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：通过将指针置为<code>NULL</code>，可以避免重复释放的问题。</p><h3 id="6-使用工具检测野指针"><a href="#6-使用工具检测野指针" class="headerlink" title="6. 使用工具检测野指针"></a>6. 使用工具检测野指针</h3><p><strong>建议</strong>：使用内存检测工具（如<code>valgrind</code>）来检测野指针和内存泄漏问题。</p><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind ./your_program</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：<code>valgrind</code>等工具可以检测内存访问错误，帮助你发现野指针问题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p><strong>野指针</strong>：指向一个随机的、不正确的内存地址的指针。</p></li><li><p><strong>产生原因</strong>：</p><ol><li><strong>定义时未初始化</strong>：指针变量没有被赋予一个具体的地址，它的值是随机的。</li><li><strong>释放后未指向NULL</strong>：指针变量指向的内存被释放了，但指针变量没有被设置为<code>NULL</code>，它仍然指向原来的内存地址。</li></ol></li></ul><h1 id="dma有什么用"><a href="#dma有什么用" class="headerlink" title="dma有什么用"></a>dma有什么用</h1><p>主要是起一个搬运数据的作用，搬运通道可以时从外设到寄存器，外设到外设，寄存器到外设。</p><p>官方回答：DMA是在专门的硬件（ DMA）控制下，实现高速外设和主存储器之间自动成批交换数据尽量减少CPU干预的输入&#x2F;输出操作方式。主要作用就是减少CPU的负担。</p><h1 id="进程间通信的方法"><a href="#进程间通信的方法" class="headerlink" title="进程间通信的方法"></a>进程间通信的方法</h1><p>管道（有名管道和无名管道）</p><p>消息队列</p><p>共享内存</p><p>信号</p><p>信号量  </p><p>套接字</p><h1 id="程序中的内存分配方法"><a href="#程序中的内存分配方法" class="headerlink" title="程序中的内存分配方法"></a>程序中的内存分配方法</h1><p>连续分配，分段，分页，段页式</p><h1 id="定时器的作用和优势"><a href="#定时器的作用和优势" class="headerlink" title="定时器的作用和优势"></a>定时器的作用和优势</h1><p>作用：定时器，延时，PWM（输出比较），捕获输入（解码和时间测量），触发中断，单脉冲输出</p><p>优势：不需要cpu参与，精准</p><h1 id="已知单片机内置12位精度的ADC"><a href="#已知单片机内置12位精度的ADC" class="headerlink" title="已知单片机内置12位精度的ADC"></a>已知单片机内置12位精度的ADC</h1><p>单片机工作电压3.3V，ADC基准电压3V，请计算ADC采样的电压最小分辨率是多少？如果单片机ADC输入口电压为1V，则采样得到的值是多少？</p><p>只看基准电压即可</p><p>当ADC满量程4095时应该是输入的基准电压3V </p><p> 电压最小分辨率为3&#x2F;4095 V </p><p> 采样值为1&#x2F;3*4095 </p><h1 id="同步通信和异步通信有什么区别？全双工和半双工以及单工有什么区别？UART、SPI和I2C分别属于什么类型的通信方式？"><a href="#同步通信和异步通信有什么区别？全双工和半双工以及单工有什么区别？UART、SPI和I2C分别属于什么类型的通信方式？" class="headerlink" title="同步通信和异步通信有什么区别？全双工和半双工以及单工有什么区别？UART、SPI和I2C分别属于什么类型的通信方式？"></a>同步通信和异步通信有什么区别？全双工和半双工以及单工有什么区别？UART、SPI和I2C分别属于什么类型的通信方式？</h1><p>同步通信：需要时钟线，且双方的时钟频率要相同，在规定的时间内完成对数据的发送</p><p>异步通信：不需要时钟线，所以在传输的时候前后必需加上</p><p>全双工：两条通道任意时候都可以进行数据的接收和发送，通常四根线，如下图</p><p>半双工：两条通道可以进行数据的接收和发送，但是同一时间只能进行接收或者发送，通常是两根线</p><p>单工：只能单独一条通道进行数据单方向的传输（只发送或者只接受），通常只有一根线</p><p><img src="/./../../images/1705922741622-ded4405c-7d26-4449-9e33-96e2d0e4f572.webp" alt="img"></p><p>UART：异步通信的全双工 </p><p>USART：比UART多一根时钟线，所以是同步通信的全双工</p><p>IIC：同步通信的半双工</p><p>SPI：同步通信的全双工</p><hr><h1 id="FreeRTOS-在智能语音台灯项目中的应用"><a href="#FreeRTOS-在智能语音台灯项目中的应用" class="headerlink" title="FreeRTOS 在智能语音台灯项目中的应用"></a><strong>FreeRTOS 在智能语音台灯项目中的应用</strong></h1><p>在智能语音台灯项目中，FreeRTOS 被广泛应用于多个关键环节，以优化任务调度、提高系统响应速度和稳定性。以下是 FreeRTOS 在项目中的具体应用：</p><h3 id="1-任务调度"><a href="#1-任务调度" class="headerlink" title="1. 任务调度"></a>1. <strong>任务调度</strong></h3><p>智能语音台灯项目包含多个功能模块，每个模块都可以作为一个任务运行在 FreeRTOS 上。通过 FreeRTOS 的任务调度功能，可以确保这些任务高效、有序地运行。例如：</p><ul><li><strong>语音控制任务</strong>：高优先级任务，负责实时响应用户的语音指令。</li><li><strong>疲劳检测任务</strong>：中高优先级任务，定期检测用户的面部姿态和疲劳程度。</li><li><strong>坐姿提醒任务</strong>：中优先级任务，通过超声波传感器检测用户的坐姿并提醒。</li><li><strong>环境监测任务</strong>：中优先级任务，定期读取光照传感器、温湿度传感器的数据。</li><li><strong>智能控光任务</strong>：低优先级任务，根据环境光照强度自动调节灯光亮度。</li><li><strong>数据记录任务</strong>：低优先级任务，负责记录用户的使用习惯和设备运行状态。</li></ul><p>通过 FreeRTOS 的任务调度器，可以根据任务的优先级动态分配 CPU 时间，确保高优先级任务能够及时响应，低优先级任务在系统空闲时运行。</p><h3 id="2-任务间通信"><a href="#2-任务间通信" class="headerlink" title="2. 任务间通信"></a>2. <strong>任务间通信</strong></h3><p>在多任务环境中，不同任务之间需要进行数据交换。FreeRTOS 提供了多种任务间通信机制，如队列、信号量、事件组等。在智能语音台灯项目中，这些机制被用于：</p><ul><li><strong>疲劳检测与语音提醒</strong>：疲劳检测任务检测到用户疲劳后，通过队列向语音控制任务发送消息，语音控制任务接收到消息后播放舒缓音乐并提醒用户休息。</li><li><strong>环境监测与智能控光</strong>：环境监测任务定期读取光照传感器数据，并通过队列将数据发送给智能控光任务，智能控光任务根据这些数据调整灯光亮度。</li><li><strong>坐姿提醒与语音提醒</strong>：坐姿提醒任务检测到用户坐姿不正确时，通过信号量通知语音控制任务，语音控制任务发出语音提示。</li></ul><h3 id="3-资源管理"><a href="#3-资源管理" class="headerlink" title="3. 资源管理"></a>3. <strong>资源管理</strong></h3><p>智能语音台灯项目中涉及多个硬件资源，如 GPIO 引脚、通信接口等。FreeRTOS 的互斥量（Mutex）可以用于保护这些共享资源，防止多个任务同时访问导致的冲突。例如：</p><ul><li><strong>GPIO 引脚</strong>：多个任务可能需要访问同一个 GPIO 引脚（如控制灯光开关的引脚），通过互斥量可以确保一次只有一个任务能够访问该引脚。</li><li><strong>通信接口</strong>：如 I2C 接口，多个任务可能需要通过 I2C 接口与传感器通信，互斥量可以防止通信冲突。</li></ul><h3 id="4-时间管理"><a href="#4-时间管理" class="headerlink" title="4. 时间管理"></a>4. <strong>时间管理</strong></h3><p>FreeRTOS 提供了时间管理功能，如延时、定时器等。在智能语音台灯项目中，这些功能被用于：</p><ul><li><strong>定时任务</strong>：环境监测任务可以使用 FreeRTOS 的定时器功能，每隔一定时间读取光照传感器的值，并根据读取结果调整灯光亮度。</li><li><strong>延时操作</strong>：语音控制任务在播放音乐或语音提示时，可能需要延时操作，FreeRTOS 的延时功能可以确保任务在指定的时间后继续执行。</li></ul><h3 id="5-内存管理"><a href="#5-内存管理" class="headerlink" title="5. 内存管理"></a>5. <strong>内存管理</strong></h3><p>FreeRTOS 提供了多种内存管理策略，可以根据项目的实际需求进行选择。在智能语音台灯项目中，可以使用静态内存分配策略，减少动态内存分配带来的碎片化和延迟。例如：</p><ul><li><strong>静态任务栈分配</strong>：为每个任务分配固定大小的栈空间，避免动态分配栈空间带来的开销。</li><li><strong>静态队列分配</strong>：为队列分配固定大小的内存，避免动态分配内存带来的开销。</li></ul><h3 id="6-系统稳定性与调试"><a href="#6-系统稳定性与调试" class="headerlink" title="6. 系统稳定性与调试"></a>6. <strong>系统稳定性与调试</strong></h3><p>FreeRTOS 提供了丰富的调试工具和功能，可以帮助开发人员监控任务的执行情况，识别瓶颈，优化系统性能。例如：</p><ul><li><strong>任务状态监控</strong>：通过 FreeRTOS 提供的调试工具，可以实时监控任务的运行状态、CPU 占用率等信息。</li><li><strong>上下文切换分析</strong>：使用 Tracealyzer 等工具，可以分析任务的上下文切换情况，优化任务调度。</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在智能语音台灯项目中，FreeRTOS 被广泛应用于任务调度、任务间通信、资源管理、时间管理、内存管理以及系统调试等多个方面。通过 FreeRTOS 的这些功能，项目能够实现高效的任务管理、稳定的系统运行和良好的用户体验。</p><hr><h3 id="回答示例"><a href="#回答示例" class="headerlink" title="回答示例"></a><strong>回答示例</strong></h3><p>如果面试官问你：“FreeRTOS 在智能语音台灯项目中用在哪里了？”你可以这样回答：</p><p>“在智能语音台灯项目中，FreeRTOS 被用于多个关键环节，以优化任务调度、提高系统响应速度和稳定性。具体来说：</p><ol><li><strong>任务调度</strong>：FreeRTOS 的任务调度器确保了语音控制、疲劳检测、坐姿提醒、环境监测和智能控光等任务能够高效、有序地运行。</li><li><strong>任务间通信</strong>：通过队列和信号量，实现了疲劳检测与语音提醒、环境监测与智能控光、坐姿提醒与语音提醒等任务之间的数据交换。</li><li><strong>资源管理</strong>：使用互斥量保护了 GPIO 引脚和通信接口等共享资源，防止任务间的冲突。</li><li><strong>时间管理</strong>：利用 FreeRTOS 的定时器功能，实现了环境监测任务的定时执行和语音控制任务的延时操作。</li><li><strong>内存管理</strong>：采用静态内存分配策略，减少了动态内存分配带来的开销和碎片化。</li><li><strong>系统调试</strong>：通过 FreeRTOS 提供的调试工具，监控任务的执行情况，优化系统性能。</li></ol><h1 id="RTOS的调度机制"><a href="#RTOS的调度机制" class="headerlink" title="RTOS的调度机制"></a>RTOS的调度机制</h1><p>应用了FreeRTOS，实现了多任务并发。RTOS的核心调度机制是基于优先级的抢占式调度。每个任务根据其优先级被调度器动态分配CPU资源，高优先级任务可随时打断低优先级任务，确保关键任务实时响应。项目中，我合理分配了传感器采集、语音处理、自动调光等任务的优先级，并利用信号量与互斥锁保障数据同步与资源互斥，极大提升了系统的响应速度和稳定性。</p><h1 id="灯心智启”智能语音台灯项目中-优先级"><a href="#灯心智启”智能语音台灯项目中-优先级" class="headerlink" title="灯心智启”智能语音台灯项目中 优先级"></a>灯心智启”智能语音台灯项目中 优先级</h1><p>首先，我根据任务的实时性需求和重要程度进行分级。例如，语音交互和自动调光属于强实时任务，我将其优先级设置为最高，确保用户操作和环境变化能在毫秒级内响应。其次，传感器数据采集、摄像头检测等周期性任务设为中等优先级，保证数据流畅采集但不抢占关键任务资源。最后，APP&#x2F;小程序远程控制和数据上传等非实时任务则设置为较低优先级，利用系统空闲时间处理。</p><h1 id="stm32启动流程"><a href="#stm32启动流程" class="headerlink" title="stm32启动流程"></a>stm32启动流程</h1><p>STM32 启动流程严格遵循：上电&#x2F;复位 → 启动文件 → 堆栈初始化 → 数据段初始化 → 时钟配置 → C 库初始化 → 进入 main 函数。</p><p><strong>1. 复位与上电</strong><br>当 STM32 上电或复位后，处理器会将程序计数器（PC）设置为启动地址。</p><p><strong>2. 启动代码执行</strong><br>芯片首先跳转到存储在 <code>0x00000004</code> 地址的复位中断向量（Reset Handler）。这个地址里存放的就是启动函数的入口（通常是 startup_xx.s 汇编文件中的 Reset_Handler）。</p><p><strong>3. 堆栈初始化</strong><br>在复位中断处理函数（Reset_Handler）中，首先会初始化主堆栈指针（MSP），确保栈空间可用。</p><p><strong>4. 数据段和 BSS 段初始化</strong></p><ul><li>将 Flash 中的已初始化全局变量复制到 RAM（data 段初始化）。</li><li>清零未初始化的全局变量和静态变量（bss 段初始化）。</li></ul><p><strong>5. 系统时钟配置</strong><br>执行 <code>SystemInit()</code> 函数，完成系统时钟（HSE、PLL 等）和外设时钟的配置。</p><p><strong>6. 进入 main 函数</strong><br>所有初始化完成后，程序跳转到 <code>main()</code> 函数，开始用户应用程序。</p><p>首先，芯片上电或复位后，程序从复位向量（Reset Vector）开始执行，跳转到启动文件（startup.s）的复位处理函数。<br>接着，启动代码会完成堆栈指针初始化、系统时钟配置，然后将.data段的数据从Flash拷贝到SRAM，并清零.bss段，确保全局变量和静态变量的初始值正确。<br>随后，启动文件会调用C库的初始化函数（如__libc_init_array），为C语言环境做准备。<br>最后，所有初始化完成后，程序跳转到main函数，正式进入用户代码逻辑。</p><h1 id="Linux系统启动流程"><a href="#Linux系统启动流程" class="headerlink" title="Linux系统启动流程"></a>Linux系统启动流程</h1><p>首先，处理器上电后会执行ROM代码，检测启动引脚，选择启动介质，并加载第一阶段引导程序FSBL（First Stage Boot Loader）。</p><p>随后，初始化外部RAM控制器   FSBL负责初始化时钟和外部DDR内存，为后续大容量代码运行做准备，并将SSBL（Second Stage Boot Loader）加载到DDR中。</p><ul><li>FSBL 代码初始化时钟树、初始化外部RAM控制器，也就是DDR。最终FSBL将SSBL加载到DDR里面并运行SSBL代码。</li><li>DDR的全称其实是DDR SDRAM。所以在介绍DDR之前，得先了解什么是SDRAM。</li><li>SDRAM（同步动态随机存取内）可以看作一种特殊的DRAM（动态随机存取内存），我们平时说的计算机内存条就是一种DRAM。</li><li>SDRAM除了异步接口，还多了一个同步接口。同步接口需要数据发送方和接收方有一个统一的时钟信号，技术相对复杂，相应的传输速率和并发度都更高。</li></ul><p>第三步，SSBL（通常为u-boot）在DDR中运行，功能更全面，包括使能USB、网络、显示等外设，并灵活加载Linux内核，比如从Flash或网络中获取。第四步，u-boot将Linux内核加载到DDR并启动，内核会初始化各类硬件驱动，挂载根文件系统。</p><p>最后，内核启动用户空间的init进程，进一步初始化根文件系统和各类服务，系统进入多进程用户空间环境。</p><h1 id="linux内核启动后进入命令行流程"><a href="#linux内核启动后进入命令行流程" class="headerlink" title="linux内核启动后进入命令行流程"></a>linux内核启动后进入命令行流程</h1><p>首先，系统上电后，U-Boot等引导程序负责加载Linux内核和设备树到内存，并启动内核。内核启动后会进行硬件初始化，包括内存管理、CPU、外设驱动加载等。在这一过程中，我配置了设备树，确保各类外设能被正确识别和初始化，提升了系统兼容性和启动速度。</p><p>接下来，内核会挂载根文件系统（rootfs），这是命令行环境的基础。我针对项目需求，定制和优化了根文件系统内容，确保所需驱动和应用均能正常启动。</p><p>随后，内核会启动第一个用户空间进程，即init进程（通常为&#x2F;sbin&#x2F;init或systemd）。init进程根据配置文件（如inittab或systemd服务单元）依次启动各类系统服务和shell环境。最终，系统进入登录界面，用户即可访问命令行。</p><h1 id="stm32和嵌入式liunx的区别"><a href="#stm32和嵌入式liunx的区别" class="headerlink" title="stm32和嵌入式liunx的区别"></a>stm32和嵌入式liunx的区别</h1><p>分别在STM32和嵌入式Linux平台上开发过完整的应用。二者在代码层面并不完全互通。STM32多为裸机或RTOS环境，代码通常直接操作寄存器和外设，依赖于HAL库或底层驱动。而嵌入式Linux则基于操作系统，代码结构更偏向多进程、多线程，常用标准库和系统调用。</p><p>虽然两者都支持C，但如GPIO、串口、I2C等外设的操作接口和驱动方式差异较大，移植时需要针对平台进行适配。例如，在“灯心智启”项目中，我为STM32独立编写了底层驱动，而在Linux MQTT智能家居系统中，则需要通过设备树和内核驱动实现外设控制。</p><p>STM32通常运行裸机程序或RTOS，资源有限，主要通过直接操作寄存器和外设，适合对实时性和低功耗要求高的场景。例如在“灯心智启”项目中，STM32作为主控，负责传感器采集和实时控制，系统启动速度快，响应延迟低至毫秒级。</p><p>嵌入式Linux如IMX6ULL PRO平台，具备更强的处理能力和丰富的外设支持，能够运行多进程、多线程，支持QT图形界面、网络协议栈等复杂应用。在Linux MQTT智能家居系统项目中，我通过驱动开发和应用移植，实现了远程控制和多任务并发，</p><h1 id="can的负载率计算"><a href="#can的负载率计算" class="headerlink" title="can的负载率计算"></a>can的负载率计算</h1><p>CAN总线的负载率计算是进行系统性能评估的关键环节。以我在STM32平台集成多种传感器的数据采集和通信为例，CAN负载率的计算公式是：</p><p><strong>负载率 &#x3D; 实际传输的数据量 &#x2F; CAN总线最大传输能力 × 100%</strong></p><p>具体来说，需要统计单位时间内所有CAN帧的总位数（包括数据帧、控制帧等），然后除以CAN总线的理论带宽。例如，若CAN总线速率为500kbps，1秒内实际发送了20000帧，每帧128位，则负载率为：(20000 × 128) &#x2F; (500,000 × 1) ≈ 5.12%。通过准确计算负载率，我能有效预判系统瓶颈，保障通信实时性和稳定性</p><h1 id="IIC和CAN发送消息"><a href="#IIC和CAN发送消息" class="headerlink" title="IIC和CAN发送消息"></a>IIC和CAN发送消息</h1><p>IIC发送消息时，首先主设备发起起始信号，发送从设备地址并等待应答，随后按照协议顺序发送数据字节，每发送一个字节都需等待从设备应答，最后由主设备发送停止信号完成通信。在“灯心智启”项目中，我用STM32的IIC接口与多种传感器通信，优化了IIC驱动，传感器数据采集效率提升了约15%。</p><p>CAN发送消息则更适用于多节点高可靠通信。发送流程包括配置CAN控制器、设置报文标识符（ID）和数据、请求发送，CAN控制器自动完成仲裁和错误检测，确保数据可靠送达目标节点。在Linux MQTT智能家居系统项目中，我曾在IMX6ULL平台下调试过CAN驱动，确保多设备间数据同步，系统稳定性提升明显。</p><h1 id="IIC和CAN的仲裁"><a href="#IIC和CAN的仲裁" class="headerlink" title="IIC和CAN的仲裁"></a>IIC和CAN的仲裁</h1><p>IIC总线采用“线与”逻辑进行仲裁。当多个主机同时发起通信时，谁先在SDA线上发送低电平，谁就拥有总线控制权。若主机检测到自己发送高电平时总线上却为低电平，则自动放弃仲裁，保证通信不会冲突。在“灯心智启”STM32项目中，我通过合理规划IIC主机优先级，确保多传感器数据采集稳定，系统误码率降低了约10%。</p><p>CAN总线则采用基于报文ID的优先级仲裁。当多个节点同时发送数据时，ID越低优先级越高，节点实时监控总线状态，若检测到自己的ID位为高电平而总线上为低电平，则自动停止发送，等待下一轮仲裁。这个机制保证了高优先级数据实时可靠传输。在Linux智能家居系统中，我调试CAN驱动时，利用ID仲裁优化了多节点数据同步，系统响应延迟缩短了20%以上。</p><p>RTOS需要移植哪些东西</p><h1 id="spi和i2c计算"><a href="#spi和i2c计算" class="headerlink" title="spi和i2c计算"></a>spi和i2c计算</h1><p>I2C的速率计算主要基于其标准模式（100kbps）、快速模式（400kbps）等，实际带宽还需考虑起始位、地址位、应答位和停止位等开销。例如，传输8字节数据，需加上1字节地址和若干控制位，实际有效数据速率会低于标称速率。通过合理安排数据包结构，我在项目中将I2C数据传输效率提升约20%，满足了多传感器并行采集的需求。</p><p>SPI的速率计算更为直接，理论带宽为时钟频率×数据线数量（如全双工4线制）。例如，主频为8MHz时，1字节数据理论传输时间为1μs左右。SPI无地址和应答开销，效率更高。在项目中，采用SPI读取摄像头数据，实际带宽接近标称值，数据延迟降低约30%。</p><h1 id="spi，iic，can的地址管理区别"><a href="#spi，iic，can的地址管理区别" class="headerlink" title="spi，iic，can的地址管理区别"></a>spi，iic，can的地址管理区别</h1><p>SPI总线采用主从（一主多从）结构，不具备硬件层面的地址管理。主控通过片选信号（CS）直接选择具体的从设备，片选线数量决定可挂载的从设备数量。在“灯心智启”项目中，我通过STM32片选线扩展，实现了对多个传感器的高效管理。</p><p>IIC总线则采用7位或10位的从设备地址（多主多从），每个设备地址唯一，主机通过发送地址字节选择目标设备。IIC支持多主多从，扩展性强。在我的智能台灯项目中，通过合理分配IIC地址，实现了对光敏和温湿度传感器的统一管理，降低了硬件复杂度，整体布线减少约30%。</p><p>CAN总线采用全局唯一标识符（ID）进行节点识别，所有节点平等，消息以广播形式发送，接收方根据ID过滤信息。这种方式大大提升了系统的灵活性和容错性。我在智能家居系统开发中，利用CAN ID灵活分配，实现了多节点高效通信，系统扩展能力提升约40%。</p><h1 id="串口115200波特率是一秒传输几个字节数据"><a href="#串口115200波特率是一秒传输几个字节数据" class="headerlink" title="串口115200波特率是一秒传输几个字节数据"></a>串口115200波特率是一秒传输几个字节数据</h1><p>串口传输一个字节通常需要10位（1位起始位、8位数据位、1位停止位）。</p><p>​每秒字节数&#x3D;115200&#x2F;10&#x3D;11520</p><h1 id="freeRTOS需要移植哪些东西"><a href="#freeRTOS需要移植哪些东西" class="headerlink" title="freeRTOS需要移植哪些东西"></a>freeRTOS需要移植哪些东西</h1><p>首先，需要适配处理器相关的端口文件（Porting Layer），包括任务切换的汇编代码和中断管理；其次，配置FreeRTOSConfig.h文件，定制系统时钟、任务优先级、堆栈大小等参数；第三，移植与硬件相关的启动文件及时钟节拍定时器（SysTick），确保系统节拍准确；最后，确保编译环境和链接脚本与目标芯片兼容。</p><p>首先，需要适配处理器相关的启动文件和端口层（Porting Layer），包括任务切换、上下文保存与恢复等核心代码。例如，在STM32 Cortex-M平台上，我优化了port.c和portmacro.h文件，保证任务切换高效可靠。</p><p>第二，必须实现与硬件平台相关的定时器中断，这为FreeRTOS提供系统时钟基础。在实际项目中，我通过配置SysTick定时器，实现了毫秒级任务调度，系统响应速度提升了约20%。</p><p>第三，内存管理模块的适配也非常关键。我根据项目实际需求选择和优化了heap_4.c内存管理方案，确保多任务运行时内存分配高效且无泄漏。</p><p>最后，还要根据应用场景适配外设驱动（如IIC、SPI、UART等）和中断服务函数，并完善任务优先级和同步互斥机制，提升整体系统稳定性和实时性。</p><ul><li>修改sys.h文件，让它支持OS。</li><li>修改usart文件，更改中断。在uC&#x2F;OS的时候，进入和退出中断需要添加OSIntEnter()和OSIntExit()两个函数，然后在FreeRTOS中并没有该机制，所以将这里的代码删除。</li><li>关于delay函数的修改，FreeRTOS中使用SysTick作为作为操作系统的心跳，所以需要将xPortSysTickHandler()添加，作为系统始终中断。</li><li>delay_init() 用于初始化SysTick，主要修改SysTick的重装载值，修改delay_ms和delay_us函数。</li><li>修改中断（SysTick中断、SVC中断、PendSV中断）。其中SysTick中断在delay.c文件中已经定义。</li></ul><h1 id="RTOS怎么实现任务调度的"><a href="#RTOS怎么实现任务调度的" class="headerlink" title="RTOS怎么实现任务调度的"></a>RTOS怎么实现任务调度的</h1><p>我深入应用了FreeRTOS任务调度机制，实现了多任务并发和高效资源管理。具体来说，RTOS通过以下方式实现任务调度：</p><p>首先，RTOS维护一个任务优先级队列，每个任务根据其优先级被动态管理。系统利用定时器中断（如SysTick）定期触发任务切换。每当中断发生时，RTOS会检查所有就绪任务，选择最高优先级的任务执行。</p><p>在我的项目中，我合理划分了各功能模块的任务优先级，例如自动调光、传感器采集和语音交互等，确保关键功能实时响应。通过配置FreeRTOS的抢占式调度，系统能在毫秒级内完成任务切换，整体响应速度提升约20%。</p><p>此外，RTOS还通过任务状态（就绪、运行、阻塞、挂起）管理任务生命周期，并利用互斥量和信号量实现任务间同步，避免资源冲突。</p><h1 id="RTOS中带ISR和不带ISR的函数区别"><a href="#RTOS中带ISR和不带ISR的函数区别" class="headerlink" title="RTOS中带ISR和不带ISR的函数区别"></a>RTOS中带ISR和不带ISR的函数区别</h1><p>在我的项目中，经常需要在FreeRTOS环境下处理任务与中断的数据交互。带ISR（如<code>xQueueSendFromISR</code>）和不带ISR（如<code>xQueueSend</code>）的函数核心区别在于：</p><p>带ISR（如 xQueueSendFromISR）专为中断服务函数（Interrupt Service Routine）设计，它们不涉及阻塞，通常会使用特殊的中断安全机制，比如临界区保护和任务切换标记，确保在中断上下文中安全、快速地操作RTOS对象。而不带ISR的函数（如 xQueueSend）只能在任务上下文中调用，支持阻塞和超时，系统会自动进行任务调度。.</p><ul><li><strong>调用环境不同</strong>：带ISR的函数只能在中断服务函数（ISR）内部调用，确保在中断上下文下操作RTOS资源时安全、快速；而不带ISR的函数仅能在任务中调用，支持阻塞和超时机制。</li><li><strong>系统行为不同</strong>：带ISR的函数不会阻塞，确保中断处理尽快完成，并通过特殊参数判断是否需要任务切换，保证系统实时性。而普通函数可以根据资源状态选择挂起或等待，系统会自动进行调度。</li></ul><p>我在实际项目中，合理区分并使用这两类API，既保证了数据的实时传递，也避免了死锁和优先级反转等问题。例如，在高频数据采集项目中，通过使用<code>xQueueSendFromISR</code>将采集数据从中断安全、无阻塞地传递到任务队列，</p><h1 id="解决RTC异常复位问题"><a href="#解决RTC异常复位问题" class="headerlink" title="解决RTC异常复位问题"></a>解决RTC异常复位问题</h1><p><strong>RTC（实时时钟）主要用于提供精准的时间基准，实现定时控制和数据记录等功能。例如，台灯的自动调光、疲劳监测和坐姿提醒等模块，都依赖RTC实现定时检测与事件触发。此外，RTC还能确保设备在断电或重启后依然保持准确的时间信息，保证用户体验和系统稳定性</strong></p><p><strong>我利用RTC实现了自动调光功能。具体做法是：首先，RTC模块为台灯提供了精准的时间信息，根据不同时间段（如早晨、傍晚、夜间）设定不同的亮度阈值。主控芯片定时读取RTC时间，并结合光敏传感器实时采集的环境光强度，通过算法判断是否需要调整灯光亮度。这样，台灯能够根据用户作息和环境变化，自动切换到最合适的照明状态。</strong></p><p>我曾遇到RTC（实时时钟）异常复位导致时间丢失的问题。面对这一挑战，我首先通过分析STM32的硬件手册，结合FreeRTOS环境，对电路和代码进行了系统排查，发现异常复位多因电源波动或初始化流程不完善引起。</p><p>在“灯心智启”智能语音台灯项目中，我曾遇到STM32 RTC模块因异常复位导致时间丢失的问题。为彻底解决这一挑战，我采取了软硬件结合的策略：</p><p>首先，我通过分析电路原理图和实际测试，发现主电源波动和初始化流程不完善是主要原因。针对硬件，我为RTC部分加装了纽扣电池，确保主电源断开时RTC依然能持续供电，保证时钟连续运行。</p><p>在软件层面，我优化了RTC初始化流程：启动时先检测备份寄存器内容，判断是否为异常复位；如果检测到异常，则从备份寄存器或外部接口恢复正确时间，避免时间重置。同时，增加了掉电检测机制，确保每次上电后RTC状态可靠。</p><p><strong>行动</strong><br>我首先定位问题，分析硬件电路和软件驱动，发现部分情况下RTC电源切换不及时，导致寄存器数据丢失。同时，系统初始化流程未对RTC状态做充分校验。<br>为此，我优化了硬件RTC电源管理，确保备用电池正常供电；在软件层面，增加了RTC寄存器的校验和自动修正机制，加入上电自检和时间回退保护。当检测到RTC异常时，系统自动恢复到最近一次有效时间，并通过日志记录异常，便于后续追踪。</p><p><strong>结果</strong><br>经过优化后，系统RTC异常复位问题大幅减少，时间丢失率降低至0.1%以内。项目顺利通过稳定性测试，客户对系统长期运行的可靠性给予高度评价。</p><h1 id="作为项目管理是怎么安排项目的"><a href="#作为项目管理是怎么安排项目的" class="headerlink" title="作为项目管理是怎么安排项目的"></a>作为项目管理是怎么安排项目的</h1><p>在某次嵌入式系统开发项目中，团队成员技术背景不一，项目任务涉及软硬件协同，时间紧、需求变更多。</p><p><strong>行动</strong>：首先，我与团队和客户一起明确里程碑和交付标准，将项目分解为若干阶段和具体可量化的任务。根据成员专长合理分工，通过每日站会跟踪进展，发现问题及时调整资源。同时引入看板工具，实现任务透明化管理，并设定每周回顾会议，确保风险早暴露、早处理。</p><p><strong>结果</strong>：最终，项目提前两周完成，产品一次性通过客户验收，Bug率降低了40%。团队成员的积极性和协作效率也显著提升。</p><p>在“灯心智启”智能语音台灯项目中，我独立承担了项目管理和全部开发工作。面对功能多、周期紧的挑战，我采用了模块化和阶段性推进的管理方式。</p><p>首先，我将项目拆分为硬件设计、嵌入式开发、AI模型训练和APP联调四大模块，明确每一阶段的目标和输出。针对每一模块，制定详细的时间表和里程碑，优先解决关键路径上的难题，比如主控芯片选型和多传感器数据融合。</p><h1 id="平时开发用什么语言"><a href="#平时开发用什么语言" class="headerlink" title="平时开发用什么语言"></a>平时开发用什么语言</h1><p>在“灯心智启”项目中，我使用C语言为STM32单片机编写底层驱动和主控逻辑，实现了多传感器数据采集、FreeRTOS多任务调度等核心功能。在“Linux MQTT智能家居系统”项目中，我则结合C++进行QT图形界面开发和多线程处理，</p><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>static 关键字主要用于控制变量和函数的作用域与生命周期 在“灯心智启”项目的嵌入式代码中，我会用 static 修饰局部变量，使其在函数多次调用时保持状态，从而提升模块的可靠性和数据一致性。同时，使用 static 修饰函数或全局变量，可以限定其只在当前文件内可见，避免命名冲突，增强代码的封装性和可维护性。</p><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>volatile，什么时候用</p><p>第一，修饰中断服务程序中会被主程序和中断同时访问的全局变量，防止编译器优化导致主程序无法及时感知变量的变化。<br>第二，用于多线程或多任务系统（如FreeRTOS）中，任务间共享的标志变量，确保每次读取的都是最新值。<br>第三，修饰与硬件寄存器相关的变量，如GPIO、外设状态寄存器等，防止编译器将其缓存到寄存器，保证对硬件的实时操作。</p><p>volatile 关键字主要用于修饰多线程或中断中会被异步修改的变量。例如，在“灯心智启”项目中，我使用STM32单片机进行多传感器数据采集和控制，涉及到中断服务程序（ISR）与主循环之间的数据通信。为了确保主循环每次都能读取到最新的传感器状态，我会将这类变量声明为volatile，防止编译器优化带来的缓存问题，确保数据实时性和系统稳定性。</p><p>通过规范使用volatile，有效避免了数据不同步导致的逻辑错误，提升了系统的可靠性。</p><p><strong>背景</strong>：在多任务或中断环境下，某些变量可能会被中断服务程序或外部硬件异步修改。如果不加<code>volatile</code>，编译器会优化代码，将变量缓存到寄存器，导致主程序无法察觉变量的实时变化。</p><p><strong>行动</strong>：针对这些易变变量，我都会加上<code>volatile</code>，确保每次访问都直接从内存读取，避免因编译器优化带来的数据不一致。例如，在FreeRTOS项目中，中断与主循环共享的标志位、状态寄存器等都会加<code>volatile</code>修饰。</p><p><strong>结果</strong>：通过规范使用<code>volatile</code>关键字，避免了难以发现的同步问题和死循环，系统稳定性提升20%以上。客户反馈项目可靠性明显增强。</p><h1 id="define"><a href="#define" class="headerlink" title="define"></a>define</h1><p><code>#define</code> 关键字经常被用于提高代码的可维护性和可读性。</p><p><strong>情境</strong>：在一个需要频繁修改硬件寄存器地址和参数的项目中，直接使用硬编码数值容易导致后期维护和调试困难。</p><p><strong>行动</strong>：我统一采用<code>#define</code>为常用的参数、寄存器地址和魔数定义宏。例如，将引脚号、缓冲区大小等用宏定义，便于代码复用和集中修改。对于条件编译和功能切换，也利用<code>#define</code>灵活控制代码片段的启用和关闭。</p><p><strong>结果</strong>：这种做法使代码结构更加清晰，后续功能扩展和Bug修复效率提升了50%以上，团队成员能够快速定位和修改关键参数，减少了人为错误。</p><h1 id="裸机进入main函数流程"><a href="#裸机进入main函数流程" class="headerlink" title="裸机进入main函数流程"></a>裸机进入main函数流程</h1><h1 id="IIC、SPI帧格式、一主多从"><a href="#IIC、SPI帧格式、一主多从" class="headerlink" title="IIC、SPI帧格式、一主多从"></a>IIC、SPI帧格式、一主多从</h1><p>IIC总线采用两根信号线（SCL、SDA），帧格式包括起始信号、从设备地址、读写位、数据段和停止信号，支持一主多从结构，主设备通过地址唯一识别多个从设备。在项目中，我通过合理分配地址，实现了光敏、温湿度等多个传感器的高效并行管理，数据采集效率提升约30%。</p><p>SPI总线则采用四根信号线（SCLK、MOSI、MISO、CS），帧格式为连续的数据流，通过片选信号（CS）区分不同从设备，同样支持一主多从。在驱动开发时，我优化了SPI通信协议，提升了外设响应速度，保证了系统的实时性和稳定性。</p><h1 id="线程通信方式"><a href="#线程通信方式" class="headerlink" title="线程通信方式"></a>线程通信方式</h1><p>我深入实践了多线程通信方式。项目采用IMX6ULL开发板和Linux系统，涉及多进程、多线程的并发控制。为实现线程间高效通信，我主要采用了互斥锁（mutex）、条件变量（condition variable）、信号量（semaphore）和消息队列（message queue）等方式。</p><p>具体来说，针对传感器数据采集和界面数据显示两个线程，我用互斥锁保证数据一致性，避免竞争条件；通过条件变量实现线程同步，确保数据显示及时准确。此外，在复杂的事件通知场景下，我还应用了信号量和消息队列，实现了线程间的高效异步通信。</p><ul><li><p><strong>共享内存</strong>：线程共享同一进程的内存空间，通过访问共享变量进行通信。需用互斥锁保护临界区。</p></li><li><p><strong>消息队列</strong>：线程间通过消息队列发送和接收消息，实现通信。</p></li><li><p><strong>信号量</strong>：用于线程同步，控制对共享资源的访问。</p></li><li><p><strong>事件</strong>：线程通过等待和触发事件进行同步。</p></li><li><p><strong>管道</strong>：线程间通过管道进行数据传输。</p><p><strong>情境</strong><br>在基于IMX6ULL开发板的Linux系统项目中，涉及多个线程并发采集传感器数据并同步到界面显示，要求高效的数据一致性与实时响应。</p><p><strong>行动</strong><br>我主要采用了互斥锁（mutex）保证多线程共享数据的安全，防止竞争条件；利用条件变量（condition variable）实现线程同步，确保数据处理和显示的时序准确；在事件通知和复杂交互场景下，还结合信号量（semaphore）与消息队列（message queue），实现了高效的异步通信和任务调度，显著提升线程间的协作效率。</p><p><strong>结果</strong><br>通过这些通信机制，系统多线程数据同步延迟降低至毫秒级，通信效率提升40%，整体运行更加稳定可靠。项目顺利通过验收，客户反馈系统响应速度和稳定性大幅提升。</p></li></ul><h1 id="怎么裁剪-u-boot启动"><a href="#怎么裁剪-u-boot启动" class="headerlink" title="怎么裁剪 u boot启动"></a>怎么裁剪 u boot启动</h1><p>在Linux MQTT智能家居系统项目中，我针对u-boot启动过程进行了精细的优化和裁剪，以提升系统启动速度和资源利用率。</p><p>具体来说，首先我分析了u-boot的启动流程，明确哪些功能模块是项目所需，哪些可以裁剪。例如，仅保留必要的启动命令和驱动，关闭如USB、网络、冗余文件系统等无关功能。通过修改<code>include/configs</code>下的配置头文件，注释或关闭不需要的宏定义，并精简启动命令行参数，减少无用初始化。</p><p>其次，我优化了环境变量设置，将启动脚本和参数直接嵌入到默认环境，避免二次加载；同时合并和简化设备树加载流程，减少等待和检测时间。</p><p>最后，在编译阶段，利用Makefile裁剪未用到的外设驱动和命令模块，使u-boot镜像体积缩小约30%，启动时间缩短近40%。整个裁剪过程严格测试，确保核心功能稳定可靠。</p><p>首先，内核裁剪是关键环节。结合我在Linux MQTT智能家居系统项目的经验，通过menuconfig等工具关闭未用的驱动模块、文件系统和功能特性，比如去除不需要的网络协议、外设驱动、调试功能等。经过裁剪，内核镜像体积可减少约35%，启动时间也相应缩短。</p><p>其次，根文件系统的精简同样重要。我会只保留实际运行所需的库、工具和应用，删除冗余的shell命令、开发工具和未用库文件。通过BusyBox集成常用命令，进一步减小文件系统体积，最高可减少50%以上的存储占用。</p><p>此外，应用层也可以优化。例如裁剪QT应用，删除未用控件和模块，优化图形界面布局；或在STM32等MCU端，精简固件代码和功能模块，提升运行效率。</p><h1 id="如何处理FreeRTOS中的任务优先级？如何避免优先级反转？"><a href="#如何处理FreeRTOS中的任务优先级？如何避免优先级反转？" class="headerlink" title="如何处理FreeRTOS中的任务优先级？如何避免优先级反转？"></a><strong>如何处理FreeRTOS中的任务优先级？如何避免优先级反转？</strong></h1><p>在“灯心智启”智能语音台灯项目中，我深入实践了FreeRTOS任务优先级的管理。针对多传感器数据采集和语音交互等并发场景，我根据任务的实时性需求合理分配优先级。例如，自动调光和疲劳监测等关键任务被设为较高优先级，后台数据处理和日志保存则分配较低优先级，从而保证系统核心功能的及时响应。</p><p>为避免优先级反转问题，我充分利用FreeRTOS的优先级继承机制。在涉及互斥量（Mutex）的任务同步场景中，确保高优先级任务被低优先级任务阻塞时，低优先级任务会临时提升优先级，直至释放资源，防止系统出现“高优先级饿死”的情况。通过这些措施，系统整体延迟降低了约25%，多任务协作更加流畅。</p><p>这些经验不仅提升了我对实时多任务系统的理解，也为我今后在贵公司开发高可靠性嵌入式产品提供了坚实的技术保障。我期待将这种精细化调度和系统优化能力带入贵团队，共同推动产品性能提升。</p><h1 id="FreeRTOS的调度算法是怎样的？如何实现时间片轮转？"><a href="#FreeRTOS的调度算法是怎样的？如何实现时间片轮转？" class="headerlink" title="FreeRTOS的调度算法是怎样的？如何实现时间片轮转？"></a><strong>FreeRTOS的调度算法是怎样的？如何实现时间片轮转？</strong></h1><p>在“灯心智启”智能语音台灯项目开发中，我深入研究并实际应用了FreeRTOS的调度算法。FreeRTOS采用基于优先级的抢占式调度机制，即始终运行当前就绪队列中最高优先级的任务。当有更高优先级任务进入就绪态时，调度器会立即切换，保证关键任务的实时响应。</p><p>针对项目中多任务并发的需求，我通过配置FreeRTOS的时间片轮转功能（即使能启用configUSE_TIME_SLICING），让同一优先级的多个任务能按时间片公平轮转。这样，自动调光、语音交互等同优先级任务能够高效协作，避免单一任务独占CPU，系统整体响应效率提升约30%。</p><p>通过合理利用FreeRTOS的调度策略和时间片机制，我确保了台灯多功能模块的稳定运行和良好用户体验。这一调度优化经验，也让我具备了为贵公司嵌入式系统设计高效任务管理方案的能力，助力产品实现更高的实时性和稳定性。</p><h2 id="如何调试FreeRTOS应用？有哪些常用的调试技巧"><a href="#如何调试FreeRTOS应用？有哪些常用的调试技巧" class="headerlink" title="如何调试FreeRTOS应用？有哪些常用的调试技巧"></a><strong>如何调试FreeRTOS应用？有哪些常用的调试技巧</strong></h2><p>在“灯心智启”智能语音台灯项目开发中，我独立完成了基于FreeRTOS的主控程序，积累了丰富的调试经验。面对多任务并发和实时性要求高的场景，我采用了多种调试技巧来保障系统稳定。</p><p>首先，我充分利用Keil的断点和单步调试功能，结合FreeRTOS内核感知插件，实时监控任务切换、堆栈使用和任务状态。这帮助我快速定位到一次任务堆栈溢出的问题，通过优化任务栈分配，系统崩溃率下降了约40%。其次，我在关键路径加入串口日志输出，实时打印任务切换、队列和信号量状态，便于追踪异常。对于死锁或优先级反转等问题，我会利用FreeRTOS自带的trace宏，分析任务间的同步关系。</p><p>此外，我还习惯用Watch窗口监控全局变量，结合硬件LED指示灯进行简单故障定位。这些调试手段，大大提升了开发效率和系统稳定性。</p><p>我相信，这些扎实的FreeRTOS调试经验和系统化的方法论，能够帮助贵公司快速定位和解决嵌入式项目中的复杂问题，提升产品可靠性和开发效率。</p><h1 id="什么是交叉编译"><a href="#什么是交叉编译" class="headerlink" title="什么是交叉编译"></a>什么是交叉编译</h1><p>交叉编译是在一个平台上编译出另一个平台上运行的程序的过程。</p><h2 id="不同平台之间的交叉编译需要以下步骤：w"><a href="#不同平台之间的交叉编译需要以下步骤：w" class="headerlink" title="不同平台之间的交叉编译需要以下步骤：w"></a>不同平台之间的交叉编译需要以下步骤：w</h2><ol><li><p><strong>准备交叉编译工具链</strong></p><ul><li>选择适合目标平台的交叉编译工具链，如GNU工具链（<code>arm-linux-gnueabihf-gcc</code>）、Linaro工具链等。</li><li>可以通过包管理器安装（如<code>sudo apt install gcc-arm-linux-gnueabihf</code>），或者从官网下载并解压。</li></ul></li><li><p><strong>配置编译环境</strong></p><ul><li><p>设置环境变量，指定交叉编译工具链的路径和目标平台的系统根目录（Sysroot）。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/path/to/toolchain/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> CC=arm-linux-gnueabihf-gcc</span><br><span class="line"><span class="built_in">export</span> SYSROOT=/path/to/sysroot</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>编写和配置代码</strong></p><ul><li>确保代码兼容目标平台的架构和操作系统。</li><li>如果使用CMake，可以通过工具链文件指定交叉编译选项。</li></ul></li><li><p><strong>编译代码</strong></p><ul><li><p>使用交叉编译工具链编译代码，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc -o hello_arm hello.c --sysroot=<span class="variable">$SYSROOT</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>部署和测试</strong></p><ul><li>将生成的可执行文件或库部署到目标平台进行测试</li></ul></li></ol><h1 id="static-1"><a href="#static-1" class="headerlink" title="static"></a>static</h1><h2 id="static关键词的作用？"><a href="#static关键词的作用？" class="headerlink" title="static关键词的作用？"></a><strong>static关键词的作用？</strong></h2><ol><li><strong>限定变量作用域</strong>：在函数内声明 static 变量时，变量只在该函数内可见，但生命周期贯穿整个程序运行。例如，在我独立开发 STM32 主控芯片源程序时，使用 static 修饰的局部变量可以实现自动调光等功能的数据持久化，避免数据在每次函数调用时被重置，提升了系统的稳定性。</li><li><strong>限制外部访问</strong>：在文件级别声明 static 变量或函数时，该变量或函数只能在当前源文件中访问，防止命名冲突。在 Linux MQTT 智能家居项目中，我通过 static 修饰驱动模块内部的私有函数，增强了代码的模块化和安全性，使驱动程序更易于维护和扩展。</li><li><strong>节省资源，提高效率</strong>：static 变量存储在静态存储区，初始化只进行一次，有效减少了内存分配和释放的开销。在 FreeRTOS 多任务环境下，这种做法使得任务间数据管理更加高效，系统运行更流畅。</li></ol><p>在“灯心智启”项目的嵌入式代码中，我会用 static 修饰局部变量，使其在函数多次调用时保持状态，从而提升模块的可靠性和数据一致性。同时，使用 static 修饰函数或全局变量，可以限定其只在当前文件内可见，避免命名冲突，增强代码的封装性和可维护性。</p><h2 id="为什么-static变量只初始化一次？"><a href="#为什么-static变量只初始化一次？" class="headerlink" title="为什么 static变量只初始化一次？"></a><strong>为什么 static变量只初始化一次？</strong></h2><p>static 变量只初始化一次的原因，源于其存储方式和生命周期。以我在 STM32 智能语音台灯和 Linux 智能家居项目中的实际开发为例：</p><p>在 C 语言中，static 变量被分配在静态存储区，程序启动时分配内存，并在整个程序生命周期内保持其值。与普通局部变量每次进入函数都会重新分配和初始化不同，static 变量只在程序首次执行到其定义处时初始化一次。之后无论函数被调用多少次，static 变量都不会再次初始化，而是保留上次的值。</p><p>在我独立开发的智能台灯项目中，利用 static 变量保存传感器历史状态，实现了对用户坐姿和环境亮度的持续监测。这样不仅节省了内存分配的系统开销，还保证了数据的连续性，程序稳定性提升约20%。同样，在 Linux 智能家居驱动开发中，static 变量的单次初始化特性，使得驱动状态管理更可靠，减少了重复初始化带来的资源浪费。</p><p>这种机制非常适合嵌入式和实时系统，有效提升了资源利用率和系统响应速度。未来，我希望把这种高效的内存管理和代码规范带到贵公司的嵌入式开发中，助力产品性能持续优化。</p><h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><h2 id="什么是常量指针？"><a href="#什么是常量指针？" class="headerlink" title="什么是常量指针？"></a><strong>什么是常量指针？</strong></h2><p>常量指针是指“指针本身的值不能改变”，即指针一旦指向某个地址后，不能再指向其他地址，但可以通过该指针修改所指向地址的内容。在 C 语言中，常量指针的声明方式为 <code>int *const p</code>。</p><p>结合我的项目经验，比如在 STM32 智能台灯开发中，为了确保关键控制变量的指针不会被意外修改，我会用常量指针来保证指针的稳定性，避免因指针误操作导致系统异常。这种做法在硬件寄存器操作、驱动开发等场景尤为重要，能提升代码的健壮性和安全性。</p><h1 id="什么是指针常量？"><a href="#什么是指针常量？" class="headerlink" title="什么是指针常量？"></a>什么是指针常量？</h1><p>指针常量是指“指针所指向的数据内容不能被修改”，但指针本身的值（即指向的地址）是可以改变的。在 C 语言中，声明方式通常为 <code>const int *p</code>，表示通过 p 不能修改所指向的内容，但可以让 p 指向其他地址。</p><p>在我主导的 STM32 智能语音台灯和 Linux 智能家居项目开发过程中，指针常量被广泛用于保护关键数据不被意外修改。例如，在操作传感器数据或硬件寄存器时，为了防止误操作导致系统异常，我会使用指针常量来限定数据的只读属性，提升系统的安全性和健壮性。</p><h1 id="typedef和define有什么区别？"><a href="#typedef和define有什么区别？" class="headerlink" title="typedef和define有什么区别？"></a>typedef和define有什么区别？</h1><p>typedef 是用来为已有的数据类型起别名，由编译器在编译阶段处理，能够提升代码的可读性和可维护性。例如在 STM32 智能台灯项目中，我常用 typedef 定义结构体别名，便于团队协作和后期维护。</p><p>#define 是预处理指令，在编译前进行简单的文本替换，常用于定义常量或宏。它不具备类型检查，容易因宏替换带来隐患。在 Linux 智能家居驱动开发中，我会用 #define 定义寄存器地址等常量，提升代码清晰度。</p><h1 id="定义常量谁更好？-define还是-const？"><a href="#定义常量谁更好？-define还是-const？" class="headerlink" title="定义常量谁更好？# define还是 const？"></a><strong>定义常量谁更好？# define还是 const？</strong></h1><p>在实际项目开发中，我更推荐使用 <code>const</code> 来定义常量，而不是 <code>#define</code>。<code>const</code> 由编译器进行类型检查，能够明确指定常量的数据类型，提升代码的安全性和可读性。例如，在 STM32 智能语音台灯和 Linux 智能家居系统开发过程中，我大量采用 <code>const</code> 定义关键参数和配置信息，有效防止了因类型不匹配导致的编译错误和运行时隐患。</p><p>相比之下，<code>#define</code> 只是简单的文本替换，不具备类型检查，容易引发调试困难和潜在 bug。在我的项目实践中，通过将 <code>#define</code> 替换为 <code>const</code>，团队在代码审查和测试阶段发现的相关问题数量下降了约15%。</p><h1 id="全局变量和局部变量的区别是什么"><a href="#全局变量和局部变量的区别是什么" class="headerlink" title="全局变量和局部变量的区别是什么?"></a><strong>全局变量和局部变量的区别是什么?</strong></h1><p><strong>全局变量</strong>和<strong>局部变量</strong>的最大区别在于作用域和生命周期。全局变量定义在函数外部，整个程序都可以访问，生命周期贯穿整个程序运行过程。而局部变量只在其所在的函数或代码块内有效，生命周期仅限于该函数或代码块执行期间。</p><p>在实际项目中，比如我在 STM32 智能语音台灯和 Linux 智能家居系统开发时，会优先使用局部变量来避免全局变量带来的命名冲突和内存占用问题。只有在驱动开发等需要多个模块共享数据时，才会合理使用全局变量，并通过加锁等手段保证线程安全。通过这种变量管理方式，项目代码的可维护性提升了约20%，也有效减少了调试过程中的隐性 bug</p><h1 id="局部变量能否和全局变量重名？"><a href="#局部变量能否和全局变量重名？" class="headerlink" title="局部变量能否和全局变量重名？"></a><strong>局部变量能否和全局变量重名？</strong></h1><ul><li>局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量，对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内</li></ul><p>全局变量不建议直接定义在可被多个 .c 文件包含的头文件中。原因在于，如果在头文件中直接定义全局变量，每个包含该头文件的 .c 文件都会生成一份同名变量，导致链接错误，增加调试难度。</p><p>局部变量可以和全局变量重名，但在同一作用域内，局部变量会覆盖全局变量。实际开发中，我在STM32智能语音台灯项目中就遇到过类似情况。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> status = <span class="number">0</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">checkStatus</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> status = <span class="number">1</span>; <span class="comment">// 局部变量，覆盖全局变量</span></span><br><span class="line">    <span class="comment">// 此处使用的status是局部变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，函数<code>checkStatus</code>里的<code>status</code>变量会屏蔽全局的<code>status</code>，只在函数内部生效。这种做法虽然语法允许，但容易引发混淆和维护风险。因此，我在实际项目中严格遵循良好的命名规范，尽量避免局部和全局变量重名。这样做让团队在代码审查和维护阶段，变量命名冲突相关的问题减少了30%以上。</p><p>在我负责的 STM32 智能语音台灯和 Linux 智能家居系统开发过程中，我始终遵循“在头文件中用 extern 声明全局变量，在一个 .c 文件中定义”的规范。这样既保证了变量的唯一性，又方便了多模块间的数据共享。实际应用中，这一规范让团队在大型项目集成时链接错误率下降了约25%，显著提升了开发效率。</p><h1 id="C语言常用字符串"><a href="#C语言常用字符串" class="headerlink" title="C语言常用字符串"></a>C语言常用字符串</h1><p>在C语言项目开发中，常用的字符串操作函数主要包括：</p><ul><li><code>strcpy</code>：字符串拷贝</li><li><code>strncpy</code>：限定长度的字符串拷贝</li><li><code>strcat</code>：字符串拼接</li><li><code>strncat</code>：限定长度的字符串拼接</li><li><code>strcmp</code>：字符串比较</li><li><code>strncmp</code>：限定长度的字符串比较</li><li><code>strlen</code>：获取字符串长度</li><li><code>strchr</code>：查找字符首次出现的位置</li><li><code>strstr</code>：查找子串首次出现的位置</li><li><code>sprintf</code>&#x2F;<code>snprintf</code>：格式化字符串输出</li></ul><h1 id="ARM-硬件基础-内部架构"><a href="#ARM-硬件基础-内部架构" class="headerlink" title="ARM -硬件基础&#x2F;内部架构"></a>ARM -硬件基础&#x2F;内部架构</h1><h2 id="NAND-FLASH-和NOR-FLASH异同？"><a href="#NAND-FLASH-和NOR-FLASH异同？" class="headerlink" title="NAND FLASH 和NOR FLASH异同？"></a>NAND FLASH 和NOR FLASH异同？</h2><p><strong>相同点</strong>：</p><ul><li>都属于非易失性存储器，断电后数据不丢失。</li><li>都广泛应用于嵌入式系统中，作为代码或数据存储介质。</li></ul><p><strong>不同点</strong>：</p><ul><li><strong>结构与原理</strong>：NOR FLASH支持随机读取，适合直接执行（XIP），常用于存储启动代码；NAND FLASH以页为单位操作，顺序读写速度快，容量大，性价比高。</li><li><strong>速度与容量</strong>：NOR FLASH读写速度较慢，容量一般较小；NAND FLASH写入和擦除速度快，容量通常大于1GB，适合大数据存储。</li><li><strong>应用场景</strong>：NOR FLASH常用于固件、引导程序存储；NAND FLASH多用于大容量数据如文件系统、存储卡等。</li><li><strong>可靠性</strong>：NOR FLASH支持更高次数的擦写，数据可靠性高；NAND FLASH需配合错误检测与纠正（ECC）机制。</li></ul><h2 id="CPU、MPU、MCU、SOC、SOPC-联系与差别？"><a href="#CPU、MPU、MCU、SOC、SOPC-联系与差别？" class="headerlink" title="CPU、MPU、MCU、SOC、SOPC 联系与差别？"></a>CPU、MPU、MCU、SOC、SOPC 联系与差别？</h2><p>在我的嵌入式项目实践中，常常需要根据系统需求选择合适的芯片架构。以下是对CPU、MPU、MCU、SoC、SOPC的联系与差别的总结：</p><ul><li><strong>CPU（中央处理器）</strong>：是计算机或嵌入式系统的核心运算单元，负责指令的运算和控制。</li><li><strong>MPU（微处理器）</strong>：通常指只包含CPU核心的芯片，需要外接存储和外设，适合高性能、灵活扩展的应用，如我在Linux智能家居系统中用到的i.MX6ULL开发板核心就是MPU。</li><li><strong>MCU（单片机）</strong>：<strong>微控制器</strong>集成了CPU、存储器（Flash&#x2F;RAM）和多种外设于一体，适合资源受限、低功耗场景。例如STM32单片机在我的AI语音台灯项目中实现了高集成度和低成本。</li><li><strong>SoC（系统级芯片）</strong>：在一块芯片上集成了CPU、存储、外设、通信接口等完整系统功能，广泛应用于智能硬件和移动设备。SoC能显著提升系统集成度和可靠性，降低整体功耗。（将就认为是MCU集成化与MPU强处理力各优点二合一）</li><li><strong>SOPC（可编程片上系统）</strong>：基于FPGA平台，用户可自定义CPU、外设等硬件资源，适合对灵活性和定制化要求极高的场合。</li></ul><h2 id="什么是交叉编译？"><a href="#什么是交叉编译？" class="headerlink" title="什么是交叉编译？"></a>什么是交叉编译？</h2><p>交叉编译是指在一种平台（如PC的x86架构）上，使用专门的交叉编译工具链，为另一种硬件平台（如ARM架构的嵌入式设备）生成可执行文件的过程。它是嵌入式开发的核心环节，尤其在我的Linux智能家居系统和STM32单片机项目中应用广泛。</p><ul><li>在一种计算机环境中运行的编译程序，能编译出在另外一种环境下运行的代码，我们就称这种编译器支持交叉编译。这个编译过程就叫交叉编译。简单地说，就是在一个平台上生成另一个平台上的可执行代码。</li><li>这里需要注意的是所谓平台，实际上包含两个概念：体系结构（Architecture）、操作系统（OperatingSystem）。同一个体系结构可以运行不同的操作系统；同样，同一个操作系统也可以在不同的体系结构上运行。举例来说，我们常说的x86 Linux平台实际上是Intel x86体系结构和Linux for x86操作系统的统称；而x86 WinNT平台实际上是Intel x86体系结构和Windows NT for x86操作系统的简称。</li></ul><h2 id="为什么需要交叉编译？"><a href="#为什么需要交叉编译？" class="headerlink" title="为什么需要交叉编译？"></a>为什么需要交叉编译？</h2><ul><li>有时是因为目的平台上不允许或不能够安装我们所需要的编译器，而我们又需要这个编译器的某些特征；有时是因为目的平台上的资源贫乏，无法运行我们所需要编译器；有时又是因为目的平台还没有建立，连操作系统都没有，根本谈不上运行什么编译器。</li></ul><h2 id="ROM和RAM的区别及类型"><a href="#ROM和RAM的区别及类型" class="headerlink" title="ROM和RAM的区别及类型"></a>ROM和RAM的区别及类型</h2><p>ROM（只读存储器）和RAM（随机存取存储器）是嵌入式系统中两类基本存储器件，二者在我的STM32和IMX6ULL项目开发中均有实际应用。</p><p>ROM主要用于永久性存储程序代码和固件，断电后数据依然保存。常见类型包括Mask ROM、EPROM、EEPROM和Flash，其中Flash ROM在STM32单片机和IMX6ULL开发板中广泛作为主程序存储介质。比如在我的智能语音台灯项目中，主控芯片的固件就是烧录在Flash ROM中，保障了系统的稳定运行。</p><p>RAM则用于临时存储运行时数据，断电后数据丢失。其类型主要有SRAM和DRAM，SRAM常用于嵌入式芯片内部高速缓存，DRAM则多见于高性能设备。以Linux智能家居系统为例，IMX6ULL板载的RAM为系统运行和多任务处理提供了充足的缓存空间</p><h2 id="关于RAM中，DRAM和SRAM对比"><a href="#关于RAM中，DRAM和SRAM对比" class="headerlink" title="关于RAM中，DRAM和SRAM对比"></a><strong>关于RAM中，DRAM和SRAM对比</strong></h2><p>DRAM和SRAM作为RAM的两种主要类型，各有特点和应用场景。</p><p>SRAM（静态随机存取存储器）速度快、功耗低、结构简单，适合用作CPU缓存和MCU片内高速缓存。例如在STM32单片机项目中，SRAM被用于存储中间变量和实时数据，显著提升了数据处理速度，使系统响应时间缩短约20%。</p><p>DRAM（动态随机存取存储器）存储密度高、成本低、容量大，但需要周期性刷新，访问速度略慢，适合大容量数据存储。在Linux智能家居系统项目中，IMX6ULL开发板采用DRAM作为主存，为多任务和复杂应用提供了充足的空间，保证了系统的稳定运行和多线程处理能力。</p><p>首先，单片机上电后，硬件电路会完成上电复位，确保系统处于初始状态。接着，芯片内部的启动引导程序（Bootloader）会初始化时钟系统、堆栈指针，并将中断向量表重定位到RAM或Flash的指定地址。随后，启动代码会将全局变量和静态变量从ROM拷贝到RAM，并对未初始化的数据区进行清零。</p><p>在此基础上，系统会依次初始化外设和关键模块，如时钟、GPIO、串口等。以我的台灯项目为例，我对光敏、温湿度等传感器进行了初始化，确保各模块协同启动。最后，主程序进入主循环或操作系统调度，开始执行核心应用逻辑。</p><h1 id="ARM中断与异常"><a href="#ARM中断与异常" class="headerlink" title="ARM中断与异常"></a>ARM中断与异常</h1><h2 id="异常和中断"><a href="#异常和中断" class="headerlink" title="异常和中断"></a>异常和中断</h2><p>中断是指外部或内部事件触发CPU暂停当前任务，转而执行相应的中断服务程序。例如在台灯项目中，光敏和超声波传感器的数据采集都采用了中断方式，极大提升了实时性和系统响应速度，系统整体响应延迟降低了约30%。</p><p>异常则通常指程序运行中出现的非法操作或特殊情况，如非法指令、访问越界等，系统会自动进入异常处理流程，保障软件和硬件的安全。</p><p><strong>中断和异常的区别：</strong></p><ul><li>产生源不相同，异常是由CPU产生的，而中断是由硬件设备产生的。</li><li>中断是异步的，这意味着中断可能随时到来:而异常是CPU产生的，所以，它是时钟同步的。</li><li>当处理中断时，处于中断上下文中:处理异常时，处于进程上下文中。</li></ul><h2 id="中断和DMA的区别"><a href="#中断和DMA的区别" class="headerlink" title="中断和DMA的区别"></a>中断和DMA的区别</h2><p>中断是指当外部或内部事件发生时，CPU会暂停当前任务，转而执行中断服务程序，处理完后再返回原任务。例如我在传感器数据采集时，采用中断方式实现数据的实时响应，保证了系统的高效性和可靠性。</p><p>而DMA（直接存储器访问）是一种无需CPU直接参与的数据传输方式，能够让外设和内存之间实现高速数据搬运。这样CPU可以专注于其他任务，显著提升系统吞吐率。在我的项目中，利用DMA进行大批量数据传输时，CPU占用率降低了近40%，系统整体运行效率有明显提升。</p><h2 id="中断响应执行流程"><a href="#中断响应执行流程" class="headerlink" title="中断响应执行流程"></a>中断响应执行流程</h2><p>首先，CPU接收到中断信号后，会立即保存当前的上下文环境（如寄存器内容和程序计数器），以便中断处理完成后能够恢复原有程序。随后，CPU跳转到中断服务程序执行上半部，完成关键的、对时效性要求高的处理，比如传感器数据的初步采集和标志位设置。接着，通过FreeRTOS将耗时的操作安排到中断下半部（如数据进一步处理或消息队列投递），这样不会长时间占用中断资源。最后，系统恢复原有上下文，CPU返回中断前的位置，继续执行主程序。</p><h2 id="中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？"><a href="#中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？" class="headerlink" title="中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？"></a>中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？</h2><ul><li><p>中断是CPU处于被动状态下来接受设备的信号，而轮询是CPU主动去查询该设备是否有请求。</p></li><li><p>凡事都是两面性，所以，看效率不能简单的说那个效率高。如果是请求设备是一个频繁请求cpu的设备，或者有大量数据请求的网络设备，那么轮询的效率是比中断高。如果是一般设备，并且该设备请求 cpu的频率比较低，则用中断效率要高一些。主要是看请求频率。</p></li><li><p>当外设请求频率较低或需要实时响应时，中断方式更高效，因为它能让CPU专注于主任务，只有事件发生才响应，避免了资源浪费。例如在台灯项目中，人体检测和姿态提醒等功能，我采用了中断，系统CPU占用率降低了约30%，响应时间也更快。</p></li><li><p>但对于高频率或大量数据传输的场景，比如网络通信或者高速ADC采集，轮询反而能减少频繁的上下文切换，整体吞吐率更高。在Linux MQTT智能家居系统中，部分驱动我就采用了高效的轮询机制，保证了数据实时性。</p></li><li><p>我们正好现在在做一个硬件通讯的性能优化工作，经过测试，中断触发的方式延时还是很可观的，大约在15微秒，而我们不注册中断函数而改用死循环不停判断中断寄存器，中断发生后1微秒就能知道。性能有了巨大提升，代价就是有一个cpu核心一直保持100%占用率，不过我们的设备就干这一件事，而且对功耗不敏感。所以方案都是根据实际需要权衡的，也不是哪个一定好。</p></li></ul><h2 id="当一个异常出现以后，ARM微处理器会执行哪几步操作？"><a href="#当一个异常出现以后，ARM微处理器会执行哪几步操作？" class="headerlink" title="当一个异常出现以后，ARM微处理器会执行哪几步操作？"></a>当一个异常出现以后，ARM微处理器会执行哪几步操作？</h2><p>首先，ARM处理器会立即保存当前的程序计数器（PC）和程序状态寄存器（CPSR），确保异常返回时能恢复原有执行状态。接着，处理器会切换到对应的异常模式（如IRQ、FIQ、SVC等），并自动屏蔽相应的中断，防止嵌套异常影响系统稳定性。随后，处理器跳转到异常向量表指定的入口地址，执行异常服务程序，进行相应的异常处理。最后，异常处理结束后，通过专门的异常返回指令（如SUBS PC, LR, #4），恢复原先的上下文，继续主程序运行。</p><h2 id="STM32是大端还是小端？"><a href="#STM32是大端还是小端？" class="headerlink" title="STM32是大端还是小端？"></a>STM32是大端还是小端？</h2><p>STM32采用的是ARM Cortex-M系列内核，默认情况下属于小端模式（Little Endian），即低字节存储在低地址，高字节存储在高地址。这种小端模式在数据通信和多字节数据处理时具有较高的兼容性，也便于与主流PC及网络协议的数据交互。</p>]]></content>
      
      
      <categories>
          
          <category> 面试知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>车载C知识</title>
      <link href="/2024/09/06/test/%E8%BD%A6%E8%BD%BDc%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/09/06/test/%E8%BD%A6%E8%BD%BDc%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>c<br>记录一些自己不会的 和理解不够深的</p><p><img src="/./../../images/image-20250513220710273.png" alt="image-20250513220710273"></p><ol><li><p><strong>存储方式</strong>：</p><ul><li>C风格字符串通过字符数组（<code>char[]</code>）表示，以<code>&#39;\0&#39;</code>（空字符）结尾。</li><li>C++中使用<code>std::string</code>类来表示字符串，更加抽象和方便。</li></ul></li><li><p><strong>动态内存管理</strong>：</p><ul><li>C风格字符串需要手动进行内存分配和释放，使用如<code>malloc()</code>或<code>new</code>来分配内存，并使用<code>free()</code>或<code>delete</code>释放内存。</li><li>C++的<code>std::string</code>类自动管理内存，通过构造函数和析构函数自动处理内存，无需手动分配或释放内存。</li></ul></li><li><p><strong>字符串操作</strong>：</p><ul><li>C风格字符串的操作需要使用一系列的字符串处理函数（如<code>strcpy()</code>、<code>strcat()</code>、<code>strlen()</code>等），这些函数需要将字符串指针作为参数。</li><li>C++的<code>std::string</code>类提供了丰富的成员函数，如<code>append()</code>、<code>length()</code>、<code>find()</code>等，可以直接操作字符串对象，更加方便和易用。</li></ul></li><li><p><strong>安全性</strong>：</p><ul><li><p>C风格字符串没有提供越界检查，需要开发人员自行保证字符串的正确性。</p><ul><li>C++的<code>std::string</code>类具有越界检查功能，可以避免缓冲区溢出等安全问题。</li></ul><p><img src="/./../../images/image-20250513220823443.png" alt="image-20250513220823443"></p></li></ul><p>连接字符串常用</p><p><img src="/./../../images/image-20250513220915980.png" alt="image-20250513220915980"></p><h3 id="向量的概念和优势"><a href="#向量的概念和优势" class="headerlink" title="向量的概念和优势"></a>向量的概念和优势</h3><ol><li><strong>动态数组容器</strong>：<ul><li>向量是C++标准库提供的一种动态数组容器，使用前需要包含头文件<code>&lt;vector&gt;</code>。</li></ul></li><li><strong>线性存储</strong>：<ul><li>向量是一种线性容器，可以存储同一类型的元素。</li></ul></li><li><strong>顺序存储</strong>：<ul><li>向量中的元素按照它们在向量中的顺序进行存储。</li></ul></li><li><strong>随机访问</strong>：<ul><li>向量支持随机访问，可以通过索引访问向量中的元素。</li></ul></li><li><strong>动态调整大小</strong>：<ul><li>向量的大小可以动态调整，可以根据需要动态添加或删除元素。</li></ul></li><li><strong>优势</strong>：<ul><li>向量具有动态大小、随机访问、内存管理简单、较好的可扩展性等优势。</li></ul></li></ol><h3 id="向量的创建和初始化"><a href="#向量的创建和初始化" class="headerlink" title="向量的创建和初始化"></a>向量的创建和初始化</h3><ol><li><p><strong>创建空向量</strong>：</p><ul><li>使用<code>std::vector&lt;int&gt; myVector;</code>创建一个空的整型向量。</li></ul></li><li><p><strong>初始化向量</strong>：</p><ul><li>可以通过初始化列表、使用迭代器、使用默认值等方式初始化向量。</li></ul><p><img src="/./../../images/image-20250513221111990.png" alt="image-20250513221111990"></p></li></ol><p><img src="/./../../images/image-20250513221125703.png" alt="image-20250513221125703"></p></li></ol><p><img src="/./../../images/image-20250513221153145.png" alt="image-20250513221153145"></p><h1 id="指针的声明和初始化"><a href="#指针的声明和初始化" class="headerlink" title="指针的声明和初始化"></a>指针的声明和初始化</h1><ol><li><p><strong>声明与初始化语法</strong>：</p><ul><li><p>语法格式为：<code>&lt;数据类型&gt;* &lt;指针名称&gt; = &lt;空指针或已存在变量地址&gt;;</code></p></li><li><p>示例：声明一个指向整数的指针并初始化为空指针。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>内存分配</strong>：</p><ul><li><p>在使用指针之前，确保为指针分配了合适的内存空间或者将其初始化为有效的内存地址。</p></li><li><p>示例：使用动态内存分配为指针分配内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>释放内存</strong>：</p><ul><li><p>使用动态分配的内存后，要记得使用<code>delete</code>运算符释放该内存，以避免内存泄漏。</p></li><li><p>示例：释放之前分配的内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> ptr;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>当然，这里有一个使用<code>new</code>和<code>delete</code>运算符进行动态内存分配和释放的实际例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 动态分配一个整数的内存</span></span><br><span class="line">    <span class="type">int</span>* dynamicInt = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">// 分配内存并初始化为0（对于基本数据类型）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给动态分配的内存赋值</span></span><br><span class="line">    *dynamicInt = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出动态分配内存中的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value of dynamicInt is: &quot;</span> &lt;&lt; *dynamicInt &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用完动态分配的内存后，释放它</span></span><br><span class="line">    <span class="keyword">delete</span> dynamicInt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放后，尝试访问dynamicInt将会导致未定义行为</span></span><br><span class="line">    <span class="comment">// *dynamicInt = 100; // 这行代码如果被执行，将会导致错误</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Memory has been freed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ol><li>使用<code>new int</code>为一个整数动态分配了内存，并将返回的指针赋值给<code>dynamicInt</code>。</li><li>通过解引用指针<code>*dynamicInt</code>给这块内存赋值为42。</li><li>输出这块内存中的值。</li><li>使用<code>delete dynamicInt</code>释放了之前分配的内存。</li><li>释放内存后，<code>dynamicInt</code>指针不再指向有效的内存区域，如果再次访问它将会导致未定义行为，可能是程序崩溃或其他不可预知的结果。</li></ol><p>请注意，对于数组，应该使用<code>delete[]</code>来释放内存：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* dynamicIntArray = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]; <span class="comment">// 动态分配一个整数数组的内存</span></span><br><span class="line"><span class="comment">// ... 使用数组</span></span><br><span class="line"><span class="keyword">delete</span>[] dynamicIntArray; <span class="comment">// 释放数组内存</span></span><br></pre></td></tr></table></figure><p>正确地管理内存是非常重要的，因为它可以防止内存泄漏和其他内存相关的问题。在现代C++中，通常推荐使用智能指针（如<code>std::unique_ptr</code>和<code>std::shared_ptr</code>），因为它们可以自动管理内存，从而减少内存泄漏的风险。</p><p>是的，<code>std::unique_ptr</code>和<code>std::shared_ptr</code>是C++11及以后版本中引入的智能指针，它们可以帮助自动管理内存，减少内存泄漏的风险。使用这些智能指针，通常不需要（也不应该）手动调用<code>delete</code>来释放内存。智能指针会在适当的时候自动释放它们所管理的资源。</p><h3 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h3><p><code>std::unique_ptr</code>代表独占所有权的智能指针，意味着同一时间只能有一个<code>std::unique_ptr</code>指向特定资源。当<code>std::unique_ptr</code>被销毁时（例如，当它离开作用域或被重新赋值时），它会自动释放所管理的资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionUsingUniquePtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 当ptr离开作用域时，它所管理的内存将自动被释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">functionUsingUniquePtr</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，当<code>ptr</code>离开<code>functionUsingUniquePtr</code>函数的作用域时，它所管理的内存会自动被释放。</p><h3 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h3><p><code>std::shared_ptr</code>代表共享所有权的智能指针，允许多个<code>std::shared_ptr</code>实例共同拥有同一资源。资源的释放是在最后一个拥有该资源的<code>std::shared_ptr</code>被销毁或被赋值为其他资源时自动进行的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">createSharedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">createSharedPtr</span>();</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1; <span class="comment">// 现在ptr1和ptr2共享同一个资源</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *ptr1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ptr1和ptr2离开作用域时，它们所管理的内存不会被释放，因为引用计数不为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>ptr1</code>和<code>ptr2</code>共享同一个资源。当<code>main</code>函数结束时，这两个智能指针都会被销毁，因为它们的引用计数都变为0，所以它们管理的内存会被自动释放。</p><p>总的来说，使用<code>std::unique_ptr</code>和<code>std::shared_ptr</code>可以大大简化内存管理，减少内存泄漏和其他内存管理错误的风险。然而，智能指针也有其开销，因此在性能敏感的应用中，需要权衡使用智能指针的便利性和性能开销。</p><h3 id="指针的简单使用"><a href="#指针的简单使用" class="headerlink" title="指针的简单使用"></a>指针的简单使用</h3><ol><li><p><strong>变量地址获取</strong>：</p><ul><li><p>使用<code>&amp;</code>运算符可以获取变量的地址，并将其赋值给指针。</p></li><li><p>示例：获取变量的地址并赋值给指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;var;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>解引用</strong>：</p><ul><li><p>使用<code>*</code>运算符可以解引用指针，即访问指针所指向的变量的值。</p></li><li><p>示例：通过指针访问变量的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; *ptr;  <span class="comment">// 输出：10</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>动态内存分配</strong>：</p><ul><li><p>使用<code>new</code>运算符可以动态分配内存，返回指向该内存的指针。</p></li><li><p>示例：动态分配内存并初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>数组操作</strong>：</p><ul><li><p>指针可以用于数组的访问和操作。</p></li><li><p>示例：使用指针遍历数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptr = arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; *(ptr + i) &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出：1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>函数参数传递</strong>：</p><ul><li><p>指针可以被用来在函数之间传递参数，使得函数可以直接修改指向对象的值。</p></li><li><p>示例：通过指针修改变量的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> *ptr)</span> </span>&#123;</span><br><span class="line">    *ptr = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">modify</span>(&amp;var);</span><br><span class="line">    std::cout &lt;&lt; var;  <span class="comment">// 输出：30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="C-容器与智能指针"><a href="#C-容器与智能指针" class="headerlink" title="C++容器与智能指针"></a>C++容器与智能指针</h1><p><img src="/./../../images/image-20250514182018774.png" alt="image-20250514182018774"></p><p><img src="/./../../images/image-20250514182052165.png" alt="image-20250514182052165"></p><p><img src="/./../../images/image-20250514182157447.png" alt="image-20250514182157447"></p><p><img src="/./../../images/image-20250514182150823.png" alt="image-20250514182150823"></p><h3 id="数组（固定大小的连续存储空间）"><a href="#数组（固定大小的连续存储空间）" class="headerlink" title="数组（固定大小的连续存储空间）"></a>数组（固定大小的连续存储空间）</h3><ul><li><strong>声明和定义</strong>：<ul><li>使用声明符号<code>[]</code>来声明数组，并指定数组的大小。</li><li>数组的大小必须是常量表达式，可以在编译时确定。</li><li>数组的元素类型可以是任意的基本类型（如整数、浮点数、字符等），也可以是自定义的类型。</li></ul></li><li><strong>数组元素的访问</strong>：<ul><li>数组元素通过索引访问，索引从0开始，到数组大小减1结束。</li><li>使用方括号<code>[]</code>运算符和元素的索引来访问数组元素。</li></ul></li><li><strong>数组的初始化</strong>：<ul><li>可以在声明数组时同时进行初始化，或者在后续的操作中对数组元素进行赋值。</li><li>使用花括号<code>&#123;&#125;</code>来提供初始值。可以使用花括号列表初始化整个数组，或者使用索引逐个初始化数组元素。</li></ul></li><li><strong>数组的遍历</strong>：<ul><li>可以使用循环结构（如<code>for</code>循环）来遍历数组，以访问和处理数组中的每个元素。</li></ul></li></ul><h3 id="向量（Vector，动态数组，可变大小的连续存储空间）"><a href="#向量（Vector，动态数组，可变大小的连续存储空间）" class="headerlink" title="向量（Vector，动态数组，可变大小的连续存储空间）"></a>向量（Vector，动态数组，可变大小的连续存储空间）</h3><ul><li><strong>声明和定义向量</strong>：<ul><li>使用<code>std::vector</code>类模板来声明和定义向量。</li><li>指定向量中元素的类型作为模板参数。</li></ul></li><li><strong>向量的操作</strong>：<ul><li>向量提供了一系列成员函数和操作符来进行元素的插入、删除、访问和修改等操作。</li><li>通过成员函数和操作符，可以获取向量的大小、清空向量、判断向量是否为空等。</li></ul></li><li><strong>向量的遍历</strong>：<ul><li>可以使用循环结构（如<code>for</code>循环）来遍历向量，以访问和处理向量中的每个元素。</li></ul></li></ul><h3 id="列表（List，双向链表结构）"><a href="#列表（List，双向链表结构）" class="headerlink" title="列表（List，双向链表结构）"></a>列表（List，双向链表结构）</h3><ul><li><strong>声明和定义列表</strong>：<ul><li>使用<code>std::list</code>类模板来声明和定义列表。</li><li>指定列表中元素的类型作为模板参数。</li></ul></li><li><strong>列表的操作</strong>：<ul><li>列表提供了一系列成员函数来进行元素的插入、删除、访问和修改等操作。</li><li>通过成员函数，可以获取列表的大小、清空列表、判断列表是否为空等。</li></ul></li><li><strong>列表的遍历</strong>：<ul><li>可以使用迭代器或循环结构（如<code>for</code>循环）来遍历列表，以访问和处理列表中的每个元素。</li></ul></li></ul><p>这些容器各有特点和适用场景，选择哪种容器取决于具体的应用需求。例如，如果需要频繁地在容器中间插入或删除元素，列表可能是更好的选择；如果需要快速随机访问元素，向量或数组可能更合适。</p><p><img src="/./../../images/image-20250514182631401.png" alt="image-20250514182631401"></p><h3 id="映射（Map）容器概述"><a href="#映射（Map）容器概述" class="headerlink" title="映射（Map）容器概述"></a>映射（Map）容器概述</h3><ul><li><strong>定义</strong>：映射（Map）是一种键值对的容器，用于存储和管理键值对（key-value）数据。</li><li><strong>特点</strong>：映射是C++标准库中的一种容器，提供了方便的操作和管理键值对数据的方法。</li><li><strong>键的唯一性</strong>：映射类似于字典的概念，其中键是唯一的，可以用于快速查找和访问对应的值。</li><li><strong>头文件</strong>：映射类定义在<code>&lt;map&gt;</code>头文件中，需要引入该头文件才能使用映射。</li></ul><h3 id="声明和定义映射"><a href="#声明和定义映射" class="headerlink" title="声明和定义映射"></a>声明和定义映射</h3><ul><li><strong>使用<code>std::map</code>类模板</strong>：使用<code>std::map</code>类模板来声明和定义映射。</li><li><strong>模板参数</strong>：指定键和值的类型作为模板参数。</li></ul><h3 id="映射的操作"><a href="#映射的操作" class="headerlink" title="映射的操作"></a>映射的操作</h3><ul><li><strong>成员函数和操作符</strong>：映射提供了一系列成员函数和操作符来进行键值对的插入、删除、查找和访问等操作。</li><li><strong>获取映射大小</strong>：通过成员函数，可以获取映射的大小。</li><li><strong>清空映射</strong>：可以清空映射，即删除映射中的所有键值对。</li><li><strong>判断映射是否为空</strong>：可以判断映射是否为空。</li></ul><h3 id="映射的遍历"><a href="#映射的遍历" class="headerlink" title="映射的遍历"></a>映射的遍历</h3><ul><li><strong>迭代器或循环结构</strong>：可以使用迭代器或循环结构（如<code>for</code>循环）来遍历映射，以访问和处理映射中的每个键值对。</li></ul><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><ul><li><p><strong>声明映射</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; studentGrades; <span class="comment">// 声明一个字符串到整数的映射</span></span><br><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; phoneBook; <span class="comment">// 声明一个整数到字符串的映射</span></span><br></pre></td></tr></table></figure></li><li><p><strong>插入键值对</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">studentGrades[<span class="string">&quot;Alice&quot;</span>] = <span class="number">90</span>; <span class="comment">// 插入一个键值对</span></span><br><span class="line">studentGrades[<span class="string">&quot;Bob&quot;</span>] = <span class="number">85</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>访问键值对</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; studentGrades[<span class="string">&quot;Alice&quot;</span>] &lt;&lt; std::endl; <span class="comment">// 访问键对应的值</span></span><br></pre></td></tr></table></figure></li><li><p><strong>遍历映射</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (std::map&lt;std::string, <span class="type">int</span>&gt;::iterator it = studentGrades.<span class="built_in">begin</span>(); it != studentGrades.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl; <span class="comment">// 输出键值对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="常见容器的分类"><a href="#常见容器的分类" class="headerlink" title="常见容器的分类"></a>常见容器的分类</h1><p><img src="/./../../images/image-20250514183545638.png" alt="image-20250514183545638"></p><h4 id="1-顺序容器（Sequence-Container）"><a href="#1-顺序容器（Sequence-Container）" class="headerlink" title="1. 顺序容器（Sequence Container）"></a>1. 顺序容器（Sequence Container）</h4><ul><li><strong>存储方式</strong>：顺序容器按照元素的插入顺序来存储元素，元素在容器中的位置由插入顺序决定。</li><li><strong>访问方式</strong>：可以使用迭代器（iterator）或下标运算符来访问容器中的元素。</li><li><strong>示例容器</strong>：包括向量（vector）、双向链表（list）、双端队列（deque）等。</li></ul><h4 id="2-有序容器（Ordered-Container）"><a href="#2-有序容器（Ordered-Container）" class="headerlink" title="2. 有序容器（Ordered Container）"></a>2. 有序容器（Ordered Container）</h4><ul><li><strong>存储方式</strong>：有序容器按照一定的排序准则对元素进行排序，并在插入时维持元素的有序性。</li><li><strong>访问方式</strong>：可以使用迭代器或下标运算符来访问容器中的元素（元素的顺序是根据排序准则来决定的）。</li><li><strong>示例容器</strong>：包括集合（set）、映射（map）、多重集合（multiset）、多重映射（multimap）等。</li></ul><h3 id="其他区别"><a href="#其他区别" class="headerlink" title="其他区别"></a>其他区别</h3><ul><li><strong>适用场景</strong>：<ul><li>顺序容器适用于需要保留元素插入顺序的场景。</li><li>有序容器适用于需要根据排序准则进行存储和访问的场景。</li></ul></li><li><strong>插入和删除操作</strong>：<ul><li>顺序容器的插入和删除操作可能会导致元素在内存中的重新分配和移动。</li><li>有序容器则需要保持元素的有序性，因此插入和删除操作可能更复杂。</li></ul></li><li><strong>查找操作</strong>：<ul><li>顺序容器的查找操作通常需要遍历整个容器，时间复杂度为O(n)。</li><li>有序容器可以利用内部的排序结构进行快速的查找，时间复杂度为O(log n)。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>顺序容器</strong>：适用于需要保留元素插入顺序的场景，如向量、列表、双端队列。</li><li><strong>有序容器</strong>：适用于需要根据排序准则进行存储和访问的场景，如集合、映射、多重集合、多重映射。</li><li><strong>性能差异</strong>：顺序容器的查找操作通常较慢，而有序容器可以利用排序结构进行快速查找。</li></ul><p><img src="/./../../images/image-20250514183612141.png" alt="image-20250514183612141"></p><p><img src="/./../../images/image-20250514183634954.png" alt="image-20250514183634954"></p><h3 id="遍历容器元素"><a href="#遍历容器元素" class="headerlink" title="遍历容器元素"></a>遍历容器元素</h3><h4 id="使用迭代器遍历容器元素"><a href="#使用迭代器遍历容器元素" class="headerlink" title="使用迭代器遍历容器元素"></a>使用迭代器遍历容器元素</h4><ul><li><strong>迭代器</strong>：是一种能够遍历容器元素的对象，类似于指针。</li><li><strong>获取迭代器</strong>：容器类通常提供<code>begin()</code>和<code>end()</code>成员函数来获取迭代器的起始和结束位置。</li><li><strong>遍历方法</strong>：可以使用循环结构（如<code>while</code>或<code>for</code>循环）和迭代器逐个访问容器元素。</li></ul><h4 id="使用范围-for循环遍历容器元素"><a href="#使用范围-for循环遍历容器元素" class="headerlink" title="使用范围-for循环遍历容器元素"></a>使用范围-for循环遍历容器元素</h4><ul><li><strong>范围-for循环</strong>：是C++11引入的语法，可以简化容器元素的遍历。</li><li><strong>自动类型推断</strong>：使用<code>auto</code>关键字来推断迭代器的类型，并使用范围-for循环对容器进行遍历。</li></ul><h3 id="容器的遍历和常用操作"><a href="#容器的遍历和常用操作" class="headerlink" title="容器的遍历和常用操作"></a>容器的遍历和常用操作</h3><h4 id="插入和删除元素"><a href="#插入和删除元素" class="headerlink" title="插入和删除元素"></a>插入和删除元素</h4><ul><li><strong>插入元素</strong>：<ul><li>顺序容器中使用<code>push_back()</code>或<code>push_front()</code>函数，分别在容器尾部和头部插入元素。</li><li>有序容器中使用<code>insert()</code>函数，在容器指定位置插入元素。</li></ul></li><li><strong>删除元素</strong>：<ul><li>顺序容器中使用<code>pop_back()</code>或<code>pop_front()</code>函数，分别删除在容器尾部和头部的元素。</li><li>使用<code>erase()</code>函数，删除有序容器和映射中指定位置或者指定键的元素。</li></ul></li></ul><h4 id="查找和替换元素"><a href="#查找和替换元素" class="headerlink" title="查找和替换元素"></a>查找和替换元素</h4><ul><li><strong>查找元素</strong>：<ul><li>有序容器和映射中，使用<code>find()</code>函数在容器中查找指定元素，并返回该元素的迭代器。</li><li>有序容器和映射中，使用<code>count()</code>函数计算容器中指定元素的个数。</li></ul></li><li><strong>替换元素</strong>：<ul><li>可以使用迭代器来直接修改容器中的元素。</li><li>使用下标运算符[]直接修改容器中的元素。</li></ul></li></ul><h4 id="容器大小和容量的操作"><a href="#容器大小和容量的操作" class="headerlink" title="容器大小和容量的操作"></a>容器大小和容量的操作</h4><ul><li><strong>容器大小</strong>：<ul><li>使用容器的成员函数<code>size()</code>函数获取容器中的元素个数。</li><li>使用容器的成员函数<code>empty()</code>函数检查容器是否为空，容器中没有元素则返回true，否则返回false。</li></ul></li><li><strong>容器容量</strong>：<ul><li>使用容器的成员函数<code>capacity()</code>，获取容器重新分配内容之前可以容纳的元素个数。</li><li>使用容器的成员函数<code>reserve()</code>，为容器设置预留的容量，可以避免频繁的重新分配内存。</li></ul></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这些操作涵盖了C++容器的基本使用，包括遍历、插入、删除、查找、替换以及获取容器的大小和容量等。通过这些操作，可以有效地管理和操作容器中的数据。使用迭代器和范围-for循环可以方便地遍历容器，而各种成员函数则提供了对容器元素的增删改查等操作。理解这些基本概念和操作对于在C++中有效地使用容器至关重要。</p><p><img src="/./../../images/image-20250518220951020.png" alt="image-20250518220951020"></p><h3 id="公有成员"><a href="#公有成员" class="headerlink" title="公有成员"></a>公有成员</h3><ul><li><strong>定义</strong>：通过公有访问修饰符<code>public</code>修饰的成员变量或成员函数。</li><li><strong>访问权限</strong>：<ul><li><strong>公有成员变量</strong>：可以被类的对象和类外部代码直接访问和修改。</li><li><strong>公有成员函数</strong>：可以被类的对象和类外部代码调用。</li></ul></li></ul><h3 id="保护成员"><a href="#保护成员" class="headerlink" title="保护成员"></a>保护成员</h3><ul><li><strong>定义</strong>：通过保护访问修饰符<code>protected</code>修饰的成员变量或成员函数。</li><li><strong>访问权限</strong>：<ul><li><strong>保护成员变量</strong>：只能被类的派生类访问和修改。</li><li><strong>保护成员函数</strong>：只能被类的派生类调用。</li></ul></li></ul><h3 id="私有成员"><a href="#私有成员" class="headerlink" title="私有成员"></a>私有成员</h3><ul><li><strong>定义</strong>：通过私有访问修饰符<code>private</code>修饰的成员变量或成员函数。</li><li><strong>访问权限</strong>：<ul><li><strong>私有成员变量</strong>：只能被类的成员函数访问和修改。</li><li><strong>私有成员函数</strong>：只能被类的其他成员函数调用。</li></ul></li></ul><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>公有成员</strong>：具有最宽松的访问权限，可以被类的对象和类外部代码访问。</li><li><strong>保护成员</strong>：具有中等的访问权限，只能被类的派生类访问。</li><li><strong>私有成员</strong>：具有最严格的访问权限，只能被类的成员函数访问。</li></ul><p><img src="/./../../images/image-20250518220805025.png" alt="image-20250518220805025"></p><h3 id="函数覆盖的概念和使用"><a href="#函数覆盖的概念和使用" class="headerlink" title="函数覆盖的概念和使用"></a>函数覆盖的概念和使用</h3><ul><li><strong>函数覆盖</strong>：派生类重写（覆盖）基类中的虚函数，以实现特定行为。这是实现运行时多态性的一种机制。</li><li><strong>使用关键字</strong>：<ul><li>在基类中声明虚函数时，使用关键字<code>virtual</code>来标识。</li><li>在派生类中重写（覆盖）基类中的虚函数。</li></ul></li></ul><h3 id="使用override和final关键字"><a href="#使用override和final关键字" class="headerlink" title="使用override和final关键字"></a>使用override和final关键字</h3><ul><li><strong>override关键字</strong>：<ul><li>在C++中，<code>override</code>和<code>final</code>是两个关键字，用于对虚函数进行重写和类进行继承的修饰。</li><li><code>override</code>关键字帮助我们确保正确地进行函数重写。</li><li><code>final</code>关键字防止派生和重写。</li><li><strong>用法</strong>：<ul><li><code>override</code>关键字可用于派生类中对基类虚函数的重写，以确保正确地进行函数覆盖。</li><li>在派生类中使用<code>override</code>关键字标识对基类中虚函数的重写，可以帮助我们在编译时捕获一些常见的错误，如函数签名不匹配的情况。</li><li>如果派生类中的函数声明使用<code>override</code>关键字，但实际上并没有重写基类中的虚函数，编译器将会发出错误提示。</li></ul></li></ul></li><li><strong>final关键字</strong>：<ul><li><code>final</code>关键字用于修饰类、虚函数或成员函数，表示它们是最终版本，禁止进一步的派生或重写。</li><li><strong>用法</strong>：<ul><li>在类声明中使用<code>final</code>关键字修饰类，表示该类是最终类，不能再被继承。</li><li>在虚函数声明中使用<code>final</code>关键字修饰虚函数，表示该虚函数不能再被派生类重写。</li><li>在成员函数声明中使用<code>final</code>关键字修饰成员函数，表示该成员函数不能在派生类中被重写。</li></ul></li></ul></li></ul><p>总结来说，<code>override</code>和<code>final</code>关键字在C++中用于确保类的继承和函数的重写符合预期，避免错误和歧义。</p><p><img src="/./../../images/image-20250514183659851.png" alt="image-20250514183659851"></p><p><img src="/./../../images/image-20250514183713078.png" alt="image-20250514183713078"></p><h1 id="C-常用总结"><a href="#C-常用总结" class="headerlink" title="C++常用总结"></a>C++常用总结</h1><p>​</p><ol><li><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a><strong>文件操作</strong></h1><ul><li>文件操作通常涉及创建、读取、写入和删除文件。在C++中，可以使用标准库中的<code>&lt;fstream&gt;</code>头文件提供的类，如<code>std::ifstream</code>（输入文件流）、<code>std::ofstream</code>（输出文件流）和<code>std::fstream</code>（输入输出文件流）来进行文件操作。</li></ul></li></ol><p>​文件指针的操作</p><p>在C++中，文件指针用于定位和控制文件中的读写位置。以下是文件指针操作的主要方法：</p><h4 id="获取文件指针的位置"><a href="#获取文件指针的位置" class="headerlink" title="获取文件指针的位置"></a>获取文件指针的位置</h4><ul><li>**<code>tellg()</code>**：用于获取输入文件流的当前读取位置。</li><li>**<code>tellp()</code>**：用于获取输出文件流的当前写入位置。</li></ul><h4 id="设置文件指针的位置"><a href="#设置文件指针的位置" class="headerlink" title="设置文件指针的位置"></a>设置文件指针的位置</h4><ul><li>**<code>seekg(pos)</code>**：将输入文件流的读取位置设置为相对于文件开头的<code>pos</code>位置。</li><li>**<code>seekp(pos)</code>**：将输出文件流的写入位置设置为相对于文件开头的<code>pos</code>位置。</li><li>**<code>seekg(offset, dir)</code> 和 <code>seekp(offset, dir)</code>**：在当前位置的基础上相对于<code>offset</code>进行偏移，<code>dir</code>可以是以下常量之一：<ul><li>**<code>std::ios::beg</code>**：相对于文件开头进行偏移。</li><li>**<code>std::ios::cur</code>**：相对于当前位置进行偏移。</li><li>**<code>std::ios::end</code>**：相对于文件末尾进行偏移。</li></ul></li></ul><h4 id="检查文件指针的有效性"><a href="#检查文件指针的有效性" class="headerlink" title="检查文件指针的有效性"></a>检查文件指针的有效性</h4><ul><li>**<code>good()</code>**：成员函数检查文件指针是否有效。如果文件指针有效，则返回<code>true</code>；否则返回<code>false</code>。</li></ul><ol><li><h1 id="空指针的处理"><a href="#空指针的处理" class="headerlink" title="空指针的处理"></a><strong>空指针的处理</strong></h1><ul><li>空指针是指没有指向任何对象的指针。在C++中，空指针通常用<code>nullptr</code>表示。处理空指针时，需要检查指针是否为空，避免解引用空指针，这会导致程序崩溃。可以使用条件语句来检查指针是否为<code>nullptr</code>。</li></ul></li></ol><p><img src="/./../../images/image-20250514221542740.png" alt="image-20250514221542740"></p><h3 id="空指针的判断和使用"><a href="#空指针的判断和使用" class="headerlink" title="空指针的判断和使用"></a>空指针的判断和使用</h3><ul><li><p><strong>判断空指针</strong>：</p><ul><li><p>使用条件判断语句将目标指针与<code>nullptr</code>进行比较。如果指针为空（即没有指向任何对象），则条件为真；否则为假。</p></li><li><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 指针为空的处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>空指针的特性</strong>：</p><ul><li>空指针没有有效的内存地址，访问空指针指向的对象是不安全的，可能导致程序崩溃或未定义行为。</li><li>将<code>nullptr</code>赋值给指针，可以将指针显式地设置为空指针。</li></ul></li></ul><h3 id="避免空指针的错误"><a href="#避免空指针的错误" class="headerlink" title="避免空指针的错误"></a>避免空指针的错误</h3><ul><li><p><strong>检查动态分配的内存</strong>：</p><ul><li><p>在动态分配内存后，应该检查分配的指针是否为空，以确保内存分配成功。如果分配失败，指针将为<code>nullptr</code>。</p></li><li><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 内存分配失败的处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用指针前检查</strong>：</p><ul><li><p>在使用指针之前，始终检查指针是否为空，并尽量避免访问空指针。</p></li><li><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 安全地使用指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>空指针是C++编程中常见的问题，处理不当可能导致程序崩溃或未定义行为。以下是一些关键点：</p><ol><li><p><strong>判断空指针</strong>：使用条件判断语句将指针与<code>nullptr</code>比较，确保指针不为空后再使用。</p></li><li><p><strong>显式设置空指针</strong>：将<code>nullptr</code>赋值给指针，显式地将指针设置为空。</p></li><li><p><strong>检查动态内存分配</strong>：在动态分配内存后，检查指针是否为空，确保内存分配成功。</p></li><li><p><strong>使用前检查指针</strong>：在每次使用指针之前，检查指针是否为空，避免访问空指针。</p></li><li><h1 id="常用版本特性"><a href="#常用版本特性" class="headerlink" title="常用版本特性"></a><strong>常用版本特性</strong></h1><ul><li>这可能指的是C++语言的不同版本中引入的新特性。例如，C++11引入了自动类型推断（<code>auto</code>）、范围<code>for</code>循环、智能指针等。了解不同版本的新特性可以帮助开发者编写更现代、更高效的代码。</li></ul><p><img src="/./../../images/image-20250514221601991.png" alt="image-20250514221601991"></p><h3 id="C-11-的特性和改进"><a href="#C-11-的特性和改进" class="headerlink" title="C++11 的特性和改进"></a>C++11 的特性和改进</h3><ol><li><strong>自动类型推导</strong>：<ul><li>引入了关键字 <code>auto</code>，可以根据初始化表达式的类型自动推导变量的类型。这简化了代码编写，特别是在处理复杂类型时。</li></ul></li><li><strong>统一的初始化语法</strong>：<ul><li>引入了初始化列表语法 <code>&#123;&#125;</code>，可以用于初始化数组、容器、结构体等各种类型的对象。这种语法提供了一种统一且直观的方式来初始化对象。</li></ul></li><li><strong>范围-based for 循环</strong>：<ul><li>引入了新的循环语法 <code>for (element : sequence)</code>，用于遍历容器、数组等序列中的元素。这种循环语法使代码更加简洁和易读。</li></ul></li><li><strong>空指针常量</strong>：<ul><li>引入了关键字 <code>nullptr</code>，用于表示空指针。它可以用来替代旧的表示空指针的 <code>NULL</code> 或者 <code>0</code>，提供了更强的类型安全。</li></ul></li><li><strong>强类型枚举</strong>：<ul><li>引入了新的枚举语法，允许为枚举类型指定底层类型，并提供了更强的类型检查。这使得枚举类型更加安全和灵活。</li></ul></li><li><strong>Lambda 表达式</strong>：<ul><li>引入了匿名函数的概念，允许在代码中定义小型的匿名函数。Lambda 表达式可以捕获外部变量，并可以作为函数对象使用，这在编写回调函数和处理事件时非常有用。</li></ul></li><li><strong>智能指针</strong>：<ul><li>引入了三种智能指针类型：<code>std::unique_ptr</code>、<code>std::shared_ptr</code> 和 <code>std::weak_ptr</code>。这些智能指针类型简化了动态内存管理，自动管理内存的分配和释放，减少了内存泄漏的风险。</li></ul></li><li><strong>并发编程支持</strong>：<ul><li>引入了线程库、互斥量、条件变量等多线程和并发编程的支持。这些特性使得C++能够更好地支持并发编程，方便开发者编写并发程序。</li></ul></li></ol><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>C++11标准引入了大量新特性和改进，这些特性不仅提高了代码的可读性和安全性，还简化了代码编写和内存管理。通过使用这些新特性，开发者可以编写更简洁、更安全、更高效的代码，充分利用C++语言的强大功能。同时，这些特性也使得C++语言在现代软件开发中更具竞争力，适用于各种应用场景。</p></li><li><h1 id="常见的编码技巧和最佳实践"><a href="#常见的编码技巧和最佳实践" class="headerlink" title="常见的编码技巧和最佳实践"></a><strong>常见的编码技巧和最佳实践</strong></h1><ul><li>编码技巧和最佳实践包括代码的组织结构、命名约定、内存管理、错误处理等。例如，使用有意义的变量名、避免魔法数字、编写可重用的代码、进行异常处理等。这些实践有助于提高代码的可读性、可维护性和性能。</li></ul><p><img src="/./../../images/image-20250514221828341.png" alt="image-20250514221828341"></p></li></ol><p><img src="/./../../images/image-20250514221850561.png" alt="image-20250514221850561"></p><p><img src="/./../../images/image-20250514221906985.png" alt="image-20250514221906985"></p><p><img src="/./../../images/image-20250514221943742.png" alt="image-20250514221943742"></p><ol><li><h1 id="一些友善的建议"><a href="#一些友善的建议" class="headerlink" title="一些友善的建议"></a><strong>一些友善的建议</strong></h1><ul><li>这可能包括编程时的一些软技能建议，如团队合作、代码审查、持续学习等。友善的建议有助于提高开发者的工作效率和团队的整体表现。</li></ul></li></ol><p><img src="/./../../images/image-20250514222009032.png" alt="image-20250514222009032"></p><p><img src="/./../../images/image-20250514222021860.png" alt="image-20250514222021860"></p><p><img src="/./../../images/image-20250514222048606.png" alt="image-20250514222048606"></p><h1 id="车载事业部C-代码规范培训"><a href="#车载事业部C-代码规范培训" class="headerlink" title="车载事业部C++代码规范培训"></a>车载事业部C++代码规范培训</h1><p><img src="/./../../images/image-20250514222156466.png" alt="image-20250514222156466"></p><p><img src="/./../../images/image-20250515212602980.png" alt="image-20250515212602980"></p><p><img src="/./../../images/image-20250515215400176.png" alt="image-20250515215400176"></p><h2 id="1-预处理宏"><a href="#1-预处理宏" class="headerlink" title="1. 预处理宏"></a>1. 预处理宏</h2><p>主要目的是<strong>避免宏带来的问题</strong>，给出了一些规范和建议：</p><ul><li>不要在 .h 文件中定义宏。<ul><li>避免头文件被多处引用时意外影响其它代码。</li></ul></li><li>在马上要使用时才进行 #define，使用后要立即 #undef。<ul><li>这样可以减少宏对其它代码的影响，做到用完即丢。</li></ul></li><li>不要只是对已经存在的宏使用 #undef，选择一个不会冲突的名称。<ul><li>避免冲突和潜在的命名污染。</li></ul></li><li>不要试图使用展开后会导致 C++ 构造不稳定的宏，否则至少要附上文档说明其行为。<ul><li>指的是有些宏展开后可能对 C++ 构造（如类、函数等）产生不可预期影响，因此要谨慎使用并注明。</li></ul></li><li>不要用 ## 处理函数、类和变量的名字。<ul><li>这是宏拼接符，容易导致名字混淆，可读性和可维护性差。</li></ul></li></ul><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>这些规范旨在<strong>减少预处理宏带来的副作用</strong>，提高代码的可维护性和安全性。</p><hr><h2 id="2-整型变量的定义"><a href="#2-整型变量的定义" class="headerlink" title="2. 整型变量的定义"></a>2. 整型变量的定义</h2><p>主要讲述<strong>整型变量的选择</strong>，以及推荐用法：</p><ul><li><p><strong>优先用 C++ 内建类型 int。</strong></p></li><li><p>需要不同大小时建议用 <code>&lt;stdint.h&gt;</code> 里的精确整型 如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int16_t  int32_t  int32_t</span><br></pre></td></tr></table></figure><ul><li>这样可以明确表达变量的位数，提升代码可移植性和准确性。</li></ul></li><li><p>如果变量可能超过 int 能表示的范围，比如大于 2^31（2GiB），就应该直接用 64 位变量 int64_t。</p><ul><li>这样可以避免溢出和数据错误。</li></ul></li><li><p>即使值不会超过 int 表示的范围，在计算过程中也可能溢出。</p><ul><li>所以宁可用大类型，不要“拿不准时用更大的类型”。</li></ul></li></ul><h3 id="介绍："><a href="#介绍：" class="headerlink" title="&lt;stdint.h&gt; 介绍："></a><code>&lt;stdint.h&gt;</code> 介绍：</h3><ul><li>里面定义了 <code>int16_t</code>、<code>uint32_t</code>、<code>int64_t</code> 等精确大小的整型。</li><li>如果需要保证整型大小，可以用这些类型代替 <code>short</code>、<code>unsigned long long</code> 等。</li></ul><hr><h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>宏的使用要谨慎，避免污染、冲突、难以维护。</strong><ul><li><strong>整型变量建议用精确类型，防止溢出和类型不确定的问题，提升代码的健壮性和可移植性</strong></li></ul></li></ul><h1 id="DTS"><a href="#DTS" class="headerlink" title="DTS"></a>DTS</h1><h3 id="一、什么是DTS"><a href="#一、什么是DTS" class="headerlink" title="一、什么是DTS"></a>一、什么是DTS</h3><p>DTS是一种描述硬件设备信息的文件格式，主要用于Linux内核中。它以文本的形式描述硬件设备的属性、连接关系等信息，然后通过设备树编译器（DTC）将其编译成设备树二进制文件（.dtb），供内核在启动时加载和解析，从而实现对硬件设备的识别和初始化。</p><h3 id="二、需要了解DTS的情况"><a href="#二、需要了解DTS的情况" class="headerlink" title="二、需要了解DTS的情况"></a>二、需要了解DTS的情况</h3><ol><li><strong>使用Linux内核的嵌入式开发</strong><ul><li>如果你开发的嵌入式系统使用Linux内核，那么了解DTS是非常重要的。因为Linux内核从3.5版本开始，对于许多嵌入式平台（如ARM、RISC-V等）都推荐使用设备树来描述硬件。例如，在开发基于ARM架构的嵌入式设备时，你需要通过DTS文件来告诉内核硬件设备的详细信息，如GPIO引脚的用途、外设的地址范围、时钟配置等。只有这样，内核才能正确地初始化和驱动硬件设备。</li><li>例如，对于一个带有多功能GPIO引脚的嵌入式开发板，你可能需要在DTS文件中指定某个GPIO引脚用于I2C通信，而另一个引脚用于普通数字输入输出。如果DTS文件配置错误，可能会导致硬件设备无法正常工作。</li></ul></li><li><strong>硬件平台的移植和定制开发</strong><ul><li>当你需要将Linux内核移植到一个新的硬件平台或者对现有硬件平台进行定制开发时，DTS文件的编写和修改是必不可少的。因为不同的硬件平台有不同的硬件架构和设备配置，你需要通过DTS文件来适配这些差异。比如，当你将一个Linux内核版本从一个开发板移植到另一个具有不同外设的开发板时，就需要修改DTS文件，以确保内核能够正确识别和管理新开发板上的硬件设备。</li></ul></li><li><strong>驱动开发</strong><ul><li>对于嵌入式系统中的驱动开发，DTS文件提供了硬件设备的接口信息。驱动开发者可以通过DTS文件获取硬件设备的寄存器地址、中断号等关键信息，从而编写出能够正确与硬件设备交互的驱动程序。例如，开发一个SPI设备的驱动时，驱动代码需要从DTS文件中获取SPI控制器的设备树节点信息，包括SPI设备的片选号、时钟速率等参数，才能实现对SPI设备的有效控制。</li></ul></li></ol><h3 id="三、不需要了解DTS的情况"><a href="#三、不需要了解DTS的情况" class="headerlink" title="三、不需要了解DTS的情况"></a>三、不需要了解DTS的情况</h3><ol><li><strong>使用非Linux内核的嵌入式开发</strong><ul><li>如果你的嵌入式系统使用的是其他操作系统（如RTOS，即实时操作系统，像FreeRTOS、μC&#x2F;OS-II等）或者无操作系统，那么DTS文件通常不会被用到。因为这些系统通常采用不同的方式来管理硬件设备，例如通过直接在代码中硬编码硬件设备的地址和配置信息，而不是依赖于像DTS这样的设备树描述机制。</li></ul></li><li><strong>使用封装良好的开发平台和硬件抽象层</strong><ul><li>在一些嵌入式开发平台中，硬件厂商可能已经提供了高度封装的硬件抽象层（HAL）或者中间件，这些抽象层直接隐藏了硬件设备的具体细节，包括DTS文件的使用。在这种情况下，开发者可以直接调用抽象层提供的接口函数来操作硬件设备，而无需关心DTS文件。例如，一些基于STM32微控制器的开发平台，通过STM32 HAL库封装了硬件操作，开发者可以直接使用库函数来控制GPIO、定时器等外设，而无需编写DTS文件。</li></ul></li></ol><h1 id="QNX共享内存"><a href="#QNX共享内存" class="headerlink" title="QNX共享内存"></a>QNX共享内存</h1><p><img src="/./../../images/image-20250521153325554.png" alt="image-20250521153325554"></p><h3 id="一、什么是QNX共享内存"><a href="#一、什么是QNX共享内存" class="headerlink" title="一、什么是QNX共享内存"></a>一、什么是QNX共享内存</h3><p>QNX是一个基于微内核的实时操作系统，其设计目标是提供高效的进程间通信（IPC）和资源管理机制。共享内存是QNX中一种重要的进程间通信方式，允许多个进程共享同一块物理内存区域，从而实现高效的数据交换和通信。</p><p>在QNX中，共享内存的使用通常涉及以下几个关键概念：</p><ol><li><strong>共享内存段（Shared Memory Segment）</strong>：这是共享内存的基本单位，由一个或多个进程创建和访问。</li><li><strong>内存映射（Memory Mapping）</strong>：通过内存映射机制，将共享内存段映射到进程的地址空间中，使得进程可以像访问普通内存一样访问共享内存。</li><li><strong>同步机制（Synchronization）</strong>：由于多个进程可能同时访问共享内存，因此需要使用同步机制（如信号量、互斥锁等）来避免数据竞争和不一致性问题。</li></ol><p><img src="/./../../images/image-20250521153608341.png" alt="image-20250521153608341"></p><p><img src="/./../../images/image-20250521153633809.png" alt="image-20250521153633809"></p><h3 id="QNX共享内存的优缺点"><a href="#QNX共享内存的优缺点" class="headerlink" title="QNX共享内存的优缺点"></a>QNX共享内存的优缺点</h3><ol><li><strong>优点</strong><ul><li><strong>高效性</strong>：共享内存是一种非常高效的进程间通信方式，因为它避免了数据的多次复制和传输。多个进程可以直接访问同一块物理内存，从而大大提高了数据交换的效率。</li><li><strong>灵活性</strong>：QNX的共享内存机制提供了灵活的控制方式，可以通过多种系统调用和库函数来创建、管理和访问共享内存。同时，还可以结合同步机制来实现复杂的并发控制。</li><li><strong>实时性</strong>：在实时系统中，共享内存可以快速地传递数据，满足实时性要求。例如，在高精度的工业控制系统中，共享内存可以用于实时传递传感器数据和控制指令。</li></ul></li><li><strong>缺点</strong><ul><li><strong>同步复杂性</strong>：由于多个进程可能同时访问共享内存，因此需要使用同步机制来避免数据竞争和不一致性问题。同步机制的使用增加了编程的复杂性，需要开发者仔细设计和实现。</li><li><strong>安全性问题</strong>：共享内存的访问权限需要严格控制，否则可能会导致安全问题。例如，如果一个恶意进程访问了共享内存，可能会篡改数据或导致系统崩溃。因此，在使用共享内存时，需要确保只有授权的进程才能访问共享内存。</li><li><strong>内存管理复杂性</strong>：共享内存的生命周期管理需要特别注意。如果某个进程意外崩溃或退出，可能会导致共享内存无法被正确释放，从而造成内存泄漏。因此，需要在程序设计中仔细处理共享内存的创建、使用和销毁过程。</li></ul></li></ol><h3 id="是否需要了解QNX共享内存"><a href="#是否需要了解QNX共享内存" class="headerlink" title="是否需要了解QNX共享内存"></a>是否需要了解QNX共享内存</h3><p>是否需要了解QNX共享内存，取决于你的开发需求和目标平台：</p><ol><li><strong>需要了解的情况</strong><ul><li>如果你正在开发基于QNX操作系统的嵌入式系统，尤其是涉及到多进程协作、实时数据交换或资源管理的场景，那么了解QNX共享内存是非常重要的。掌握共享内存的使用方法可以帮助你设计出高效、可靠的系统架构，提高系统的性能和实时性。</li><li>例如，在开发一个实时监控系统时，多个进程需要实时交换图像数据和传感器数据。通过使用QNX共享内存，可以快速地传递这些数据，同时结合同步机制确保数据的一致性和完整性。</li></ul></li><li><strong>不需要了解的情况</strong><ul><li>如果你的嵌入式系统不使用QNX操作系统，或者你的开发场景中不需要使用共享内存机制（例如，系统中只有一个进程，或者数据交换量非常小），那么了解QNX共享内存可能不是必要的。</li><li>另外，如果你使用的是封装良好的开发框架或中间件，这些框架可能已经隐藏了共享内存的实现细节，你只需要调用相关的接口函数即可实现进程间通信，而无需深入了解共享内存的底层机制。</li></ul></li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src="/./../../images/image-20250521154241355.png" alt="image-20250521154241355"></p><p><img src="/./../../images/image-20250521154302419.png" alt="image-20250521154302419"></p><p>一个使用共享内存（Shared Memory）和互斥锁（Mutex）在QNX操作系统中进行进程间通信（IPC）的示例。下面我将详细解释这个示例的代码和运行结果。</p><h3 id="示例代码解释"><a href="#示例代码解释" class="headerlink" title="示例代码解释"></a>示例代码解释</h3><h4 id="shmemcreator-c"><a href="#shmemcreator-c" class="headerlink" title="shmemcreator.c"></a><code>shmemcreator.c</code></h4><p>这个程序创建共享内存和一个信号量，并在共享内存中写入一些文本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shmemcreator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *programname = <span class="string">&quot;shmemcreator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">shmem_t</span> *ptr;</span><br><span class="line">    <span class="type">pthread_mutexattr_t</span> myattr;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> myshmmutex;</span><br><span class="line"></span><br><span class="line">    pthread_mutexattr_init(&amp;myattr);</span><br><span class="line">    pthread_mutexattr_setpshared(&amp;myattr, PTHREAD_PROCESS_SHARED);</span><br><span class="line">    pthread_mutex_init(&amp;ptr-&gt;myshmemmutex, &amp;myattr);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;ptr-&gt;myshmemmutex);</span><br><span class="line">    <span class="built_in">strcpy</span>(ptr-&gt;text, <span class="string">&quot;Text by shmemcreator.c&quot;</span>); <span class="comment">/* write to the shared memory */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Shared memory created and semaphore initialized to 0.\n&quot;</span>,</span><br><span class="line">            programname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Wrote text &#x27;%s&#x27; to shared memory.\n&quot;</span>,</span><br><span class="line">            programname, ptr-&gt;text);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Sleeping for 20 seconds. While this program is sleeping\n&quot;</span>,</span><br><span class="line">            programname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: run &#x27;example_shmem_user&#x27;\n&quot;</span>, programname, programname);</span><br><span class="line">    sleep(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Woke up. Now unlocking the mutex.\n&quot;</span>, programname);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;ptr-&gt;myshmemmutex);</span><br><span class="line"></span><br><span class="line">    close(fd); <span class="comment">// Closing the file descriptor</span></span><br><span class="line">    munmap(ptr, <span class="keyword">sizeof</span>(<span class="type">shmem_t</span>)); <span class="comment">// removing the mapping</span></span><br><span class="line">    shm_unlink(<span class="string">&quot;/myshmemobject&quot;</span>); <span class="comment">// Delete the shared memory object</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shmemuser-c"><a href="#shmemuser-c" class="headerlink" title="shmemuser.c"></a><code>shmemuser.c</code></h4><p>这个程序打开共享内存对象，等待信号量，访问共享内存并读取其中的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shmemcreator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *programname = <span class="string">&quot;shmemuser&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">shmem_t</span> *ptr;</span><br><span class="line"></span><br><span class="line">    fd = shm_open(<span class="string">&quot;/myshmemobject&quot;</span>, O_RDWR, S_IRWXU);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: error opening the shared memory object: %s\n&quot;</span>,</span><br><span class="line">                programname, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr = mmap(<span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">shmem_t</span>),</span><br><span class="line">               PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Waiting on the mutex. Run &#x27;pidin&#x27;. I should be MUTEX_blocked.\n&quot;</span>,</span><br><span class="line">            programname);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;ptr-&gt;myshmemmutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Got the mutex, now accessing shared memory\n&quot;</span>, programname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Shared memory contains &#x27;%s&#x27;\n&quot;</span>, programname, ptr-&gt;text);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;ptr-&gt;myshmemmutex);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    munmap(ptr, <span class="keyword">sizeof</span>(<span class="type">shmem_t</span>));</span><br><span class="line">    <span class="keyword">return</span> (EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ./shmemcreator</span><br><span class="line">shmemcreator: Shared memory created and semaphore initialized to <span class="number">0.</span></span><br><span class="line">shmemcreator: Wrote text <span class="string">&#x27;Text by shmemcreator.c&#x27;</span> to shared memory</span><br><span class="line">shmemcreator: Sleeping <span class="keyword">for</span> <span class="number">20</span> seconds. While this program is sleeping</span><br><span class="line">shmemcreator: run <span class="string">&#x27;example_shmem_user&#x27;</span></span><br><span class="line"></span><br><span class="line"># ./shmemuser</span><br><span class="line">shmemuser: Waiting on the mutex. Run <span class="string">&#x27;pidin&#x27;</span>. I should be MUTEX_blocked.</span><br><span class="line">shmemuser: Got the mutex, now accessing shared memory</span><br><span class="line">shmemuser: The shared memory contains <span class="string">&#x27;Text by shmemcreator.c&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="运行结果解释"><a href="#运行结果解释" class="headerlink" title="运行结果解释"></a>运行结果解释</h4><p><strong><code>shmemcreator</code> 程序</strong>：</p><ul><li>创建共享内存和信号量，初始化为0。</li><li>写入文本 <code>&quot;Text by shmemcreator.c&quot;</code> 到共享内存。</li><li>打印共享内存创建和信号量初始化的信息。</li><li>打印写入共享内存的文本。</li><li>打印程序将要休眠20秒的信息。</li><li>休眠20秒。</li><li>解锁信号量。</li><li>关闭文件描述符，解除映射，删除共享内存对象。</li></ul><p><strong><code>shmemuser</code> 程序</strong>：</p><ul><li>打开共享内存对象。</li><li>将共享内存对象映射到进程地址空间。</li><li>等待信号量（此时会被阻塞，因为 <code>shmemcreator</code> 程序已经锁定了信号量）。</li><li>获取信号量后，访问共享内存并读取其中的内容。</li><li>打印读取到的共享内存内容。</li><li>解锁信号量。</li><li>关闭文件描述符，解除映射。</li></ul><p>运行 <code>shmemcreator</code> 程序后，它会创建共享内存，写入文本，然后休眠20秒。在此过程中，运行 <code>shmemuser</code> 程序，它会等待信号量，因为 <code>shmemcreator</code> 程序已经锁定了信号量。20秒后，<code>shmemcreator</code> 程序解锁信号量，<code>shmemuser</code> 程序获取信号量，访问共享内存并读取其中的内容。</p><p>这个示例展示了如何在QNX操作系统中使用共享内存和互斥锁进行进程间通信。<code>shmemcreator</code> 程序创建共享内存并写入数据，然后休眠一段时间。<code>shmemuser</code> 程序等待信号量，获取信号量后访问共享内存并读取数据。通过这种方式，可以实现多个进程之间的高效数据交换。</p><h2 id="通俗解释QNX程序"><a href="#通俗解释QNX程序" class="headerlink" title="通俗解释QNX程序"></a>通俗解释QNX程序</h2><p>想象你和朋友们在做一个团队项目，需要共享一些信息。为了避免混乱，你们决定用一个特别的“共享笔记本”来记录信息。这个笔记本就像电脑里的“共享内存”，大家都能看和写。</p><ol><li><strong>创建共享笔记本</strong>：<ul><li>你（<code>shmemcreator</code>程序）首先创建了这个共享笔记本，并写下了第一条信息：“Text by shmemcreator.c”。</li><li>然后你锁上了笔记本（使用互斥锁），这样其他人就不能同时写入，避免信息混乱。</li><li>你告诉其他人，你要休息20秒（程序休眠20秒），在这期间他们可以开始读取笔记本。</li></ul></li><li><strong>读取共享笔记本</strong>：<ul><li>你的朋友（<code>shmemuser</code>程序）看到你锁上了笔记本，就等着（等待互斥锁）。</li><li>20秒后，你回来解锁了笔记本，告诉你的朋友可以看了。</li><li>你的朋友打开笔记本，看到了你写的信息：“Text by shmemcreator.c”，然后他把这条信息告诉了团队里的其他人。</li></ul></li><li><strong>结束工作</strong>：<ul><li>你和你的朋友都完成了工作，你把笔记本收起来，这样其他人就不能再次访问它了。</li></ul></li></ol><p><strong>运行结果</strong>：</p><ul><li>你先创建了共享内存，写入了信息，然后休息了20秒。</li><li>在这期间，你的朋友尝试读取共享内存，但因为你锁定了它，所以他必须等待。</li><li>20秒后，你解锁了共享内存，你的朋友读取了里面的信息，并告诉了团队其他人。</li></ul><p>20秒等待主要是为了演示和测试的目的：</p><ol><li><p><strong>演示互斥锁的效果</strong>：<code>shmemcreator</code>程序通过锁定互斥锁来确保在它休眠的20秒内，<code>shmemuser</code>程序能够体验到等待互斥锁释放的过程。这展示了互斥锁的同步机制，即一个程序在访问共享资源时如何等待另一个程序释放锁。(你有足够的时间完成所有与笔记本相关的操作)</p></li><li><p><strong>测试共享内存的访问</strong>：通过在写入数据后休眠，<code>shmemcreator</code>程序确保了<code>shmemuser</code>程序在其休眠期间运行并尝试读取共享内存。这样可以测试<code>shmemuser</code>程序是否能够正确地等待互斥锁，以及在互斥锁释放后是否能够成功读取共享内存中的数据。(其他人不会在你完成之前干扰笔记本中的内容。)</p></li><li><p><strong>模拟实际应用场景</strong>：在实际应用中，可能存在一个程序需要在完成数据写入后，让另一个程序来处理这些数据的情况。通过休眠20秒，<code>shmemcreator</code>程序模拟了这种场景，即在一个程序完成数据处理后，另一个程序开始处理这些数据。(当你解锁笔记本时，其他人可以安全地访问最新的、完整的信息。)</p></li><li><p><strong>为什么你的朋友不能自己打开笔记本？</strong></p><ul><li>因为你在笔记本上加了一把锁（这就像是电脑里的互斥锁）。这把锁是为了防止大家同时写入笔记本，造成信息混乱。所以，只有你（或者有钥匙的人）能打开这个锁，其他人必须等待。</li></ul></li><li><p><strong>为什么一定要等20秒后才能打开给他看？</strong></p><ul><li>你告诉团队，你要休息20秒。在这期间，你的朋友不能打开笔记本，因为笔记本被锁住了。这20秒就像是你处理一些事情的时间，比如写一些重要的信息到笔记本里。</li></ul></li><li><p><strong>如果我打开了，不就是两个人一起看了吗？</strong></p><ul><li>当你20秒后回来，你打开了笔记本的锁，这时候你的朋友就可以看了。但是，即使他看了，也只有一个人能同时写入笔记本，因为每次只能有一个人拿着钥匙（解锁）。这样，其他人就不会同时写入，造成混乱。</li></ul></li></ol><h1 id="C语言编码规范"><a href="#C语言编码规范" class="headerlink" title="C语言编码规范"></a>C语言编码规范</h1><p><img src="/./../../images/image-20250521164427381.png" alt="image-20250521164427381"></p><p><img src="/./../../images/image-20250521164537900.png" alt="image-20250521164537900"></p><p><img src="/./../../images/image-20250521164502982.png" alt="image-20250521164502982"></p><h3 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h3><ol><li><strong>组成</strong>：<ul><li>只能包含字母、数字和下划线。</li><li>不能以数字开头。</li><li>下划线不能出现在开头或结尾。</li></ul></li><li><strong>目的</strong>：<ul><li>让代码更易读。</li><li>避免混淆，例如 <code>variable_name</code> 和 <code>variable___name</code>。</li></ul></li><li><strong>命名原则</strong>：<ul><li>使用完整的英文描述。</li><li>遵循“最小长度 &amp; 最大信息”原则，谨慎使用缩写。</li></ul></li><li><strong>说明</strong>：<ul><li>如果缩写，需在代码中统一使用。例如，<code>num</code> 代表 <code>number</code>，则全程使用 <code>num</code>。</li></ul></li></ol><p>这样命名标识符可以让代码更清晰、更一致。</p><p><img src="/./../../images/image-20250521164739687.png" alt="image-20250521164739687"></p><p><strong>规则</strong>：</p><ul><li>文件名必须全部小写。</li><li>单词之间用下划线分隔。</li><li>文件后缀只能是 <code>.h</code> 或 <code>.c</code>。</li></ul><p><strong>正确示例</strong>：</p><ul><li><code>bw_media_scan_service.c</code></li><li><code>bw_media_scan_service.h</code></li></ul><p><strong>错误示例</strong>：</p><ul><li><code>MediaScanner.inc</code> （文件名不对）</li><li><code>mediascanner.cc</code> （文件名和后缀都不对）</li><li><code>Media_Scanner.hpp</code> （文件名和后缀都不对）</li></ul><p><img src="/./../../images/image-20250521165229163.png" alt="image-20250521165229163"></p><p><img src="/./../../images/image-20250521165317163.png" alt="image-20250521165317163"></p><p><img src="/./../../images/image-20250521165423756.png" alt="image-20250521165423756"></p><p><img src="/./../../images/image-20250521165442890.png" alt="image-20250521165442890"></p><p><img src="/./../../images/image-20250521165606544.png" alt="image-20250521165606544"></p><p><img src="/./../../images/image-20250521171346648.png" alt="image-20250521171346648"></p><h1 id="智能汽车技术培训-操作系统基础"><a href="#智能汽车技术培训-操作系统基础" class="headerlink" title="智能汽车技术培训-操作系统基础"></a>智能汽车技术培训-操作系统基础</h1><p><img src="/./../../images/image-20250521171816673.png" alt="image-20250521171816673"></p><p><img src="/./../../images/image-20250521171850212.png" alt="image-20250521171850212"></p>]]></content>
      
      
      <categories>
          
          <category> 车载c知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 车载C知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell语法复习</title>
      <link href="/2024/08/07/test/shell%E8%AF%AD%E6%B3%95%E5%A4%8D%E4%B9%A0/"/>
      <url>/2024/08/07/test/shell%E8%AF%AD%E6%B3%95%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>以下是完善后的 Markdown 文件内容，标题已添加超链接：</p><hr><h1 id="Linux硬件开发常用Shell指令笔记"><a href="#Linux硬件开发常用Shell指令笔记" class="headerlink" title="Linux硬件开发常用Shell指令笔记"></a>Linux硬件开发常用Shell指令笔记</h1><h2 id="一、系统信息查看"><a href="#一、系统信息查看" class="headerlink" title="一、系统信息查看"></a><a href="#%E4%B8%80%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E6%9F%A5%E7%9C%8B">一、系统信息查看</a></h2><ol><li><p><strong>查看系统信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统内核版本、主机名、硬件架构等详细信息。</li><li><strong>用途</strong>：确认系统环境是否符合开发要求。</li></ul></li><li><p><strong>查看CPU信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示CPU的详细信息，包括型号、核心数、主频等。</li><li><strong>用途</strong>：确认CPU性能是否满足需求。</li></ul></li><li><p><strong>查看内存信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/meminfo</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统的内存信息，包括总内存、可用内存等。</li><li><strong>用途</strong>：评估内存是否足够支持程序运行。</li></ul></li><li><p><strong>查看系统负载</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uptime</span></span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统当前的负载情况，包括平均负载值。</li><li><strong>用途</strong>：监控系统运行状态，判断是否需要优化。</li></ul></li></ol><hr><h2 id="二、硬件设备检测"><a href="#二、硬件设备检测" class="headerlink" title="二、硬件设备检测"></a><a href="#%E4%BA%8C%E7%A1%AC%E4%BB%B6%E8%AE%BE%E5%A4%87%E6%A3%80%E6%B5%8B">二、硬件设备检测</a></h2><ol><li><p><strong>查看设备文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：列出系统中所有设备文件。</li><li><strong>用途</strong>：确认设备是否被正确识别。</li></ul></li><li><p><strong>查看USB设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsusb</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示当前连接的USB设备信息。</li><li><strong>用途</strong>：检测USB接口的硬件设备是否连接成功。</li></ul></li><li><p><strong>查看PCI设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lspci</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统中所有PCI设备信息。</li><li><strong>用途</strong>：确认PCI接口的硬件设备是否被识别。</li></ul></li><li><p><strong>查看硬件信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lshw</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：详细列出系统中的硬件信息，包括CPU、内存、硬盘等。</li><li><strong>用途</strong>：全面了解硬件配置。</li></ul></li></ol><hr><h2 id="三、文件系统操作"><a href="#三、文件系统操作" class="headerlink" title="三、文件系统操作"></a><a href="#%E4%B8%89%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C">三、文件系统操作</a></h2><ol><li><p><strong>查看文件系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示文件系统的磁盘使用情况，包括挂载点、总容量、已用容量等。</li><li><strong>用途</strong>：确认存储空间是否足够。</li></ul></li><li><p><strong>查看文件类型</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file &lt;文件名&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示文件的类型信息。</li><li><strong>用途</strong>：确认文件格式是否符合要求。</li></ul></li><li><p><strong>挂载文件系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount &lt;设备&gt; &lt;挂载点&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：将设备挂载到指定的挂载点。</li><li><strong>用途</strong>：挂载外部存储设备。</li></ul></li><li><p><strong>卸载文件系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount &lt;挂载点&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：卸载指定的挂载点。</li><li><strong>用途</strong>：安全地卸载外部存储设备。</li></ul></li></ol><hr><h2 id="四、网络操作"><a href="#四、网络操作" class="headerlink" title="四、网络操作"></a><a href="#%E5%9B%9B%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C">四、网络操作</a></h2><ol><li><p><strong>查看网络接口</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示网络接口的配置信息，包括IP地址、子网掩码等。</li><li><strong>用途</strong>：确认网络接口是否正常。<strong>注意</strong>：在现代Linux系统中，<code>ip addr</code> 更常用。</li></ul></li><li><p><strong>查看网络连接</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示当前的网络连接状态。</li><li><strong>用途</strong>：调试网络通信问题。<strong>注意</strong>：在现代Linux系统中，<code>ss -an</code> 更常用。</li></ul></li><li><p><strong>网络测试</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping &lt;IP地址&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：测试与指定IP地址的网络连通性。</li><li><strong>用途</strong>：确认网络连接是否正常。</li></ul></li><li><p><strong>查看DNS配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/resolv.conf</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示DNS服务器的配置信息。</li><li><strong>用途</strong>：确认DNS配置是否正确。</li></ul></li></ol><hr><h2 id="五、系统管理"><a href="#五、系统管理" class="headerlink" title="五、系统管理"></a><a href="#%E4%BA%94%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86">五、系统管理</a></h2><ol><li><p><strong>查看进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示系统中所有进程的详细信息。</li><li><strong>用途</strong>：监控进程运行状态。</li></ul></li><li><p><strong>杀死进程</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> &lt;进程ID&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：终止指定的进程。</li><li><strong>用途</strong>：停止异常运行的进程。</li></ul></li><li><p><strong>查看日志</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/messages</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：查看系统日志文件。</li><li><strong>用途</strong>：调试系统运行中的问题。<strong>注意</strong>：在现代Linux系统中，<code>journalctl</code> 更常用。</li></ul></li><li><p><strong>更新系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get upgrade</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：更新系统软件包。</li><li><strong>用途</strong>：确保系统环境是最新的。适用于基于Debian&#x2F;Ubuntu的系统。</li></ul></li></ol><hr><h2 id="六、脚本与自动化"><a href="#六、脚本与自动化" class="headerlink" title="六、脚本与自动化"></a><a href="#%E5%85%AD%E8%84%9A%E6%9C%AC%E4%B8%8E%E8%87%AA%E5%8A%A8%E5%8C%96">六、脚本与自动化</a></h2><ol><li><p><strong>运行Shell脚本</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;脚本文件&gt;.sh</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：执行Shell脚本文件。</li><li><strong>用途</strong>：自动化执行一系列命令。</li></ul></li><li><p><strong>查看脚本权限</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l &lt;脚本文件&gt;.sh</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：查看脚本文件的权限。</li><li><strong>用途</strong>：确保脚本具有可执行权限。</li></ul></li><li><p><strong>设置脚本权限</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x &lt;脚本文件&gt;.sh</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：为脚本文件设置可执行权限。</li><li><strong>用途</strong>：确保脚本可以正常运行。</li></ul></li></ol><hr><h2 id="七、硬件调试"><a href="#七、硬件调试" class="headerlink" title="七、硬件调试"></a><a href="#%E4%B8%83%E7%A1%AC%E4%BB%B6%E8%B0%83%E8%AF%95">七、硬件调试</a></h2><ol><li><p><strong>查看串口设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep <span class="built_in">tty</span></span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：显示串口设备的初始化信息。</li><li><strong>用途</strong>：确认串口设备是否被正确识别。</li></ul></li><li><p><strong>查看GPIO状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/class/gpio/gpio&lt;号&gt;/value</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：查看指定GPIO引脚的状态。</li><li><strong>用途</strong>：调试GPIO相关的硬件问题。</li></ul></li><li><p><strong>设置GPIO状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> &lt;值&gt; &gt; /sys/class/gpio/gpio&lt;号&gt;/value</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：设置指定GPIO引脚的状态。</li><li><strong>用途</strong>：控制GPIO引脚。</li></ul></li><li><p><strong>查看I2C设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i2cdetect -y &lt;总线号&gt;</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：扫描I2C总线上的设备。</li><li><strong>用途</strong>：确认I2C设备是否被正确识别。</li></ul></li><li><p><strong>查看SPI设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> /dev/spi*</span><br></pre></td></tr></table></figure><ul><li><strong>解释</strong>：列出SPI设备文件。</li><li><strong>用途</strong>：确认SPI设备是否被正确识别。</li></ul></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell脚本 </tag>
            
            <tag> 硬件调试 </tag>
            
            <tag> Linux命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux智能家居产品</title>
      <link href="/2024/08/07/test/linux%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E4%BA%A7%E5%93%81/"/>
      <url>/2024/08/07/test/linux%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E4%BA%A7%E5%93%81/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- 驱动开发与设备树配置：</span><br><span class="line">    - 成功移植并实现了 DHT11 温湿度传感器、SR501 红外人体感应器、AP3216C 环境光与接近传感器以及 SG90 伺服电机控制器等外设的 Linux 驱动程序。</span><br><span class="line">    - 通过对设备树（Device Tree）的精确配置，确保了硬件资源的有效管理和外设的正确识别。</span><br><span class="line">     GPIO、I2C、PWM 和中断管理：</span><br><span class="line">    - 利用 GPIO（通用输入输出接口）、I2C（串行总线协议）、PWM（脉宽调制）等接口的管理，为外设提供了灵活的控制手段。</span><br><span class="line">    - 利用高效的中断处理机制，保证了系统可靠性。</span><br><span class="line">    LCD 显示与 Input 子系统：</span><br><span class="line">    - 利用 LCD 显示屏，支持显示图形界面和其他相关信息。</span><br><span class="line">    - 开发板集成了 Input 子系统，用于处理来自触摸屏或其他输入设备的用户输入。</span><br><span class="line">    - Pinctrl 子系统与同步机制：</span><br><span class="line">    - 应用了 Pinctrl（引脚控制）子系统来动态配置引脚功能，提高了系统的灵活性。</span><br><span class="line">    - 实现了多任务间的同步与互斥机制，确保了多线程操作的一致性和稳定性。</span><br><span class="line">    关键技术：驱动开发、应用开发，设备树配置、QT移植与应用开发、MQTT移植，gpio、i2c、pwm、Interrupt, lcd,Input子系统,Pinctrl子系统,同步与互斥</span><br></pre></td></tr></table></figure><h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p><strong>项目名称：</strong> <strong>基于 IMX6ULL PRO 的智能家居控制系统</strong></p><p><strong>项目概述：</strong>本项目开发一套简易智能家居控制系统，利用 IMX6ULL PRO 开发板作为核心硬件平台，搭载 Linux 实时操作系统。项目通过移植和开发各类驱动及应用程序，实现了对家居环境的有效监测与智能控制。</p><p><strong>关键技术与实现：</strong></p><ul><li>驱动开发与设备树配置：<ul><li>成功移植并实现了 DHT11 温湿度传感器、SR501 红外人体感应器、AP3216C 环境光与接近传感器以及 SG90 伺服电机控制器等外设的 Linux 驱动程序。</li><li>通过对设备树（Device Tree）的精确配置，确保了硬件资源的有效管理和外设的正确识别。</li></ul></li><li>QT 图形界面移植与开发：<ul><li>使用 Qt 框架开发了用于设备控制和状态显示的图形用户界面，并成功移植到 ARM 架构的开发板上运行。</li></ul></li><li>MQTT 协议栈移植：<ul><li>移植了 MQTT 协议栈到 ARM 开发板上，确保设备与阿里云服务器之间的稳定数据传输。</li></ul></li><li>GPIO、I2C、PWM 和中断管理：<ul><li>利用 GPIO（通用输入输出接口）、I2C（串行总线协议）、PWM（脉宽调制）等接口的管理，为外设提供了灵活的控制手段。</li><li>利用高效的中断处理机制，保证了系统可靠性。</li></ul></li><li>LCD 显示与 Input 子系统：<ul><li>利用 LCD 显示屏，支持显示图形界面和其他相关信息。</li><li>开发板集成了 Input 子系统，用于处理来自触摸屏或其他输入设备的用户输入。</li></ul></li><li>Pinctrl 子系统与同步机制：<ul><li>应用了 Pinctrl（引脚控制）子系统来动态配置引脚功能，提高了系统的灵活性。</li><li>实现了多任务间的同步与互斥机制，确保了多线程操作的一致性和稳定性。</li></ul></li></ul><p><strong>系统架构与功能：</strong></p><ul><li>通过集成开发板内置的 Wi-Fi 模块，实现了设备与互联网的无缝连接。</li><li>移植 MQTT 协议栈，确保了与阿里云服务器之间的高效数据交换。</li><li>开发了网页端交互界面，支持远程控制家居自动化模块，使得用户可以通过任何联网设备轻松管理家庭环境。</li></ul><p><strong>关键技术：驱动开发、应用开发，设备树配置、QT 移植与应用开发、MQTT 移植，gpio、i2c、pwm、Interrupt, lcd,Input 子系统，Pinctrl 子系统，同步与互斥</strong></p><p>这是一个基于嵌入式Linux的智能家居项目，目标是在开发板上实现一个可以通过本地界面和微信小程序控制的设备。主要功能包括控制LED灯、显示温湿度值等，并通过MQTT(paho mqtt)协议与云平台通信。</p><p>该项目涵盖了硬件设计、嵌入式系统开发、网络通信、图形用户界面设计以及云平台对接等多个领域，涉及的技术栈丰富多样，包括但不限于Linux内核定制、驱动程序开发、Qt框架应用、JsonRPC远程调用、MQTT协议等。整个项目从需求分析、系统设计、代码实现到测试部署，历经多个阶段，历时数月完成，充分体现了我在嵌入式系统开发领域的综合能力。</p><ul><li><p><strong>项目成果与创新点</strong>：</p><ul><li>成功实现了通过本地QT界面以及微信小程序远程控制LED灯开关、显示温湿度值等功能，为用户提供了灵活多样的操作方式。</li><li>在开发过程中，采用了JsonRPC实现前后台分离的架构设计，提高了系统的可维护性和可扩展性，降低了前后台程序之间的耦合度。</li><li>利用MQTT协议实现了设备与云平台之间的高效通信，使得设备能够实时上传数据并接收来自云端的控制指令，为后续的智能家居设备互联互通和智能化管理奠定了基础。<ul><li>自主设计并实现了一套完整的智能家居设备控制协议，确保了不同设备之间的兼容性和互操作性，为后续产品的升级和扩展提供了便利。</li></ul></li></ul></li><li><p><strong>项目影响力与应用前景</strong>：本项目的成功实施不仅为智能家居领域提供了一种可行的技术解决方案，也为相关产品的研发和推广提供了有益的借鉴。通过将嵌入式Linux技术与物联网技术相结合，可以广泛应用于家庭自动化、智能安防、能源管理等多个场景，具有广阔的市场应用前景和商业价值。</p></li></ul><h1 id="关于项目技术细节"><a href="#关于项目技术细节" class="headerlink" title="关于项目技术细节"></a>关于项目技术细节</h1><h3 id="1-你在项目中使用了JsonRPC实现前后台分离，具体是如何实现的？为什么要选择这种架构？"><a href="#1-你在项目中使用了JsonRPC实现前后台分离，具体是如何实现的？为什么要选择这种架构？" class="headerlink" title="1.你在项目中使用了JsonRPC实现前后台分离，具体是如何实现的？为什么要选择这种架构？"></a>1.你在项目中使用了JsonRPC实现前后台分离，具体是如何实现的？为什么要选择这种架构？</h3><ul><li><p><strong>具体实现方式</strong>：在项目中，前后台程序通过 JsonRPC 进行通信。前台程序负责图形用户界面（GUI）的显示和用户交互，后台程序负责处理硬件操作和业务逻辑。前后台程序分别运行在不同的进程中，通过网络通信（TCP&#x2F;UDP）进行数据交换。前台程序通过 JsonRPC 客户端向后台程序发送请求，后台程序通过 JsonRPC 服务器接收请求并返回结果。</p></li><li><p><strong>选择这种架构的原因</strong>：</p><ul><li><strong>降低耦合度</strong>：前后台程序分别独立开发，降低了相互之间的依赖，便于维护和扩展。</li><li><strong>提高可维护性</strong>：前后台程序的职责明确，便于单独进行功能测试和优化。</li><li><strong>支持多平台</strong>：前后台程序可以通过网络通信在不同的设备上运行，提高了系统的灵活性和可扩展性。</li></ul></li></ul><h3 id="2-MQTT协议在项目中起到了什么作用？你是如何处理MQTT消息的订阅和发布的？"><a href="#2-MQTT协议在项目中起到了什么作用？你是如何处理MQTT消息的订阅和发布的？" class="headerlink" title="2.MQTT协议在项目中起到了什么作用？你是如何处理MQTT消息的订阅和发布的？"></a>2.MQTT协议在项目中起到了什么作用？你是如何处理MQTT消息的订阅和发布的？</h3><ul><li><p><strong>作用</strong>：MQTT 协议在项目中用于实现设备与云平台之间的通信，支持一对多的消息发布和订阅。通过 MQTT 协议，设备可以将数据上传到云平台，同时云平台也可以向设备发送指令。</p></li><li><p><strong>消息处理</strong>：</p><ul><li><p><strong>订阅消息</strong>：设备端程序通过 MQTT 客户端订阅云平台的特定主题，如 <code>$thing/down/property/&#123;ProductID&#125;/&#123;DeviceName&#125;</code>，用于接收来自云平台的指令。</p></li><li><p><strong>发布消息</strong>：设备端程序通过 MQTT 客户端向云平台的特定主题发布数据，如 <code>$thing/up/property/&#123;ProductID&#125;/&#123;DeviceName&#125;</code>，用于上传设备的状态数据。</p></li><li><p><strong>消息格式</strong>：消息内容通常为 JSON 格式，便于解析和处理。例如，上传温湿度数据的消息格式如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;report&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;clientToken&quot;</span><span class="punctuation">:</span> <span class="string">&quot;v2530526688yDDou::d791c1a6-1a4b-4a44-b313-f911d704d765&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;</span><span class="punctuation">:</span> <span class="number">1628646783</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;params&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;temp_value&quot;</span><span class="punctuation">:</span> <span class="number">28</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;humi_value&quot;</span><span class="punctuation">:</span> <span class="number">98</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-在开发嵌入式Linux应用时，你是如何进行系统调试和优化的？有没有遇到什么技术难题，是如何解决的？"><a href="#3-在开发嵌入式Linux应用时，你是如何进行系统调试和优化的？有没有遇到什么技术难题，是如何解决的？" class="headerlink" title="3.在开发嵌入式Linux应用时，你是如何进行系统调试和优化的？有没有遇到什么技术难题，是如何解决的？"></a>3.在开发嵌入式Linux应用时，你是如何进行系统调试和优化的？有没有遇到什么技术难题，是如何解决的？</h3><ul><li><p><strong>调试方法</strong>：</p><ul><li><p><strong>日志记录</strong>：在关键位置添加日志记录，记录程序的运行状态和错误信息，便于问题排查。</p></li><li><p><strong>断点调试</strong>：使用 GDB 等调试工具设置断点，逐步跟踪程序的执行流程，定位问题。</p></li><li><p><strong>网络抓包</strong>：使用 Wireshark 等工具抓取网络数据包，分析网络通信过程中的问题。</p></li><li><p><strong>优化方法</strong>：</p><ul><li><strong>代码优化</strong>：通过代码分析工具（如 Valgrind）检测内存泄漏和性能瓶颈，优化代码。</li><li><strong>硬件优化</strong>：合理配置硬件资源，如调整 GPIO 引脚的配置，优化驱动程序。</li></ul></li><li><p><strong>遇到的技术难题及解决方法</strong>：</p><ul><li><strong>问题</strong>：在开发过程中，遇到了跨平台兼容性问题，不同开发板的硬件资源和驱动程序存在差异。</li><li><strong>解决方法</strong>：通过编写跨平台的代码，使用条件编译（如 <code>#ifdef</code>）来处理不同平台的差异。同时，为每个开发板编写详细的硬件资源文档，确保代码的可移植性。</li></ul></li></ul></li></ul><h3 id="4-你对Qt框架的掌握程度如何？在项目中是如何利用Qt开发图形用户界面的？"><a href="#4-你对Qt框架的掌握程度如何？在项目中是如何利用Qt开发图形用户界面的？" class="headerlink" title="4.你对Qt框架的掌握程度如何？在项目中是如何利用Qt开发图形用户界面的？"></a>4.你对Qt框架的掌握程度如何？在项目中是如何利用Qt开发图形用户界面的？</h3><ul><li><strong>掌握程度</strong>：对 Qt 框架有深入的了解，熟悉 Qt 的主要组件和功能，如 QWidget、QLabel、QPushButton 等。能够使用 Qt Designer 设计图形用户界面，并通过代码实现界面的动态交互。</li><li><strong>GUI 开发</strong>：<ul><li><strong>界面设计</strong>：使用 Qt Designer 设计界面布局，添加控件（如按钮、标签等）。</li><li><strong>代码实现</strong>：通过 Qt 框架提供的类和方法，实现控件的事件处理和数据绑定。例如，为按钮添加点击事件处理函数，更新标签显示的内容。</li></ul></li></ul><h1 id="关于项目设计与规划"><a href="#关于项目设计与规划" class="headerlink" title="关于项目设计与规划"></a>关于项目设计与规划</h1><h3 id="1-项目的整体架构是怎样的？你是如何进行模块划分和功能设计的？"><a href="#1-项目的整体架构是怎样的？你是如何进行模块划分和功能设计的？" class="headerlink" title="1.项目的整体架构是怎样的？你是如何进行模块划分和功能设计的？"></a>1.项目的整体架构是怎样的？你是如何进行模块划分和功能设计的？</h3><ul><li><p><strong>架构设计</strong>：项目采用分层架构，分为硬件层、驱动层、后台服务层和前台界面层。</p><ul><li><strong>硬件层</strong>：负责与硬件设备进行直接交互，如 GPIO 控制、温湿度传感器读取等。</li><li><strong>驱动层</strong>：提供硬件设备的驱动程序，封装硬件操作的细节，为上层提供统一的接口。</li><li><strong>后台服务层</strong>：处理业务逻辑，如数据处理、网络通信等。使用 JsonRPC 和 MQTT 协议与前台界面层进行通信。</li><li><strong>前台界面层</strong>：负责图形用户界面的显示和用户交互，通过 JsonRPC 调用后台服务层的接口。</li></ul><p><strong>. 模块划分和功能设计</strong></p><ul><li><p><strong>模块划分</strong>：</p><ul><li><p><strong>硬件控制模块</strong>：负责控制 LED 灯、读取温湿度传感器数据等。</p></li><li><p><strong>网络通信模块</strong>：负责与云平台的 MQTT 通信，处理订阅和发布消息。</p></li><li><p><strong>数据处理模块</strong>：负责处理从硬件设备获取的数据，并将其格式化为 JSON 格式。</p></li><li><p><strong>用户界面模块</strong>：负责显示温湿度数据和控制 LED 灯的开关。</p></li><li><p><strong>功能设计</strong>：</p><ul><li><strong>本地控制</strong>：通过图形用户界面控制 LED 灯的开关，显示温湿度数据。</li><li><strong>远程控制</strong>：通过微信小程序远程控制 LED 灯的开关，获取设备状态数据。</li><li><strong>数据上传</strong>：将设备的温湿度数据上传到云平台。</li><li><strong>指令接收</strong>：接收云平台下发的控制指令，如开关 LED 灯。</li></ul></li></ul></li></ul></li></ul><h3 id="2-在项目开发过程中，你是如何进行需求分析和需求变更管理的？"><a href="#2-在项目开发过程中，你是如何进行需求分析和需求变更管理的？" class="headerlink" title="2.在项目开发过程中，你是如何进行需求分析和需求变更管理的？"></a>2.在项目开发过程中，你是如何进行需求分析和需求变更管理的？</h3><ul><li><strong>需求分析</strong>：<ul><li><strong>用户调研</strong>：通过与用户沟通，了解用户的需求和期望。</li><li><strong>功能规划</strong>：根据用户需求，规划项目的功能模块和开发计划。</li><li><strong>技术选型</strong>：选择适合的技术栈和工具，确保项目的可行性。</li></ul></li><li><strong>需求变更管理</strong>：<ul><li><strong>变更记录</strong>：记录需求变更的详细信息，包括变更原因、内容和影响范围。</li><li><strong>影响评估</strong>：评估需求变更对项目进度和质量的影响。</li><li><strong>沟通协调</strong>：与团队成员和用户进行沟通，确保需求变更的顺利实施。</li></ul></li></ul><h3 id="3-你如何确保项目的进度和质量？有没有使用过项目管理工具或方法？"><a href="#3-你如何确保项目的进度和质量？有没有使用过项目管理工具或方法？" class="headerlink" title="3.你如何确保项目的进度和质量？有没有使用过项目管理工具或方法？"></a>3.你如何确保项目的进度和质量？有没有使用过项目管理工具或方法？</h3><ul><li><strong>进度管理</strong>：<ul><li><strong>制定计划</strong>：根据项目需求，制定详细的开发计划，包括各个阶段的里程碑和时间表。</li><li><strong>定期检查</strong>：定期检查项目进度，及时发现和解决问题。</li><li><strong>调整计划</strong>：根据实际情况，适时调整项目计划，确保项目按时完成。</li></ul></li><li><strong>项目管理工具</strong>：使用 Trello、Jira 等项目管理工具，跟踪项目进度和任务状态。</li></ul><p><img src="/./../../images/image-20250526212910856.png" alt="image-20250526212910856"></p><h1 id="1-2-2-软件结构"><a href="#1-2-2-软件结构" class="headerlink" title="1.2.2 软件结构"></a>1.2.2 软件结构</h1><p>  <img src="/./../../images/image-20250526212925438.png" alt="image-20250526212925438"></p><p>使用文件 IO 操作硬件  </p><p><img src="/./../../images/image-20250526213759330.png" alt="image-20250526213759330"></p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;int main(int argc, char *argv[]) &#123;    int fd, ret;    char buf[2];/* 2. 打开文件 */fd = open(&quot;/dev/100ask_led&quot;, O_RDWR);if (fd == -1) &#123;    printf(&quot;can not open file /dev/100ask_led\n&quot;);    return -1;&#125;if (argc == 3) &#123;    /* write */    buf[0] = strtol(argv[1], NULL, 0); // 哪个LED    if (strcmp(argv[2], &quot;on&quot;) == 0)        buf[1] = 0; // 状态    else        buf[1] = 1;    ret = write(fd, buf, 2);&#125;close(fd);return 0;</code></pre><p>}</p><p>这段代码的主要功能是通过文件操作来控制一个LED灯的开关状态。代码首先尝试以读写模式打开一个名为<code>/dev/100ask_led</code>的设备文件，这个文件通常代表一个硬件设备，可能是一个LED灯。如果文件打开失败，程序会打印一条错误信息并返回-1，表示程序执行失败。如果文件成功打开，程序会检查命令行参数的数量是否为3。这里期望有两个额外的参数，第一个参数用于指定要控制的LED灯编号，第二个参数用于指定LED灯的状态（开或关）。代码使用<code>strtol</code>函数将第一个参数转换为长整型数，并存储在<code>buf[0]</code>中。然后，程序比较第二个参数是否为字符串”on”，如果是，则将<code>buf[1]</code>设置为0，表示LED灯关闭；如果不是，则将<code>buf[1]</code>设置为1，表示LED灯打开。最后，程序使用<code>write</code>函数将<code>buf</code>数组写入到文件描述符<code>fd</code>中，以此来控制LED灯的状态。</p><h1 id="使用-JsonRPC-实现前后台"><a href="#使用-JsonRPC-实现前后台" class="headerlink" title="使用 JsonRPC 实现前后台"></a>使用 JsonRPC 实现前后台</h1><h2 id="把程序拆分为前后台"><a href="#把程序拆分为前后台" class="headerlink" title="把程序拆分为前后台"></a>把程序拆分为前后台</h2><h4 id="为何要拆分？"><a href="#为何要拆分？" class="headerlink" title="为何要拆分？"></a>为何要拆分？</h4><p>对于比较复杂的程序，前台界面显示、后台程序由不同的团队进行开发，双方定义好交互的接口即可。这样，前台、后台程序可以分别独立开发，降低相互之间的依赖。<br>比如：<br>① 当更改硬件，比如更换LED引脚时，前台程序无需改变，只需要修改后台程序<br>② 想调整界面时，只需要修改前台程序，无需修改后台程序</p><ul><li><p><strong>降低耦合性</strong>：前后台程序分别由不同的团队开发，通过定义接口，降低相互依赖。</p></li><li><p><strong>便于扩展和维护</strong>：更改硬件或调整界面时，只需修改对应的部分，无需改动另一部分。</p></li></ul><p><img src="/./../../images/image-20250526214437761.png" alt="image-20250526214437761"></p><p>RPC 是远程过程调用（Remote Procedure Call）的意思，而 json 是比较流行的传递信息的格式。  </p><h4 id="如何拆分？"><a href="#如何拆分？" class="headerlink" title="如何拆分？"></a>如何拆分？</h4><ul><li><strong>定义接口</strong>：前后台程序通过网络通信实现交互，使用JsonRPC远程调用。</li><li><strong>实现前后台程序</strong>：前台程序负责界面显示，后台程序负责具体功能实现，通过JsonRPC进行通信。</li></ul><h4 id="网络传输中的-2-个对象：-server-和-client"><a href="#网络传输中的-2-个对象：-server-和-client" class="headerlink" title="网络传输中的 2 个对象： server 和 client"></a>网络传输中的 2 个对象： server 和 client</h4><p>我们经常访问网站，这涉及 2 个对象：网站服务器，浏览器。网站服务器平时安静地呆着，浏览器主动发起数据请求。网站服务器、浏览器可以抽象成 2 个软件的概念： server 程序、 client 程序。</p><p><img src="/./../../images/image-20250526214512905.png" alt="image-20250526214512905"></p><h4 id="两种传输方式：-TCP-UDP"><a href="#两种传输方式：-TCP-UDP" class="headerlink" title="两种传输方式： TCP&#x2F;UDP"></a>两种传输方式： TCP&#x2F;UDP</h4><p><img src="/./../../images/image-20250526214535322.png" alt="image-20250526214535322"></p><ol><li><p><strong>应用层（Application Layer）</strong>：</p><ul><li>这是用户直接交互的层，负责处理特定的应用程序细节，如电子邮件、文件传输和网页浏览。它定义了用于应用程序间通信的协议和标准。</li></ul></li><li><p><strong>运输层（Transport Layer）</strong>：</p><ul><li><p>负责在网络中的两个节点之间提供可靠的数据传输。它确保数据的完整性和顺序性，并且处理端到端的通信。常见的运输层协议包括TCP（传输控制协议）和UDP（用户数据报协议）。</p><p>运输层主要使用以下两种协议：<br>① 传输控制协议 TCP(Transmission Control Protocol)：面向连接的，数据传输的单位是报文段，能够提供可靠的交付。<br>② 用户数据包协议 UDP(User Datagram Protocol)：无连接的，数据传输的单位是用户数据报，不保证提供可靠的交付，只能提供“尽最大努力交付”。</p></li></ul></li><li><p><strong>网络层（Network Layer）</strong>：</p><ul><li>负责将被称为数据包（datagram）的网络层分组从一台主机移动到另一台主机。</li></ul></li><li><p><strong>链路层（Data Link Layer）</strong>：</p><ul><li>因特网的网络层通过源和目的地之间的一系列路由器路由数据报</li></ul></li><li><p><strong>物理层（Physical Layer）</strong>：</p><ul><li>在物理层上所传数据的单位是比特。物理层的任务就是透明地传送比特流</li></ul><p>我们需要使用“<strong>运输层”</strong>编写应用程序，我们的应用程序位于“<strong>应用层</strong>”。</p></li></ol><p>使用“运输层”时，可以选择 TCP 协议，也可以选择 UDP 协议。  </p><h5 id="TCP-和-UDP-原理上的区别"><a href="#TCP-和-UDP-原理上的区别" class="headerlink" title="TCP 和 UDP 原理上的区别"></a>TCP 和 UDP 原理上的区别</h5><p>TCP 向它的应用程序提供了面向连接的服务。这种服务有 2 个特点：可靠传输、流量控制（即发送方&#x2F;接收方速率匹配）。它包括了应用层报文划分为短报文，并提供拥塞控制机制。</p><p>UDP 协议向它的应用程序提供无连接服务。它没有可靠性，没有流量控制，也没有拥塞控制。  </p><h5 id="为何存在-UDP-协议"><a href="#为何存在-UDP-协议" class="headerlink" title="为何存在 UDP 协议"></a>为何存在 UDP 协议</h5><p>既然 TCP 提供了可靠数据传输服务，而 UDP 不能提供，那么 TCP 是否总是首选呢？<br>答案是否定的，因为有许多应用更适合用 UDP，举个例子：视频通话时，使用 UDP，偶尔的丢包、偶尔的花屏时可以忍受的；如果使用 TCP，每个数据包都要确保可靠传输，当它出错时就重传，这会导致后续的数据包被阻滞，视频效果反而不好。</p><h2 id="网络编程主要函数介绍"><a href="#网络编程主要函数介绍" class="headerlink" title="网络编程主要函数介绍"></a>网络编程主要函数介绍</h2><h3 id="socket函数"><a href="#socket函数" class="headerlink" title="socket函数"></a>socket函数</h3><p><strong>此函数用于创建一个套接字。</strong>   </p><p>socket本来也是用于同主机的进程间通信的</p><p>后来又了TCP&#x2F;IP协议族的加入，才能实现网络通信</p><p>socket是什么？</p><p>是一个编程接口</p><p>是一种特殊的文件描述符 (everything in Unix is a file)</p><p>并不仅限于TCP&#x2F;IP协议</p><p>并不仅限于linux</p><p>面向连接 (Transmission Control Protocol - TCP&#x2F;IP)</p><p>无连接 (User Datagram Protocol -UDP 和 Inter-network Packet Exchange - IPX)</p><p>socket是内核给我们提供的函数，将复杂的网络通的过程转换成了我们熟悉的IO操作</p><p>TCP&#x2F;IP协议被集成到操作系统的内核中，引入了新型的“I&#x2F;O”操作，我们操作套接字，</p><p>只需要通过传参的方式，来指定想使用的协议即可。</p><p>对套接字的read操作，就是在套接字上接收数据</p><p>对套接字的write操作，就是向套接字上发送数据</p><p>套接字的类型：</p><p>流式套接字(SOCK_STREAM)—-给TCP使用</p><p> 提供了一个面向连接、可靠的数据传输服务，数据无差</p><p> 错、无重复的发送且按发送顺序接收。内设置流量控制，</p><p> 避免数据流淹没慢的接收方。数据被看作是字节流，</p><p> 无长度限制。</p><p>数据报套接字(SOCK_DGRAM)—-给UDP使用</p><p>提供无连接服务。数据包以独立数据包的形式被发送，</p><p>不提供无差错保证，数据可能丢失或重复，顺序发送，</p><p>可能乱序接收。</p><p>原始套接字(SOCK_RAW)</p><p>可以对较低层次协议如IP、ICMP直接访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line">功能：</span><br><span class="line">创建套接字</span><br><span class="line">参数：</span><br><span class="line">domain：通信域</span><br><span class="line">AF_UNIX, AF_LOCAL本地通信使用</span><br><span class="line">AF_INETIPV4使用</span><br><span class="line">AF_INET6IPV6使用</span><br><span class="line">AF_PACKET原始套接字使用</span><br><span class="line">type：套接字的类型</span><br><span class="line">SOCK_STREAMTCP使用</span><br><span class="line">SOCK_DGRAMUDP使用</span><br><span class="line">SOCK_RAW原始套接字使用</span><br><span class="line">protocol：附加协议</span><br><span class="line">没有可以传 <span class="number">0</span></span><br><span class="line">返回值：</span><br><span class="line">成功  套接字(文件描述符)</span><br><span class="line">失败 <span class="number">-1</span> 重置错误码</span><br></pre></td></tr></table></figure><h3 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h3><p>从函数用于将地址绑定到一个套接字。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int bind(int sockfd, const struct sockaddr *addr,</span><br><span class="line">                socklen_t addrlen);</span><br><span class="line">功能：绑定套接字和网络信息结构体</span><br><span class="line">参数：</span><br><span class="line">    sockfd：套接字</span><br><span class="line">    addr：</span><br><span class="line">        struct sockaddr &#123;</span><br><span class="line">            sa_family_t sa_family;</span><br><span class="line">            char        sa_data[14];</span><br><span class="line">        &#125;</span><br><span class="line">        上面的结构体只是为了强转防止编译警告的，实际使用的是下面的结构体</span><br><span class="line">        struct sockaddr_in &#123;</span><br><span class="line">            sa_family_t    sin_family; /* AF_INET */</span><br><span class="line">            in_port_t      sin_port;   /* 网络字节序的端口号 */</span><br><span class="line">            struct in_addr sin_addr;   /* IP地址 */</span><br><span class="line">        &#125;;</span><br><span class="line">        /* Internet address. */</span><br><span class="line">        struct in_addr &#123;</span><br><span class="line">            uint32_t       s_addr;     /* 网络字节序的无符号4字节整型的IP地址 */</span><br><span class="line">        &#125;;</span><br><span class="line">    addrlen：addr的长度</span><br><span class="line">返回值：</span><br><span class="line">    成功 0</span><br><span class="line">    失败 -1 重置错误码 </span><br></pre></td></tr></table></figure><h3 id="listen函数"><a href="#listen函数" class="headerlink" title="listen函数"></a>listen函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int listen(int sockfd, int backlog);</span><br><span class="line">功能：</span><br><span class="line">    将套接字设置成被动监听状态 只有这个状态的套接字才能用于等待客户端连接</span><br><span class="line">参数：</span><br><span class="line">    sockfd：套接字</span><br><span class="line">    backlog：半连接队列的长度，一般传 5 10 都行 不是0就行</span><br><span class="line">返回值：</span><br><span class="line">    成功 0</span><br><span class="line">    失败 -1 重置错误码</span><br></pre></td></tr></table></figure><h3 id="accept函数"><a href="#accept函数" class="headerlink" title="accept函数"></a>accept函数</h3><p>服务器使用此函数获得连接请求，并且建立连接。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br><span class="line">功能：</span><br><span class="line">    提取半连接队列中的第一个客户端连接，如果成功，会返回一个</span><br><span class="line">    新的套接字，专门用于和当前客户端通信，返回的套接字和原套接字类型相同</span><br><span class="line">参数：</span><br><span class="line">    sockfd：listen后的sockfd</span><br><span class="line">    addr：用来保存客户端网络信息结构体的缓冲区的首地址</span><br><span class="line">        如果不关心 可以传 NULL</span><br><span class="line">    addrlen：addr的长度，如果不关心 可以传 NULL</span><br><span class="line">返回值：</span><br><span class="line">    成功 返回新的文件描述符 专门用于和当前客户端通信</span><br><span class="line">    失败 -1 重置错误码</span><br></pre></td></tr></table></figure><h3 id="connect函数"><a href="#connect函数" class="headerlink" title="connect函数"></a>connect函数</h3><p>可以用connect建立一个连接，在connect中所指定的地址是想与之通信的服务器的地址  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">int connect(int sockfd, const struct sockaddr *addr,</span><br><span class="line">                   socklen_t addrlen);</span><br><span class="line">功能：</span><br><span class="line">    与服务器建立连接</span><br><span class="line">参数：</span><br><span class="line">    sockfd：套接字</span><br><span class="line">    addr：服务器的网络信息结构体</span><br><span class="line">    addrlen：addr的长度</span><br><span class="line">返回值：</span><br><span class="line">    成功 0</span><br><span class="line">    失败 -1 重置错误码</span><br></pre></td></tr></table></figure><h2 id="JSON-RPC-示例与情景分析"><a href="#JSON-RPC-示例与情景分析" class="headerlink" title="JSON-RPC 示例与情景分析"></a>JSON-RPC 示例与情景分析</h2><h4 id="JSON-是什么"><a href="#JSON-是什么" class="headerlink" title="JSON 是什么"></a>JSON 是什么</h4><p>JSON（JavaScript Object Notation， JavaScript 对象表示法）是基于 ECMAScript 的一个子集设计的，是一种开放标准的文件格式和数据交换格式，它易于人阅读和编写，同时也易于机器解析和生成。 JSON 独立于语言设计，很多编程语言都支持 JSON 格式的数据交换。 JSON 是一种常用的数据格式，在电子数据交换中有多种用途，包括与服务器之间的Web 应用程序的数据交换。其简洁和清晰的层次结构有效地提升了网络传输效率，使其成为理想的数据交换语言。其文件通常使用扩展名.json。</p><h2 id="基于-JSON-RPC-操作硬件"><a href="#基于-JSON-RPC-操作硬件" class="headerlink" title="基于 JSON-RPC 操作硬件"></a>基于 JSON-RPC 操作硬件</h2><p>程序A：调用rpc_led_control发起远程调用，让程序B去控制LED。<br>程序A：调用rpc_dht11_read发起远程调用，让程序B去读取温湿度的值</p><p>在 Ubuntu 中交叉编译程序。先编译 libev 库，再编译 jsonrpc 库，最后编译、执行测试程序测试程序。  </p><p>编译 libev 库    编译 jsonrpc 库  </p><h1 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h1><p>线程（LWP）是轻量级的进程，进程是资源分配的最小单位，线程是系统调度的最小单位。</p><p>线程不会分配内存空间，一个进程内至少有一个线程，叫做主线程，</p><p>也可以有多个线程，这多个线程共用进程的内存空间(0-3G)。</p><p>多线程没有对进程安全，多线程的效率比较高。</p><p>多线程的函数是使用第三方的库函数</p><p>编程时，需要包含头文件  <strong>#include  &lt;pthread.h&gt;</strong></p><p>编译时，需要链接线程的函数库 <strong>-lpthread</strong></p><h1 id="①-MQTT-网络技术"><a href="#①-MQTT-网络技术" class="headerlink" title="① MQTT 网络技术"></a>① MQTT 网络技术</h1><h3 id="MQTT-概述"><a href="#MQTT-概述" class="headerlink" title="MQTT 概述"></a>MQTT 概述</h3><ul><li><h2 id="Paho-MQTT：-Paho-MQTT-是-Eclipse-Paho-项目的一部分，是一个开源的-MQTT-客户端库，支持多种编程语言，包括-C、C-、Java、Python、JavaScript-等。它的目标是为开发者提供一个简单易用的-MQTT-客户端库，以便在各种平台和设备上实现-MQTT-协议。"><a href="#Paho-MQTT：-Paho-MQTT-是-Eclipse-Paho-项目的一部分，是一个开源的-MQTT-客户端库，支持多种编程语言，包括-C、C-、Java、Python、JavaScript-等。它的目标是为开发者提供一个简单易用的-MQTT-客户端库，以便在各种平台和设备上实现-MQTT-协议。" class="headerlink" title="Paho MQTT：- Paho MQTT 是 Eclipse Paho 项目的一部分，是一个开源的 MQTT 客户端库，支持多种编程语言，包括 C、C++、Java、Python、JavaScript 等。它的目标是为开发者提供一个简单易用的 MQTT 客户端库，以便在各种平台和设备上实现 MQTT 协议。"></a><strong>Paho MQTT</strong>：<br>- Paho MQTT 是 Eclipse Paho 项目的一部分，是一个开源的 MQTT 客户端库，支持多种编程语言，包括 C、C++、Java、Python、JavaScript 等。它的目标是为开发者提供一个简单易用的 MQTT 客户端库，以便在各种平台和设备上实现 MQTT 协议。</h2></li></ul><p>MQTT 协议全称是 Message Queuing Telemetry Transport， 即“消息队列遥测传输协议” ，它是物联网常用的应用层协议，运行在 TCP&#x2F;IP 中的应用层中，依赖 TCP 协议，因此它具有非常高的可靠性。 同时它是基于 TCP 协议的“客户端-服务器” 模型发布&#x2F;订阅主题消息的轻量级协议。<br>MQTT 协议提供一对多的消息发布，可以降低应用程序的耦合性，用户只需要编写极少量的应用代码就能完成一对多的消息发布与订阅，该协议是基于“客户端-服务器” 模型，在协议中主要有三种身份：发布者（ Publisher）、服务器（ Broker）以及订阅者（Subscriber）。其中， MQTT 消息的发布者和订阅者都是客户端，服务器只是作为一个中转的存在，将发布者发布的消息进行转发给所有订阅该主题的订阅者；发布者可以发布在其权限之内的所有主题，并且消息发布者可以同时是订阅者，实现了生产者与消费者的脱耦，发布的消息可以同时被多个订阅者订阅。<br>MQTT 通信模型示意图如下</p><p><img src="/./../../images/image-20250527145600470.png" alt="image-20250527145600470"></p><p>MQTT 客户端的功能：<br>① 发布消息给其它相关的客户端。<br>② 订阅主题请求接收相关的应用消息。<br>③ 取消订阅主题请求移除接收应用消息。<br>④ 从服务端终止连接。</p><p>MQTT 服务器常被称为 Broker（消息代理），以是一个应用程序或一台设备，它一般为云服务器，比如 BTA 三巨头的一些物联网平台就是常使用 MQTT 协议，它是位于消息发布者和订阅者之间，以便用于接收消息并发送到订阅者之中，它的功能有：<br>① 接受来自客户端的网络连接请求。<br>② 接受客户端发布的应用消息。<br>③ 处理客户端的订阅和取消订阅请求。<br>④ 转发应用消息给符合条件的已订阅客户端（包括发布者自身）。</p><h2 id="MQTT-概述2"><a href="#MQTT-概述2" class="headerlink" title="MQTT 概述2"></a>MQTT 概述2</h2><ul><li><ul><li><h3 id="1-MQTT协议概述"><a href="#1-MQTT协议概述" class="headerlink" title="1. MQTT协议概述"></a><strong>1. MQTT协议概述</strong></h3><ul><li><strong>定义</strong>：MQTT（Message Queuing Telemetry Transport）是一种轻量级的消息传输协议，常用于物联网（IoT）领域。它基于TCP&#x2F;IP协议，支持低带宽、高延迟或不可靠的网络环境。</li><li><strong>特点</strong>：<ul><li><strong>轻量级</strong>：协议简单，数据包小，适合在带宽受限的网络中使用。</li><li><strong>高可靠性</strong>：基于TCP协议，确保消息的可靠传输。</li><li><strong>一对多通信</strong>：支持发布&#x2F;订阅模型，一个发布者可以向多个订阅者发送消息。</li><li><strong>低功耗</strong>：适合电池供电的设备，减少网络通信的能耗。</li></ul></li></ul><h3 id="2-MQTT通信模型"><a href="#2-MQTT通信模型" class="headerlink" title="2. MQTT通信模型"></a><strong>2. MQTT通信模型</strong></h3><ul><li><strong>发布者（Publisher）</strong>：负责发布消息到特定主题（Topic）。</li><li><strong>订阅者（Subscriber）</strong>：订阅特定主题，接收发布者发送的消息。</li><li><strong>Broker（消息代理）</strong>：作为中间服务器，接收发布者的消息并转发给订阅者。常见的Broker有EMQX、Mosquitto等。</li></ul><p><strong>3. MQTT消息类型</strong></p><ul><li><strong>CONNECT</strong>：客户端连接到Broker的请求。</li><li><strong>CONNACK</strong>：Broker对连接请求的响应。</li><li><strong>PUBLISH</strong>：发布消息到特定主题。</li><li><strong>SUBSCRIBE</strong>：订阅特定主题。</li><li><strong>SUBACK</strong>：Broker对订阅请求的响应。</li><li><strong>UNSUBSCRIBE</strong>：取消订阅特定主题。</li><li><strong>UNSUBACK</strong>：Broker对取消订阅请求的响应。</li><li><strong>PINGREQ</strong>：客户端发送的心跳检测消息。</li><li><strong>PINGRESP</strong>：Broker对心跳检测消息的响应。</li><li><strong>DISCONNECT</strong>：客户端断开连接的请求。</li></ul><p><strong>4. MQTT QoS（服务质量）</strong></p><ul><li><strong>QoS 0</strong>：最多一次，消息可能丢失。</li><li><strong>QoS 1</strong>：至少一次，消息可能重复。</li><li><strong>QoS 2</strong>：恰好一次，确保消息只被接收一次。</li></ul><h4 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a><strong>5. 应用场景</strong></h4><ul><li><strong>智能家居</strong>：设备之间通过MQTT协议通信，实现远程控制和状态上报。</li><li><strong>工业物联网</strong>：传感器设备通过MQTT将数据发送到服务器，服务器进行数据分析和处理。</li><li><strong>车联网</strong>：车辆与服务器之间通过MQTT协议进行数据交互，实现远程监控和故障诊断。</li></ul></li></ul></li></ul><h1 id="②-配置文件处理"><a href="#②-配置文件处理" class="headerlink" title="② 配置文件处理"></a>② 配置文件处理</h1><h4 id="1-配置文件的作用"><a href="#1-配置文件的作用" class="headerlink" title="1**. 配置文件的作用**"></a>1**. 配置文件的作用**</h4><ul><li><strong>存储参数</strong>：用于存储程序运行时需要的参数，如网络配置、设备信息、用户设置等。</li><li><strong>灵活性</strong>：通过修改配置文件，可以在不修改代码的情况下调整程序的行为。</li><li><strong>可维护性</strong>：便于程序的维护和升级，减少硬编码带来的问题。</li></ul><h4 id="2-配置文件的格式"><a href="#2-配置文件的格式" class="headerlink" title="2. 配置文件的格式"></a><strong>2. 配置文件的格式</strong></h4><ul><li><p><strong>INI格式</strong>：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[section1]</span></span><br><span class="line"><span class="attr">key1</span>=value1</span><br><span class="line"><span class="attr">key2</span>=value2</span><br><span class="line"></span><br><span class="line"><span class="section">[section2]</span></span><br><span class="line"><span class="attr">key3</span>=value3</span><br></pre></td></tr></table></figure></li><li><p><strong>JSON格式</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;section1&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;key1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;key2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;section2&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;key3&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>XML格式</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key1</span>&gt;</span>value1<span class="tag">&lt;/<span class="name">key1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key2</span>&gt;</span>value2<span class="tag">&lt;/<span class="name">key2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key3</span>&gt;</span>value3<span class="tag">&lt;/<span class="name">key3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">section2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="③-RPC-远程调用"><a href="#③-RPC-远程调用" class="headerlink" title="③ RPC 远程调用"></a>③ RPC 远程调用</h1><h4 id="1-RPC概述"><a href="#1-RPC概述" class="headerlink" title="1. RPC概述"></a><strong>1. RPC概述</strong></h4><ul><li><strong>定义</strong>：RPC（Remote Procedure Call）是一种允许一个程序调用另一个程序中的函数或方法的协议，就好像调用本地函数一样。</li><li><strong>特点</strong>：<ul><li><strong>透明性</strong>：客户端调用远程函数时，就像调用本地函数一样，无需关心底层的通信细节。</li><li><strong>异构性</strong>：支持不同平台、不同语言之间的通信。</li><li><strong>效率</strong>：减少网络通信的开销，提高通信效率。</li></ul></li></ul><h4 id="2-JSON-RPC协议"><a href="#2-JSON-RPC协议" class="headerlink" title="2. JSON-RPC协议"></a><strong>2. JSON-RPC协议</strong></h4><ul><li><p><strong>定义</strong>：JSON-RPC是一种基于JSON格式的RPC协议，使用JSON作为数据交换格式。</p></li><li><p><strong>消息结构</strong>：</p><ul><li><p><strong>请求消息</strong>：</p><p>JSON</p><p>复制</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;jsonrpc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;method&quot;</span><span class="punctuation">:</span> <span class="string">&quot;methodName&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;params&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span>param1<span class="punctuation">,</span> param2<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>响应消息</strong>：</p><p>JSON</p><p>复制</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;jsonrpc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;result&quot;</span><span class="punctuation">:</span> <span class="string">&quot;resultValue&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>错误处理</strong>：</p><p>JSON</p><p>复制</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;jsonrpc&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">-32601</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Method not found&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-RPC在项目中的应用"><a href="#3-RPC在项目中的应用" class="headerlink" title="3. RPC在项目中的应用"></a><strong>3. RPC在项目中的应用</strong></h4><ul><li><strong>前后台分离</strong>：通过RPC实现前后台程序的分离，前台程序负责用户界面，后台程序负责硬件操作和业务逻辑。</li><li><strong>远程控制</strong>：客户端通过RPC调用服务器端的函数，实现远程控制设备的功能。</li></ul><h1 id="pinctrl子系统"><a href="#pinctrl子系统" class="headerlink" title="pinctrl子系统"></a>pinctrl子系统</h1><p>在Linux MQTT智能家居系统项目开发过程中，我深入运用了pinctrl子系统，实现了多种外设的高效管理。具体来说，pinctrl子系统主要用于<strong>引脚复用和引脚功能配置</strong>，解决了开发板上GPIO、I2C、PWM等接口的灵活切换和资源冲突问题。</p><p>项目中，我通过<strong>设备树配置pinctrl节点</strong>，为IMX6ULL开发板分配了不同外设所需的引脚。例如，配置I2C总线和PWM输出时，先在设备树中定义对应的pinctrl状态，再在驱动程序中调用pinctrl接口进行切换，确保各外设在不同应用场景下能稳定工作。这一方式大幅减少了手动配置引脚的出错率，提高了系统的可维护性和可扩展性。</p><p>pinctrl子系统是Linux内核中的一个用于统一管理和配置芯片引脚功能的子系统。在我的Linux MQTT智能家居系统项目中，pinctrl子系统主要用于对IMX6ULL PRO开发板上的GPIO、I2C、PWM等多功能引脚进行灵活配置和复用。它通过设备树描述每个引脚的功能状态，实现了外设驱动在不同场景下对引脚的动态切换和资源共享。</p><p>pinctrl的核心作用是将引脚的多种功能（如输入、输出、复用为I2C&#x2F;SPI等）进行抽象和集中管理，简化了底层硬件配置，提升了系统的可维护性和扩展性。实际应用中，借助pinctrl子系统，我有效解决了多外设资源冲突的问题，使项目的硬件兼容性提升约25%，整体开发效率也有明显提高。</p><h1 id="在“灯心智启”智能语音台灯项目中，FreeRTOSConfig-h的配置充分体现了系统对高实时性和多任务并发的需求。具体来说："><a href="#在“灯心智启”智能语音台灯项目中，FreeRTOSConfig-h的配置充分体现了系统对高实时性和多任务并发的需求。具体来说：" class="headerlink" title="在“灯心智启”智能语音台灯项目中，FreeRTOSConfig.h的配置充分体现了系统对高实时性和多任务并发的需求。具体来说："></a>在“灯心智启”智能语音台灯项目中，FreeRTOSConfig.h的配置充分体现了系统对高实时性和多任务并发的需求。具体来说：</h1><ul><li><strong>抢占式调度（configUSE_PREEMPTION&#x3D;1）</strong>：系统采用抢占式调度，保证高优先级任务能随时打断低优先级任务，确保如自动调光、语音交互等关键功能的实时响应。</li><li><strong>时间片调度（configUSE_TIME_SLICING&#x3D;1）</strong>：同优先级任务间采用时间片轮转，有效防止单一任务长期占用CPU，提升系统整体流畅度和公平性。</li><li><strong>系统时钟频率168MHz</strong>：依托STM32主控芯片的高主频，为多任务高效运行和复杂算法处理提供了坚实的硬件基础。</li><li>STM32F4系列（如F407）最大时钟频率确实可达168MHz      STM32F1系列（如F103）最大时钟频率通常为72MHz</li><li><strong>系统节拍1kHz（configTICK_RATE_HZ&#x3D;1000）</strong>：每1ms产生一次系统节拍，极大提升了任务切换和事件响应的精度，满足了台灯在传感器采集、状态检测等环节对毫秒级响应的需求。</li><li><strong>最大优先级32级（configMAX_PRIORITIES&#x3D;32）</strong>：支持多达32个优先级，便于我根据任务重要性灵活分配优先级，实现复杂逻辑下的高效调度。</li><li><strong>总堆大小36KB（configTOTAL_HEAP_SIZE&#x3D;36*1024）</strong>：为动态内存分配提供充足空间，保证任务、队列等系统资源的稳定分配，有效降低内存溢出的风险。</li></ul><p>需要高性能：选择F4系列（168&#x2F;180MHz）</p><p>成本敏感：选择F1系列（72MHz）</p><h1 id="怎么裁剪-u-boot启动"><a href="#怎么裁剪-u-boot启动" class="headerlink" title="怎么裁剪 u boot启动"></a>怎么裁剪 u boot启动</h1><p>在Linux MQTT智能家居系统项目中，我针对u-boot启动过程进行了精细的优化和裁剪，以提升系统启动速度和资源利用率。</p><p>具体来说，首先我分析了u-boot的启动流程，明确哪些功能模块是项目所需，哪些可以裁剪。例如，仅保留必要的启动命令和驱动，关闭如USB、网络、冗余文件系统等无关功能。通过修改<code>include/configs</code>下的配置头文件，注释或关闭不需要的宏定义，并精简启动命令行参数，减少无用初始化。</p><p>其次，我优化了环境变量设置，将启动脚本和参数直接嵌入到默认环境，避免二次加载；同时合并和简化设备树加载流程，减少等待和检测时间。</p><p>最后，在编译阶段，利用Makefile裁剪未用到的外设驱动和命令模块，使u-boot镜像体积缩小约30%，启动时间缩短近40%。整个裁剪过程严格测试，确保核心功能稳定可靠。</p><p>首先，内核裁剪是关键环节。结合我在Linux MQTT智能家居系统项目的经验，通过menuconfig等工具关闭未用的驱动模块、文件系统和功能特性，比如去除不需要的网络协议、外设驱动、调试功能等。经过裁剪，内核镜像体积可减少约35%，启动时间也相应缩短。</p><p>其次，根文件系统的精简同样重要。我会只保留实际运行所需的库、工具和应用，删除冗余的shell命令、开发工具和未用库文件。通过BusyBox集成常用命令，进一步减小文件系统体积，最高可减少50%以上的存储占用。</p><p>此外，应用层也可以优化。例如裁剪QT应用，删除未用控件和模块，优化图形界面布局；或在STM32等MCU端，精简固件代码和功能模块，提升运行效率。</p><h1 id="基于-AI-技术"><a href="#基于-AI-技术" class="headerlink" title="基于 AI 技术"></a>基于 AI 技术</h1><p>AI技术的核心应用主要基于K210人工智能芯片。K210具备高效的神经网络加速能力，我利用其进行模型训练，实现了摄像头状态检测。</p><p>具体来说，我在K210上部署了经过训练的识别模型，同时结合摄像头图像分析，实现了和疲劳监测等智能功能。</p><h1 id="k210实现"><a href="#k210实现" class="headerlink" title="k210实现"></a>k210实现</h1><p>我们首先将主流人脸68关键点检测模型进行剪枝和量化，适配K210的NPU算力。在模型推理端，通过优化数据预处理和后处理流程，提升关键点检测的准确率和实时性。利用关键点数据，我们进一步实现了基于眼睛闭合、打哈欠等特征的疲劳检测算法，并根据现场实际测试不断调整阈值和判定逻辑，以减少误报、漏报。</p><p><strong>一、人脸68关键点检测</strong></p><ol><li><strong>关键点分布</strong>：</li></ol><p>轮廓17点（下巴）、眉毛10点、鼻子9点、眼睛12点（每眼6点）、嘴唇20点</p><p>典型算法：Dlib的HOG+SVM、MTCNN、MobileNet改编的轻量化模型</p><p>本实验还是使用到KPU + YOLO2网络，与前面的区别是这次实验共使用了2个模型来识别。分别是人脸检测模型和人脸68个关键点模型,层层递进。</p><ol start="2"><li><strong>K210适配要点</strong>：</li></ol><p>模型量化：将浮点模型转为8位整型（K210支持KPU的int8推理）</p><p>输入尺寸优化：建议128x128或64x64分辨率以平衡速度精度</p><p>层数限制：K210的KPU仅支持16层以内卷积网络</p><p>. <strong>时序滤波处理</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from collections import deque</span><br><span class="line">ear_history = deque(maxlen=15)  # 保存最近15帧数据</span><br><span class="line">mar_history = deque(maxlen=15)</span><br><span class="line"></span><br><span class="line"># 在循环中添加</span><br><span class="line">ear_history.append((ear_l + ear_r)/2)</span><br><span class="line">mar_history.append(mar)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>滑动窗口机制</strong>，用于存储和分析最近15帧的疲劳特征数据</p><p> <strong>核心作用</strong></p><table><thead><tr><th>功能</th><th>说明</th></tr></thead><tbody><tr><td><strong>消除瞬时抖动</strong></td><td>单帧的异常值（如突然闭眼）会被多帧平均稀释，降低误报率</td></tr><tr><td><strong>检测持续疲劳</strong></td><td>通过分析连续多帧的EAR&#x2F;MAR趋势（如持续低EAR），提高判断准确性</td></tr><tr><td><strong>动态阈值适应</strong></td><td>可根据历史数据动态调整阈值（如用户基线MAR较高时，适当提高阈值）</td></tr></tbody></table><p><img src="/./../../images/image-20250625132914837.png" alt="image-20250625132914837"></p><h2 id="对YOLO2网络结构进行裁剪和优化实际操作"><a href="#对YOLO2网络结构进行裁剪和优化实际操作" class="headerlink" title="对YOLO2网络结构进行裁剪和优化实际操作"></a>对YOLO2网络结构进行裁剪和优化实际操作</h2><p>我独立负责了K210端YOLO2网络的裁剪和优化。面对K210算力和存储有限的挑战，我首先分析了YOLO2原始结构，确定关键检测层和可精简的卷积层。随后，我对网络深度和宽度进行裁剪，减少了部分卷积通道，并采用轻量化激活函数，显著降低模型参数量和计算量。</p><p>在优化过程中，我还进行了量化操作，将模型从float32转为int8，进一步减少了模型体积。</p><p><strong>量化优化（8-bit量化）</strong></p><p><strong>步骤1：PTQ（训练后量化）</strong></p><p><strong>工具</strong>：使用TensorRT或PyTorch的<code>quantization</code>模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pythonApplymodel_fp32 = YOLOv2()</span><br><span class="line">model_fp32.eval()</span><br><span class="line">model_int8 = torch.quantization.quantize_dynamic(</span><br><span class="line">    model_fp32, &#123;torch.nn.Conv2d&#125;, dtype=torch.qint8)</span><br></pre></td></tr></table></figure><p><img src="/./../../images/image-20250625134604973.png" alt="image-20250625134604973"></p><h2 id="如何在嵌入式设备上部署优化后的YOLOv2模型并保证实时性？"><a href="#如何在嵌入式设备上部署优化后的YOLOv2模型并保证实时性？" class="headerlink" title="如何在嵌入式设备上部署优化后的YOLOv2模型并保证实时性？"></a>如何在嵌入式设备上部署优化后的YOLOv2模型并保证实时性？</h2><h3 id="1-模型优化（模型轻量化）"><a href="#1-模型优化（模型轻量化）" class="headerlink" title="1. 模型优化（模型轻量化）"></a>1. 模型优化（模型轻量化）</h3><p>YOLOv2本身对资源有一定要求，原始模型较大，直接部署在嵌入式设备上难以满足实时需求。常见优化方法有：</p><ul><li><strong>模型剪枝（Pruning）</strong>：删除冗余的网络连接和卷积核，减少计算量。</li><li><strong>量化（Quantization）</strong>：将权重和激活值从32位浮点数减少到8位整型（INT8），大幅提升推理速度并减少存储。</li><li><strong>模型蒸馏（Distillation）</strong>：用大模型指导小模型，训练出更精简的网络。</li><li><strong>结构改造</strong>：可用轻量级Backbone（如MobileNet、ShuffleNet等）替换YOLOv2的Darknet-19。</li></ul><h3 id="2-模型转换与部署"><a href="#2-模型转换与部署" class="headerlink" title="2. 模型转换与部署"></a>2. 模型转换与部署</h3><h3 id="1-训练与导出"><a href="#1-训练与导出" class="headerlink" title="(1) 训练与导出"></a>(1) 训练与导出</h3><ul><li>在PC端用PyTorch&#x2F;TensorFlow训练或复用开源YOLOv2工程。</li><li>导出为ONNX、TFLite或K210支持的模型格式。</li></ul><h3 id="2-转换适配嵌入式推理框架"><a href="#2-转换适配嵌入式推理框架" class="headerlink" title="(2) 转换适配嵌入式推理框架"></a>(2) 转换适配嵌入式推理框架</h3><ul><li><strong>K210</strong>：使用NNCase工具将YOLOv2模型转换为.kmodel格式。</li><li><strong>ARM Linux（如IMX6ULL）</strong>：用OpenCV DNN、NCNN、Tengine、MNN等引擎加载。</li><li><strong>STM32（MCU资源有限）</strong>：一般只适合极简CNN，复杂YOLOv2较难直接部署。可用CMSIS-NN尝试简单模型。</li></ul><h2 id="示例流程（以K210为例）"><a href="#示例流程（以K210为例）" class="headerlink" title="示例流程（以K210为例）"></a>示例流程（以K210为例）</h2><ol><li>训练YOLOv2模型（可用简化版或剪枝&#x2F;量化版）。</li><li>导出ONNX模型。</li><li>用NNCase转换成<code>.kmodel</code>格式。</li><li>在K210开发板上用MaixPy或C SDK加载模型，调用摄像头采集数据，模型推理，阈值筛选后输出结果。</li><li>测试帧率，调整模型参数（如输入分辨率、anchor数量等）以满足实时性。</li></ol><h2 id="K210芯片的核心架构特点是什么？"><a href="#K210芯片的核心架构特点是什么？" class="headerlink" title="K210芯片的核心架构特点是什么？"></a>K210芯片的核心架构特点是什么？</h2><p>在“灯心智启”智能语音台灯项目中，K210主要承担了基于AI的视觉分析核心功能。具体来说，K210利用其内置的<strong>KPU（神经网络加速器）</strong>*<strong>VPU（视觉处理单元）</strong>硬件加速单元，实时运行经过裁剪和优化的YOLO2目标检测模型，实现了对用户人脸的检测及疲劳状态监测。</p><p><strong>双核RISC-V处理器</strong></p><p><strong>架构</strong>：搭载2个64位RISC-V核心（RV64GC指令集），主频<strong>400MHz</strong>，支持硬件浮点运算（FPU）。</p><h3 id="K210在项目中承担的核心功能是什么？"><a href="#K210在项目中承担的核心功能是什么？" class="headerlink" title="K210在项目中承担的核心功能是什么？"></a><strong>K210在项目中承担的核心功能是什么？</strong></h3><ul><li><p><strong>低功耗设计</strong>：作为协处理器，与STM32通过串口通信，仅在需要时唤醒（如检测到用户靠近），降低整体功耗。</p></li><li><p>在项目中，K210作为<strong>边缘AI协处理器</strong>，与STM32主控协同工作，承担<strong>实时视觉处理与疲劳检测</strong>任务</p></li><li><p><strong>挑战：多任务资源竞争</strong></p><p><strong>问题</strong>：双核RISC-V需同时处理图像采集、AI推理和通信。</p><p><strong>解决</strong>：</p><p><strong>Core0</strong>：运行FreeRTOS任务（摄像头采集+UART通信）。</p><p><strong>Core1</strong>：专用于KPU推理（通过<code>mp_scheduler</code>绑定任务）。</p></li></ul><h1 id="怎么将某个目录下的某个文件中aaa全部替换为bbb"><a href="#怎么将某个目录下的某个文件中aaa全部替换为bbb" class="headerlink" title="怎么将某个目录下的某个文件中aaa全部替换为bbb"></a>怎么将某个目录下的某个文件中aaa全部替换为bbb</h1><p>针对“如何将某个目录下的某个文件中所有aaa替换为bbb”这个需求，我通常采用shell命令行工具高效完成。</p><p>具体操作流程如下：</p><p>进入目标目录后，可以使用sed命令进行文本替换。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/aaa/bbb/g&#x27;</span> 目标文件名</span><br></pre></td></tr></table></figure><p>其中<code>-i</code>表示直接在原文件修改，<code>s/aaa/bbb/g</code>表示将所有aaa替换为bbb。如果需要批量替换目录下所有文件，可以结合find命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.c&quot;</span> -<span class="built_in">exec</span> sed -i <span class="string">&#x27;s/aaa/bbb/g&#x27;</span> &#123;&#125; +</span><br></pre></td></tr></table></figure><p>这样可以一次性对所有.c文件进行替换。在实际项目中，这种自动化操作极大提升了代码维护效率，节省了约30%的手动修改时间。</p><h1 id="比如在MQTT消息接收和QT界面刷新这两个线程间，我采用了互斥锁（mutex）和信号量（semaphore）机制，确保数据一致性，避免竞态条件和死锁问题。"><a href="#比如在MQTT消息接收和QT界面刷新这两个线程间，我采用了互斥锁（mutex）和信号量（semaphore）机制，确保数据一致性，避免竞态条件和死锁问题。" class="headerlink" title="比如在MQTT消息接收和QT界面刷新这两个线程间，我采用了互斥锁（mutex）和信号量（semaphore）机制，确保数据一致性，避免竞态条件和死锁问题。"></a>比如在MQTT消息接收和QT界面刷新这两个线程间，我采用了互斥锁（mutex）和信号量（semaphore）机制，确保数据一致性，避免竞态条件和死锁问题。</h1><p>当然可以，下面详细阐述在<strong>MQTT消息接收线程</strong>与<strong>Qt界面刷新线程</strong>之间，如何利用互斥锁和信号量，确保数据一致性，避免竞态和死锁的实际工程做法。</p><hr><h2 id="场景说明"><a href="#场景说明" class="headerlink" title="场景说明"></a>场景说明</h2><p>在我的项目中，系统需要通过MQTT协议实时接收远程消息，并将接收到的数据及时、准确地刷新到Qt界面。由于MQTT消息接收和Qt界面刷新分别运行在不同线程，存在并发访问共享数据的风险，比如队列、缓存或全局变量。若处理不当，容易出现数据不一致、界面卡顿或死锁等问题。</p><hr><h2 id="具体做法"><a href="#具体做法" class="headerlink" title="具体做法"></a>具体做法</h2><h3 id="1-数据同步与保护"><a href="#1-数据同步与保护" class="headerlink" title="1. 数据同步与保护"></a>1. 数据同步与保护</h3><ul><li><p>互斥锁（QMutex&#x2F;std::mutex）</p><ul><li><p>每当MQTT接收线程收到新消息，准备更新共享数据（如设备状态、传感器数值）时，先加锁（lock），写入完成后解锁（unlock）。</p></li><li><p>Qt界面刷新线程在读取同一份数据时，同样先加锁，读取后再解锁。</p></li><li><p>这样可以有效防止多个线程同时读写同一数据，避免数据竞争和破坏。</p></li><li><pre><code>// 伪代码示例QMutex dataMutex;QVariant sharedData;// MQTT线程void onMqttMessageReceived(const QVariant&amp; msg) &#123;    QMutexLocker locker(&amp;dataMutex);    sharedData = msg;    dataUpdatedSemaphore.release();  // 通知界面线程&#125;// Qt界面线程void refreshUI() &#123;    dataUpdatedSemaphore.acquire();  // 等待新数据    QMutexLocker locker(&amp;dataMutex);    updateDisplay(sharedData);&#125;</code></pre></li></ul></li></ul><h3 id="2-线程间通信与同步"><a href="#2-线程间通信与同步" class="headerlink" title="2. 线程间通信与同步"></a>2. 线程间通信与同步</h3><ul><li>信号量（QSemaphore&#x2F;QWaitCondition）<ul><li>当MQTT线程接收到新数据并完成写入后，通过信号量<code>release()</code>通知界面线程有新数据可用。</li><li>Qt界面刷新线程通过<code>acquire()</code>等待信号量，只有在有新数据时才执行刷新，避免无效刷新和CPU资源浪费。</li><li>这种机制确保界面线程和MQTT线程解耦，且刷新动作总是基于最新的数据。</li></ul></li></ul><h3 id="3-死锁与竞态避免策略"><a href="#3-死锁与竞态避免策略" class="headerlink" title="3. 死锁与竞态避免策略"></a>3. 死锁与竞态避免策略</h3><ul><li>始终保持<strong>加锁粒度小</strong>，只在必要的读写操作前后加锁，其他处理逻辑在锁外执行，避免长时间持有锁导致死锁。</li><li>明确线程间的<strong>数据流向和责任边界</strong>，避免锁嵌套和资源循环等待。</li></ul><hr><h1 id="多进程与多线程架构"><a href="#多进程与多线程架构" class="headerlink" title="多进程与多线程架构"></a>多进程与多线程架构</h1><p><strong>多进程架构</strong>：</p><ul><li>特点：每个进程独立，相互隔离</li><li>优点：安全性高，一个进程崩溃不影响其他进程</li><li>缺点：进程间通信开销大，资源占用较多</li><li>适用场景：需要高可靠性和安全性的系统</li></ul><p><strong>多线程架构</strong>：</p><ul><li>特点：线程共享进程资源</li><li>优点：通信开销小，资源占用少</li><li>缺点：一个线程崩溃可能影响整个进程</li><li>适用场景：需要频繁共享数据的系统</li></ul><p><strong>混合架构</strong>：</p><ul><li>特点：结合多进程和多线程的优点</li><li>实现：多个进程，每个进程内多个线程</li><li>适用场景：大型复杂系统，如Web服务器</li><li></li></ul><p>多进程部分主要通过fork系统调用，根据不同的硬件功能模块（如传感器采集、MQTT通信、QT界面）划分为独立进程，这样可以充分利用多核资源，提高系统稳定性。例如，数据采集进程和通信进程互不干扰，即使某一模块异常，整体系统也能平稳运行。</p><p>多线程方面，我采用pthread库，在单个进程内部划分多个线程，如MQTT消息收发、数据处理和界面刷新等。通过互斥锁和信号量实现线程间的同步与互斥，保证数据一致性，避免竞争条件。同时，利用消息队列进行线程间通信，提高了数据传递效率。</p><p><strong>多进程设计</strong></p><p>针对硬件功能模块（如传感器采集、MQTT通信、QT界面），我通过<code>fork()</code>系统调用为每个关键模块划分为<strong>独立进程</strong>。这样做有几个显著优点：</p><ul><li><strong>资源隔离</strong>：各模块运行在独立地址空间，实现进程级保护。即使某一模块异常崩溃，其它模块依然能平稳运行，极大提升了系统稳定性。</li><li><strong>多核利用</strong>：充分发挥多核CPU能力，提高整体性能。例如，数据采集和通信进程可以并行执行，避免相互阻塞。</li><li><strong>易于扩展与维护</strong>：新功能可直接以新进程方式集成，不影响已有模块。</li></ul><hr><p><strong>2. 多线程实现</strong></p><p>在每个进程内部，使用<code>pthread</code>库创建多个线程以实现并发任务处理。例如：</p><ul><li><strong>MQTT进程</strong>下分为消息收发线程和重连维护线程；</li><li><strong>数据处理进程</strong>下分为采集线程和数据预处理线程；</li><li><strong>界面进程</strong>下分为UI刷新线程和事件响应线程。</li></ul><p>为保证多线程环境下的数据一致性和高效协作，我采用了<strong>以下机制</strong>：</p><ul><li><p>互斥锁（pthread_mutex）</p><p>：</p><ul><li>对共享数据结构加锁保护，确保同一时刻只有一个线程能读写，彻底消除数据竞争。例如，当MQTT线程和界面线程都需要访问状态缓存时，先加锁，操作完成后解锁。</li></ul></li><li><p>信号量（pthread_semaphore）</p><p>：</p><ul><li>用于线程间同步，如数据生产者线程采集到新数据后，通过信号量通知消费者线程进行处理，实现高效异步解耦，避免忙等。</li></ul></li><li><p>消息队列</p><p>：</p><ul><li>利用Linux的<code>msgqueue</code>或自定义队列，实现线程间的数据高效传递。例如，消息收发线程将新消息入队，数据处理线程出队异步处理。</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>华勤技术面试准备</title>
      <link href="/2024/08/07/test/%E5%8D%8E%E5%8B%A4%E6%8A%80%E6%9C%AF/"/>
      <url>/2024/08/07/test/%E5%8D%8E%E5%8B%A4%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="华勤技术"><a href="#华勤技术" class="headerlink" title="华勤技术"></a><strong>华勤技术</strong></h1><p>岗位描述：</p><p>1、负责X86&#x2F;Arm平台Linux驱动开发，OS开发维护。对于Arm产品如OpenBMC也包含Bootloader，Memory、OS定制及维护。</p><p>2、负责网络产品、计算产品的驱动及OS架构设计，系统需求设计。应用工具及App开发。</p><p>3、负责分解&amp;实现客户的需求，解决测试和客户反馈的问题，确保项目进度按时达成。</p><p>岗位要求：</p><p>1、熟悉linux或RTOS下底层驱动以及系统开发</p><p>2、熟悉操作系统以及编译、链接等基础知识，能熟练应用到debug过，程中，</p><p>3、熟练使用各种仪器，调试功能，和调试手段，</p><p>4、良好的分析与解决问题能力、学习能力、创新能力和团队合作精神。</p><p>首先我觉得这种面试肯定是靠运气。因为他可能现在补录了。所以面试一点技术都没有问。但是你如果是面驱动岗位肯定要会c语言。其次就是你要会一些字符设备驱动或者platform驱动的架构及你要会做过一些这种项目，这就涉及到嵌入式开发，这些东西都是你必须要掌握的。当然面试就是看运气了。    </p><h1 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1.自我介绍"></a>1.自我介绍</h1><p>面试官您好，我叫林言威，来自西北民族大学电子信息工程专业。非常感谢您给我这次面试的机会。</p><p>我很喜欢嵌入式开发，并在校期间积累了丰富的实践经验。我的主要项目经历包括主导开发一款基于AI的智能语音台灯。该项目采用STM32单片机（<strong>ARM Cortex-M系列内核</strong>）的单片机，集成了光敏、温湿度和超声波等多种传感器，实现了自动调光、坐姿提醒、疲劳监测等多项功能，并支持语音交互和手机远程控制。项目中，我深入掌握了STM32硬件设计、串口通信、PWM控制和多任务开发等关键技术。</p><p>此外，我还参与了基于Linux的MQTT智能家居系统开发，使用IMX6ULL（ARM Cortex-A内核）开发板及Linux实时操作系统。</p><p>并实现了小程序远程控制功能 。这一经历让我系统掌握了嵌入式Linux开发、驱动开发、MQTT协议移植和多进程&#x2F;多线程编程。</p><p>我的专业技能包括：</p><ul><li>熟悉嵌入式Linux应用开发，熟悉系统编程、文件IO、多进程&#x2F;多线程等技术；</li><li>熟练使用STM32等单片机，熟悉寄存器操作、GPIO、UART、IIC等常用接口及总线协议；</li><li>具备良好的软硬件协同开发能力和团队协作能力。</li></ul><p>我的自我介绍到此结束，谢谢面试官的认真聆听，期待与您的深入交流，也希望能为团队贡献我的力量。</p><h1 id="2-主要掌握什么语言（c-shell脚本）"><a href="#2-主要掌握什么语言（c-shell脚本）" class="headerlink" title="2.主要掌握什么语言（c shell脚本）"></a>2.主要掌握什么语言（c shell脚本）</h1><p>我主要掌握C语言和Shell脚本，同时也熟悉C++语言。我熟练运用常用数据结构与算法，比如链表、栈、队列、二分查找和哈希表，并且了解STL库的使用,python 语言。在蓝桥杯省赛中，我也获得了C语言一等奖，我觉得我对这些编程语言还算熟悉。</p><h1 id="Python、C（过程）、C-（对象）有什么区别（解释器、编译器、面向过程、面向对象……）"><a href="#Python、C（过程）、C-（对象）有什么区别（解释器、编译器、面向过程、面向对象……）" class="headerlink" title="Python、C（过程）、C++（对象）有什么区别（解释器、编译器、面向过程、面向对象……）"></a>Python、C（过程）、C++（对象）有什么区别（解释器、编译器、面向过程、面向对象……）</h1><h3 id="Python、C、C-的区别"><a href="#Python、C、C-的区别" class="headerlink" title="Python、C、C++的区别"></a><strong>Python、C、C++的区别</strong></h3><ol><li><p><strong>解释器与编译器</strong>：</p><ul><li><strong>Python</strong>：解释型语言，代码通过解释器逐行执行。</li><li>**C&#x2F;C++**：编译型语言，代码先编译成机器码，再执行。</li></ul></li><li><p><strong>运行速度</strong>：</p><ul><li><strong>Python</strong>：运行速度相对较慢，适合快速开发。</li><li>**C&#x2F;C++**：运行速度快，适合性能要求高的应用。</li></ul></li><li><p><strong>内存管理</strong>：</p><ul><li><strong>Python</strong>：自动内存管理（垃圾回收）。</li><li>**C&#x2F;C++**：手动内存管理，需程序员管理内存。</li></ul></li><li><p><strong>面向过程与面向对象</strong>：</p><ul><li><strong>Python</strong>：支持面向对象编程，也支持函数式编程。</li><li><strong>C</strong>：主要面向过程编程，但支持结构体。</li><li>**C++**：面向对象编程，支持类、继承、多态等。</li></ul></li><li><p><strong>用途</strong>：</p><ul><li><p><strong>Python</strong>：适合快速开发、脚本、数据分析、机器学习等。</p></li><li><p><strong>C</strong>：适合系统编程、嵌入式开发、性能敏感的应用。</p></li><li><p>**C++**：适合系统编程、游戏开发、高性能应用。</p></li></ul></li></ol><h1 id="3-用到什么开发软件（答了source-insight-notepad-vscode-面试官补充了一个git）"><a href="#3-用到什么开发软件（答了source-insight-notepad-vscode-面试官补充了一个git）" class="headerlink" title="3.用到什么开发软件（答了source insight notepad++ vscode 面试官补充了一个git）"></a>3.用到什么开发软件（答了source insight notepad++ vscode 面试官补充了一个git）</h1><p>在开发过程中，用到了不同的开发工具和软件来满足不同阶段和需求的开发任务。对于嵌入式项目，我常用 <strong>Keil</strong> 进行 STM32 等嵌入式项目的开发，同时，我也熟练使用 <strong>Linux 下的 GCC 和 GDB</strong>，用于嵌入式 Linux 开发，它们帮助我高效完成代码编译和调试。此外，<strong>Source Insight</strong> 是我用于代码阅读和分析的重要工具，尤其适合大型项目的代码管理和理解；<strong>Notepad++</strong> 编辑和查看代码。<strong>VSCode</strong> 是我日常使用最多的开发工具，它不仅支持多种语言（如 C、C++、Python 和 Shell 脚本），还具备强大的调试功能和丰富的插件生态。</p><p>我还学过使用Git进行代码版本控制和代码管理。我也熟悉Makefile，用于自动化编译多文件项目。在图形界面开发方面，我使用QT框架，比如在智能家居系统项目中开发了用户交互界面。这些工具覆盖了从嵌入式到应用开发的全流程，帮助我高效完成开发任务。</p><h1 id="4-在项目中遇到的困难以及如何解决带来什么收获（-这个感觉比较重要"><a href="#4-在项目中遇到的困难以及如何解决带来什么收获（-这个感觉比较重要" class="headerlink" title="4.在项目中遇到的困难以及如何解决带来什么收获（  这个感觉比较重要"></a>4.在项目中遇到的困难以及如何解决带来什么收获（  这个感觉比较重要</h1><h3 id="项目：灯心智启——基于-AI-技术智能语音台灯的设计与实现"><a href="#项目：灯心智启——基于-AI-技术智能语音台灯的设计与实现" class="headerlink" title="项目：灯心智启——基于 AI 技术智能语音台灯的设计与实现"></a>项目：灯心智启——基于 AI 技术智能语音台灯的设计与实现</h3><p>疲劳识别算法方面存在困难</p><p>在“灯心智启”智能语音台灯项目中，我遇到过RTC异常复位导致时间丢失的难题。最初，台灯在断电或主控芯片复位后，RTC无法保持准确时间，影响了自动调光等核心功能。</p><p>针对这个问题，我首先系统性排查了电路和代码，发现主电源断开时RTC缺乏持续供电是主因。为此，我在硬件上为RTC加装了独立纽扣电池，确保掉电时RTC依然正常运行。同时，在软件层面，优化了RTC初始化流程，通过检测备份寄存器判断是否异常复位，若检测到异常则自动从备份或外部接口恢复时间，确保系统恢复后时间准确。</p><p><strong>解决方法</strong>：</p><ul><li>对 模型进行进一步的优化和调整，通过增加训练数据量、调整模型参数等方式，提高模型的准确率。</li></ul><p><strong>收获</strong>：提高了 <strong>问题解决能力</strong>  和  相关领域的<strong>技术提升</strong>    并对技术有了更深入的理解和掌握。</p><h3 id="AI-模型训练与移植"><a href="#AI-模型训练与移植" class="headerlink" title="AI 模型训练与移植"></a>AI 模型训练与移植</h3><p>K210的模型部署和优化是一个挑战，特别是在有限算力和内存条件下，需要兼顾模型精度与运行效率。为此，我针对实际应用场景，选取了轻量级神经网络结构，并利用K210的硬件加速特性，在K210与STM32主控芯片的数据通信方面，我通过串口协议优化，确保了AI推理结果能够实时反馈到系统控制流程中，有效提升了用户交互体验。</p><ul><li><strong>难点描述</strong>：项目中涉及到 K210 模型的训练，用于语音交互等功能。AI 模型训练本身需要大量的数据和计算资源，并且要选择合适的算法和模型架构。训练完成后，还需要将模型移植到 STM32 单片机上运行，而单片机的计算能力和存储资源相对有限，这使得模型的优化和移植变得非常困难。</li><li><strong>解决方法</strong>：在模型训练阶段，可以通过数据增强等技术扩充训练数据集，选择适合嵌入式设备的轻量级神经网络架构，如 TinyML 等。在移植过程中，使用模型量化技术将模型参数从浮点数转换为整数，以减少模型的存储空间和计算量。同时，对模型进行裁剪，去除一些对性能影响不大的层，以适应单片机的资源限制。并且要编写高效的代码来实现模型的推理过程，充分利用单片机的硬件资源，如使用 DMA（直接存储器访问）来加速数据传输。</li></ul><h3 id="项目：Linux-MQTT-智能家居系统"><a href="#项目：Linux-MQTT-智能家居系统" class="headerlink" title="项目：Linux MQTT 智能家居系统"></a>项目：Linux MQTT 智能家居系统</h3><p>困难<strong>问题描述</strong>：：</p><p>uboot 启动提示找不到设备树文件 无法启动内核 但是直接查看内存卡后看到设备树文件存在 并且在该目录下，并且 在uboot中使用fdt 命令查询设备树都可以查看到 </p><p>在启动过程中，U-Boot 未能正确加载设备树文件（.dtb），导致内核无法正确识别硬件设备。</p><p><strong>解决方法</strong>：</p><p><strong>文件路径问题</strong></p><ul><li><p><strong>解决方法</strong>：</p><ul><li><p>确保在 U-Boot 中加载设备树文件时使用了正确的路径。例如，如果设备树文件位于内存卡的根目录下，可以使用以下命令加载：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load mmc 0:1 <span class="variable">$&#123;fdt_addr_r&#125;</span> /boot/dtb</span><br></pre></td></tr></table></figure><p>其中，<code>mmc 0:1</code> 表示从第一个 MMC 设备的第一个分区加载文件，<code>$&#123;fdt_addr_r&#125;</code> 是设备树文件加载的内存地址。</p></li><li><p>如果路径中包含特殊字符或空格，确保正确转义或使用引号。</p></li></ul><p><strong>文件名大小写问题</strong> </p></li><li><p><strong>问题</strong>：文件名大小写不匹配。U-Boot 对文件名大小写敏感。</p></li><li><p><strong>解决方法</strong>：</p><ul><li>确保在 U-Boot 中指定的设备树文件名与实际文件名完全一致，包括大小写。例如，如果文件名是 <code>dtb.dtb</code>，则不能写成 <code>DTB.DTB</code>。</li></ul></li></ul><p> <strong>环境变量问题</strong></p><ul><li><p><strong>问题</strong>：U-Boot 的环境变量可能未正确设置。</p></li><li><p><strong>解决方法</strong>：</p><ul><li><p>检查 U-Boot 的环境变量是否正确设置了设备树文件的路径和名称。使用以下命令查看环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printenv</span></span><br></pre></td></tr></table></figure></li><li><p>如果发现 <code>bootargs</code> 或其他相关变量中缺少设备树文件路径，进行手动设置。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenv bootargs <span class="variable">$&#123;bootargs&#125;</span> fdt_file=/boot/dtb.dtb</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>检查启动日志</strong></p><p>仔细查看 U-Boot 启动日志，确认设备树文件加载和传递给内核的过程。</p><h4 id="示例日志："><a href="#示例日志：" class="headerlink" title="示例日志："></a>示例日志：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">U-Boot&gt; boot</span><br><span class="line">...</span><br><span class="line">Loading Kernel from FIT Image at 80000000 ...</span><br><span class="line">Loading Device Tree from FIT Image at 80000000 ...</span><br><span class="line">Booting using the fdt blob at 83000000</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>通过上述步骤，你应该能够解决 U-Boot 启动时找不到设备树文件的问题。</p><p><strong>收获</strong>：</p><ul><li><strong>对设备树的理解加深</strong>：通过解决这个问题，更加深入地理解了设备树文件的作用以及如何在启动过程中正确加载设备树文件。</li><li><strong>调试能力提升</strong>：学会了如何在 U-Boot 中进行调试和配置，提升了对 Bootloader 的调试能力。</li><li><strong>对启动参数的理解加深</strong>：通过解决启动参数问题，更加深入地了解了启动参数的作用以及如何正确传递启动参数。</li></ul><h1 id="在Linux-MQTT智能家居系统项目中，我遇到的最大困难是"><a href="#在Linux-MQTT智能家居系统项目中，我遇到的最大困难是" class="headerlink" title="在Linux MQTT智能家居系统项目中，我遇到的最大困难是"></a>在Linux MQTT智能家居系统项目中，我遇到的最大困难是</h1><p>驱动移植和多协议设备的兼容性问题。项目初期，IMX6ULL PRO开发板需要支持多种传感器和外设，但现有驱动与Linux内核版本不完全兼容，导致部分外设无法正常通信，影响了系统的稳定性和实时性。</p><p>为解决这一挑战，我首先梳理了设备树配置，结合原理图分析硬件接口，逐步排查驱动加载日志，定位问题根源。随后，我针对性地重写和优化了部分驱动代码，并手动配置GPIO、I2C、PWM等底层参数，确保各类传感器和执行器均能被系统正确识别与控制。同时，针对MQTT协议在Linux下的移植难点，我利用多线程技术和同步机制，提高了消息的实时响应能力。最终，系统实现了通过小程序远程控制，家居环境监测与智能调节功能，整体运行稳定，响应速度提升约40%。</p><h1 id="设备树配置"><a href="#设备树配置" class="headerlink" title="设备树配置"></a>设备树配置</h1><p>在Linux MQTT智能家居系统项目中，设备树配置是实现各类外设正常工作的关键环节。项目初期，IMX6ULL PRO开发板需要连接多种传感器和执行器，但由于硬件资源分配复杂，设备树节点配置不当会导致驱动无法加载或者资源冲突。</p><p>为此，我详细研读了开发板原理图，结合芯片手册梳理每一个外设的GPIO、I2C、PWM等硬件连接关系。在设备树中，逐一配置各外设节点，包括pinctrl子系统的管脚复用、输入子系统的事件映射、lcd显示以及中断资源。每次修改后，我通过dmesg日志和cat &#x2F;proc&#x2F;device-tree进行验证，确保驱动能够正确识别和初始化各外设。通过这一系列优化，外设识别率提升至100%，系统稳定性和可扩展性显著增强。</p><h1 id="设备树作用"><a href="#设备树作用" class="headerlink" title="设备树作用"></a>设备树作用</h1><p>设备树的作用非常关键。设备树本质上是描述硬件资源和连接关系的数据结构，它让操作系统在启动时无需修改内核源码，就能灵活识别和配置不同的外设，比如GPIO、I2C、PWM等。</p><p>通过设备树配置，我能够精准地分配硬件资源，避免驱动冲突和资源浪费。例如，在IMX6ULL PRO开发板上，依靠设备树完成了各类传感器和执行器的挂载与初始化，驱动识别效率提升至100%，大大缩短了调试周期。设备树还极大增强了系统的可移植性和扩展性，为后续新增模块提供了便利。</p><h1 id="pthread-mutex-lock和pthread-mutex-unlock是Linux多线程编程中常用的互斥锁操作函数。"><a href="#pthread-mutex-lock和pthread-mutex-unlock是Linux多线程编程中常用的互斥锁操作函数。" class="headerlink" title="pthread_mutex_lock和pthread_mutex_unlock是Linux多线程编程中常用的互斥锁操作函数。"></a>pthread_mutex_lock和pthread_mutex_unlock是Linux多线程编程中常用的互斥锁操作函数。</h1><p>在我的Linux MQTT智能家居系统项目中，我常用这两个函数来保护多线程对共享资源的访问。pthread_mutex_lock用于加锁，确保当前线程独占访问某一临界区，防止其他线程同时修改数据。操作完成后，调用pthread_mutex_unlock解锁，允许其他线程进入临界区。这样可以有效避免数据竞争和资源冲突。</p><p>具体做法是：在访问共享数据（如传感器缓冲区）前，先调用pthread_mutex_lock获取互斥锁，确保当前只有一个线程能操作该数据；操作完成后，立即调用pthread_mutex_unlock释放锁。这样有效防止了数据竞争和异常，提高了系统稳定性。</p><p>在每次访问或修改共享数据前，在线程中调用<code>pthread_mutex_lock(&amp;mutex)</code>加锁，确保当前线程独占资源。数据操作完成后，立即调用<code>pthread_mutex_unlock(&amp;mutex)</code>解锁，允许其他线程访问。这样有效防止了数据竞争和异常，系统长时间运行未出现死锁或数据错乱问题。</p><p>通过合理使用这两个函数，项目实现了多线程环境下的数据一致性和系统稳定性，系统在长时间运行下稳定率超过99%。未来在贵公司多线程嵌入式开发任务中，我能够熟练运用pthread互斥锁机制，确保系统高效安全运行。</p><h1 id="5-简述一下uboot启动流程"><a href="#5-简述一下uboot启动流程" class="headerlink" title="5.简述一下uboot启动流程"></a>5.简述一下uboot启动流程</h1><p>第一阶段：ROM code（芯片厂商内置的代码）初始化一些基本的时钟，从选定的设备中去加载FSBL的代码，并启动FSBL第一阶段引导程序代码</p><p>第二阶段：FSBL (first stage boot loader)   第一阶段引导程序完成时钟的初始化，初始化DDR，从选定的设备中去加载SSBL第二阶段引导程序的代码，并启动SSBL第二阶段引导程序代码</p><p>第三阶段：从外部储存或者网络中加载linux系统，通过启动动画向用户反馈启动过程，启动linux内核</p><p>第四阶段：linux内核初始化，挂载根文件系统，启动用户空间的init程序</p><p>最后进入到linux用户空间</p><ol><li><p><strong>时钟设置</strong>：配置处理器的时钟和电源管理，确保系统的时钟频率设置正确。</p></li><li><p><strong>内存控制器初始化</strong>：设置内存控制器，以便能够正确访问SDRAM。</p></li><li><p><strong>关闭看门狗</strong>：禁用看门狗计时器，防止在引导过程中重置系统。</p></li><li><p><strong>关闭中断</strong>：禁用所有中断，确保引导过程不会被打断。</p></li><li><p><strong>设置栈</strong>：初始化处理器的栈指针，为后续的程序执行提供必要的内存空间。</p></li><li><p><strong>重定位U-Boot</strong>：将U-Boot的代码从非易失性存储器（如NAND或NOR Flash）复制到SDRAM中，这个过程称为重定位。</p></li><li><p><strong>清除BSS段</strong>：清零所有未初始化的全局变量，为程序的运行提供一个干净的环境。</p></li><li><p><strong>硬件设备初始化</strong>：初始化串口、网络接口等硬件设备，以便可以与U-Boot进行交互。</p></li><li><p><strong>环境变量设置</strong>：加载U-Boot的环境变量，这些变量包含了系统启动所需的配置信息。</p></li><li><p><strong>加载内核映像</strong>：从存储设备中读取操作系统内核映像，并将其加载到SDRAM中。</p></li><li><p><strong>设置启动参数</strong>：为操作系统内核设置启动参数，这些参数告诉内核硬件的配置信息和启动方式。</p></li><li><p><strong>跳转执行内核</strong>：最后，U-Boot通过设置处理器的程序计数器（PC）来跳转执行操作系统内核。</p></li></ol><h1 id="5-详细uboot启动流程"><a href="#5-详细uboot启动流程" class="headerlink" title="5.详细uboot启动流程"></a>5.详细uboot启动流程</h1><p>首先，在第一阶段，ROM Code（芯片厂商内置的代码）会进行硬件检查、<strong>设置基本时钟</strong>，并从存储设备（如SPI Flash、eMMC或SD卡）加载第一阶段引导程序FSBL（First Stage Boot Loader）到内存中运行。接着，FSBL负责初始化硬件，包括初始化内存控制器（如DDR）、配置更精确的时钟、禁用看门狗计时器和中断，初始化处理器的栈指针，将U-Boot代码从非易失性存储器重定位到SDRAM中，清零未初始化的全局变量（BSS段），并加载第二阶段引导程序SSBL到内存中运行。在第三阶段，SSBL进一步初始化硬件设备（如串口、网络接口），加载U-Boot的环境变量，从存储设备或网络加载Linux内核映像到SDRAM中，设置启动参数，并可能显示启动动画，最后通过设置处理器的程序计数器跳转执行操作系统内核。进入第四阶段，Linux内核初始化操作系统的核心功能，检测和初始化硬件设备，挂载根文件系统（如ext4、initramfs），并启动用户空间的<code>init</code>程序（如<code>systemd</code>或<code>init</code>），负责启动其他系统服务和程序。最终，计算机进入Linux用户空间，启动用户界面（如图形用户界面或命令行界面），用户可以打开各种应用程序，进行日常操作。整个启动过程环环相扣，确保了计算机能够顺利启动并为用户提供服务。；</p><h1 id="10、你能列举一个你最熟悉的协议吗？"><a href="#10、你能列举一个你最熟悉的协议吗？" class="headerlink" title="10、你能列举一个你最熟悉的协议吗？"></a>10、你能列举一个你最熟悉的协议吗？</h1><p>I2C协议是一种简单、低速的同步串行通信协议，主要用于连接低速外设，如传感器和存储器。它通过两根线（SDA数据线和SCL时钟线）实现通信，支持多主多从架构，每个从设备都有唯一地址。通信过程包括启动信号、发送设备地址、数据传输和停止信号。I2C协议广泛应用于嵌入式系统，例如连接温湿度传感器、EEPROM或实时时钟等设备。我曾在项目中通过STM32微控制器使用I2C协议读取传感器数据，其简单性和可靠性非常适合低速通信需求。</p><h1 id="6-主要用到什么通信协议：-I2C-UART-SPI-简述一下I2C的通信特点以及时序"><a href="#6-主要用到什么通信协议：-I2C-UART-SPI-简述一下I2C的通信特点以及时序" class="headerlink" title="6.主要用到什么通信协议： I2C UART SPI 简述一下I2C的通信特点以及时序"></a>6.主要用到什么通信协议： I2C UART SPI 简述一下I2C的通信特点以及时序</h1><h3 id="1-主要用到的通信协议"><a href="#1-主要用到的通信协议" class="headerlink" title="1. 主要用到的通信协议"></a>1. 主要用到的通信协议</h3><h4 id="1-I2C（Inter-Integrated-Circuit）"><a href="#1-I2C（Inter-Integrated-Circuit）" class="headerlink" title="1.I2C（Inter-Integrated Circuit）"></a>1.I2C（Inter-Integrated Circuit）</h4><ul><li><strong>用途</strong>：用于连接低速外设，如传感器、EEPROM等。</li><li><strong>特点</strong>：<ul><li><strong>多主多从</strong>：支持多个主设备和多个从设备。</li><li><strong>两线制</strong>：使用两条线（SDA和SCL）进行通信，SDA为数据线，SCL为时钟线。</li><li><strong>地址寻址</strong>：每个从设备都有唯一的地址，主设备通过地址来选择特定的从设备。</li><li><strong>速率</strong>：标准速率100 kbps，快速速率400 kbps，高速速率3.4 Mbps。</li><li><strong>简单</strong>：协议简单，适合低速通信。</li></ul></li></ul><h4 id="2-UART（Universal-Asynchronous-Receiver-Transmitter）"><a href="#2-UART（Universal-Asynchronous-Receiver-Transmitter）" class="headerlink" title="2.UART（Universal Asynchronous Receiver&#x2F;Transmitter）"></a>2.UART（Universal Asynchronous Receiver&#x2F;Transmitter）</h4><ul><li><strong>用途</strong>：用于串行通信，常用于设备之间的数据传输，如调试接口。</li><li><strong>特点</strong>：<ul><li><strong>异步通信</strong>：不使用时钟线，通过起始位和停止位来同步数据。</li><li><strong>单向通信</strong>：通常使用两条线（TX和RX）进行全双工通信。</li><li><strong>波特率</strong>：通信速率可配置，常见的波特率有9600、115200等。</li><li><strong>简单</strong>：协议简单，适合长距离通信。</li></ul></li></ul><h4 id="3-SPI（Serial-Peripheral-Interface）"><a href="#3-SPI（Serial-Peripheral-Interface）" class="headerlink" title="3.SPI（Serial Peripheral Interface）"></a>3.SPI（Serial Peripheral Interface）</h4><ul><li><strong>用途</strong>：用于高速通信，常用于连接存储器、传感器等。</li><li><strong>特点</strong>：<ul><li><strong>主从模式</strong>：通常有一个主设备和多个从设备。</li><li><strong>四线制</strong>：使用四条线（SCLK、MOSI、MISO、CS）进行通信。</li><li><strong>高速</strong>：速率可达几Mbps甚至更高。  </li><li><strong>简单</strong>：协议简单，适合高速通信。</li></ul></li></ul><h4 id="4-CAN（Controller-Area-Network）"><a href="#4-CAN（Controller-Area-Network）" class="headerlink" title="4.CAN（Controller Area Network）"></a>4.CAN（Controller Area Network）</h4><ul><li><strong>用途</strong>：广泛应用于汽车电子、工业自动化等领域。</li><li><strong>特点</strong>：<ul><li><strong>多节点通信</strong>：支持多个设备以总线型拓扑结构连接。</li><li><strong>高可靠性</strong>：具有强大的错误检测和仲裁机制。</li><li><strong>差分信号</strong>：使用两条差分信号线（CAN_H和CAN_L），抗干扰能力强。</li><li><strong>速率</strong>：最高可达1 Mbps。</li><li><strong>适用于高噪声环境</strong>：适合工业自动化和汽车电子系统。</li></ul></li></ul><h3 id="I2C通信特点及简要时序"><a href="#I2C通信特点及简要时序" class="headerlink" title="I2C通信特点及简要时序"></a>I2C通信特点及简要时序</h3><p>I2C是一种两线制通信协议，使用SDA（数据线）和SCL（时钟线）进行通信。它支持多主多从，每个从设备通过唯一的地址进行识别。I2C协议简单，适合低速通信，标准速率为100 kbps，快速速率为400 kbps，高速速率为3.4 Mbps。</p><p>其通信时序包括起始条件（SCL为高电平时，SDA从高电平变为低电平）、停止条件（SCL为高电平时，SDA从低电平变为高电平），以及数据传输（每个字节包含8位数据，从最高位开始传输，每个字节后有一个应答位）。</p><h3 id="UART通信特点及简要时序"><a href="#UART通信特点及简要时序" class="headerlink" title="UART通信特点及简要时序"></a>UART通信特点及简要时序</h3><p>UART是一种异步通信协议，通常使用两条线（TX和RX）进行全双工通信。它不使用时钟线，通过起始位和停止位来同步数据。UART通信速率可配置，常见的波特率有9600、115200等。</p><p>其通信时序简单，数据帧由起始位、数据位（通常8位）、可选的奇偶校验位和停止位组成。</p><h3 id="SPI通信特点及简要时序"><a href="#SPI通信特点及简要时序" class="headerlink" title="SPI通信特点及简要时序"></a>SPI通信特点及简要时序</h3><p>SPI是一种四线制的通信协议，使用SCLK（时钟线）、MOSI（主设备数据输出）、MISO（主设备数据输入）和CS（片选线）。SPI协议简单，适合高速通信，速率可达几Mbps甚至更高。</p><p>其通信时序包括主设备提供时钟信号，数据在时钟的上升沿或下降沿被采样，具体取决于通信模式（SPI有四种模式，分别对应不同的时钟极性和相位）。</p><h3 id="CAN通信特点及简要时序"><a href="#CAN通信特点及简要时序" class="headerlink" title="CAN通信特点及简要时序"></a>CAN通信特点及简要时序</h3><p>CAN是一种多节点通信协议，广泛应用于汽车电子和工业自动化中。它使用两条差分信号线（CAN_H和CAN_L），具有强大的抗干扰能力和错误检测机制。CAN通信速率最高可达1 Mbps。</p><p>其通信时序包括帧头（包含标识符和控制信息）、数据段（可变长度，最大8字节）和校验段（CRC校验）。CAN协议通过仲裁机制确保在多个设备同时发送数据时不会发生冲突。</p><h1 id="1-给我介绍下spi-i2c"><a href="#1-给我介绍下spi-i2c" class="headerlink" title="1 给我介绍下spi i2c"></a>1 给我介绍下spi i2c</h1><h2 id="1-SPI（Serial-Peripheral-Interface，串行外设接口）"><a href="#1-SPI（Serial-Peripheral-Interface，串行外设接口）" class="headerlink" title="1. SPI（Serial Peripheral Interface，串行外设接口）"></a>1. SPI（Serial Peripheral Interface，串行外设接口）</h2><h3 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h3><ul><li><strong>全双工</strong>通信（数据可以同时双向传输）</li><li><strong>主从模式</strong>（一个主设备，多个从设备）</li><li>通常有4根线：<ul><li><strong>MOSI</strong>（主输出从输入，Master Out Slave In）</li><li><strong>MISO</strong>（主输入从输出，Master In Slave Out）</li><li><strong>SCLK</strong>（时钟信号，Serial Clock）</li><li><strong>SS&#x2F;CS</strong>（从设备选择，Slave Select&#x2F;Chip Select）</li></ul></li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>速度快（10Mbps甚至更高）</li><li>协议简单，硬件实现容易</li><li>支持多从设备</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>需要较多的引脚（每个从设备都需要一个独立的CS线）</li><li>没有规范的应答机制（ACK）</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>SD卡、Flash存储器、显示屏、传感器等</li></ul><hr><h2 id="2-I²C（Inter-Integrated-Circuit，集成电路间总线）"><a href="#2-I²C（Inter-Integrated-Circuit，集成电路间总线）" class="headerlink" title="2. I²C（Inter-Integrated Circuit，集成电路间总线）"></a>2. I²C（Inter-Integrated Circuit，集成电路间总线）</h2><h3 id="基本特点-1"><a href="#基本特点-1" class="headerlink" title="基本特点"></a>基本特点</h3><ul><li><strong>半双工</strong>通信（数据只能单向传输）</li><li><strong>多主多从</strong>（可以有多个主设备和多个从设备）</li><li>只需要2根线<ul><li><strong>SDA</strong>（数据线，Serial Data）</li><li><strong>SCL</strong>（时钟线，Serial Clock）</li></ul></li></ul><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>只需两根信号线，节省引脚</li><li>支持多个设备挂在同一总线上</li><li>有应答机制，通信更可靠</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>速度较低（标准模式100kbps，快速模式400kbps，高速模式3.4Mbps）</li><li>总线长度和设备数量有限（电容影响信号完整性）</li></ul><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>温湿度传感器、EEPROM、实时时钟等</li></ul><p><strong>SPI</strong> 是一种全双工的串行通信协议，通常用于高速通信场景。它使用四根线：SCLK（时钟线）、MOSI（主设备数据输出）、MISO（主设备数据输入）和CS（片选线）。SPI 支持一个主机连接多个从机，通过片选信号来选择当前通信的从机。它的优点是数据传输速度快，适合与存储器、显示屏等设备通信。</p><p><strong>I2C</strong> 是一种半双工的串行通信协议，通常用于低速通信场景。它只需要两根线：SDA（数据线）和SCL（时钟线）。I2C 支持多主多从架构，通过设备地址来区分不同的设备。它的优点是引脚需求少，适合空间受限的环境，常用于与传感器、EEPROM 等设备通信。</p><h1 id="2-i2c的速率有几种，帧的组成，仲裁方法"><a href="#2-i2c的速率有几种，帧的组成，仲裁方法" class="headerlink" title="2 i2c的速率有几种，帧的组成，仲裁方法"></a>2 i2c的速率有几种，帧的组成，仲裁方法</h1><p><strong>I2C速率</strong>：I2C协议定义了多种速率标准：</p><ul><li><strong>标准速率（Standard-mode）</strong>：最高100 kbps。</li><li><strong>快速速率（Fast-mode）</strong>：最高400 kbps。</li><li><strong>快速加速率（Fast-mode Plus）</strong>：最高1 Mbps。</li><li><strong>高速速率（High-speed mode）</strong>：最高3.4 Mbps。</li><li><strong>超速速率（Ultra Fast-mode）</strong>：最高5 Mbps。</li></ul><p>不同速率适用于不同的应用场景，速率越高，对硬件和信号完整性的要求也越高。</p><hr><p><strong>I2C帧组成</strong>：I2C通信的基本单位是帧，一个完整的帧包括以下部分：</p><ol><li><strong>起始位（Start Condition）</strong>：SCL为高电平时，SDA从高电平变为低电平。</li><li><strong>数据位（Data Bits）</strong>：每个字节包含8位数据，从最高位（MSB）开始传输。</li><li><strong>应答位（Acknowledge Bit）</strong>：每个字节传输后，接收方发送一个应答位，低电平表示应答（ACK），高电平表示不应答（NACK）。</li><li><strong>停止位（Stop Condition）</strong>：SCL为高电平时，SDA从低电平变为高电平。</li></ol><hr><p><strong>I2C仲裁方法</strong>：当多个主机同时尝试控制总线时，I2C采用<strong>位仲裁机制</strong>：</p><ul><li>在SCL时钟信号为高电平时，如果某个主机检测到SDA线上的电平与其预期发送的电平不一致，则该主机会放弃总线控制权，进入从机模式。</li><li>仲裁基于SDA线的电平状态，确保只有一个主机能够成功控制总线，避免数据冲突。</li></ul><h1 id="3-spi的4种模式，这些模式有啥区别"><a href="#3-spi的4种模式，这些模式有啥区别" class="headerlink" title="3 spi的4种模式，这些模式有啥区别"></a>3 spi的4种模式，这些模式有啥区别</h1><ol><li><strong>模式0（CPOL&#x3D;0, CPHA&#x3D;0）</strong>：时钟空闲为低，数据在上升沿采样。</li><li><strong>模式1（CPOL&#x3D;0, CPHA&#x3D;1）</strong>：时钟空闲为低，数据在下降沿采样。</li><li><strong>模式2（CPOL&#x3D;1, CPHA&#x3D;0）</strong>：时钟空闲为高，数据在下降沿采样。</li><li><strong>模式3（CPOL&#x3D;1, CPHA&#x3D;1）</strong>：时钟空闲为高，数据在上升沿采样。</li></ol><p><strong>区别</strong>：主要在于时钟的空闲电平和数据采样的时钟边沿。主从设备必须配置为相同模式，以确保通信正常。</p><h1 id="4-用过实时操作系统吗，介绍下启动流程"><a href="#4-用过实时操作系统吗，介绍下启动流程" class="headerlink" title="4 用过实时操作系统吗，介绍下启动流程"></a>4 用过实时操作系统吗，介绍下启动流程</h1><p><strong>用过实时操作系统</strong>。以常见的RTOS（如FreeRTOS）为例，其启动流程通常包括以下几个关键步骤：</p><ol><li><p><strong>硬件初始化</strong>：</p><ul><li>在系统启动时，首先进行硬件初始化，包括设置时钟、初始化外设（如GPIO、UART等）和配置中断控制器。</li></ul></li><li><p><strong>内核初始化</strong>：</p><ul><li>RTOS内核初始化，包括任务调度器、内存管理模块等。例如，FreeRTOS会初始化任务调度器，设置初始任务列表。</li></ul></li><li><p><strong>创建初始任务</strong>：</p><ul><li>创建并初始化系统运行所需的初始任务。这些任务通常包括一些后台服务任务和用户定义的任务。</li></ul></li><li><p><strong>启动调度器</strong>：</p><ul><li>调度器开始运行，根据任务的优先级和状态进行调度，使系统进入多任务运行状态。</li></ul></li><li><p><strong>任务执行</strong>：</p><ul><li>各任务根据调度器的调度，开始执行各自的功能，系统进入稳定运行状态。</li></ul><p>RTOS的启动流程主要包括硬件初始化、内核初始化、创建初始任务、启动调度器和任务执行。这个过程确保系统从硬件启动到多任务运行的平稳过渡。</p></li></ol><h1 id="1、请问I2C协议你有什么了解"><a href="#1、请问I2C协议你有什么了解" class="headerlink" title="1、请问I2C协议你有什么了解"></a>1、请问I2C协议你有什么了解</h1><p>回答的很表面，只是说这是一种板间通信的协议，速度如何，优势在哪里等等。。</p><ul><li><strong>两线制</strong>：使用SDA（数据线）和SCL（时钟线）进行通信。</li><li><strong>多主多从</strong>：支持多个主设备和多个从设备在同一总线上通信。</li><li><strong>速率</strong>：标准速率100 kbps，快速速率400 kbps，快速加速率1 Mbps，高速速率3.4 Mbps，超速速率5 Mbps。</li><li><strong>帧结构</strong>：包括起始位、数据位、应答位和停止位。</li><li><strong>仲裁</strong>：通过位仲裁机制解决多个主设备同时控制总线的问题。</li></ul><h1 id="2、那I2C里面的SDA和SCL是如何进行通信的，主从模式之间地址如何配置等等？"><a href="#2、那I2C里面的SDA和SCL是如何进行通信的，主从模式之间地址如何配置等等？" class="headerlink" title="2、那I2C里面的SDA和SCL是如何进行通信的，主从模式之间地址如何配置等等？"></a>2、那I2C里面的SDA和SCL是如何进行通信的，主从模式之间地址如何配置等等？</h1><p><strong>SDA和SCL通信机制</strong>：</p><ul><li><strong>SDA（数据线）</strong>：用于传输数据和地址信息，是双向的，通过上拉电阻保持高电平，设备通过拉低SDA线来传输数据。</li><li><strong>SCL（时钟线）</strong>：由主设备控制，用于同步数据传输的时钟信号，确保数据在SCL的高电平期间保持稳定。</li></ul><p><strong>通信过程</strong>：</p><ul><li><strong>开始信号</strong>：SCL为高电平时，SDA从高电平变为低电平，表示通信开始。</li><li><strong>结束信号</strong>：SCL为高电平时，SDA从低电平变为高电平，表示通信结束。</li><li><strong>数据传输</strong>：每个字节传输后，接收方发送一个应答信号（ACK），表示数据已成功接收。</li></ul><p><strong>主从模式</strong>：</p><ul><li><strong>主设备</strong>：控制SCL时钟线，发起通信，发送地址和数据。</li><li><strong>从设备</strong>：根据主设备发送的地址，响应通信请求，发送或接收数据。</li><li><strong>地址配置</strong>：每个从设备都有一个唯一的地址（通常是7位或10位），主设备通过发送地址来选择特定的从设备。</li></ul><p><strong>多主设备支持</strong>：</p><ul><li>I2C总线允许多个主设备共享同一总线，但一次只允许一个主设备控制总线。</li></ul><h1 id="3、I2C协议的数据格式如何，什么时候是数据的起始，什么时候是数据的结束"><a href="#3、I2C协议的数据格式如何，什么时候是数据的起始，什么时候是数据的结束" class="headerlink" title="3、I2C协议的数据格式如何，什么时候是数据的起始，什么时候是数据的结束"></a>3、I2C协议的数据格式如何，什么时候是数据的起始，什么时候是数据的结束</h1><h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a><strong>数据格式</strong></h4><p>I2C协议的数据传输是按字节进行的，每个字节包含8位数据，从最高位（MSB）开始传输。数据传输的基本单位是一个字节，每个字节传输后，接收方需要发送一个应答位（ACK）或非应答位（NACK）。</p><h4 id="起始和结束标志"><a href="#起始和结束标志" class="headerlink" title="起始和结束标志"></a><strong>起始和结束标志</strong></h4><ul><li><strong>起始条件</strong>：<ul><li>当SCL线为高电平时，SDA线从高电平变为低电平，表示通信开始。</li><li>这个信号由主设备发起，用于通知总线上的所有设备通信即将开始。</li></ul></li><li><strong>结束条件</strong>：<ul><li>当SCL线为高电平时，SDA线从低电平变为高电平，表示通信结束。</li><li>这个信号由主设备发起，用于通知总线上的所有设备通信已经结束。</li></ul></li></ul><h4 id="数据传输过程"><a href="#数据传输过程" class="headerlink" title="数据传输过程"></a><strong>数据传输过程</strong></h4><ol><li><strong>起始条件</strong>：主设备拉低SDA线，开始通信。</li><li><strong>发送地址</strong>：主设备发送一个字节的地址，包括设备地址和读写位。</li><li><strong>应答位</strong>：从设备发送ACK或NACK。</li><li><strong>数据传输</strong>：主设备发送或接收数据字节，每个字节后都有一个应答位。</li><li><strong>结束条件</strong>：主设备拉高SDA线，结束通信。</li></ol><h1 id="针对I2C、SPI和UART三种常用通信接口，我有如下速率配置和优化经验"><a href="#针对I2C、SPI和UART三种常用通信接口，我有如下速率配置和优化经验" class="headerlink" title="针对I2C、SPI和UART三种常用通信接口，我有如下速率配置和优化经验"></a>针对I2C、SPI和UART三种常用通信接口，我有如下速率配置和优化经验</h1><ul><li>I2C速率：在“灯心智启”项目中，I2C主要用于连接温湿度、光敏等传感器，常用速率为100kHz（标准模式）和400kHz（快速模式），实际应用中多选择400kHz以提升数据采集效率，通信延迟降低约25%。</li><li>SPI速率：SPI用于STM32与K210等模块的高速数据交互，实际设置为8MHz，能够满足AI模型推理和多传感器协同需求，数据传输效率提升约30%。STM32平台下SPI最高可支持到18MHz以上。</li><li>UART速率：在台灯和智能家居系统中，UART主要用于模块间调试和数据传输，常用波特率为115200bps，部分场景可配置到4.5Mbps，满足大部分实时通信需求。</li></ul><h1 id="5-线程进程的区别"><a href="#5-线程进程的区别" class="headerlink" title="5 线程进程的区别"></a>5 线程进程的区别</h1><p><strong>线程</strong>和<strong>进程</strong>的主要区别：</p><ul><li><strong>资源</strong>：进程有独立内存空间，线程共享进程内存。</li><li><strong>开销</strong>：线程创建和切换快，进程开销大。</li><li><strong>通信</strong>：线程通信快（共享内存），进程通信慢（需IPC）。</li><li><strong>调度</strong>：线程是调度单位，切换快；进程切换慢。</li><li><strong>独立性</strong>：进程独立，崩溃不影响其他进程；线程崩溃可能影响整个进程。</li></ul><h1 id="6-freertos-的信号传递有哪些方法"><a href="#6-freertos-的信号传递有哪些方法" class="headerlink" title="6 freertos 的信号传递有哪些方法"></a>6 freertos 的信号传递有哪些方法</h1><p>FreeRTOS 提供了五种主要的信号传递方法，分别是队列、信号量、互斥量、事件组和任务通知</p><h3 id="1-队列（Queue）"><a href="#1-队列（Queue）" class="headerlink" title="1. 队列（Queue）"></a>1. <strong>队列（Queue）</strong></h3><ul><li><strong>特点</strong>：队列是一种先进先出（FIFO）的数据结构，用于任务与任务、任务与中断之间的通信。</li><li><strong>适用场景</strong>：适用于需要传递数据的情况，可以存储多个数据项。</li><li><strong>示例</strong>：任务间传输传感器值、指令等。</li></ul><h3 id="2-信号量（Semaphore）"><a href="#2-信号量（Semaphore）" class="headerlink" title="2. 信号量（Semaphore）"></a>2. <strong>信号量（Semaphore）</strong></h3><ul><li><strong>特点</strong>：信号量用于任务同步，不承载数据。FreeRTOS 中的信号量分为二值信号量和计数型信号量。</li><li><strong>适用场景</strong>：适用于事件通知、任务同步。</li><li><strong>示例</strong>：中断触发任务启动。</li></ul><h3 id="3-互斥量（Mutex）"><a href="#3-互斥量（Mutex）" class="headerlink" title="3. 互斥量（Mutex）"></a>3. <strong>互斥量（Mutex）</strong></h3><ul><li><strong>特点</strong>：互斥量用于保护临界资源，确保同一时间只有一个任务可以访问。</li><li><strong>适用场景</strong>：适用于保护共享资源。</li></ul><h3 id="4-事件组（Event-Group）"><a href="#4-事件组（Event-Group）" class="headerlink" title="4. 事件组（Event Group）"></a>4. <strong>事件组（Event Group）</strong></h3><ul><li><strong>特点</strong>：事件组可以组合多个事件标志，允许任务等待多个事件中的任意一个或多个。</li><li><strong>适用场景</strong>：适用于任务需要与多个事件同步的场景。</li></ul><h3 id="5-任务通知（Task-Notification）"><a href="#5-任务通知（Task-Notification）" class="headerlink" title="5. 任务通知（Task Notification）"></a>5. <strong>任务通知（Task Notification）</strong></h3><ul><li><strong>特点</strong>：任务通知是一种轻量级的通信机制，每个任务有一个32位的通知值，可以在任务之间或中断中更新和读取。</li><li><strong>适用场景</strong>：适用于快速事件触发、中断触发事件通知。</li></ul><p>LED 灯驱动程序详细编写</p><h1 id="线程间通讯方式，死锁概念"><a href="#线程间通讯方式，死锁概念" class="headerlink" title="线程间通讯方式，死锁概念"></a>线程间通讯方式，死锁概念</h1><h3 id="线程间通讯方式"><a href="#线程间通讯方式" class="headerlink" title="线程间通讯方式"></a><strong>线程间通讯方式</strong></h3><ul><li><strong>共享内存</strong>：线程共享同一进程的内存空间，通过访问共享变量进行通信。需用互斥锁保护临界区。</li><li><strong>消息队列</strong>：线程间通过消息队列发送和接收消息，实现通信。</li><li><strong>信号量</strong>：用于线程同步，控制对共享资源的访问。</li><li><strong>事件</strong>：线程通过等待和触发事件进行同步。</li><li><strong>管道</strong>：线程间通过管道进行数据传输。</li></ul><hr><h3 id="死锁概念"><a href="#死锁概念" class="headerlink" title="死锁概念"></a><strong>死锁概念</strong></h3><ul><li><strong>定义</strong>：多个线程因相互等待对方持有的资源而无法继续执行的状态。</li><li><strong>产生条件</strong>：<ol><li><strong>互斥条件</strong>：资源不能同时被多个线程使用。</li><li><strong>请求与保持条件</strong>：线程已持有资源，又请求其他资源。</li><li><strong>不可剥夺条件</strong>：线程持有的资源不能被强制剥夺。</li><li><strong>循环等待条件</strong>：存在一个线程等待资源的循环链。</li></ol></li></ul><h1 id="2-介绍一下i2c"><a href="#2-介绍一下i2c" class="headerlink" title="2.介绍一下i2c"></a>2.介绍一下i2c</h1><p><strong>I2C（Inter-Integrated Circuit）</strong>是一种半双工、同步串行通信协议，主要用于微控制器和低速外围设备之间的通信。以下是I2C的关键特点：</p><ul><li><strong>两线制</strong>：使用两条线进行通信，分别是SDA（数据线）和SCL（时钟线）。</li><li><strong>多主多从</strong>：支持多个主设备和多个从设备在同一总线上通信，通过设备地址区分。</li><li><strong>速率</strong>：标准速率100 kbps，快速速率400 kbps，快速加速率1 Mbps，高速速率3.4 Mbps，超速速率5 Mbps。</li><li><strong>帧结构</strong>：包括起始位、数据位、应答位和停止位。</li><li><strong>仲裁</strong>：通过位仲裁机制解决多个主设备同时控制总线的问题.</li></ul><h1 id="3-介绍一下中断"><a href="#3-介绍一下中断" class="headerlink" title="3.介绍一下中断"></a>3.介绍一下中断</h1><p><strong>中断</strong>是一种机制，允许硬件设备在特定事件发生时通知处理器暂停当前任务，转而执行特定的处理程序（中断服务例程，ISR）。以下是中断的关键特点：</p><ul><li><strong>触发条件</strong>：硬件设备（如传感器、定时器等）在特定事件发生时（如数据接收完成、定时器溢出等）触发中断信号。</li><li><strong>中断信号</strong>：硬件设备通过中断引脚向处理器发送信号。</li><li><strong>中断处理</strong>：处理器暂停当前任务，保存上下文，切换到中断服务例程（ISR）执行。5</li><li><strong>中断优先级</strong>：多个中断同时发生时，处理器根据优先级选择处理。</li><li><strong>中断返回</strong>：ISR执行完毕后，处理器恢复上下文，继续执行原任务。</li></ul><h1 id="7-项目学到什么新兴的技术"><a href="#7-项目学到什么新兴的技术" class="headerlink" title="7.项目学到什么新兴的技术"></a>7.项目学到什么新兴的技术</h1><h3 id="1-物联网通信协议（MQTT）"><a href="#1-物联网通信协议（MQTT）" class="headerlink" title="1. 物联网通信协议（MQTT）"></a>1. <strong>物联网通信协议（MQTT）</strong></h3><ul><li><strong>MQTT协议</strong>：MQTT是一种轻量级的消息传输协议，特别适合物联网设备的通信。它支持低带宽、高延迟或不可靠的网络环境，具有高可靠性和低功耗的特点。在项目中，你通过MQTT协议实现了设备与云平台之间的高效通信，包括数据上传和指令接收。</li><li><strong>应用场景</strong>：MQTT广泛应用于智能家居、工业物联网和车联网等领域。你将MQTT应用于智能家居设备的通信，为后续的智能家居设备互联互通和智能化管理奠定了基础。</li></ul><h3 id="2-前后端分离架构（JsonRPC）"><a href="#2-前后端分离架构（JsonRPC）" class="headerlink" title="2. 前后端分离架构（JsonRPC）"></a>2. <strong>前后端分离架构（JsonRPC）</strong></h3><ul><li><strong>JsonRPC</strong>：JsonRPC是一种基于JSON格式的远程过程调用（RPC）协议。在项目中，你通过JsonRPC实现了前后台程序的分离，前台程序负责用户界面，后台程序负责硬件操作和业务逻辑。</li><li><strong>优势</strong>：这种架构降低了前后台程序的耦合度，便于独立开发、维护和扩展。例如，当硬件更换或界面调整时，只需修改对应的部分，无需改动另一部分。</li></ul><h3 id="3-嵌入式Linux开发"><a href="#3-嵌入式Linux开发" class="headerlink" title="3. 嵌入式Linux开发"></a>3. <strong>嵌入式Linux开发</strong></h3><ul><li><strong>驱动开发</strong>：你成功移植并实现了多种外设（如DHT11温湿度传感器、SR501红外人体感应器等）的Linux驱动程序。这涉及到对硬件资源的精确管理和外设的正确识别。</li><li><strong>设备树配置</strong>：通过对设备树（Device Tree）的配置，确保了硬件资源的有效管理。</li><li><strong>系统调试与优化</strong>：你使用了日志记录、断点调试和网络抓包等方法进行系统调试。同时，通过代码优化和硬件优化提高了系统的性能。</li></ul><h3 id="4-图形用户界面开发（Qt框架）"><a href="#4-图形用户界面开发（Qt框架）" class="headerlink" title="4. 图形用户界面开发（Qt框架）"></a>4. <strong>图形用户界面开发（Qt框架）</strong></h3><ul><li><strong>Qt框架</strong>：你使用Qt框架开发了用于设备控制和状态显示的图形用户界面，并成功移植到ARM架构的开发板上运行。Qt框架提供了丰富的组件和功能，支持动态交互。</li><li><strong>界面设计与实现</strong>：通过Qt Designer设计界面布局，并通过代码实现控件的事件处理和数据绑定。</li></ul><h3 id="5-多线程与同步机制"><a href="#5-多线程与同步机制" class="headerlink" title="5. 多线程与同步机制"></a>5. <strong>多线程与同步机制</strong></h3><ul><li><strong>多线程</strong>：你实现了多任务间的同步与互斥机制，确保了多线程操作的一致性和稳定性。这在嵌入式系统中非常重要，尤其是在处理多个外设和任务时。</li><li><strong>线程管理</strong>：你使用了pthread库来管理线程，并确保线程安全。</li></ul><h3 id="6-网络编程"><a href="#6-网络编程" class="headerlink" title="6. 网络编程"></a>6. <strong>网络编程</strong></h3><ul><li><strong>Socket编程</strong>：你使用了socket函数创建套接字，并通过bind、listen、accept和connect等函数实现了网络通信。这为前后台程序的通信提供了基础。</li><li><strong>TCP&#x2F;UDP协议</strong>：你理解并应用了TCP和UDP协议的特点，选择了适合项目需求的传输方式。</li></ul><h3 id="7-配置文件处理"><a href="#7-配置文件处理" class="headerlink" title="7. 配置文件处理"></a>7. <strong>配置文件处理</strong></h3><ul><li><strong>配置文件格式</strong>：你学习了INI、JSON和XML等配置文件格式，并理解了它们在项目中的作用。配置文件用于存储程序运行时需要的参数，便于程序的维护和升级。</li></ul><h3 id="8-云平台对接"><a href="#8-云平台对接" class="headerlink" title="8. 云平台对接"></a>8. <strong>云平台对接</strong></h3><ul><li><strong>阿里云服务器</strong>：你通过MQTT协议实现了设备与阿里云服务器之间的数据交换。这为设备的远程控制和数据管理提供了支持。</li><li><strong>网页端交互界面</strong>：你开发了网页端交互界面，支持远程控制家居自动化模块。这使得用户可以通过任何联网设备轻松管理家庭环境。</li></ul><h3 id="9-智能家居设备控制协议"><a href="#9-智能家居设备控制协议" class="headerlink" title="9. 智能家居设备控制协议"></a>9. <strong>智能家居设备控制协议</strong></h3><ul><li><strong>自定义协议</strong>：你自主设计并实现了一套完整的智能家居设备控制协议。这确保了不同设备之间的兼容性和互操作性，为后续产品的升级和扩展提供了便利。</li></ul><h1 id="8-Frtos-rtthread线程带来的好处"><a href="#8-Frtos-rtthread线程带来的好处" class="headerlink" title="8.Frtos rtthread线程带来的好处"></a>8.Frtos rtthread线程带来的好处</h1><h3 id="FreeRTOS-线程带来的好处"><a href="#FreeRTOS-线程带来的好处" class="headerlink" title="FreeRTOS 线程带来的好处"></a>FreeRTOS 线程带来的好处</h3><ol><li><strong>提高系统响应速度</strong><ul><li><strong>多任务并发处理</strong>：FreeRTOS 支持多任务并发运行，每个任务可以独立执行不同功能。例如，在智能家居系统中，一个任务读取温湿度传感器数据，另一个任务控制电机，通过合理分配任务优先级，高优先级任务可以快速响应外部事件，从而提高系统响应速度。</li><li><strong>任务调度灵活性</strong>：FreeRTOS 提供抢占式调度和轮询调度算法。抢占式调度允许高优先级任务打断低优先级任务，确保关键任务能够及时处理，例如在工业自动化中，紧急故障处理任务可以立即抢占 CPU 资源。</li></ul></li><li><strong>增强系统可靠性</strong><ul><li><strong>任务隔离与保护</strong>：每个任务在 FreeRTOS 中有独立的堆栈空间和运行上下文，任务之间相互隔离。即使一个任务出现异常，也不会影响其他任务的正常运行，例如在医疗设备中，数据采集任务和用户界面任务相互独立，增强了系统的可靠性。</li><li><strong>错误处理机制</strong>：FreeRTOS 提供任务挂起、删除和系统重启等错误处理机制，可以及时处理任务错误，避免系统崩溃。</li></ul></li><li><strong>优化资源利用</strong><ul><li><strong>动态内存管理</strong>：FreeRTOS 提供多种动态内存分配策略，可以根据任务需求动态分配和释放内存，例如在视频监控系统中，根据视频数据的分辨率动态调整内存分配。</li><li><strong>任务优先级调整</strong>：可以根据系统负载动态调整任务优先级，确保关键任务获得足够的 CPU 时间片，例如在多用户系统中，根据任务负载调整优先级，保证系统整体性能。</li></ul></li><li><strong>简化开发流程</strong><ul><li><strong>任务封装与复用</strong>：FreeRTOS 允许将功能封装成独立任务，便于代码模块化设计和复用，例如在智能交通系统中，将车辆检测、信号灯控制等功能封装成独立任务。</li><li><strong>开发工具支持</strong>：FreeRTOS 提供任务状态查看、堆栈溢出检测和任务切换跟踪等工具，帮助开发者快速定位和解决问题，提高开发效率。</li></ul></li></ol><h3 id="RT-Thread-线程带来的好处"><a href="#RT-Thread-线程带来的好处" class="headerlink" title="RT-Thread 线程带来的好处"></a>RT-Thread 线程带来的好处</h3><ol><li><strong>提高系统实时性</strong><ul><li><strong>微秒级任务调度</strong>：RT-Thread 支持微秒级任务调度精度，能够快速响应外部中断和事件，例如在高精度仪器设备中，确保传感器数据的实时采集和处理。</li><li><strong>中断优先级管理</strong>：RT-Thread 提供中断优先级管理机制，确保高优先级中断能够优先处理，例如在通信设备中，紧急数据包可以快速打断当前任务进行处理。</li></ul></li><li><strong>增强系统稳定性</strong><ul><li><strong>内核保护机制</strong>：RT-Thread 内核提供内存保护单元（MPU）支持和任务优先级保护，防止任务之间的非法访问和资源冲突，提高系统稳定性。</li><li><strong>系统自检与恢复</strong>：RT-Thread 可以定期检查系统状态，检测到异常时自动重启或恢复到正常状态，例如在无人飞行器控制系统中，确保飞行安全。</li></ul></li><li><strong>优化系统性能</strong><ul><li><strong>轻量级线程切换</strong>：RT-Thread 的线程切换开销小，切换速度快，有效提高系统运行效率，例如在多任务处理的嵌入式系统中，频繁的任务切换不会导致性能下降。</li><li><strong>资源动态分配与回收</strong>：RT-Thread 提供动态内存分配和回收机制，根据任务需求动态调整资源分配，例如在智能穿戴设备中，根据用户切换的功能模块动态调整资源。</li></ul></li><li><strong>简化开发与维护</strong><ul><li><strong>组件化开发模式</strong>：RT-Thread 采用组件化开发模式，将功能模块封装成独立组件，便于开发和维护，例如在物联网设备开发中，将传感器驱动、网络通信和数据处理等功能封装成组件。</li><li><strong>丰富的开发工具</strong>：RT-Thread 提供图形化配置工具、调试器和性能分析工具，帮助开发者快速开发和优化系统。</li></ul></li></ol><p><strong>最大的区别</strong>在于 FreeRTOS 的<strong>轻量级和模块化设计</strong>，适合资源受限和功能简单的嵌入式设备；而 RT-Thread 的<strong>组件化和微内核架构</strong>，适合功能复杂、需要支持多种组件的复杂应用场景。</p><h1 id="9-使用信号量主要是什么类型"><a href="#9-使用信号量主要是什么类型" class="headerlink" title="9.使用信号量主要是什么类型"></a>9.使用信号量主要是什么类型</h1><ol><li><strong>二进制信号量（Binary Semaphore）</strong>：<br>也叫互斥锁（Mutex），值只有0和1，主要用于互斥，确保一次只有一个线程可以访问共享资源。</li><li><strong>计数信号量（Counting Semaphore）</strong>：<br>值可以是任意非负整数，用于控制多个线程对有限资源的访问，比如限制同时访问某个资源的线程数量。</li><li><strong>命名信号量（Named Semaphore）</strong>：<br>可以在不同进程之间共享，通过文件系统路径名来标识，用于进程间同步。</li><li><strong>匿名信号量（Anonymous Semaphore）</strong>：<br>只能在同一个进程内的线程之间使用，通常通过内存分配创建，用于线程间同步。</li><li><strong>信号量集（Semaphore Set）</strong>：<br>是一组信号量的集合，可以同时操作多个信号量，适用于更复杂的同步场景。</li></ol><h1 id="10-了解原子操作吗-主要用在哪里-有什么好处"><a href="#10-了解原子操作吗-主要用在哪里-有什么好处" class="headerlink" title="10.了解原子操作吗 主要用在哪里 有什么好处"></a>10.了解原子操作吗 主要用在哪里 有什么好处</h1><p>了解原子操作。原子操作是指在执行过程中不会被其他线程或进程打断的操作，它要么完全执行，要么完全不执行。</p><p><strong>主要用途：</strong></p><ol><li><strong>线程安全的变量更新</strong>：当多个线程需要对同一个变量进行读写操作时，原子操作可以确保变量的更新是安全的，不会出现数据竞争问题。</li><li><strong>实现锁机制</strong>：原子操作常用于实现互斥锁（Mutex）、自旋锁（Spinlock）等同步机制，确保临界区代码的互斥执行。</li><li><strong>无锁编程</strong>：在某些高性能场景下，原子操作可以用于实现无锁数据结构，避免锁的开销，提高系统性能。</li></ol><p><strong>好处：</strong></p><ol><li><strong>线程安全</strong>：原子操作确保了在多线程环境下对共享变量的操作是安全的，不会出现数据不一致的问题。</li><li><strong>性能优化</strong>：相比传统的锁机制，原子操作通常更轻量级，不会引入线程切换的开销，适合对性能要求较高的场景。</li><li><strong>简化代码</strong>：使用原子操作可以减少锁的使用，使代码更加简洁，同时降低死锁等并发问题的风险。</li></ol><h1 id="11-信号量使用过程有什么问题-自旋锁-互斥锁（面试官补充全局变量会常用到-）"><a href="#11-信号量使用过程有什么问题-自旋锁-互斥锁（面试官补充全局变量会常用到-）" class="headerlink" title="11.信号量使用过程有什么问题 自旋锁 互斥锁（面试官补充全局变量会常用到 ）"></a>11.信号量使用过程有什么问题 自旋锁 互斥锁（面试官补充全局变量会常用到 ）</h1><p>信号量、自旋锁和互斥锁都是线程同步机制，但在使用过程中需要注意一些问题，尤其是在涉及全局变量的场景中。</p><h3 id="信号量使用过程中的问题"><a href="#信号量使用过程中的问题" class="headerlink" title="信号量使用过程中的问题"></a><strong>信号量使用过程中的问题</strong></h3><ol><li><strong>死锁风险</strong>：如果信号量的使用不当，比如忘记释放信号量或者释放顺序错误，可能会导致死锁。例如，多个线程试图获取同一个信号量，但信号量的数量不足以满足所有线程的需求，可能会导致部分线程永远等待。</li><li><strong>性能问题</strong>：信号量的使用可能会导致线程阻塞，尤其是在高并发场景下，线程的频繁阻塞和唤醒会增加系统开销。</li><li><strong>初始化问题</strong>：信号量的初始值必须正确设置，否则可能会导致线程饥饿或资源竞争问题。</li><li><strong>复杂性</strong>：信号量的使用需要仔细设计，尤其是在涉及多个线程和多个资源的场景中，逻辑可能会变得复杂。</li></ol><h3 id="自旋锁和互斥锁的优缺点"><a href="#自旋锁和互斥锁的优缺点" class="headerlink" title="自旋锁和互斥锁的优缺点"></a><strong>自旋锁和互斥锁的优缺点</strong></h3><h4 id="自旋锁（Spinlock）"><a href="#自旋锁（Spinlock）" class="headerlink" title="自旋锁（Spinlock）"></a><strong>自旋锁（Spinlock）</strong></h4><ul><li><strong>优点</strong>：<ul><li><strong>低延迟</strong>：适用于锁持有时间非常短的场景。自旋锁不会导致线程切换，因此在锁竞争不激烈时可以快速获取锁。</li><li><strong>简单高效</strong>：实现相对简单，适合快速同步。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>高CPU占用</strong>：如果锁竞争激烈，线程会不断自旋，占用大量CPU资源，导致系统性能下降。</li><li><strong>不适合长时间锁持有</strong>：如果锁持有时间较长，自旋锁会导致其他线程长时间等待，浪费CPU资源。</li></ul></li></ul><h4 id="互斥锁（Mutex）"><a href="#互斥锁（Mutex）" class="headerlink" title="互斥锁（Mutex）"></a><strong>互斥锁（Mutex）</strong></h4><ul><li><strong>优点</strong>：<ul><li><strong>公平性</strong>：互斥锁会将等待的线程放入等待队列，按照先来后到的顺序获取锁，避免了线程饥饿。</li><li><strong>适合长时间锁持有</strong>：适用于锁持有时间较长的场景，不会像自旋锁那样浪费CPU资源。</li></ul></li><li><strong>缺点</strong>：<ul><li><strong>线程切换开销</strong>：当线程获取或释放互斥锁时，可能会导致线程切换，增加系统开销。</li><li><strong>性能问题</strong>：在高并发场景下，互斥锁的性能可能不如自旋锁，尤其是在锁竞争激烈的情况下。</li></ul></li></ul><h3 id="全局变量的场景"><a href="#全局变量的场景" class="headerlink" title="全局变量的场景"></a><strong>全局变量的场景</strong></h3><p>在涉及全局变量的场景中，线程同步机制的选择尤为重要。全局变量通常会被多个线程访问和修改，如果没有适当的同步机制，可能会导致数据竞争和数据不一致的问题。</p><ul><li><strong>信号量</strong>：可以用于控制多个线程对全局变量的访问，但需要注意死锁和性能问题。</li><li><strong>自旋锁</strong>：适用于全局变量访问频率高且锁持有时间非常短的场景，但要注意避免CPU资源浪费。</li><li><strong>互斥锁</strong>：适用于全局变量访问频率高且锁持有时间较长的场景，可以有效避免线程饥饿问题，但要注意线程切换的开销。</li></ul><p><strong>总结：</strong> 在实际开发中，选择合适的同步机制需要根据具体场景来决定。如果全局变量的访问频率高且锁持有时间非常短，可以考虑使用自旋锁；如果锁持有时间较长，或者需要保证线程的公平性，互斥锁可能是更好的选择。信号量则适用于需要控制多个线程对有限资源访问的场景，但在使用时需要注意初始化值和操作的正确性。</p><h1 id="12-主要用的是阻塞还是非阻塞"><a href="#12-主要用的是阻塞还是非阻塞" class="headerlink" title="12.主要用的是阻塞还是非阻塞"></a>12.主要用的是阻塞还是非阻塞</h1><p>信号量在使用过程中可能会遇到一些问题，比如如果信号量的初始化值设置不当，可能会导致线程饥饿或死锁。此外，信号量的操作必须成对出现，否则可能会出现资源泄漏或逻辑错误。在高并发场景下，信号量的性能可能不如一些更轻量级的同步机制。</p><p>对于自旋锁和互斥锁，它们在全局变量的场景中通常使用阻塞操作。具体来说：</p><ol><li><strong>互斥锁（Mutex）</strong>：<ul><li><strong>特点</strong>：互斥锁是一种阻塞锁，当一个线程获取锁后，其他线程会被阻塞，直到锁被释放。</li><li><strong>适用场景</strong>：适用于需要保护全局变量或其他共享资源的场景，尤其是当锁持有时间较长时。</li><li><strong>优点</strong>：可以有效防止数据竞争，确保线程安全。</li><li><strong>缺点</strong>：可能会导致线程切换的开销，尤其是在高并发场景下。</li></ul></li><li><strong>自旋锁（Spinlock）</strong>：<ul><li><strong>特点</strong>：自旋锁是一种非阻塞锁，线程在尝试获取锁时会不断自旋，直到锁被释放。</li><li><strong>适用场景</strong>：适用于锁持有时间非常短的场景，比如对全局变量进行快速读写操作。</li><li><strong>优点</strong>：可以减少线程切换的开销，提高系统性能。</li><li><strong>缺点</strong>：如果锁竞争激烈，线程会不断占用CPU资源，导致CPU利用率过高。</li></ul></li></ol><p>东莞华勤技术驱动开发二面面经</p><h1 id="8-你觉得你的项目难点是什么"><a href="#8-你觉得你的项目难点是什么" class="headerlink" title="8.你觉得你的项目难点是什么"></a>8.你觉得你的项目难点是什么</h1><h3 id="AI-模型训练与移植-1"><a href="#AI-模型训练与移植-1" class="headerlink" title="AI 模型训练与移植"></a>AI 模型训练与移植</h3><ul><li><strong>难点描述</strong>：项目中涉及到 K210 模型的训练，用于语音交互等功能。AI 模型训练本身需要大量的数据和计算资源，并且要选择合适的算法和模型架构。训练完成后，还需要将模型移植到 STM32 单片机上运行，而单片机的计算能力和存储资源相对有限，这使得模型的优化和移植变得非常困难。</li><li><strong>解决方法</strong>：在模型训练阶段，可以通过数据增强等技术扩充训练数据集，选择适合嵌入式设备的轻量级神经网络架构，如 TinyML 等。在移植过程中，使用模型量化技术将模型参数从浮点数转换为整数，以减少模型的存储空间和计算量。同时，对模型进行裁剪，去除一些对性能影响不大的层，以适应单片机的资源限制。并且要编写高效的代码来实现模型的推理过程，充分利用单片机的硬件资源，如使用 DMA（直接存储器访问）来加速数据传输。</li></ul><h2 id="Linux-MQTT-智能家居系统"><a href="#Linux-MQTT-智能家居系统" class="headerlink" title="Linux MQTT 智能家居系统"></a>Linux MQTT 智能家居系统</h2><h3 id="（一）驱动开发与设备树配置"><a href="#（一）驱动开发与设备树配置" class="headerlink" title="（一）驱动开发与设备树配置"></a>（一）驱动开发与设备树配置</h3><ul><li><strong>难点描述</strong>：项目需要移植和开发多种外设的 Linux 驱动程序，如 DHT11 温湿度传感器、SR501 红外人体感应器等。这些外设的硬件接口和通信协议各不相同，而且 Linux 驱动开发涉及到内核代码，需要深入理解 Linux 内核的机制。同时，设备树（Device Tree）的配置也非常关键，它用于描述硬件设备的连接关系和资源分配，如果配置不正确，外设将无法被系统正确识别和管理。</li><li><strong>解决方法</strong>：在驱动开发方面，需要仔细阅读外设的数据手册，了解其通信协议和硬件接口特性。通过阅读 Linux 内核源码中相关的驱动框架代码，学习如何编写符合 Linux 内核规范的驱动程序。对于设备树配置，要深入学习设备树的语法和规范，参考已有的设备树示例，结合硬件电路图，准确地描述每个外设的连接关系和资源分配。在开发过程中，使用调试工具（如 GDB）和日志记录来排查驱动开发和设备树配置过程中出现的问题。</li></ul><h3 id="（二）前后台分离架构的实现与通信"><a href="#（二）前后台分离架构的实现与通信" class="headerlink" title="（二）前后台分离架构的实现与通信"></a>（二）前后台分离架构的实现与通信</h3><ul><li><strong>难点描述</strong>：项目采用 JsonRPC 实现前后台分离的架构。前台程序负责图形用户界面（GUI）的显示和用户交互，后台程序负责处理硬件操作和业务逻辑。前后台程序通过网络通信（TCP&#x2F;UDP）进行数据交换，这种架构虽然有诸多优点，但在实现过程中需要解决通信的稳定性、数据传输的效率以及前后台程序之间的同步等问题。例如，当用户在前台界面发送控制指令时，后台程序需要及时响应并执行相应的操作，并且要将操作结果反馈给前台界面。</li><li><strong>解决方法</strong>：在通信方面，要确保网络连接的稳定性，可以通过设置心跳机制来检测网络连接状态。对于数据传输效率，优化 JsonRPC 的消息格式，减少不必要的数据传输。在前后台同步方面，使用多线程同步机制（如互斥锁、信号量等）来确保数据的一致性。同时，要编写详细的接口文档，明确前后台程序之间的接口规范，以便前后台程序的开发人员能够更好地协作。</li></ul><h1 id="9-linux启动过程"><a href="#9-linux启动过程" class="headerlink" title="9.linux启动过程"></a>9.linux启动过程</h1><ul><li><strong>BIOS&#x2F;UEFI 启动</strong>：BIOS 或 UEFI 负责硬件初始化和自检，并加载引导程序（如 GRUB）。</li><li><strong>引导程序（Bootloader）</strong>：GRUB 会显示启动菜单，加载 Linux 内核和初始化内存文件（<code>initrd</code> 或 <code>initramfs</code>）到内存中，并将控制权移交给内核。</li><li><strong>内核初始化</strong>：内核会初始化硬件设备、加载驱动程序，并启动用户空间的初始化进程（如 <code>systemd</code> 或 <code>/sbin/init</code>）。</li><li><strong>用户空间初始化</strong>：<code>systemd</code> 会根据配置文件启动系统服务，包括网络、文件系统挂载、用户登录管理等。</li><li><strong>用户登录</strong>：用户通过图形界面或终端登录系统，开始使用。</li></ul><p>首先，在第一阶段，ROM Code（芯片厂商内置的代码）会进行硬件检查、<strong>设置基本时钟</strong>，并从存储设备（如SPI Flash、eMMC或SD卡）加载第一阶段引导程序FSBL（First Stage Boot Loader）到内存中运行。接着，FSBL负责初始化硬件，包括初始化内存控制器（如DDR）、配置更精确的时钟、禁用看门狗计时器和中断，初始化处理器的栈指针，将U-Boot代码从非易失性存储器重定位到SDRAM中，清零未初始化的全局变量（BSS段），并加载第二阶段引导程序SSBL到内存中运行。在第三阶段，SSBL进一步初始化硬件设备（如串口、网络接口），加载U-Boot的环境变量，从存储设备或网络加载Linux内核映像到SDRAM中，设置启动参数，并可能显示启动动画，最后通过设置处理器的程序计数器跳转执行操作系统内核。进入第四阶段，Linux内核初始化操作系统的核心功能，检测和初始化硬件设备，挂载根文件系统（如ext4、initramfs），并启动用户空间的<code>init</code>程序（如<code>systemd</code>或<code>init</code>），负责启动其他系统服务和程序。最终，计算机进入Linux用户空间，启动用户界面（如图形用户界面或命令行界面），用户可以打开各种应用程序，进行日常操作。整个启动过程环环相扣，确保了计算机能够顺利启动并为用户提供服务。</p><h1 id="const的作用"><a href="#const的作用" class="headerlink" title="const的作用"></a>const的作用</h1><p><code>const</code> 关键字在 C++ 中有以下几个主要作用：</p><ol><li><p><strong>声明常量</strong>：使变量的值在初始化后不可更改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_SIZE = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>修饰函数参数</strong>：保证函数不会修改传入的参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>修饰函数返回值</strong>：保证返回值不会被修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> std::string <span class="title">getError</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>修饰类成员函数</strong>：保证成员函数不会修改对象的状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>修饰指针</strong>：可以修饰指针本身或指针所指向的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr; <span class="comment">// 指针所指向的内容是常量</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr; <span class="comment">// 指针本身是常量</span></span><br></pre></td></tr></table></figure></li></ol><p><code>const</code> 的主要目的是提高代码的安全性和可读性，确保数据不会被意外修改。</p><h1 id="static的作用"><a href="#static的作用" class="headerlink" title="static的作用"></a>static的作用</h1><ol><li><p><strong>局部静态变量</strong>：</p><ul><li><p>在函数内部定义的静态变量，只在第一次调用时初始化，且在程序运行期间保持存在。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 局部静态变量</span></span><br><span class="line">    count++;</span><br><span class="line">    std::cout &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>全局静态变量</strong>：</p><ul><li><p>在文件作用域中定义的静态变量，只在定义它的文件内可见，不会被其他文件访问。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> globalVar = <span class="number">10</span>; <span class="comment">// 全局静态变量</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>静态成员变量</strong>：</p><ul><li><p>类的静态成员变量属于类本身，而不是类的某个对象，因此不需要实例化对象即可访问。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count; <span class="comment">// 静态成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> MyClass::count = <span class="number">0</span>; <span class="comment">// 静态成员变量的定义</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>静态成员函数</strong>：</p><ul><li><p>类的静态成员函数属于类本身，而不是类的某个对象，因此不需要实例化对象即可调用。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">MyClass::<span class="built_in">print</span>(); <span class="comment">// 调用静态成员函数</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>静态局部函数</strong>：</p><ul><li><p>在函数内部定义的静态函数，只在定义它的函数内可见，不会被其他函数访问。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">outerFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">innerFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inner function&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">innerFunc</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul><li><strong>局部静态变量</strong>：在函数内部，只在第一次调用时初始化，保持存在。</li><li><strong>全局静态变量</strong>：在文件作用域中，只在定义它的文件内可见。</li><li><strong>静态成员变量</strong>：属于类本身，不需要实例化对象即可访问。</li><li><strong>静态成员函数</strong>：属于类本身，不需要实例化对象即可调用。</li><li><strong>静态局部函数</strong>：在函数内部，只在定义它的函数内可见。</li></ul><p><code>static</code> 的主要作用是控制变量和函数的作用域和生命周期，提高代码的安全性和可读性。</p><h1 id="switch-case中break"><a href="#switch-case中break" class="headerlink" title="switch-case中break"></a>switch-case中break</h1><ul><li><strong>作用</strong>：<code>break</code> 用于终止当前的 <code>case</code> 分支，防止代码继续执行到下一个 <code>case</code>，避免“穿透”。</li><li><strong>重要性</strong>：如果没有 <code>break</code>，代码会继续执行到下一个 <code>case</code>，直到遇到 <code>break</code> 或 <code>switch</code> 结束。</li><li><strong>注意</strong>：每个 <code>case</code> 后通常都需要 <code>break</code>，除非你希望代码穿透。</li></ul><h1 id="栈和堆的区别"><a href="#栈和堆的区别" class="headerlink" title="栈和堆的区别"></a>栈和堆的区别</h1><p>1、栈区是系统自动申请自动释放，且空间较小</p><p>2、堆区是需要手动申请，手动释放，空间较大</p><p>3、栈区常用来存放局部变量等</p><p>4、堆区常用来存放全局变量等</p><p>5、栈的空间是连续的，而堆不是</p><h1 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h1><p><strong>进程</strong>是程序的运行实例，是资源分配的最小单位，拥有独立的内存空间和系统资源。<br><strong>线程</strong>是进程内的执行单元，是CPU调度的最小单位，共享进程的内存空间，创建和切换开销小，适合高并发任务。</p><h1 id="我需要实现多线程的数据采集和处理，因此通过pthread库实现了线程同步"><a href="#我需要实现多线程的数据采集和处理，因此通过pthread库实现了线程同步" class="headerlink" title="我需要实现多线程的数据采集和处理，因此通过pthread库实现了线程同步"></a>我需要实现多线程的数据采集和处理，因此通过pthread库实现了线程同步</h1><p>具体做法是：首先，针对多个线程同时访问共享资源（如传感器数据缓冲区）的场景，我采用了pthread_mutex_t互斥锁进行加锁和解锁操作。每当线程需要读写共享数据时，先执行pthread_mutex_lock加锁，操作完成后再pthread_mutex_unlock解锁，防止数据竞争和不一致。</p><p>此外，在需要线程间协作的部分，比如一个线程采集数据，另一个线程处理数据时，我还应用了pthread_cond_t条件变量。采集线程采集到数据后，通过pthread_cond_signal通知处理线程，处理线程用pthread_cond_wait等待信号，实现了生产者-消费者模型。这样既避免了忙等，又提升了系统响应效率。</p><h1 id="malloc和new的区别，如何开辟内存"><a href="#malloc和new的区别，如何开辟内存" class="headerlink" title="malloc和new的区别，如何开辟内存"></a>malloc和new的区别，如何开辟内存</h1><p><code>malloc</code>是C语言的内存分配函数，需要手动转换指针类型，不自动调用构造函数。<code>new</code>是C++的操作符，自动调用构造函数初始化对象，使用更方便。</p><ul><li><strong>malloc</strong>：C语言函数，只分配内存，不调用构造函数，返回<code>void*</code>指针，需手动转换类型，用<code>free</code>释放。</li><li><strong>new</strong>：C++操作符，分配内存并调用构造函数初始化对象，返回目标类型指针，用<code>delete</code>释放。</li></ul><hr><h3 id="如何开辟内存"><a href="#如何开辟内存" class="headerlink" title="如何开辟内存"></a><strong>如何开辟内存</strong></h3><ul><li><p><strong>malloc</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="built_in">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配内存</span></span><br><span class="line"><span class="built_in">free</span>(ptr); <span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure></li><li><p><strong>new</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">// 分配内存</span></span><br><span class="line"><span class="keyword">delete</span>[] ptr; <span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="内存分配的方式"><a href="#内存分配的方式" class="headerlink" title="内存分配的方式"></a>内存分配的方式</h1><ol><li><strong>静态分配</strong>：编译时分配，适合全局变量和静态变量。</li><li><strong>自动分配</strong>：函数调用时分配，适合局部变量。</li><li><strong>动态分配</strong>：运行时通过 <code>malloc</code> 等函数分配，需手动释放，适合动态数据结构。</li></ol><h1 id="malloc和free"><a href="#malloc和free" class="headerlink" title="malloc和free"></a>malloc和free</h1><p><code>malloc</code> 和 <code>free</code> 是 C 语言中用于动态内存分配和释放的函数，它们在 Linux 环境下同样被广泛使用。</p><h4 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a><code>malloc</code></h4><ul><li><p><strong>功能</strong>：动态分配内存。</p></li><li><p><strong>声明</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>参数</strong>：</p><ul><li><code>size</code>：需要分配的内存大小，以字节为单位。</li></ul></li><li><p><strong>返回值</strong>：</p><ul><li>成功：返回指向分配内存的指针。</li><li>失败：返回 <code>NULL</code>。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配一个包含10个整数的数组</span></span><br><span class="line"><span class="keyword">if</span> (arr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">    perror(<span class="string">&quot;malloc failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="free"><a href="#free" class="headerlink" title="free"></a><code>free</code></h4><ul><li><p><strong>功能</strong>：释放之前通过 <code>malloc</code> 分配的内存。</p></li><li><p><strong>声明</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span>* ptr)</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>参数</strong>：</p><ul><li><code>ptr</code>：指向之前通过 <code>malloc</code> 分配的内存的指针。</li></ul></li><li><p><strong>返回值</strong>：无返回值。</p></li><li><p><strong>注意事项</strong>：</p><ul><li>只能释放通过 <code>malloc</code> 分配的内存。</li><li>不要释放同一个指针多次。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(arr); <span class="comment">// 释放之前分配的内存</span></span><br><span class="line">arr = <span class="literal">NULL</span>; <span class="comment">// 避免悬空指针</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-malloc-和-free-的使用注意事项"><a href="#2-malloc-和-free-的使用注意事项" class="headerlink" title="2. malloc 和 free 的使用注意事项"></a>2. <strong><code>malloc</code> 和 <code>free</code> 的使用注意事项</strong></h3><ul><li><p><strong>内存泄漏</strong>：</p><ul><li><p>如果分配了内存但没有释放，会导致内存泄漏。例如：</p><p>c</p><p>复制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="comment">// 没有调用 free(ptr);</span></span><br></pre></td></tr></table></figure></li><li><p>避免内存泄漏的方法：确保每次调用 <code>malloc</code> 后，都有对应的 <code>free</code>。</p></li></ul></li><li><p><strong>悬空指针</strong>：</p><ul><li><p>释放内存后，指针仍然指向已释放的内存地址，称为悬空指针。例如：</p><p>c</p><p>复制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line"><span class="comment">// ptr 仍然是一个悬空指针</span></span><br></pre></td></tr></table></figure></li><li><p>避免悬空指针的方法：释放内存后，将指针设置为 <code>NULL</code>：</p><p>c</p><p>复制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">ptr = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>重复释放</strong>：</p><ul><li><p>不能对同一个指针多次调用 <code>free</code>，否则会导致未定义行为。例如：</p><p>c</p><p>复制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line"><span class="built_in">free</span>(ptr); <span class="comment">// 重复释放</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>分配失败的处理</strong>：</p><ul><li><p><code>malloc</code> 可能返回 <code>NULL</code>，需要检查返回值。例如：</p><p>c</p><p>复制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="3-malloc-和-free-的实现原理"><a href="#3-malloc-和-free-的实现原理" class="headerlink" title="3. malloc 和 free 的实现原理"></a>3. <strong><code>malloc</code> 和 <code>free</code> 的实现原理</strong></h3><ul><li><strong><code>malloc</code> 的实现</strong>：<ul><li><code>malloc</code> 通常会从堆（Heap）中分配内存。</li><li>常见的内存分配算法包括：<ul><li><strong>首次适应算法（First Fit）</strong>：从堆的起始位置开始查找第一个足够大的空闲块。</li><li><strong>最佳适应算法（Best Fit）</strong>：从堆中查找最小的足够大的空闲块。</li><li><strong>下次适应算法（Next Fit）</strong>：从上次分配的结束位置开始查找。</li><li><strong>伙伴系统（Buddy System）</strong>：将内存块分成大小相等的伙伴块，按需分配。</li></ul></li><li>现代的 <code>malloc</code> 实现（如 glibc 的 ptmalloc）通常会使用多种算法结合，以提高效率和减少内存碎片。</li></ul></li><li><strong><code>free</code> 的实现</strong>：<ul><li><code>free</code> 会将已分配的内存块标记为可用。</li><li>如果相邻的内存块也是空闲的，可能会将它们合并成一个更大的空闲块，以减少内存碎片。</li></ul></li></ul><h3 id="4-内存碎片问题"><a href="#4-内存碎片问题" class="headerlink" title="4. 内存碎片问题"></a>4. <strong>内存碎片问题</strong></h3><ul><li><strong>内存碎片</strong>：<ul><li>内存碎片是指内存中存在许多小的空闲块，但没有足够大的连续空间来满足新的内存分配请求。</li><li>内存碎片分为内部碎片和外部碎片：<ul><li><strong>内部碎片</strong>：分配的内存块比实际需要的内存大。</li><li><strong>外部碎片</strong>：内存中存在许多小的空闲块，但没有足够大的连续空间。</li></ul></li></ul></li><li><strong>解决方法</strong>：<ul><li>使用合适的内存分配算法（如伙伴系统）。</li><li>定期进行内存整理（如合并空闲块）。</li><li>使用内存池（Memory Pool）技术，预先分配一块较大的内存，按需分配小块内存。</li></ul></li></ul><h3 id="5-malloc-和-free-的性能问题"><a href="#5-malloc-和-free-的性能问题" class="headerlink" title="5. malloc 和 free 的性能问题"></a>5. <strong><code>malloc</code> 和 <code>free</code> 的性能问题</strong></h3><ul><li><strong>性能问题</strong>：<ul><li><code>malloc</code> 和 <code>free</code> 的性能可能受到内存分配算法、内存碎片等因素的影响。</li><li>频繁的内存分配和释放可能导致性能下降。</li></ul></li><li><strong>优化方法</strong>：<ul><li>使用内存池技术，减少对 <code>malloc</code> 和 <code>free</code> 的调用。</li><li>使用高效的内存分配算法。</li><li>避免频繁的内存分配和释放，尽量重用内存。</li></ul></li></ul><h3 id="6-面试中可能被问到的问题"><a href="#6-面试中可能被问到的问题" class="headerlink" title="6. 面试中可能被问到的问题"></a>6. <strong>面试中可能被问到的问题</strong></h3><ul><li><strong>问题 1</strong>：<code>malloc</code> 和 <code>free</code> 的区别是什么？<ul><li><strong>回答</strong>：<code>malloc</code> 用于动态分配内存，返回指向分配内存的指针；<code>free</code> 用于释放之前通过 <code>malloc</code> 分配的内存，避免内存泄漏。</li></ul></li><li><strong>问题 2</strong>：如何避免内存泄漏？<ul><li><strong>回答</strong>：确保每次调用 <code>malloc</code> 后，都有对应的 <code>free</code>。同时，检查 <code>malloc</code> 的返回值，避免分配失败导致的未定义行为。</li></ul></li><li><strong>问题 3</strong>：什么是悬空指针？如何避免？<ul><li><strong>回答</strong>：悬空指针是指向已释放内存的指针。避免方法是在释放内存后，将指针设置为 <code>NULL</code>。</li></ul></li><li><strong>问题 4</strong>：<code>malloc</code> 和 <code>free</code> 的实现原理是什么？<ul><li><strong>回答</strong>：<code>malloc</code> 从堆中分配内存，常见的算法包括首次适应、最佳适应等。<code>free</code> 将已分配的内存块标记为可用，并可能合并相邻的空闲块。</li></ul></li><li><strong>问题 5</strong>：如何解决内存碎片问题？<ul><li><strong>回答</strong>：使用合适的内存分配算法，如伙伴系统；使用内存池技术；定期进行内存整理。</li></ul></li><li><strong>问题 6</strong>：如何优化 <code>malloc</code> 和 <code>free</code> 的性能？<ul><li><strong>回答</strong>：使用内存池技术减少调用次数；选择高效的内存分配算法；避免频繁的内存分配和释放。</li></ul></li></ul><h2 id="new-delete与malloc-free的区别是什么？"><a href="#new-delete与malloc-free的区别是什么？" class="headerlink" title="new&#x2F;delete与malloc&#x2F;free的区别是什么？"></a><strong>new&#x2F;delete与malloc&#x2F;free的区别是什么？</strong></h2><ul><li>在C++中，申请动态内存和释放动态内存，用new&#x2F;delete 和 malloc&#x2F;free都可以，<strong>new和malloc动态申请的内存都位于堆中</strong>，无法被操作系统回收，需要对应的delete&#x2F;free来释放空间</li></ul><p><strong>void *malloc(int size);</strong></p><ul><li><strong>说明：</strong>malloc向系统申请分配指定size个字节的内存空间返回类型是 void* 类型void* 表示未确定类型的指针C,C++规定，void* 类型可以强制转换为任何其它类型的指针</li><li>对于类的对象而言，malloc&#x2F;free无法满足动态对象的要求，对象在创建时要自动执行构造函数，在对象消亡之前要自动执行析构函数，而malloc&#x2F;free 不在编译器控制权限之内，无法执行构造函数和析构函数</li><li>当然对于没有资源要清理的类，不调用析构函数也没有太大的问题，即使用free或delete没有区别但万一有一些类的成员是指针，而这个指针又在堆上开辟了空间，这时不调用析构函数去释放这个指针指向的这段空间，就会造成内存泄漏delete会调用析构函数，释放指针成员变量的空间，再销毁对象本身的空间；而free只释放了对象本身的空间，而指针成员所指向的空间没有被释放</li></ul><p><strong>具体而言：</strong></p><ul><li>new 能够自动计算需要分配的内存空间，而malloc需要手工计算字节数</li><li>new与delete带具体类型的指针，malloc与free返回void类型的指针</li><li>new 将调用构造函数，而malloc不能；delete将调用析构函数，而free不能</li><li>malloc&#x2F;free 需要库文件&lt;stdlib.h&gt;支持，而new&#x2F;delete不需要库文件支持</li><li>new操作可以重载，可以自定义内存分配策略，不做内存分配，或者分配到非内存设备上而malloc不能</li></ul><p>delete和free被调用后，内存不会不会立即收回，指针也不会指向空，delete或free仅仅是告诉操作系统，这一块内存被释放啦，还可以做其他用途由于没有对这块内存进行写操作，所以内存中的变量数值并没有发生变化，出现野指针的情况，因此，释放完内存后需要将指针向量置为空</p><h1 id="几个简单的Linux指令-shell"><a href="#几个简单的Linux指令-shell" class="headerlink" title="几个简单的Linux指令 shell"></a>几个简单的Linux指令 shell</h1><p>在面试中，掌握一些基本的 Linux 命令是非常重要的，尤其是对于嵌入式软件工程师岗位。以下是一些常见的 Linux 命令及其用途，适合在面试中展示你的 Linux 操作能力。</p><h3 id="1-文件和目录操作"><a href="#1-文件和目录操作" class="headerlink" title="1. 文件和目录操作"></a>1. <strong>文件和目录操作</strong></h3><ul><li><p>**<code>ls</code>**：列出目录内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l       <span class="comment"># 以长格式列出文件和目录</span></span><br><span class="line"><span class="built_in">ls</span> -a       <span class="comment"># 列出所有文件，包括隐藏文件</span></span><br><span class="line"><span class="built_in">ls</span> -la      <span class="comment"># 以长格式列出所有文件</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>cd</code>**：切换目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/directory   <span class="comment"># 切换到指定目录</span></span><br><span class="line"><span class="built_in">cd</span> ..                   <span class="comment"># 切换到上一级目录</span></span><br><span class="line"><span class="built_in">cd</span>                      <span class="comment"># 切换到用户主目录</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>pwd</code>**：显示当前工作目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>mkdir</code>**：创建目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> new_directory</span><br><span class="line"><span class="built_in">mkdir</span> -p parent/child   <span class="comment"># 递归创建目录</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>rm</code>**：删除文件或目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> file.txt             <span class="comment"># 删除文件</span></span><br><span class="line"><span class="built_in">rm</span> -r directory         <span class="comment"># 递归删除目录</span></span><br><span class="line"><span class="built_in">rm</span> -f file.txt          <span class="comment"># 强制删除文件，不提示</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>cp</code>**：复制文件或目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> file.txt newfile.txt   <span class="comment"># 复制文件</span></span><br><span class="line"><span class="built_in">cp</span> -r directory newdir    <span class="comment"># 递归复制目录</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>mv</code>**：移动或重命名文件或目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> file.txt newfile.txt   <span class="comment"># 重命名文件</span></span><br><span class="line"><span class="built_in">mv</span> file.txt /path/to/directory  <span class="comment"># 移动文件</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-文件查看和编辑"><a href="#2-文件查看和编辑" class="headerlink" title="2. 文件查看和编辑"></a>2. <strong>文件查看和编辑</strong></h3><ul><li><p>**<code>cat</code>**：显示文件内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> file.txt</span><br></pre></td></tr></table></figure></li><li><p>**<code>less</code>**：分页显示文件内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less file.txt</span><br></pre></td></tr></table></figure></li><li><p>**<code>head</code>**：显示文件的前几行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -n 10 file.txt   <span class="comment"># 显示文件的前10行</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>tail</code>**：显示文件的后几行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tail</span> -n 10 file.txt   <span class="comment"># 显示文件的后10行</span></span><br><span class="line"><span class="built_in">tail</span> -f log.txt       <span class="comment"># 实时查看文件的新增内容</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>vi</code> 或 <code>nano</code>**：编辑文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi file.txt           <span class="comment"># 使用 vi 编辑器</span></span><br><span class="line">nano file.txt         <span class="comment"># 使用 nano 编辑器</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-权限管理"><a href="#3-权限管理" class="headerlink" title="3. 权限管理"></a>3. <strong>权限管理</strong></h3><ul><li><p>**<code>chmod</code>**：修改文件或目录的权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 755 file.txt    <span class="comment"># 设置文件权限为 rwxr-xr-x</span></span><br><span class="line"><span class="built_in">chmod</span> +x script.sh    <span class="comment"># 为脚本添加可执行权限</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>chown</code>**：更改文件或目录的所有者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> user:group file.txt</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-系统信息"><a href="#4-系统信息" class="headerlink" title="4. 系统信息"></a>4. <strong>系统信息</strong></h3><ul><li><p>**<code>whoami</code>**：显示当前用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">whoami</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>uname</code>**：显示系统信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a               <span class="comment"># 显示所有系统信息</span></span><br><span class="line"><span class="built_in">uname</span> -m               <span class="comment"># 显示机器硬件架构</span></span><br><span class="line"><span class="built_in">uname</span> -r               <span class="comment"># 显示内核版本</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>df</code>**：显示磁盘空间使用情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h                  <span class="comment"># 以易读的格式显示磁盘空间</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>du</code>**：显示文件或目录的磁盘使用情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">du</span> -sh directory       <span class="comment"># 以易读的格式显示目录的总大小</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>top</code> 或 <code>htop</code>**：显示系统进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">top                    <span class="comment"># 显示系统进程（动态更新）</span></span><br><span class="line">htop                   <span class="comment"># 更友好的进程查看工具</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-网络操作"><a href="#5-网络操作" class="headerlink" title="5. 网络操作"></a>5. <strong>网络操作</strong></h3><ul><li><p>**<code>ping</code>**：测试网络连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 4 google.com   <span class="comment"># 向目标主机发送4次ICMP请求</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>ifconfig</code> 或 <code>ip</code>**：显示或配置网络接口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig               <span class="comment"># 显示网络接口信息</span></span><br><span class="line">ip addr show           <span class="comment"># 显示网络接口信息</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>netstat</code> 或 <code>ss</code>**：显示网络连接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">netstat -tuln          <span class="comment"># 显示所有监听的TCP/UDP端口</span></span><br><span class="line">ss -tuln               <span class="comment"># 替代 netstat 的工具</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="6-查找和搜索"><a href="#6-查找和搜索" class="headerlink" title="6. 查找和搜索"></a>6. <strong>查找和搜索</strong></h3><ul><li><p>**<code>find</code>**：查找文件或目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path -name <span class="string">&quot;file.txt&quot;</span>  <span class="comment"># 在指定路径下查找文件</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>grep</code>**：搜索文件内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">&quot;pattern&quot;</span> file.txt      <span class="comment"># 在文件中搜索匹配的字符串</span></span><br><span class="line">grep -r <span class="string">&quot;pattern&quot;</span> /path      <span class="comment"># 递归搜索目录中的文件</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="7-脚本和命令行工具"><a href="#7-脚本和命令行工具" class="headerlink" title="7. 脚本和命令行工具"></a>7. <strong>脚本和命令行工具</strong></h3><ul><li><p>**<code>echo</code>**：输出字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>date</code>**：显示或设置日期和时间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>history</code>**：显示命令历史</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>alias</code>**：创建命令别名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -la&#x27;</span>        <span class="comment"># 创建别名</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="8-系统管理"><a href="#8-系统管理" class="headerlink" title="8. 系统管理"></a>8. <strong>系统管理</strong></h3><ul><li><p>**<code>ps</code>**：显示进程状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux                   <span class="comment"># 显示所有进程的详细信息</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>kill</code>**：终止进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 PID              <span class="comment"># 强制终止进程</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>shutdown</code> 或 <code>reboot</code>**：关闭或重启系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h now          <span class="comment"># 立即关机</span></span><br><span class="line">reboot                   <span class="comment"># 重启系统</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="9-管道和重定向"><a href="#9-管道和重定向" class="headerlink" title="9. 管道和重定向"></a>9. <strong>管道和重定向</strong></h3><ul><li><p>**管道 (<code>|</code>)**：将一个命令的输出作为另一个命令的输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep <span class="string">&quot;process_name&quot;</span>  <span class="comment"># 查找特定进程</span></span><br></pre></td></tr></table></figure></li><li><p>**重定向 (<code>&gt;</code> 和 <code>&gt;&gt;</code>)**：将命令的输出重定向到文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello&quot;</span> &gt; file.txt   <span class="comment"># 将输出写入文件（覆盖）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;World&quot;</span> &gt;&gt; file.txt  <span class="comment"># 将输出追加到文件</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="10-压缩和解压"><a href="#10-压缩和解压" class="headerlink" title="10. 压缩和解压"></a>10. <strong>压缩和解压</strong></h3><ul><li><p>**<code>tar</code>**：打包和解包文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf archive.tar.gz directory/  <span class="comment"># 打包并压缩目录</span></span><br><span class="line">tar -xzvf archive.tar.gz             <span class="comment"># 解压文件</span></span><br></pre></td></tr></table></figure></li><li><p>**<code>gzip</code> 和 <code>gunzip</code>**：压缩和解压文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gzip file.txt            <span class="comment"># 压缩文件</span></span><br><span class="line">gunzip file.txt.gz       <span class="comment"># 解压文件</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="面试中可能被问到的问题"><a href="#面试中可能被问到的问题" class="headerlink" title="面试中可能被问到的问题"></a>面试中可能被问到的问题</h3><ul><li><p><strong>问题 1</strong>：如何查看当前目录下的所有文件，包括隐藏文件？</p><ul><li><strong>回答</strong>：<code>ls -a</code></li></ul></li><li><p><strong>问题 2</strong>：如何递归删除一个目录？</p><ul><li><strong>回答</strong>：<code>rm -r directory</code></li></ul></li><li><p><strong>问题 3</strong>：如何查看文件的前10行？</p><ul><li><strong>回答</strong>：<code>head -n 10 file.txt</code></li></ul></li><li><p><strong>问题 4</strong>：如何实时查看日志文件的新增内容？</p><ul><li><strong>回答</strong>：<code>tail -f log.txt</code></li></ul></li><li><p><strong>问题 5</strong>：如何查找某个文件？</p><ul><li><strong>回答</strong>：<code>find /path -name &quot;file.txt&quot;</code></li></ul></li><li><p><strong>问题 6</strong>：如何终止一个进程？</p><ul><li><strong>回答</strong>：<code>kill -9 PID</code></li></ul></li><li><p><strong>问题 7</strong>：如何查看系统磁盘空间使用情况？</p><ul><li><strong>回答</strong>：<code>df -h</code></li></ul></li><li><p><strong>问题 8</strong>：如何将一个命令的输出重定向到文件？</p><ul><li><strong>回答</strong>：<code>command &gt; file.txt</code></li></ul></li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>掌握这些基本的 Linux 命令可以帮助你在面试中展示你的 Linux 操作能力。这些命令涵盖了文件操作、权限管理、系统信息查看、网络操作、查找搜索等多个方面，是嵌入式软件工程师必备的技能。</p><h1 id="什么是野指针，产后的原因是什么"><a href="#什么是野指针，产后的原因是什么" class="headerlink" title="什么是野指针，产后的原因是什么"></a>什么是野指针，产后的原因是什么</h1><p>1、野指针是指向位置是随机的且不正确的</p><p>2、产生原因  定义时未初始化，指向位置随机</p><p>或者在释放时没有指向null，从而指向垃圾内存</p><h3 id="1-什么是野指针？"><a href="#1-什么是野指针？" class="headerlink" title="1. 什么是野指针？"></a>1. 什么是野指针？</h3><p><strong>比喻</strong>：想象你手里拿着一张地图，但地图上的地址是乱写的，或者地图根本就没有地址，你按照这个地图去寻找某个地方，很可能就会迷失方向，甚至走到一个完全错误的地方。</p><p><strong>实际操作</strong>：</p><ul><li><strong>野指针</strong>：在编程中，指针是一个变量，它用来存储另一个变量的内存地址。如果一个指针指向了一个随机的、不正确的内存地址，或者指向了一个已经被释放的内存地址，这个指针就被称为“野指针”。</li><li><strong>野指针的危害</strong>：野指针可能会导致程序访问到错误的内存区域，从而引发程序崩溃、数据损坏等不可预测的问题。</li></ul><h3 id="2-产生原因"><a href="#2-产生原因" class="headerlink" title="2. 产生原因"></a>2. 产生原因</h3><h4 id="1-定义时未初始化"><a href="#1-定义时未初始化" class="headerlink" title="1. 定义时未初始化"></a>1. 定义时未初始化</h4><p><strong>比喻</strong>：你手里拿着一张地图，但地图上没有写地址，你不知道它指向哪里，所以你可能会走到一个完全错误的地方。</p><p><strong>实际操作</strong>：</p><ul><li><p>当你定义了一个指针变量，但没有给它一个具体的地址时，这个指针变量的值是随机的。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr; <span class="comment">// 没有初始化，ptr的值是随机的</span></span><br></pre></td></tr></table></figure></li><li><p>这个随机的值可能指向一个完全错误的内存地址，这就是野指针。</p></li></ul><h4 id="2-释放后未指向NULL"><a href="#2-释放后未指向NULL" class="headerlink" title="2. 释放后未指向NULL"></a>2. 释放后未指向NULL</h4><p><strong>比喻</strong>：你手里拿着一张地图，地图上写了一个地址，但这个地址的房子已经被拆掉了。你按照这个地图去寻找，可能会走到一个空地，或者一个完全不同的地方。</p><p><strong>实际操作</strong>：</p><ul><li><p>当你用<code>malloc</code>等函数分配了一块内存，并用一个指针变量指向它，然后释放了这块内存，但没有把指针变量设置为<code>NULL</code>，这个指针变量就会变成野指针。比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配内存</span></span><br><span class="line"><span class="built_in">free</span>(ptr); <span class="comment">// 释放内存</span></span><br><span class="line"><span class="comment">// 此时ptr仍然指向原来的内存地址，但这块内存已经被释放了</span></span><br></pre></td></tr></table></figure></li><li><p>如果你继续使用<code>ptr</code>，它就会指向一个已经被释放的内存地址，这就是野指针。</p></li></ul><h2 id="如何避免野指针的问题"><a href="#如何避免野指针的问题" class="headerlink" title="如何避免野指针的问题"></a>如何避免野指针的问题</h2><h3 id="1-初始化指针"><a href="#1-初始化指针" class="headerlink" title="1. 初始化指针"></a>1. 初始化指针</h3><p><strong>建议</strong>：在定义指针时，始终初始化指针为<code>NULL</code>或指向一个有效的地址。</p><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="literal">NULL</span>; <span class="comment">// 初始化为NULL</span></span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;value; <span class="comment">// 初始化为一个有效的地址</span></span><br></pre></td></tr></table></figure><p><strong>解释</strong>：初始化为<code>NULL</code>可以让你在后续使用指针时，通过检查是否为<code>NULL</code>来避免使用未初始化的指针。</p><h3 id="2-释放内存后将指针置为NULL"><a href="#2-释放内存后将指针置为NULL" class="headerlink" title="2. 释放内存后将指针置为NULL"></a>2. 释放内存后将指针置为<code>NULL</code></h3><p><strong>建议</strong>：在释放动态分配的内存后，立即将指针置为<code>NULL</code>。</p><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用ptr</span></span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">ptr = <span class="literal">NULL</span>; <span class="comment">// 释放内存后将指针置为NULL</span></span><br></pre></td></tr></table></figure><p><strong>解释</strong>：这样可以避免指针继续指向已经被释放的内存，从而防止野指针的产生。</p><h3 id="3-检查指针是否为NULL"><a href="#3-检查指针是否为NULL" class="headerlink" title="3. 检查指针是否为NULL"></a>3. 检查指针是否为<code>NULL</code></h3><p><strong>建议</strong>：在使用指针之前，始终检查指针是否为<code>NULL</code>。</p><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用ptr</span></span><br><span class="line">*ptr = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">ptr = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：通过检查指针是否为<code>NULL</code>，可以避免对未初始化或已经释放的指针进行操作。</p><h3 id="4-使用智能指针（C-）"><a href="#4-使用智能指针（C-）" class="headerlink" title="4. 使用智能指针（C++）"></a>4. 使用智能指针（C++）</h3><p><strong>建议</strong>：如果你使用的是C++，尽量使用智能指针（如<code>std::unique_ptr</code>或<code>std::shared_ptr</code>）来管理动态内存。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 使用ptr</span></span><br></pre></td></tr></table></figure><p><strong>解释</strong>：智能指针会自动管理内存的分配和释放，避免手动管理内存带来的风险。</p><h3 id="5-避免重复释放"><a href="#5-避免重复释放" class="headerlink" title="5. 避免重复释放"></a>5. 避免重复释放</h3><p><strong>建议</strong>：确保内存只被释放一次，避免重复释放。</p><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用ptr</span></span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">ptr = <span class="literal">NULL</span>; <span class="comment">// 释放内存后将指针置为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免重复释放</span></span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：通过将指针置为<code>NULL</code>，可以避免重复释放的问题。</p><h3 id="6-使用工具检测野指针"><a href="#6-使用工具检测野指针" class="headerlink" title="6. 使用工具检测野指针"></a>6. 使用工具检测野指针</h3><p><strong>建议</strong>：使用内存检测工具（如<code>valgrind</code>）来检测野指针和内存泄漏问题。</p><p><strong>示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind ./your_program</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：<code>valgrind</code>等工具可以检测内存访问错误，帮助你发现野指针问题。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><p><strong>野指针</strong>：指向一个随机的、不正确的内存地址的指针。</p></li><li><p><strong>产生原因</strong>：</p><ol><li><strong>定义时未初始化</strong>：指针变量没有被赋予一个具体的地址，它的值是随机的。</li><li><strong>释放后未指向NULL</strong>：指针变量指向的内存被释放了，但指针变量没有被设置为<code>NULL</code>，它仍然指向原来的内存地址。</li></ol></li></ul><ol><li><ul><li></li></ul></li></ol><h1 id="网络五层协议分别是哪些？"><a href="#网络五层协议分别是哪些？" class="headerlink" title="网络五层协议分别是哪些？"></a>网络五层协议分别是哪些？</h1><ol><li><strong>应用层（Application Layer）</strong>：负责处理特定的应用程序细节，如电子邮件、文件传输和网页浏览。</li><li><strong>运输层（Transport Layer）</strong>：负责在网络中的两个节点之间提供可靠的数据传输，常见的协议有TCP和UDP。</li><li><strong>网络层（Network Layer）</strong>：负责将数据包从源主机移动到目的主机。</li><li><strong>链路层（Link Layer）</strong>：负责在物理层上传输数据帧，包括以太网等。</li><li><strong>物理层（Physical Layer）</strong>：负责在物理介质上透明地传输比特流。</li></ol><p>- </p><h1 id="4、你说你曾经做过某某驱动的移植，那你介绍下某某的驱动，是如何进行的？"><a href="#4、你说你曾经做过某某驱动的移植，那你介绍下某某的驱动，是如何进行的？" class="headerlink" title="4、你说你曾经做过某某驱动的移植，那你介绍下某某的驱动，是如何进行的？"></a>4、你说你曾经做过某某驱动的移植，那你介绍下某某的驱动，是如何进行的？</h1><p> 硬件连接与初始化</p><ul><li><strong>连接</strong>：DHT11通过GPIO引脚与开发板相连。</li><li><strong>初始化</strong>：在驱动中申请GPIO引脚，并设置为输入&#x2F;输出模式，为数据通信做好准备。</li></ul><h3 id="数据采集与解析"><a href="#数据采集与解析" class="headerlink" title="数据采集与解析"></a>数据采集与解析</h3><ul><li><strong>启动信号</strong>：主机拉低GPIO引脚一段时间后拉高，触发DHT11响应。</li><li><strong>接收数据</strong>：DHT11逐位发送40位数据（包括温湿度信息和校验位），主机通过检测GPIO引脚的电平变化来读取数据，并解析出温湿度值。</li></ul><h3 id="驱动框架搭建与注册"><a href="#驱动框架搭建与注册" class="headerlink" title="驱动框架搭建与注册"></a>驱动框架搭建与注册</h3><ul><li><strong>定义驱动结构体</strong>：创建<code>platform_driver</code>结构体，包含<code>probe</code>和<code>remove</code>函数。</li><li><strong>注册驱动</strong>：调用<code>platform_driver_register</code>将驱动注册到内核。</li><li><strong>设备树匹配</strong>：在设备树中添加DHT11设备描述，确保内核能够匹配驱动和硬件。</li></ul><h3 id="提供数据接口"><a href="#提供数据接口" class="headerlink" title="提供数据接口"></a>提供数据接口</h3><ul><li><strong>创建字符设备</strong>：通过<code>register_chrdev</code>注册字符设备，创建设备节点。</li><li><strong>实现读写操作</strong>：在<code>file_operations</code>中实现<code>read</code>函数，将采集到的温湿度数据提供给上层应用。</li></ul><h3 id="测试与优化"><a href="#测试与优化" class="headerlink" title="测试与优化"></a>测试与优化</h3><ul><li><strong>功能测试</strong>：编写测试程序，通过设备节点读取数据，验证驱动功能。</li><li><strong>性能优化</strong>：优化延时和数据处理逻辑，确保驱动高效运行。</li></ul><h1 id="6、你说你曾经用UART协议做过东西，那你解释下UART协议中的内容"><a href="#6、你说你曾经用UART协议做过东西，那你解释下UART协议中的内容" class="headerlink" title="6、你说你曾经用UART协议做过东西，那你解释下UART协议中的内容"></a>6、你说你曾经用UART协议做过东西，那你解释下UART协议中的内容</h1><h3 id="UART协议简介"><a href="#UART协议简介" class="headerlink" title="UART协议简介"></a>UART协议简介</h3><p>UART（Universal Asynchronous Receiver&#x2F;Transmitter，通用异步收发传输器）是一种常用的串行通信协议，用于设备之间的数据传输。它支持全双工通信，即可以同时发送和接收数据。</p><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ul><li><strong>异步通信</strong>：发送方和接收方不需要共享时钟信号，通过起始位和停止位来标识数据帧的开始和结束。</li><li><strong>数据帧格式</strong>：通常由起始位（低电平）、数据位（可配置为7位或8位）、可选的校验位（奇校验、偶校验或无校验）和停止位（高电平）组成。</li><li><strong>波特率</strong>：通信双方需要约定一个波特率（如9600、115200等），表示每秒传输的位数，以确保数据同步。</li></ul><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li><p><strong>发送数据时</strong>：</p><ul><li>发送方将数据位依次发送，起始位为低电平，表示数据帧开始。</li><li>数据位按位发送，从最低位到最高位。</li><li>如果有校验位，根据校验规则添加校验位。</li><li>最后发送停止位，高电平表示数据帧结束。</li></ul></li><li><p><strong>接收数据时</strong>：</p><ul><li>接收方检测到起始位后，开始采样数据位。</li><li>按照约定的波特率和数据位数，依次读取数据位。</li><li>如果有校验位，对接收到的数据进行校验。</li><li>最后检测停止位，确认数据帧结束。</li></ul><h1 id="智能指针有哪些"><a href="#智能指针有哪些" class="headerlink" title="智能指针有哪些"></a>智能指针有哪些</h1><ol><li><p>**<code>std::unique_ptr</code>**：</p><ul><li><p><strong>特点</strong>：独占所有权，不允许复制，但可以移动。</p></li><li><p><strong>用途</strong>：当需要独占资源时使用，确保资源不会被多个指针共享。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>**<code>std::shared_ptr</code>**：</p><ul><li><p><strong>特点</strong>：共享所有权，通过引用计数管理资源的生命周期。</p></li><li><p><strong>用途</strong>：当多个指针需要共享同一资源时使用。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">20</span>))</span></span>;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1; <span class="comment">// ptr1 和 ptr2 共享同一个资源</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>**<code>std::weak_ptr</code>**：</p><ul><li><p><strong>特点</strong>：弱引用，不增加引用计数，用于打破 <code>std::shared_ptr</code> 的循环引用。</p></li><li><p><strong>用途</strong>：常用于观察但不拥有资源，避免内存泄漏。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">30</span>))</span></span>;</span><br><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1; <span class="comment">// 弱引用，不增加引用计数</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>总结</strong></p><ul><li>**<code>std::unique_ptr</code>**：独占所有权，适合独占资源。</li><li>**<code>std::shared_ptr</code>**：共享所有权，适合资源共享。</li><li>**<code>std::weak_ptr</code>**：弱引用，用于打破循环引用。</li></ul><h1 id="share-ptr和weak-ptr的作用和区别"><a href="#share-ptr和weak-ptr的作用和区别" class="headerlink" title="share_ptr和weak_ptr的作用和区别"></a>share_ptr和weak_ptr的作用和区别</h1><p>**<code>std::shared_ptr</code>**：</p><ul><li><strong>作用</strong>：管理动态分配的资源，通过引用计数自动管理内存。</li><li><strong>特点</strong>：可以复制，引用计数会增加；可以移动，引用计数会减少。</li><li><strong>适用场景</strong>：需要多个指针共享同一资源时。</li></ul><p>**<code>std::weak_ptr</code>**：</p><ul><li><strong>作用</strong>：提供对 <code>std::shared_ptr</code> 管理的资源的非拥有性引用，避免循环引用。</li><li><strong>特点</strong>：不增加引用计数，不会阻止资源被释放。</li><li><strong>适用场景</strong>：用于观察但不拥有资源，避免内存泄漏。</li></ul><p><strong>区别</strong>：</p><ol><li><strong>引用计数</strong>：<ul><li><code>std::shared_ptr</code>：增加引用计数。</li><li><code>std::weak_ptr</code>：不增加引用计数。</li></ul></li><li><strong>生命周期管理</strong>：<ul><li><code>std::shared_ptr</code>：管理资源的生命周期。</li><li><code>std::weak_ptr</code>：不管理资源的生命周期，仅提供对资源的访问。</li></ul></li><li><strong>适用场景</strong>：<ul><li><code>std::shared_ptr</code>：资源共享。</li><li><code>std::weak_ptr</code>：打破循环引用，避免内存泄漏。</li></ul></li></ol><h1 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h1><ul><li><p><strong>左值（Lvalue）</strong>：</p><ul><li><p><strong>定义</strong>：表示一个有持久存储位置的值，可以被取地址（<code>&amp;</code>）。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>; <span class="comment">// a 是左值</span></span><br><span class="line"><span class="type">int</span>&amp; ref = a; <span class="comment">// 引用左值</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>右值（Rvalue）</strong>：</p><ul><li><p><strong>定义</strong>：表示一个临时的、没有持久存储位置的值，不能被取地址（<code>&amp;</code>）。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b = <span class="number">10</span> + <span class="number">20</span>; <span class="comment">// 10 + 20 是右值</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a><strong>区别</strong></h3><ul><li><strong>存储位置</strong>：<ul><li><strong>左值</strong>：有持久存储位置。</li><li><strong>右值</strong>：通常是临时的，没有持久存储位置。</li></ul></li><li><strong>取地址</strong>：<ul><li><strong>左值</strong>：可以取地址。</li><li><strong>右值</strong>：不能取地址。</li></ul></li><li><strong>用途</strong>：<ul><li><strong>左值</strong>：可以被引用（<code>&amp;</code>）。</li><li><strong>右值</strong>：通常用于移动语义（C++11 引入）。</li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>; <span class="comment">// a 是左值</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span> + <span class="number">20</span>; <span class="comment">// 10 + 20 是右值</span></span><br><span class="line"><span class="type">int</span>&amp; ref = a; <span class="comment">// 引用左值</span></span><br><span class="line"><span class="comment">// int&amp; ref2 = 10 + 20; // 错误，不能引用右值</span></span><br></pre></td></tr></table></figure><h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><ul><li><strong>定义</strong>：右值引用是C++11引入的一种引用类型，专门用于绑定到右值（临时对象）。</li><li><strong>语法</strong>：使用<code>&amp;&amp;</code>声明，例如<code>int&amp;&amp; r = 10;</code>。</li><li><strong>用途</strong>：支持移动语义和完美转发，提高性能，避免不必要的拷贝。</li><li><strong>特点</strong>：<ul><li>可以绑定到右值（临时对象）。</li><li>不能绑定到左值（持久对象）。</li><li>用于实现移动构造函数和移动赋值运算符。</li></ul></li></ul><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; r = <span class="number">10</span>; <span class="comment">// 绑定到右值</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// int&amp;&amp; r2 = a; // 错误，不能绑定到左值</span></span><br></pre></td></tr></table></figure><h1 id="move原理"><a href="#move原理" class="headerlink" title="move原理"></a>move原理</h1><p><strong>移动语义</strong>通过右值引用（<code>T&amp;&amp;</code>）实现，允许资源从一个对象转移到另一个对象，避免不必要的拷贝。主要通过以下机制实现：</p><ol><li><strong>右值引用</strong>：绑定到临时对象（右值）。</li><li><strong>移动构造函数</strong>：将资源从右值对象转移到新对象。</li><li><strong>移动赋值运算符</strong>：将资源从右值对象转移到已有对象。</li><li>**<code>std::move</code>**：将左值转换为右值，触发移动语义。</li></ol><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Resource</span>(<span class="type">int</span> size) : <span class="built_in">data</span>(<span class="keyword">new</span> <span class="type">int</span>[size]) &#123;&#125;</span><br><span class="line">    <span class="built_in">Resource</span>(Resource&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">data</span>(other.data) &#123; other.data = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">    Resource&amp; <span class="keyword">operator</span>=(Resource&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">        data = other.data;</span><br><span class="line">        other.data = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Resource</span>() &#123; <span class="keyword">delete</span>[] data; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>总结</strong>：移动语义通过右值引用和移动构造函数&#x2F;赋值运算符，高效转移资源，提高性能。</p><h1 id="编译的过程"><a href="#编译的过程" class="headerlink" title="编译的过程"></a>编译的过程</h1><ol><li><strong>预处理（Preprocessing）</strong>：<ul><li>处理源代码文件中的预处理指令，如<code>#include</code>、<code>#define</code>等。</li><li>生成预处理后的文件（通常是<code>.i</code>或<code>.ii</code>文件）。</li></ul></li><li><strong>编译（Compilation）</strong>：<ul><li>将预处理后的文件转换为汇编语言代码。</li><li>生成汇编文件（通常是<code>.s</code>文件）。</li></ul></li><li><strong>汇编（Assembly）</strong>：<ul><li>将汇编语言代码转换为机器码。</li><li>生成目标文件（通常是<code>.o</code>文件）。</li></ul></li><li><strong>链接（Linking）</strong>：<ul><li>将多个目标文件和库文件合并为一个可执行文件。</li><li>解决符号引用，生成最终的可执行文件（通常是<code>.exe</code>或无扩展名的文件）。</li></ul></li></ol><h1 id="最熟悉什么语言"><a href="#最熟悉什么语言" class="headerlink" title="最熟悉什么语言"></a>最熟悉什么语言</h1><p>C和C++是我最熟悉的语言。我有丰富的嵌入式系统开发经验，C++在性能和资源管理方面表现出色，非常适合这类场景。</p><h1 id="数组和链表区别？"><a href="#数组和链表区别？" class="headerlink" title="数组和链表区别？"></a>数组和链表区别？</h1><h3 id="数组和链表的区别"><a href="#数组和链表的区别" class="headerlink" title="数组和链表的区别"></a><strong>数组和链表的区别</strong></h3><ol><li><strong>存储方式</strong>：<ul><li><strong>数组</strong>：连续存储，内存分配固定。</li><li><strong>链表</strong>：非连续存储，通过指针连接。</li></ul></li><li><strong>访问速度</strong>：<ul><li><strong>数组</strong>：随机访问，速度快。</li><li><strong>链表</strong>：顺序访问，速度慢。</li></ul></li><li><strong>内存分配</strong>：<ul><li><strong>数组</strong>：静态分配，大小固定。</li><li><strong>链表</strong>：动态分配，大小可变。</li></ul></li><li><strong>插入和删除</strong>：<ul><li><strong>数组</strong>：插入和删除需要移动元素，效率低。</li><li><strong>链表</strong>：插入和删除直接操作指针，效率高。</li></ul></li><li><strong>内存使用</strong>：<ul><li><strong>数组</strong>：连续内存，浪费空间。</li><li><strong>链表</strong>：非连续内存，节省空间。</li></ul></li></ol><h1 id="7-愿意做bios吗"><a href="#7-愿意做bios吗" class="headerlink" title="7 愿意做bios吗"></a>7 愿意做bios吗</h1><p><strong>愿意</strong>。BIOS（Basic Input&#x2F;Output System，基本输入输出系统）开发是一个很有挑战性和成就感的领域，它涉及到硬件初始化、系统启动等底层技术，对提升我的嵌入式系统开发能力非常有帮助。我期待能在这个领域深入学习和实践。</p></li></ol><h1 id="得C-11和之前的有什么区别（auto、智能指针、右值引用等）"><a href="#得C-11和之前的有什么区别（auto、智能指针、右值引用等）" class="headerlink" title="得C++11和之前的有什么区别（auto、智能指针、右值引用等）"></a>得C++11和之前的有什么区别（auto、智能指针、右值引用等）</h1><ol><li><p><strong><code>auto</code> 关键字</strong>：</p><ul><li><p><strong>C++11 之前</strong>：需要显式声明变量类型。</p></li><li><p><strong>C++11 之后</strong>：<code>auto</code> 关键字让编译器自动推断变量类型，简化代码。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">10</span>; <span class="comment">// x 的类型为 int</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">3.14</span>; <span class="comment">// y 的类型为 double</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>智能指针</strong>：</p><ul><li><p><strong>C++11 之前</strong>：手动管理动态内存，容易导致内存泄漏。</p></li><li><p><strong>C++11 之后</strong>：引入智能指针（如 <code>std::unique_ptr</code> 和 <code>std::shared_ptr</code>），自动管理内存，减少内存泄漏风险。</p></li><li><p><strong>示例</strong>：</p><p>cpp</p><p>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>; <span class="comment">// 自动释放内存</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">20</span>))</span></span>; <span class="comment">// 引用计数管理内存</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>右值引用</strong>：</p><ul><li><p><strong>C++11 之前</strong>：只有左值引用，无法直接操作临时对象。</p></li><li><p><strong>C++11 之后</strong>：引入右值引用（<code>&amp;&amp;</code>），支持移动语义，提高性能。</p></li><li><p><strong>示例</strong>：</p><p>cpp</p><p>复制</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; rvalueRef = <span class="number">10</span>; <span class="comment">// 绑定到临时对象</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>移动语义</strong>：</p><ul><li><p><strong>C++11 之前</strong>：只有拷贝语义，复制对象时会创建新的副本。</p></li><li><p><strong>C++11 之后</strong>：支持移动语义，允许将资源从一个对象转移到另一个对象，避免不必要的拷贝。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v2 = std::<span class="built_in">move</span>(v1); <span class="comment">// v1 的内容被移动到 v2</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>初始化列表</strong>：</p><ul><li><p><strong>C++11 之前</strong>：初始化数组或集合需要逐个赋值。</p></li><li><p><strong>C++11 之后</strong>：支持初始化列表，简化初始化过程。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Lambda 表达式</strong>：</p><ul><li><p><strong>C++11 之前</strong>：需要定义函数或函数对象。</p></li><li><p><strong>C++11 之后</strong>：支持 Lambda 表达式，方便定义匿名函数。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda = [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">lambda</span>(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// result = 8</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>并发支持</strong>：</p><ul><li><p><strong>C++11 之前</strong>：没有标准的并发支持。</p></li><li><p><strong>C++11 之后</strong>：引入了线程库（<code>std::thread</code>），支持多线程编程。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">([]() &#123; std::cout &lt;&lt; <span class="string">&quot;Hello from thread!&quot;</span> &lt;&lt; std::endl; &#125;)</span></span>;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>总结</strong></p><p>C++11 引入了 <code>auto</code>、智能指针、右值引用、移动语义、初始化列表、Lambda 表达式和并发支持等特性，显著提升了语言的表达能力和效率，减少了内存泄漏风险，简化了代码编写。</p><h1 id="8、你说你曾经用过云服务器，我们这边也是云服务器开发这一块的，你了解服务器里面都是些什么吗？"><a href="#8、你说你曾经用过云服务器，我们这边也是云服务器开发这一块的，你了解服务器里面都是些什么吗？" class="headerlink" title="8、你说你曾经用过云服务器，我们这边也是云服务器开发这一块的，你了解服务器里面都是些什么吗？"></a>8、你说你曾经用过云服务器，我们这边也是云服务器开发这一块的，你了解服务器里面都是些什么吗？</h1><h3 id="1-CPU（中央处理器）"><a href="#1-CPU（中央处理器）" class="headerlink" title="1. CPU（中央处理器）"></a>1. <strong>CPU（中央处理器）</strong></h3><ul><li><strong>功能</strong>：负责执行服务器上的所有计算任务，包括运行操作系统、应用程序和处理用户请求。</li><li><strong>特点</strong>：云服务器通常会分配虚拟CPU（vCPU），这些vCPU是物理CPU核心的虚拟化实例。</li></ul><h3 id="2-内存（RAM）"><a href="#2-内存（RAM）" class="headerlink" title="2. 内存（RAM）"></a>2. <strong>内存（RAM）</strong></h3><ul><li><strong>功能</strong>：用于临时存储操作系统、应用程序和当前运行的数据，提供快速读写能力。</li><li><strong>特点</strong>：云服务器的内存是物理服务器内存的虚拟化分配，支持动态扩展和收缩。</li></ul><h3 id="3-存储（磁盘）"><a href="#3-存储（磁盘）" class="headerlink" title="3. 存储（磁盘）"></a>3. <strong>存储（磁盘）</strong></h3><ul><li><strong>功能</strong>：用于持久化存储数据，如操作系统文件、应用程序数据和用户数据。</li><li><strong>类型</strong>：<ul><li><strong>本地存储</strong>：直接连接到物理服务器的硬盘（如SSD或HDD）。</li><li><strong>网络存储</strong>：通过网络连接的存储资源，如云存储服务（如AWS S3、阿里云OSS）。</li></ul></li><li><strong>特点</strong>：支持弹性扩展，用户可以根据需求动态调整存储容量。</li></ul><h3 id="4-网络接口"><a href="#4-网络接口" class="headerlink" title="4. 网络接口"></a>4. <strong>网络接口</strong></h3><ul><li><strong>功能</strong>：负责云服务器与其他设备（如其他云服务器、客户端、外部网络）的通信。</li><li><strong>特点</strong>：通过虚拟网络接口连接到虚拟网络，支持多种网络协议（如TCP&#x2F;IP）。</li></ul><h3 id="5-操作系统"><a href="#5-操作系统" class="headerlink" title="5. 操作系统"></a>5. <strong>操作系统</strong></h3><ul><li><strong>功能</strong>：管理服务器的硬件资源，提供用户与硬件之间的交互界面。</li><li><strong>常见类型</strong>：Linux（如Ubuntu、CentOS）、Windows Server等。</li></ul><h3 id="6-虚拟化层（Hypervisor）"><a href="#6-虚拟化层（Hypervisor）" class="headerlink" title="6. 虚拟化层（Hypervisor）"></a>6. <strong>虚拟化层（Hypervisor）</strong></h3><ul><li><strong>功能</strong>：将物理服务器的资源虚拟化，分配给多个云服务器实例。</li><li><strong>特点</strong>：确保每个云服务器实例之间的隔离性，提高资源利用率。</li></ul><h3 id="7-管理工具和服务"><a href="#7-管理工具和服务" class="headerlink" title="7. 管理工具和服务"></a>7. <strong>管理工具和服务</strong></h3><ul><li><strong>功能</strong>：用于监控、管理和维护云服务器的运行状态。</li><li><strong>常见工具</strong>：<ul><li><strong>监控工具</strong>：如Prometheus、Grafana，用于监控资源使用情况和性能指标。</li><li><strong>配置管理工具</strong>：如Ansible、Puppet，用于自动化配置和部署。</li><li><strong>日志管理工具</strong>：如ELK（Elasticsearch、Logstash、Kibana），用于收集和分析日志。</li></ul></li></ul><h3 id="8-安全机制"><a href="#8-安全机制" class="headerlink" title="8. 安全机制"></a>8. <strong>安全机制</strong></h3><ul><li><strong>功能</strong>：保护云服务器免受攻击，确保数据安全。</li><li><strong>常见机制</strong>：<ul><li><strong>防火墙</strong>：控制进出服务器的网络流量。</li><li><strong>身份认证</strong>：如SSH密钥、多因素认证。</li><li><strong>数据加密</strong>：存储和传输中的数据加密。</li></ul></li></ul><h3 id="9-备份和恢复机制"><a href="#9-备份和恢复机制" class="headerlink" title="9. 备份和恢复机制"></a>9. <strong>备份和恢复机制</strong></h3><ul><li><strong>功能</strong>：确保数据的完整性和可用性，防止数据丢失。</li><li><strong>特点</strong>：支持定期备份和快速恢复。</li></ul><h3 id="10-负载均衡"><a href="#10-负载均衡" class="headerlink" title="10. 负载均衡"></a>10. <strong>负载均衡</strong></h3><ul><li><strong>功能</strong>：在多个云服务器之间分配用户请求，提高系统的可用性和性能。</li><li><strong>特点</strong>：支持自动扩展和故障转移。</li></ul><h1 id="11、那你对TCP的协议了解吗，TCP的协议发送流程是怎么样的，数据格式是怎么样的？"><a href="#11、那你对TCP的协议了解吗，TCP的协议发送流程是怎么样的，数据格式是怎么样的？" class="headerlink" title="11、那你对TCP的协议了解吗，TCP的协议发送流程是怎么样的，数据格式是怎么样的？"></a>11、那你对TCP的协议了解吗，TCP的协议发送流程是怎么样的，数据格式是怎么样的？</h1><h3 id="TCP-发送流程"><a href="#TCP-发送流程" class="headerlink" title="TCP 发送流程"></a>TCP 发送流程</h3><ol><li><strong>建立连接（三次握手）</strong>：<ul><li>客户端发送一个SYN（同步）包到服务器。</li><li>服务器回应一个SYN+ACK（同步+确认）包。</li><li>客户端发送一个ACK（确认）包，完成连接建立。</li></ul></li><li><strong>数据传输</strong>：<ul><li>数据被分割成多个TCP段（Segment），每个段包含TCP头部和数据部分。</li><li>每个TCP段通过IP层发送，TCP头部包含源端口、目的端口、序列号、确认号、窗口大小等信息。</li><li>接收方通过序列号确认数据完整性，发送ACK确认收到的段。</li></ul></li><li><strong>关闭连接（四次挥手）</strong>：<ul><li>发送方发送一个FIN（结束）包，表示数据发送完毕。</li><li>接收方回应一个ACK确认收到FIN。</li><li>接收方发送自己的FIN包。</li><li>发送方回应ACK，完成连接关闭。</li></ul></li></ol><h3 id="TCP-数据格式"><a href="#TCP-数据格式" class="headerlink" title="TCP 数据格式"></a>TCP 数据格式</h3><ul><li><strong>TCP头部</strong>：<ul><li><strong>源端口和目的端口</strong>：标识发送和接收端的应用程序。</li><li><strong>序列号</strong>：用于数据段的顺序确认。</li><li><strong>确认号</strong>：接收方期望收到的下一个字节的序列号。</li><li><strong>标志位（如SYN、ACK、FIN）</strong>：控制连接的建立和关闭。</li><li><strong>窗口大小</strong>：接收方的接收缓冲区大小，用于流量控制。</li><li><strong>校验和</strong>：确保数据的完整性。</li></ul></li></ul><h1 id="12、你知道发送中有哪些检测错误的协议类型吗？说出任意一个都可以"><a href="#12、你知道发送中有哪些检测错误的协议类型吗？说出任意一个都可以" class="headerlink" title="12、你知道发送中有哪些检测错误的协议类型吗？说出任意一个都可以"></a>12、你知道发送中有哪些检测错误的协议类型吗？说出任意一个都可以</h1><p>当然！TCP协议中使用了多种机制来检测和纠正错误，其中一个关键机制是<strong>校验和（Checksum）</strong>。</p><h3 id="TCP-校验和"><a href="#TCP-校验和" class="headerlink" title="TCP 校验和"></a>TCP 校验和</h3><ul><li><strong>作用</strong>：用于检测数据在传输过程中是否发生错误。</li><li><strong>原理</strong>：TCP校验和是一个简单的16位一的补码和，覆盖了TCP头部和数据部分。</li><li><strong>计算方法</strong>：<ol><li>将TCP头部和数据部分按16位分组。</li><li>对每个16位的段进行一的补码加法。</li><li>将最终的和取反，得到校验和。</li></ol></li><li><strong>发送方</strong>：在发送TCP段之前，计算校验和并将其放入TCP头部。</li><li><strong>接收方</strong>：收到TCP段后，重新计算校验和。如果计算结果为全0，说明数据没有错误；否则，数据可能在传输过程中被篡改。</li></ul><h3 id="其他错误检测机制"><a href="#其他错误检测机制" class="headerlink" title="其他错误检测机制"></a>其他错误检测机制</h3><p>除了校验和，TCP还通过以下机制确保数据的可靠性：</p><ul><li><strong>序列号和确认号</strong>：确保数据按顺序接收，并通过ACK确认机制检测丢失或重复的段。</li><li><strong>超时重传</strong>：如果发送方在超时时间内没有收到ACK，会重新发送数据段。</li><li><strong>流量控制</strong>：通过窗口机制控制发送速率，避免接收方缓冲区溢出。</li></ul><h1 id="13、那你解释解释CRC校验是怎么回事，怎么的一个流程。"><a href="#13、那你解释解释CRC校验是怎么回事，怎么的一个流程。" class="headerlink" title="13、那你解释解释CRC校验是怎么回事，怎么的一个流程。"></a>13、那你解释解释CRC校验是怎么回事，怎么的一个流程。</h1><h3 id="CRC校验流程"><a href="#CRC校验流程" class="headerlink" title="CRC校验流程"></a>CRC校验流程</h3><ol><li><strong>选择生成多项式</strong>：选择一个预定义的多项式（如CRC-16的0x8005）。</li><li><strong>数据预处理</strong>：在数据后面附加若干个零（零的数量等于校验码的位数）。</li><li><strong>多项式除法</strong>：用生成多项式对预处理后的数据进行除法，得到余数。</li><li><strong>生成校验码</strong>：将余数作为校验码附加到数据末尾。</li><li><strong>接收方校验</strong>：接收方收到数据后，用相同生成多项式对数据进行除法，若余数为0，则数据正确。</li></ol><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>高效</strong>：能检测出大多数常见错误，如单比特错误和突发错误。</li><li><strong>可靠</strong>：基于数学运算，抗干扰能力强。</li><li><strong>易于实现</strong>：硬件和软件实现都简单。</li></ul><h1 id="13-针对竞赛：如何沟通-如何安排任务（我详细答了我的电赛-强调4天3夜时间想要获奖对于配合沟通非常重要）"><a href="#13-针对竞赛：如何沟通-如何安排任务（我详细答了我的电赛-强调4天3夜时间想要获奖对于配合沟通非常重要）" class="headerlink" title="13.针对竞赛：如何沟通 如何安排任务（我详细答了我的电赛 强调4天3夜时间想要获奖对于配合沟通非常重要）"></a>13.针对竞赛：如何沟通 如何安排任务（我详细答了我的电赛 强调4天3夜时间想要获奖对于配合沟通非常重要）</h1><p>在参加电子设计竞赛（电赛）时，我们团队面临着4天3夜的紧张赛程，时间非常紧迫。为了在这种高压环境下取得优异成绩，我们非常注重团队的沟通和任务安排。</p><h3 id="1-沟通方式"><a href="#1-沟通方式" class="headerlink" title="1. 沟通方式"></a><strong>1. 沟通方式</strong></h3><ul><li><strong>明确分工</strong>：在竞赛开始前，我们团队根据每个人的专长和兴趣，明确了各自的分工。例如，我主要负责硬件设计和调试，另一位队员负责软件编程，还有一位队员负责撰写文档和测试。明确分工后，我们通过定期的团队会议来同步进度和解决问题。</li><li><strong>实时沟通</strong>：在整个竞赛过程中，我们保持实时沟通。遇到技术难题或进度延误时，我们会立即召开小组讨论，共同寻找解决方案。我们还通过微信群和项目管理工具（如Trello）来记录任务进展和关键问题，确保每个成员都能随时了解项目状态。</li><li><strong>面对面交流</strong>：尽管有线上工具，但我们更倾向于面对面交流。在竞赛期间，我们每天都会安排固定的时间进行面对面的讨论，这不仅提高了沟通效率，还增强了团队凝聚力。</li></ul><h3 id="2-任务安排"><a href="#2-任务安排" class="headerlink" title="2. 任务安排"></a><strong>2. 任务安排</strong></h3><ul><li><strong>制定详细计划</strong>：在竞赛开始前，我们制定了详细的项目计划，将整个竞赛过程分解为多个小任务，并为每个任务分配了明确的时间节点。例如，第一天完成需求分析和初步设计，第二天进行硬件搭建和软件框架搭建，第三天进行系统集成和调试，最后一天进行测试和文档撰写。</li><li><strong>灵活调整</strong>：尽管我们制定了详细的计划，但在实际操作中，难免会遇到意外情况。我们团队非常注重灵活性，一旦发现某个任务的进度滞后，我们会立即重新分配任务，确保整体进度不受影响。例如，在硬件调试阶段，我们发现一个问题需要额外的时间来解决，于是软件团队提前介入，帮助进行部分测试工作，确保整体进度不受影响。</li><li><strong>优先级管理</strong>：在任务安排中，我们特别注重优先级管理。对于关键任务，我们会集中资源优先完成，确保项目的核心功能能够正常运行。例如，在竞赛中，我们优先完成了核心功能的硬件和软件设计，然后再逐步完善其他辅助功能。</li></ul><h3 id="3-团队协作"><a href="#3-团队协作" class="headerlink" title="3. 团队协作"></a><strong>3. 团队协作</strong></h3><ul><li><strong>信任与支持</strong>：在整个竞赛过程中，团队成员之间建立了深厚的信任。每个成员都清楚自己的职责，同时也愿意在需要时为其他成员提供支持。这种信任和团队精神是我们能够在4天3夜内完成任务并获得优异成绩的关键。</li><li><strong>共同目标</strong>：我们始终牢记竞赛的最终目标，即在规定时间内完成高质量的作品。这种共同的目标意识激励着我们每个人在面对困难时保持积极态度，共同努力克服挑战。</li></ul><h1 id="14-觉得自己在团队中是担任一个什么角色（分派任务-执行任务-监督管理）"><a href="#14-觉得自己在团队中是担任一个什么角色（分派任务-执行任务-监督管理）" class="headerlink" title="14.觉得自己在团队中是担任一个什么角色（分派任务 执行任务 监督管理）"></a>14.觉得自己在团队中是担任一个什么角色（分派任务 执行任务 监督管理）</h1><p>在团队中，我通常会根据项目的具体需求和团队成员的专长来灵活调整自己的角色。不过，总体来说，我更倾向于担任一个“协调者”和“执行者”的角色。</p><h3 id="1-协调者角色"><a href="#1-协调者角色" class="headerlink" title="1. 协调者角色"></a><strong>1. 协调者角色</strong></h3><ul><li><strong>任务分配与沟通</strong>：在项目初期，我会积极参与任务的分配和计划的制定。我会根据每个成员的技能和兴趣，合理分配任务，确保每个人都能发挥自己的优势。同时，我会负责团队内部的沟通协调，确保信息的透明和流畅。</li><li><strong>解决冲突</strong>：在团队合作过程中，难免会出现意见分歧。我会主动倾听各方观点，帮助团队达成共识，确保项目顺利推进。</li><li><strong>进度跟踪</strong>：我会定期检查项目的进度，及时发现潜在的问题，并调整计划以确保项目按时完成。例如，在电子设计竞赛中，我负责每天总结团队的进展，并根据实际情况灵活调整任务分配。</li></ul><h3 id="2-执行者角色"><a href="#2-执行者角色" class="headerlink" title="2. 执行者角色"></a><strong>2. 执行者角色</strong></h3><ul><li><strong>高效执行</strong>：除了协调工作外，我也会积极参与具体的任务执行。我会确保自己负责的任务高质量完成，同时也会主动协助其他成员解决技术难题。</li><li><strong>技术专长</strong>：在技术方面，我具备扎实的编程和硬件设计能力，能够独立完成复杂的任务。例如，在智能家居项目中，我负责了核心硬件的开发和调试工作，确保了系统的稳定运行。</li><li><strong>质量把控</strong>：在执行任务时，我会严格把控质量，确保每个环节都符合项目要求。我会主动进行测试和验证，确保交付的成果无误。</li></ul><h1 id="15-入职时间以及入职时长"><a href="#15-入职时间以及入职时长" class="headerlink" title="15.入职时间以及入职时长"></a>15.入职时间以及入职时长</h1><h1 id="16-对家庭-发展-城市-岗位-行业-职位-薪酬进行排序"><a href="#16-对家庭-发展-城市-岗位-行业-职位-薪酬进行排序" class="headerlink" title="16.对家庭&#x2F;发展&#x2F;城市&#x2F;岗位&#x2F;行业&#x2F;职位&#x2F;薪酬进行排序"></a>16.对家庭&#x2F;发展&#x2F;城市&#x2F;岗位&#x2F;行业&#x2F;职位&#x2F;薪酬进行排序</h1><ol><li><strong>家庭</strong><ul><li><strong>理由</strong>：家庭是生活的基础，是我在工作中保持动力和平衡的重要支撑。无论工作多忙，家庭的幸福和健康始终是最重要的。</li></ul></li><li><strong>发展</strong><ul><li><strong>理由</strong>：职业发展是我选择工作的重要考量。我希望在一个能够提供成长机会和职业晋升空间的环境中工作，这样我不仅能实现个人价值，也能为家庭带来更好的生活保障。</li></ul></li><li><strong>行业</strong><ul><li><strong>理由</strong>：选择一个有前景的行业对于长期职业发展至关重要。嵌入式软件行业目前正处于快速发展阶段，技术更新换代快，市场需求大，这为我提供了广阔的发展空间。</li></ul></li><li><strong>岗位</strong><ul><li><strong>理由</strong>：岗位的具体职责和工作内容直接影响到我的工作满意度和职业成就感。我希望在一个能够充分发挥自己专业技能和兴趣的岗位上工作，这样可以提高工作效率和质量。</li></ul></li><li><strong>城市</strong><ul><li><strong>理由</strong>：城市的选择也非常重要，它不仅影响生活质量，还会影响职业机会。我更倾向于选择一个经济发展良好、生活成本合理、文化氛围浓厚的城市，这样可以更好地平衡工作和生活。</li></ul></li><li><strong>职位</strong><ul><li><strong>理由</strong>：职位的高低虽然重要，但并不是我最看重的因素。我更关注职位是否能够让我在团队中发挥重要作用，是否能够为我提供学习和成长的机会。</li></ul></li><li><strong>薪酬</strong><ul><li><strong>理由</strong>：薪酬是工作的重要组成部分，但它并不是我选择工作的首要因素。合理的薪酬可以保障生活质量，但职业发展和个人成长对我来说更为重要。我相信，随着职业的发展，薪酬自然会得到提升。</li></ul></li></ol><h1 id="17-你觉得你自己是一个什么样的人"><a href="#17-你觉得你自己是一个什么样的人" class="headerlink" title="17.你觉得你自己是一个什么样的人"></a>17.你觉得你自己是一个什么样的人</h1><p>我是一个有责任心、学习能力强且注重团队合作的人。 细心且有耐心  积极主动</p><h1 id="18-家庭情况，家庭成员…"><a href="#18-家庭情况，家庭成员…" class="headerlink" title="18.家庭情况，家庭成员…"></a>18.家庭情况，家庭成员…</h1><p>我的家庭非常温馨和支持我。我来自一个普通的家庭，父母都非常重视教育，他们一直鼓励我追求自己的梦想，并在学业和职业上给予我很大的支持。我有一个弟弟。我的家庭氛围很融洽，这让我能够在一个充满爱和支持的环境中成长，也培养了我积极向上的人生态度和责任感。</p><h1 id="19-职业规划以及生活规划（生活规划暂时还没考虑那么远）"><a href="#19-职业规划以及生活规划（生活规划暂时还没考虑那么远）" class="headerlink" title="19.职业规划以及生活规划（生活规划暂时还没考虑那么远）"></a>19.职业规划以及生活规划（生活规划暂时还没考虑那么远）</h1><p>在未来1-3年的短期职业规划中，我期望能够顺利入职贵公司并快速适应工作环境，熟悉公司的业务流程和技术栈。在入职的第一年，我计划通过参与实际项目，重点提升自己在嵌入式软件开发方面的技能，尤其是在Linux驱动开发和硬件调试领域。接下来的1-2年里，我希望能够参与更多具有挑战性的项目，积累丰富的项目经验，提升自己在团队中的贡献度，并进一步深化对嵌入式系统的理解和掌握。</p><p>目前，我的生活规划还没有考虑得特别长远，但总体上，我希望能够在工作和生活之间找到一个良好的平衡。我计划在工作稳定后，逐步实现一些个人的生活目标</p><h1 id="20-了解公司在哪里吗"><a href="#20-了解公司在哪里吗" class="headerlink" title="20.了解公司在哪里吗"></a>20.了解公司在哪里吗</h1><p>广东省东莞市东莞市；江苏省无锡市市辖区；江西省南昌市；上海市市辖区；陕西省西安市</p><h1 id="21-一个月可以接受加班时间"><a href="#21-一个月可以接受加班时间" class="headerlink" title="21.一个月可以接受加班时间"></a>21.一个月可以接受加班时间</h1><p>50个小时？ 只要给加班费就好了</p><h1 id="22-怎么看待加班"><a href="#22-怎么看待加班" class="headerlink" title="22.怎么看待加班"></a>22.怎么看待加班</h1><p>我认为工作和生活的平衡非常重要，但我也理解在某些情况下，项目可能需要额外的时间投入。如果项目确实需要，我愿意在必要时加班以确保任务的完成。然而，我也相信通过高效的管理和合理的工作安排，可以在正常工作时间内完成大部分任务，从而减少不必要的加班。如果每月需要加班50小时，我会尽力配合，但同时也会与团队和管理层沟通，寻找更高效的工作方式，以确保长期的工作效率和团队的可持续发展。</p><h1 id="23-自己进入公司有什么优势（答了活力和效益）"><a href="#23-自己进入公司有什么优势（答了活力和效益）" class="headerlink" title="23.自己进入公司有什么优势（答了活力和效益）"></a>23.自己进入公司有什么优势（答了活力和效益）</h1><p><strong>首先，我充满活力和热情</strong>。我对嵌入式系统开发和物联网技术充满兴趣，这种热情让我始终保持积极主动的工作态度。我相信这种活力能够为团队带来新的想法和动力，推动项目的顺利进行。</p><p><strong>其次，我注重效益和效率</strong>。我深知在快节奏的科技行业，时间和资源都非常宝贵。因此，我始终致力于通过优化代码、合理规划项目进度以及高效解决问题，提升工作效率和项目质量。我相信这种对效益的关注能够为公司创造更大的价值。</p><p><strong>此外，我还具备扎实的技术基础和快速学习能力</strong>。我在嵌入式Linux开发、驱动程序编写以及硬件调试方面积累了丰富的经验，并且能够迅速掌握新的技术和工具。这使我能够快速适应公司的技术栈和业务需求，为团队贡献实际力量。</p><p><strong>最后，我具备良好的团队合作精神和沟通能力</strong>。我深知团队合作的重要性，能够与团队成员有效协作，共同解决问题。同时，我也能够清晰地表达自己的想法和建议，确保信息的高效传递。</p><h1 id="1-为什么选择读目前的专业"><a href="#1-为什么选择读目前的专业" class="headerlink" title="1.为什么选择读目前的专业"></a>1.为什么选择读目前的专业</h1><p>我选择电子信息工程专业，主要是基于以下几个原因：</p><ol><li><strong>个人兴趣</strong>：<br>我从小就对电子设备和技术充满了浓厚的兴趣。喜欢拆解和组装各种电子设备，对电路、芯片和编程有着天生的好奇心。这种兴趣促使我选择了电子信息工程专业，希望能够系统地学习相关知识。</li><li><strong>职业前景</strong>：<br>电子信息工程是一个快速发展的领域，涵盖了嵌入式系统、物联网、通信技术等多个热门方向。我看到了这个专业的广阔职业前景，尤其是在嵌入式软件开发方面，市场需求非常大。我希望通过学习这个专业，能够在未来的职业生涯中找到一个有挑战性和发展前景的工作。</li><li><strong>实践与创新</strong>：<br>电子信息工程专业注重实践和创新，课程设置中包含了大量的实验和项目。这让我有机会将理论知识应用到实际项目中，培养了我的动手能力和解决问题的能力。例如，在大学期间，我参与了多个项目，如基于AI技术的智能语音台灯和Linux智能家居系统，这些项目不仅锻炼了我的技术能力，也让我对专业有了更深入的理解。</li><li><strong>技术基础</strong>：<br>这个专业为我提供了坚实的理论基础和技术技能，包括C语言编程、单片机原理、嵌入式系统设计等。这些知识和技能为我未来的职业发展打下了坚实的基础，使我能够更好地适应快速变化的技术环境。</li></ol><h1 id="2-为什么想做嵌入式的工作"><a href="#2-为什么想做嵌入式的工作" class="headerlink" title="2.为什么想做嵌入式的工作"></a>2.为什么想做嵌入式的工作</h1><ol><li><strong>个人兴趣</strong>：<br>我对电子设备和底层硬件的交互非常感兴趣。从小就喜欢拆解和组装各种电子设备，对电路、芯片和编程有着浓厚的兴趣。嵌入式开发让我能够将这些兴趣结合起来，直接与硬件设备进行交互，实现各种功能。</li><li><strong>职业规划</strong>：<br>我希望在技术领域深耕，成为一名专业的嵌入式软件工程师。嵌入式系统在现代科技中无处不在，从智能家居到工业自动化，从医疗设备到汽车电子，嵌入式技术的应用非常广泛。我希望通过从事嵌入式工作，积累丰富的项目经验，提升自己的技术能力，为未来的职业发展打下坚实的基础。</li><li><strong>行业前景</strong>：<br>嵌入式行业目前正处于快速发展阶段，随着物联网、人工智能和5G技术的普及，嵌入式系统的需求不断增加。这为嵌入式工程师提供了广阔的职业发展空间和丰富的就业机会。我相信在这个领域工作，能够接触到最新的技术和创新项目，保持职业的竞争力。</li><li><strong>专业背景</strong>：<br>我在大学期间系统地学习了电子信息工程专业，掌握了C语言编程、单片机原理、嵌入式系统设计等核心课程。通过参与多个项目，如基于AI技术的智能语音台灯和Linux智能家居系统，我积累了丰富的实践经验，这些都让我对嵌入式开发有了更深入的理解和兴趣。</li><li><strong>技术挑战</strong>：<br>嵌入式开发涉及到硬件和软件的紧密结合，需要解决各种技术难题，如硬件资源管理、实时性要求、低功耗设计等。这些挑战让我感到兴奋，也让我有机会不断提升自己的技术水平和解决问题的能力。</li></ol><h1 id="3-怎么找到兴趣的"><a href="#3-怎么找到兴趣的" class="headerlink" title="3.怎么找到兴趣的"></a>3.怎么找到兴趣的</h1><ol><li><strong>尝试不同的活动</strong>：<br>在高中和大学期间，我尝试了各种不同的活动，包括参加电子制作社团、编程比赛、机器人竞赛等。这些活动让我接触到了不同的领域，逐渐发现自己对电子技术和编程的浓厚兴趣。</li><li><strong>参与项目实践</strong>：<br>在大学期间，我积极参与了多个项目，比如基于AI技术的智能语音台灯和Linux智能家居系统。通过这些项目，我不仅学到了很多专业知识，还发现自己在解决实际问题时的成就感，这进一步激发了我对嵌入式开发的兴趣。</li><li><strong>深入学习</strong>：<br>我通过阅读专业书籍、参加在线课程和学习最新的技术文章，不断深入了解嵌入式领域的知识。在这个过程中，我发现自己对硬件和软件的结合、系统优化等方面特别感兴趣。</li><li><strong>与他人交流</strong>：<br>我经常与同学、老师和行业专家交流，分享彼此的经验和见解。这些交流不仅拓宽了我的视野，还帮助我更清晰地认识到自己的兴趣所在。例如，在参加技术研讨会和行业论坛时，我了解到嵌入式技术在智能家居、工业自动化等领域的广泛应用，这让我更加坚定了自己的兴趣方向。</li><li><strong>反思和调整</strong>：<br>在探索兴趣的过程中，我不断反思自己的经历，思考哪些活动让我感到兴奋和满足，哪些活动则让我感到无聊或疲惫。通过这种反思，我逐渐明确了自己真正感兴趣的领域，并调整了自己的学习和实践方向。</li></ol><h1 id="4-如果在本专业没有找到兴趣那你会怎么做"><a href="#4-如果在本专业没有找到兴趣那你会怎么做" class="headerlink" title="4.如果在本专业没有找到兴趣那你会怎么做"></a>4.如果在本专业没有找到兴趣那你会怎么做</h1><ol><li><strong>深入自我反思</strong>：<br>首先，我会花时间深入反思自己的兴趣和优势所在。通过与导师、职业规划师的交流，以及进行职业兴趣测试，更全面地了解自己的兴趣点和适合的方向。</li><li><strong>探索相关领域</strong>：<br>如果在本专业没有找到兴趣，我会尝试探索与本专业相关的其他领域。例如，电子信息工程与计算机科学、自动化、人工智能等领域有很多交叉点。通过选修相关课程或参与跨学科项目，可能会发现新的兴趣点。</li><li><strong>实践与尝试</strong>：<br>我会积极参与实习和项目实践，尝试不同的工作内容和角色。通过实际工作经验，了解不同领域的工作性质和要求，找到自己真正感兴趣的方向。</li><li><strong>继续教育</strong>：<br>如果发现本专业与我的兴趣不符，我可能会考虑继续深造，攻读相关领域的研究生学位。这不仅可以拓宽我的知识面，还能为未来的职业发展提供更多选择。</li><li><strong>职业规划与调整</strong>：<br>最重要的是，我会根据自己的兴趣和市场需求，制定灵活的职业规划。如果发现某个领域更适合自己，我会毫不犹豫地调整职业方向，确保自己的工作能够带来成就感和满足感。</li></ol><h1 id="5-怎么定义兴趣-喜欢"><a href="#5-怎么定义兴趣-喜欢" class="headerlink" title="5.怎么定义兴趣&#x2F;喜欢"></a>5.怎么定义兴趣&#x2F;喜欢</h1><ol><li><strong>内在的兴奋感</strong>：<br>当我对某件事情感兴趣时，我会感到一种内在的兴奋和愉悦。这种感觉会让我主动去了解更多的相关信息，并且在思考和讨论这些内容时感到快乐。</li><li><strong>主动投入时间</strong>：<br>兴趣会让我愿意主动投入时间和精力去学习和实践。例如，如果我对某个技术感兴趣，我会在课余时间阅读相关书籍、参加在线课程，甚至自己动手做一些小项目来加深理解。</li><li><strong>持续的动力</strong>：<br>兴趣会给我带来持续的动力，即使遇到困难和挑战，我也会坚持下去。这种动力让我在面对复杂问题时不会轻易放弃，而是会努力寻找解决方案。</li><li><strong>积极的反馈</strong>：<br>当我对某件事情感兴趣时，我通常会收到积极的反馈。这种反馈可能来自自己的成就感，也可能来自他人的认可。例如，在参与项目时，如果我对某个模块特别感兴趣，我通常能够更高效地完成任务，并且得到团队成员的认可。</li><li><strong>长期的追求</strong>：<br>兴趣不仅仅是一时的喜好，而是一种长期的追求。它会让我在一段时间内持续关注某个领域，并且愿意不断学习和进步。例如，我对嵌入式开发的兴趣让我在大学期间参与了多个相关项目，并且在毕业后仍然希望在这个领域继续发展。</li></ol><h1 id="6-为什么不去别的公司"><a href="#6-为什么不去别的公司" class="headerlink" title="6.为什么不去别的公司"></a>6.为什么不去别的公司</h1><ol><li><strong>公司的行业地位和影响力</strong>：<br>贵公司在嵌入式系统和物联网领域具有很高的行业地位和广泛的影响力。我非常钦佩公司在技术创新和产品开发方面的成就，特别是在智能家居、智能安防等领域的应用。我希望能够在这样一个行业领先的企业中工作，学习先进的技术和管理经验。</li><li><strong>公司文化和价值观</strong>：<br>我了解到贵公司非常注重团队合作、创新和员工发展。这种积极向上的公司文化与我的个人价值观非常契合。我相信在这样的环境中，我能够更好地发挥自己的能力，同时也能够不断成长和进步。</li><li><strong>职业发展机会</strong>：<br>贵公司为员工提供了丰富的职业发展机会，包括内部培训、项目实践和晋升通道。我看到了自己在贵公司未来的职业发展路径，这让我非常期待能够加入贵公司，实现自己的职业目标。</li><li><strong>项目和团队</strong>：<br>在了解贵公司的项目和团队时，我被团队的专业能力和项目的创新性所吸引。例如，贵公司在智能家居系统开发方面的项目，不仅技术先进，而且具有很强的市场竞争力。我希望能够加入这样的团队，贡献自己的力量，并与团队成员共同成长。</li><li><strong>个人兴趣和职业规划</strong>：<br>我对嵌入式开发和物联网技术有着浓厚的兴趣，而贵公司在这些领域有着深厚的技术积累和丰富的项目经验。我相信在贵公司工作，能够让我更好地实现自己的职业规划，同时也能够为公司的项目贡献自己的专业知识和技能。</li></ol><h1 id="7-家庭情况如何"><a href="#7-家庭情况如何" class="headerlink" title="7.家庭情况如何"></a>7.家庭情况如何</h1><p>我的家庭非常温馨和支持我。我来自一个普通的家庭，父母都非常重视教育，他们一直鼓励我追求自己的梦想，并在学业和职业上给予我很大的支持。我有一个弟弟。我的家庭氛围很融洽，这让我能够在一个充满爱和支持的环境中成长，也培养了我积极向上的人生态度和责任感。</p><h1 id="10-什么时候可以入职"><a href="#10-什么时候可以入职" class="headerlink" title="10.什么时候可以入职"></a>10.什么时候可以入职</h1><p>非常感谢您对我的认可！如果顺利通过面试，我可以在**[具体日期]**入职。目前我已经完成了手头的所有事务，没有任何其他工作安排，可以全身心投入到新的工作中。我非常期待能够尽快加入贵公司，开始新的职业旅程。</p><h1 id="11-你的学校是985还是211（双非仔落泪了）"><a href="#11-你的学校是985还是211（双非仔落泪了）" class="headerlink" title="11.你的学校是985还是211（双非仔落泪了）"></a>11.你的学校是985还是211（双非仔落泪了）</h1><p>我的学校是西北民族大学，它是一所非常注重实践和创新的高校。虽然它不是985或211院校，但我在这里接受了系统的专业教育，并且通过参与多个项目和竞赛，积累了丰富的实践经验。例如，我曾独立完成基于AI技术的智能语音台灯项目，并在Linux智能家居系统项目中负责驱动开发和应用开发。这些经历不仅锻炼了我的技术能力，也培养了我的团队合作和解决问题的能力。我相信，这些经验和能力能够让我在贵公司的工作中发挥重要作用。</p><h1 id="12-期望薪资"><a href="#12-期望薪资" class="headerlink" title="12.期望薪资"></a>12.期望薪资</h1><p>我对薪资的期望是根据市场行情和我的专业背景来设定的。根据我目前的了解，嵌入式软件工程师的市场薪资范围在**[具体范围]<strong>。考虑到我的专业技能、项目经验以及对贵公司的热情，我期望的薪资范围是</strong>1w-1w2**。当然，我也理解薪资会根据公司的具体情况和市场变化有所调整，我愿意与公司进行进一步的沟通和协商。</p><h1 id="平时项目怎么分配任务"><a href="#平时项目怎么分配任务" class="headerlink" title="平时项目怎么分配任务"></a>平时项目怎么分配任务</h1><h3 id="1-沟通方式-1"><a href="#1-沟通方式-1" class="headerlink" title="1. 沟通方式"></a><strong>1. 沟通方式</strong></h3><ul><li><strong>明确分工</strong>：在竞赛开始前，我们团队根据每个人的专长和兴趣，明确了各自的分工。例如，我主要负责硬件设计和调试，另一位队员负责软件编程，还有一位队员负责撰写文档和测试。明确分工后，我们通过定期的团队会议来同步进度和解决问题。</li><li><strong>实时沟通</strong>：在整个竞赛过程中，我们保持实时沟通。遇到技术难题或进度延误时，我们会立即召开小组讨论，共同寻找解决方案。我们还通过微信群和项目管理工具（如Trello）来记录任务进展和关键问题，确保每个成员都能随时了解项目状态。</li><li><strong>面对面交流</strong>：尽管有线上工具，但我们更倾向于面对面交流。在竞赛期间，我们每天都会安排固定的时间进行面对面的讨论，这不仅提高了沟通效率，还增强了团队凝聚力。</li></ul><h3 id="2-任务安排-1"><a href="#2-任务安排-1" class="headerlink" title="2. 任务安排"></a><strong>2. 任务安排</strong></h3><ul><li><strong>制定详细计划</strong>：在竞赛开始前，我们制定了详细的项目计划，将整个竞赛过程分解为多个小任务，并为每个任务分配了明确的时间节点。例如，第一天完成需求分析和初步设计，第二天进行硬件搭建和软件框架搭建，第三天进行系统集成和调试，最后一天进行测试和文档撰写。</li><li><strong>灵活调整</strong>：尽管我们制定了详细的计划，但在实际操作中，难免会遇到意外情况。我们团队非常注重灵活性，一旦发现某个任务的进度滞后，我们会立即重新分配任务，确保整体进度不受影响。例如，在硬件调试阶段，我们发现一个问题需要额外的时间来解决，于是软件团队提前介入，帮助进行部分测试工作，确保整体进度不受影响。</li><li><strong>优先级管理</strong>：在任务安排中，我们特别注重优先级管理。对于关键任务，我们会集中资源优先完成，确保项目的核心功能能够正常运行。例如，在竞赛中，我们优先完成了核心功能的硬件和软件设计，然后再逐步完善其他辅助功能。</li></ul><h3 id="3-团队协作-1"><a href="#3-团队协作-1" class="headerlink" title="3. 团队协作"></a><strong>3. 团队协作</strong></h3><ul><li><strong>信任与支持</strong>：在整个竞赛过程中，团队成员之间建立了深厚的信任。每个成员都清楚自己的职责，同时也愿意在需要时为其他成员提供支持。这种信任和团队精神是我们能够在4天3夜内完成任务并获得优异成绩的关键。</li><li><strong>共同目标</strong>：我们始终牢记竞赛的最终目标，即在规定时间内完成高质量的作品。这种共同的目标意识激励着我们每个人在面对困难时保持积极态度，共同努力克服挑战。</li></ul><h1 id="为什么投华勤"><a href="#为什么投华勤" class="headerlink" title="为什么投华勤"></a>为什么投华勤</h1><h3 id="1-行业地位与业务布局"><a href="#1-行业地位与业务布局" class="headerlink" title="1. 行业地位与业务布局"></a>1. <strong>行业地位与业务布局</strong></h3><p>华勤技术是全球知名的智能硬件ODM（原始设计制造商）企业，连续多年在全球智能手机ODM&#x2F;IDH厂商中市占率名列前茅。其“3+N+3”战略（手机、笔电、服务器 + N个新兴场景 + 3大技术中台）正在加速落地，业务涵盖智能终端、高性能计算、汽车电子、AIoT等多个领域，显示出强大的市场竞争力和多元化的业务布局。</p><h3 id="2-技术创新与研发实力"><a href="#2-技术创新与研发实力" class="headerlink" title="2. 技术创新与研发实力"></a>2. <strong>技术创新与研发实力</strong></h3><p>华勤技术在技术研发方面投入巨大，建立了多个研发中心，汇聚了全球顶尖技术人才。公司在5G、AI、物联网等前沿技术领域取得了显著成果，例如在AI笔电、服务器等产品上实现了技术创新。此外，华勤还通过并购豪成智能科技有限公司，快速切入机器人市场，并启动人形机器人研发，展现了强大的技术储备和前瞻性布局。</p><h3 id="3-市场前景与增长潜力"><a href="#3-市场前景与增长潜力" class="headerlink" title="3. 市场前景与增长潜力"></a>3. <strong>市场前景与增长潜力</strong></h3><p>华勤技术2024年实现营收首破千亿大关，同比增长28.76%。随着AI技术的发展，华勤在AI服务器、智能座舱及机器人业务等新兴领域的持续放量，有望进一步推动公司增长。公司还通过“China + VMI”全球化制造布局和垂直整合增强供应链韧性，进一步提升市场竞争力。</p><h3 id="4-职业发展与个人成长"><a href="#4-职业发展与个人成长" class="headerlink" title="4. 职业发展与个人成长"></a>4. <strong>职业发展与个人成长</strong></h3><p>华勤技术作为行业内的龙头企业，提供了广阔的职业发展空间和丰富的学习机会。加入华勤，不仅能接触到前沿的技术和项目，还能与全球顶尖的技术人才合作，提升个人的技术水平和职业素养。</p><h1 id="加班怎么看"><a href="#加班怎么看" class="headerlink" title="加班怎么看"></a>加班怎么看</h1><p>我理解加班是工作中不可避免的一部分，尤其是在项目紧急或任务繁重时。我认为，加班本身并不是目的，而是为了确保项目能够按时交付、质量达标的一种手段。如果加班能够帮助团队完成重要任务，我会毫不犹豫地参与其中。</p><p>不过，我也相信通过合理的时间管理和高效的工作方式，可以在一定程度上减少不必要的加班。例如，提前规划工作流程、优化任务分配、提高工作效率等，都能帮助我们在正常工作时间内完成更多任务。</p><p>总的来说，我愿意在必要时加班，但同时也会努力提高工作效率，尽量减少加班的频率，以保持良好的工作与生活平衡。</p><p>首先是想通过自己的努力获得丰厚回报，能力中等偏上，但是又距离大神还有差距，抗压能力强，想在大城市稳住脚跟。</p><p>关于加班，华勤这几年顶着这么大的行业压力依然杀到了<a href="https://zhida.zhihu.com/search?content_id=343157993&content_type=Answer&match_order=1&q=ODM&zhida_source=entity">ODM</a>的榜首，绝对不是随随便便能实现的。强度也分部门，<a href="https://zhida.zhihu.com/search?content_id=343157993&content_type=Answer&match_order=1&q=%E5%B8%82%E5%9C%BA&zhida_source=entity">市场</a>和<a href="https://zhida.zhihu.com/search?content_id=343157993&content_type=Answer&match_order=1&q=%E7%A0%94%E5%8F%91&zhida_source=entity">研发</a>应该是强度最大的，当然也是公司地位决定的。真到了<a href="https://zhida.zhihu.com/search?content_id=343157993&content_type=Answer&match_order=1&q=%E9%A1%B9%E7%9B%AEdl&zhida_source=entity">项目dl</a>，该上得上啊，不过日常项目不急，也是正常上下班。</p><h1 id="对公司的了解"><a href="#对公司的了解" class="headerlink" title="对公司的了解"></a>对公司的了解</h1><p><strong>公司背景：</strong> 华勤技术股份有限公司（简称“华勤”）是一家全球领先的智能硬件平台型企业，成立于2005年，总部位于中国上海。华勤专注于智能硬件产品的研发设计、生产制造和运营服务，业务覆盖智能手机、平板电脑、笔记本电脑、智能穿戴设备、AIoT设备等多个领域。</p><p><strong>行业地位：</strong> 华勤在全球智能硬件ODM（原始设计制造商）市场中占据重要地位，连续多年在全球智能手机ODM&#x2F;IDH厂商中市占率名列前茅。根据市场研究机构的数据，华勤在2024年实现营收首破千亿大关，同比增长28.76%，显示出强大的市场竞争力和增长潜力。</p><p><strong>业务布局：</strong> 华勤的业务布局广泛，涵盖了“3+N+3”战略，即：</p><ul><li><strong>3大核心业务</strong>：智能手机、笔记本电脑、服务器。</li><li><strong>N个新兴场景</strong>：如智能穿戴、智能汽车、智能家居等。</li><li><strong>3大技术中台</strong>：包括研发、供应链和制造技术中台，为业务发展提供坚实的技术支持。</li></ul><p><strong>技术创新：</strong> 华勤在技术创新方面投入巨大，建立了多个研发中心，汇聚了全球顶尖的技术人才。公司在5G、AI、物联网等前沿技术领域取得了显著成果。例如，华勤在AI笔电、服务器等产品上实现了技术创新，并通过并购豪成智能科技有限公司，快速切入机器人市场，启动人形机器人研发，展现了强大的技术储备和前瞻性布局。</p><p><strong>全球化布局：</strong> 华勤在全球范围内建立了广泛的制造和运营网络，通过“China + VMI”全球化制造布局和垂直整合增强供应链韧性，进一步提升市场竞争力。公司在多个国家和地区设有研发中心和生产基地，能够快速响应全球客户的需求。</p><p><strong>企业文化：</strong> 华勤注重企业文化建设，倡导“客户至上、奋斗为本、创新为魂、合作共赢”的价值观。公司为员工提供了广阔的职业发展空间和丰富的学习机会，致力于打造一个充满活力和创新精神的工作环境。</p><h1 id="同时拥有几个offer怎么选择"><a href="#同时拥有几个offer怎么选择" class="headerlink" title="同时拥有几个offer怎么选择"></a>同时拥有几个offer怎么选择</h1><ol><li><strong>职业发展与个人兴趣</strong>：<ul><li>我会首先考虑每个Offer的职位内容和发展机会，确保工作内容符合我的职业兴趣和长期规划。例如，如果某个职位能够让我接触到前沿技术，或者为我提供清晰的职业晋升路径，这会是一个重要的加分项。</li></ul></li><li><strong>公司背景与行业地位</strong>：<ul><li>我会研究每家公司的背景，包括行业地位、市场前景和企业文化。选择一个在行业内有良好声誉和稳定发展的公司，可以为我的职业发展提供更坚实的基础。</li></ul></li><li><strong>薪资与福利</strong>：<ul><li>虽然薪资不是唯一考虑因素，但它确实很重要。我会比较每个Offer的薪资水平、奖金结构以及福利待遇，如健康保险、退休金计划、带薪休假等。</li></ul></li><li><strong>工作环境与文化</strong>：<ul><li>公司的工作环境和文化对我的工作满意度和幸福感有很大影响。我会尽量了解每家公司的文化，包括团队合作方式、工作氛围和领导风格。如果可能，我会参观公司，与未来的同事和领导交流，以更好地感受公司的工作环境。</li></ul></li><li><strong>个人因素</strong>：<ul><li>我也会考虑一些个人因素，比如工作地点是否方便，是否需要搬家或长途通勤。此外，工作与生活的平衡也很重要，我会选择一个能够支持我实现工作与生活平衡的公司。</li></ul></li><li><strong>长期目标</strong>：<ul><li>最后，我会考虑每个Offer如何与我的长期职业目标相契合。选择一个能够帮助我实现长期目标的公司，对我来说是最重要的。</li></ul></li></ol><h3 id="面试官可能的追问及回答"><a href="#面试官可能的追问及回答" class="headerlink" title="面试官可能的追问及回答"></a>面试官可能的追问及回答</h3><h4 id="追问-1：你最看重的因素是什么？"><a href="#追问-1：你最看重的因素是什么？" class="headerlink" title="追问 1：你最看重的因素是什么？"></a>追问 1：你最看重的因素是什么？</h4><p><strong>回答：</strong> 我最看重的是职业发展机会和个人兴趣。我认为，如果工作内容是我感兴趣的，并且能够为我提供成长和晋升的机会，我会更有动力和热情。当然，薪资和福利也很重要，但它们更多是锦上添花，而不是决定性因素。</p><h4 id="追问-2：如果两个Offer在职业发展方面都很有吸引力，你会怎么选择？"><a href="#追问-2：如果两个Offer在职业发展方面都很有吸引力，你会怎么选择？" class="headerlink" title="追问 2：如果两个Offer在职业发展方面都很有吸引力，你会怎么选择？"></a>追问 2：如果两个Offer在职业发展方面都很有吸引力，你会怎么选择？</h4><p><strong>回答：</strong> 如果两个Offer在职业发展方面都很有吸引力，我会进一步比较公司的文化和工作环境。我会选择一个让我感到舒适、能够与团队成员和领导良好合作的公司。此外，我也会考虑工作与生活的平衡，因为这对我个人的幸福感和长期职业发展同样重要。</p><h4 id="追问-3：你有没有遇到过类似的情况？你是怎么做的？"><a href="#追问-3：你有没有遇到过类似的情况？你是怎么做的？" class="headerlink" title="追问 3：你有没有遇到过类似的情况？你是怎么做的？"></a>追问 3：你有没有遇到过类似的情况？你是怎么做的？</h4><p><strong>回答：</strong> 是的，我曾经遇到过类似的情况。当时，我收到了两个Offer，一个来自一家大型公司，薪资较高但工作压力大；另一个来自一家初创公司，薪资略低但工作环境灵活，有更多学习和成长的机会。经过仔细考虑，我选择了初创公司，因为它的文化和工作环境更符合我的价值观，而且我能感受到公司对员工的重视和支持。事实证明，这个选择让我在工作中感到更加充实和满足。</p><h1 id="找工作的侧重点"><a href="#找工作的侧重点" class="headerlink" title="找工作的侧重点"></a>找工作的侧重点</h1><p>我在找工作时最注重的是职业发展机会和学习成长的空间。我希望加入一个能够提供清晰职业晋升路径的公司，同时也能让我接触到前沿技术和行业动态。例如，如果公司有完善的培训体系和导师制度，这将是一个很大的加分项。我相信，通过不断学习和提升自己的技能，我能够更好地实现个人职业目标，同时也为公司创造更大的价值。</p><h1 id="3-场景题，一个项目需要4天完成，现在需要你2天完成，你会怎么做"><a href="#3-场景题，一个项目需要4天完成，现在需要你2天完成，你会怎么做" class="headerlink" title="3 场景题，一个项目需要4天完成，现在需要你2天完成，你会怎么做"></a>3 场景题，一个项目需要4天完成，现在需要你2天完成，你会怎么做</h1><ol><li><strong>紧急评估与任务分解</strong>：<ul><li><strong>评估任务</strong>：首先，我会对项目的整体任务进行快速评估，了解每个任务的优先级和所需时间。这有助于我确定哪些任务是关键路径上的任务，哪些任务可以并行处理。</li><li><strong>任务分解</strong>：将项目分解为更小的子任务，并列出每个子任务的详细步骤和所需时间。这有助于我更清晰地了解任务的复杂性和优先级。</li></ul></li><li><strong>优先级排序与资源分配</strong>：<ul><li><strong>优先级排序</strong>：根据任务的重要性和紧急性，对子任务进行优先级排序。将关键任务放在优先位置，确保这些任务能够按时完成。</li><li><strong>资源分配</strong>：评估我是否有足够的资源来完成任务。如果需要，我会请求额外的资源支持，例如团队成员的帮助或工具支持。</li></ul></li><li><strong>优化工作流程</strong>：<ul><li><strong>提高效率</strong>：寻找可以优化的工作流程，例如通过自动化工具减少重复性工作，或者通过更高效的方法来完成任务。</li><li><strong>减少不必要的工作</strong>：检查是否有可以省略或简化的任务，确保只专注于核心任务。</li></ul></li><li><strong>沟通与协调</strong>：<ul><li><strong>与团队沟通</strong>：如果项目需要团队合作，我会立即与团队成员沟通，明确每个人的职责和任务，确保团队成员能够高效协作。</li><li><strong>与上级沟通</strong>：及时向上级汇报项目进度和可能遇到的问题，确保他们了解情况并能够提供必要的支持。</li></ul></li><li><strong>时间管理与监控</strong>：<ul><li><strong>制定详细计划</strong>：根据任务分解和优先级排序，制定一个详细的两天工作计划，明确每个任务的开始和结束时间。</li><li><strong>监控进度</strong>：在执行过程中，持续监控任务进度，确保每个任务都能按时完成。如果发现某个任务可能会延迟，我会立即调整计划，寻找解决方案。</li></ul></li><li><strong>应对突发问题</strong>：<ul><li><strong>预留缓冲时间</strong>：在计划中预留一定的缓冲时间，以应对可能出现的突发问题或意外情况。</li><li><strong>灵活调整</strong>：如果遇到突发问题，我会迅速评估影响并调整计划，确保项目整体进度不受太大影响。</li></ul></li><li><strong>质量保证</strong>：<ul><li><strong>确保质量</strong>：尽管时间紧迫，但我会确保每个任务的质量符合要求。在必要时，我会进行快速测试和验证，确保交付的成果是可靠的。</li><li><strong>持续改进</strong>：在项目完成后，我会总结经验教训，找出可以改进的地方，以便在未来的项目中更好地应对类似情况。</li></ul></li></ol><h1 id="4-场景题，接3，接到项目，你会最先考虑什么？如果项目中，有一个团队成员摆烂，不想加班，不想做项目，你会怎么做？"><a href="#4-场景题，接3，接到项目，你会最先考虑什么？如果项目中，有一个团队成员摆烂，不想加班，不想做项目，你会怎么做？" class="headerlink" title="4 场景题，接3，接到项目，你会最先考虑什么？如果项目中，有一个团队成员摆烂，不想加班，不想做项目，你会怎么做？"></a>4 场景题，接3，接到项目，你会最先考虑什么？如果项目中，有一个团队成员摆烂，不想加班，不想做项目，你会怎么做？</h1><h4 id="接到项目，你会最先考虑什么？"><a href="#接到项目，你会最先考虑什么？" class="headerlink" title="接到项目，你会最先考虑什么？"></a>接到项目，你会最先考虑什么？</h4><p><strong>回答：</strong> 接到项目后，我会首先进行以下几件事情：</p><ol><li><strong>项目目标与需求分析</strong>：<ul><li><strong>明确目标</strong>：我会与项目负责人或客户沟通，确保我完全理解项目的目标、期望的成果以及交付的时间节点。</li><li><strong>需求分析</strong>：详细分析项目需求，了解项目的具体要求和关键点，确保没有遗漏任何重要细节。</li></ul></li><li><strong>任务分解与优先级排序</strong>：<ul><li><strong>任务分解</strong>：将项目分解为更小的子任务，列出每个子任务的具体步骤和所需时间。这有助于我更清晰地了解项目的复杂性和工作量。</li><li><strong>优先级排序</strong>：根据任务的重要性和紧急性，对子任务进行优先级排序，确保关键任务能够优先处理。</li></ul></li><li><strong>资源评估与分配</strong>：<ul><li><strong>评估资源</strong>：评估完成项目所需的资源，包括人力、工具、技术等。如果发现资源不足，我会及时提出解决方案，例如请求额外的资源支持或调整项目范围。</li><li><strong>分配任务</strong>：根据团队成员的能力和时间安排，合理分配任务，确保每个成员都能承担合适的任务。</li></ul></li><li><strong>制定详细计划</strong>：<ul><li><strong>时间规划</strong>：制定一个详细的项目计划，明确每个任务的开始和结束时间，确保项目能够按时完成。</li><li><strong>监控机制</strong>：建立项目监控机制，定期检查项目进度，及时发现和解决问题。</li></ul></li><li><strong>沟通与协调</strong>：<ul><li><strong>团队沟通</strong>：与团队成员进行沟通，确保每个人都清楚自己的职责和任务，了解项目的目标和重要性。</li><li><strong>客户沟通</strong>：与客户保持密切沟通，及时汇报项目进展，确保客户对项目进展感到满意。</li></ul></li></ol><h3 id="问题-2：如果项目中有一个团队成员摆烂，不想加班，不想做项目，你会怎么做？"><a href="#问题-2：如果项目中有一个团队成员摆烂，不想加班，不想做项目，你会怎么做？" class="headerlink" title="问题 2：如果项目中有一个团队成员摆烂，不想加班，不想做项目，你会怎么做？"></a>问题 2：如果项目中有一个团队成员摆烂，不想加班，不想做项目，你会怎么做？</h3><p><strong>回答：</strong> 如果项目中有一个团队成员摆烂，不想加班，也不想积极参与项目，我会采取以下步骤来解决问题：</p><ol><li><p><strong>私下沟通</strong>：</p><ul><li><strong>了解原因</strong>：首先，我会私下与该团队成员进行沟通，了解他&#x2F;她不愿意参与项目的原因。可能是因为个人问题、工作压力过大、对项目不感兴趣或其他原因。</li><li><strong>表达关心</strong>：表达我对他的关心和理解，让他&#x2F;她感受到团队的支持和关心。</li></ul></li><li><p><strong>明确期望</strong>：</p><ul><li><strong>重申项目重要性</strong>：向该团队成员重申项目的重要性和紧迫性，让他&#x2F;她明白项目对团队和公司的重要性。</li><li><strong>明确职责</strong>：明确他&#x2F;她在项目中的职责和任务，确保他&#x2F;她清楚自己的工作内容和期望。</li></ul></li><li><p><strong>提供支持</strong>：</p><ul><li><strong>帮助解决问题</strong>：如果他&#x2F;她遇到困难或问题，我会提供必要的支持和帮助，例如调整任务难度、提供培训或资源支持。</li><li><strong>激励措施</strong>：如果可能，我会提出一些激励措施，例如额外的奖励或认可，以提高他&#x2F;她的积极性。</li></ul></li><li><p><strong>调整任务分配</strong>：</p><ul><li><strong>重新分配任务</strong>：如果该团队成员确实无法在短时间内完成任务，我会考虑重新分配任务，将一些任务分配给其他团队成员，确保项目能够按时完成。</li><li><strong>优化工作流程</strong>：优化工作流程，减少不必要的工作量，确保每个任务都能高效完成。</li></ul></li><li><p><strong>持续监控与反馈</strong>：</p><ul><li><strong>定期检查</strong>：定期检查该团队成员的工作进展，及时发现问题并提供反馈。</li><li><strong>正面激励</strong>：对于他&#x2F;她的积极表现，及时给予正面激励，增强他&#x2F;她的自信心和积极性。</li></ul></li><li><p><strong>向上级汇报</strong>：</p><ul><li><strong>及时沟通</strong>：如果问题无法解决，我会及时向上级汇报情况，寻求更多的支持和建议。</li><li><strong>制定解决方案</strong>：与上级共同制定解决方案，确保项目能够顺利进行。</li></ul><h3 id="面试官可能的追问及回答-1"><a href="#面试官可能的追问及回答-1" class="headerlink" title="面试官可能的追问及回答"></a>面试官可能的追问及回答</h3><h4 id="追问-1：如果团队成员摆烂的原因是个人问题，你会怎么做？"><a href="#追问-1：如果团队成员摆烂的原因是个人问题，你会怎么做？" class="headerlink" title="追问 1：如果团队成员摆烂的原因是个人问题，你会怎么做？"></a>追问 1：如果团队成员摆烂的原因是个人问题，你会怎么做？</h4><p><strong>回答：</strong> 如果团队成员摆烂的原因是个人问题，我会采取以下措施：</p><ul><li><strong>表达关心</strong>：首先，我会表达我对他的关心和理解，让他感受到团队的支持和关心。</li><li><strong>提供帮助</strong>：询问他是否需要帮助，例如调整工作时间、提供心理支持等。如果问题严重，我会建议他寻求专业的帮助。</li><li><strong>灵活调整</strong>：根据他的情况，灵活调整任务分配，确保项目能够顺利进行，同时不影响他的个人问题解决。</li><li><strong>持续关注</strong>：持续关注他的情况，定期与他沟通，确保他能够尽快恢复状态。</li></ul></li></ol><h1 id="5-问了家庭基本情况，是否愿意接受加班，能否在无锡定居？"><a href="#5-问了家庭基本情况，是否愿意接受加班，能否在无锡定居？" class="headerlink" title="5 问了家庭基本情况，是否愿意接受加班，能否在无锡定居？"></a>5 问了家庭基本情况，是否愿意接受加班，能否在无锡定居？</h1><h3 id="1-家庭基本情况"><a href="#1-家庭基本情况" class="headerlink" title="1. 家庭基本情况"></a>1. <strong>家庭基本情况</strong></h3><p><strong>回答：</strong> 我的家庭非常支持我的职业发展。我的父母和伴侣都非常理解我的工作性质，知道有时候工作可能会比较忙碌。他们总是鼓励我追求自己的职业目标，并且愿意在需要的时候给予我支持。我的家庭环境很和谐，这让我能够全身心地投入到工作中。</p><h3 id="2-是否愿意接受加班"><a href="#2-是否愿意接受加班" class="headerlink" title="2. 是否愿意接受加班"></a>2. <strong>是否愿意接受加班</strong></h3><p><strong>回答：</strong> 我理解加班是工作中不可避免的一部分，尤其是在项目紧急或任务繁重时。我认为加班本身并不是目的，而是为了确保项目能够按时交付、质量达标的一种手段。如果加班能够帮助团队完成重要任务，我会毫不犹豫地参与其中。</p><p>不过，我也相信通过合理的时间管理和高效的工作方式，可以在一定程度上减少不必要的加班。例如，提前规划工作流程、优化任务分配、提高工作效率等，都能帮助我们在正常工作时间内完成更多任务。</p><p>总的来说，我愿意在必要时加班，但同时也会努力提高工作效率，尽量减少加班的频率，以保持良好的工作与生活平衡。</p><h3 id="3-能否在无锡定居"><a href="#3-能否在无锡定居" class="headerlink" title="3. 能否在无锡定居"></a>3. <strong>能否在无锡定居</strong></h3><p><strong>回答：</strong> 我非常愿意在无锡定居。无锡是一个充满活力和发展机会的城市，我很看好这里的职业前景和生活环境。我已经开始了解无锡的住房市场，并且正在考虑合适的居住地点。我相信，通过努力工作和合理规划，我能够在无锡建立一个稳定的生活和职业基础。</p><h1 id="理想中工作的样子"><a href="#理想中工作的样子" class="headerlink" title="理想中工作的样子"></a>理想中工作的样子</h1><p>我希望工作内容能激发我的热情，让我专注于自己感兴趣的领域，比如嵌入式系统开发，同时有机会接触前沿技术，保持多样化任务，避免重复枯燥。在职业发展上，公司能提供清晰的晋升路径、丰富的培训资源和导师指导，让我能参与重要项目，实现自我价值。</p><p>工作环境舒适，配备先进设备，注重员工健康，这是基础保障。团队合作方面，我期待与优秀、有责任心的同事共事，大家相互支持、沟通顺畅，公司倡导合作文化，领导信任员工，给予自主空间。</p><p>工作与生活平衡也很重要，合理的工作时间、灵活的工作安排、完善的假期福利，能让我保持身心健康。公司文化要积极向上，鼓励创新，对失败宽容，同时注重社会责任，内部信息透明，决策公平公正。</p><p>薪酬待遇要合理，有绩效奖金和年终奖，最好还有股权激励，让我能分享公司成长。最重要的是，我的工作要有意义，能得到认可和奖励，让我感受到自己的价值。</p><h1 id="自己的优缺点"><a href="#自己的优缺点" class="headerlink" title="自己的优缺点"></a>自己的优缺点</h1><h3 id="我的优点"><a href="#我的优点" class="headerlink" title="我的优点"></a><strong>我的优点</strong></h3><ul><li><strong>学习能力强</strong>：能够快速掌握新技术和知识。例如，我曾自学并成功移植了一个新的嵌入式驱动程序。</li><li><strong>责任心强</strong>：对工作认真负责，确保任务高质量完成。曾加班加点解决项目中的技术难题，确保按时交付。</li><li><strong>团队合作好</strong>：善于与不同背景的同事沟通协作，乐于分享经验，共同推动项目进展。</li><li><strong>问题解决能力强</strong>：面对困难时，能冷静分析并迅速找到解决方案，多次成功解决开发中的复杂问题。</li></ul><h3 id="我的缺点"><a href="#我的缺点" class="headerlink" title="我的缺点"></a><strong>我的缺点</strong></h3><ul><li><strong>追求完美</strong>：有时会因过度追求完美而花费过多时间优化细节，影响项目进度。我正在学习在质量与效率之间找到平衡。</li><li><strong>沟通不够主动</strong>：在团队讨论中，我有时不够主动表达自己的想法，更倾向于先倾听他人意见。我正在努力提升自己的沟通主动性。</li><li><strong>时间管理能力有待提高</strong>：有时会因专注于某项任务而忽略其他任务的进度，正在通过使用时间管理工具来改进。</li></ul><h1 id="抗压能力"><a href="#抗压能力" class="headerlink" title="抗压能力"></a>抗压能力</h1><h3 id="我的抗压能力"><a href="#我的抗压能力" class="headerlink" title="我的抗压能力"></a><strong>我的抗压能力</strong></h3><ul><li><p><strong>能够承受压力</strong>：我能够很好地应对工作中的压力，保持冷静和专注。例如，在之前的一个紧急项目中，我们面临紧迫的交付期限和复杂的技术挑战，但我通过合理安排时间和高效解决问题，成功按时完成了任务。</p></li><li><p><strong>善于调整心态</strong>：面对压力时，我会积极调整心态，将压力转化为动力，保持乐观和积极的态度。</p></li><li><p><strong>有效的时间管理</strong>：我会通过合理规划任务和优先级，确保在压力下也能高效完成工作。</p></li><li></li></ul><p>13.有对华勤有了解吗？<br>    华勤是一家规模很大的上市公司。主要接受品牌方的委托，生产，研发，设计笔记本、手机等。有点狼性文化。<br>14.对于加班怎么看？<br>    如果给的多，我爱加班。<br>15.期望毕业的薪资<br>    12k&#x2F;月<br>反问<br>    1.实习生待遇<br>        大概本科160元&#x2F;天，硕士200元&#x2F;天，具体开会讨论过后，会有人事联系你。</p><p><img src="/./../../images/image-20250603204902571.png" alt="image-20250603204902571"></p><p>二面（综合）</p><p>自我介绍，询问了项目的一些基本问题（项目负责哪部分，遇到什么问题，怎么解决的）。就业选择公司看重哪些点？如果别人给你批评建议你会如何对待？平常玩游戏吗（玩cs）？你觉得怎么才能赢得游戏（团队协作）？本科期间c语言考试多少分？c++掌握程度怎么样，如何学习的？你觉得c和c++有什么区别？你的职业规划有哪些？堆和栈有什么区别？你觉得自己有什么优缺点？平常有什么爱好？</p><p>面试官人很好，特别温和的一种感觉，然后说是做平板开发（安卓开发，说是比较难，也还是C语言的）</p><p>问家庭情况，问是否愿意去无锡</p><p>华勤一面就是八股，进线程，驱动问的多，会问到uboot和系统移植等相关问题，最后加一个简单的手撕代码，二面的话项目上深问一下</p><h1 id="反问："><a href="#反问：" class="headerlink" title="反问："></a>反问：</h1><h2 id="24-驱动开发主要针对哪些方面"><a href="#24-驱动开发主要针对哪些方面" class="headerlink" title="24.驱动开发主要针对哪些方面"></a>24.驱动开发主要针对哪些方面</h2><ol><li><strong>硬件设备的初始化和配置</strong>：<br>驱动程序负责初始化硬件设备，设置其工作模式和参数。例如，在我参与的智能家居项目中，我为DHT11温湿度传感器和SG90伺服电机控制器等外设编写了驱动程序，确保它们能够在系统启动时正确初始化并进入工作状态。</li><li><strong>硬件设备的通信接口</strong>：<br>驱动程序需要管理硬件设备的通信接口，如GPIO、I2C、SPI、UART等。这些接口用于设备之间的数据传输和控制信号传递。在Linux智能家居系统项目中，我成功移植并实现了这些接口的驱动程序，确保了硬件设备与系统之间的稳定通信。</li><li><strong>硬件设备的中断处理</strong>：<br>驱动程序需要处理硬件设备产生的中断信号。中断处理是确保设备能够及时响应外部事件的关键。例如，在智能家居系统中，我实现了高效的中断处理机制，确保设备能够实时响应用户的操作和环境变化。</li><li><strong>硬件设备的状态管理</strong>：<br>驱动程序需要监控和管理硬件设备的状态，包括设备的开启、关闭、故障检测等。在项目中，我通过设备树（Device Tree）配置和Pinctrl子系统，动态管理硬件设备的引脚功能，提高了系统的灵活性和可靠性。</li><li><strong>与操作系统的集成</strong>：<br>驱动程序需要与操作系统紧密集成，提供设备的抽象接口，使得应用程序能够通过标准的系统调用访问硬件设备。在Linux环境下，我熟悉设备树配置和内核模块的开发，能够确保驱动程序与Linux内核的无缝集成。</li><li><strong>性能优化</strong>：<br>驱动程序的性能直接影响到整个系统的响应速度和效率。在开发过程中，我通过代码优化和硬件资源的合理配置，确保驱动程序的高效运行。例如，在智能家居项目中，我优化了驱动程序的代码，减少了CPU的占用率，提高了系统的整体性能。</li></ol><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>驱动开发主要针对硬件设备的初始化、通信接口管理、中断处理、状态管理、与操作系统的集成以及性能优化。通过这些工作，驱动程序能够确保硬件设备在系统中的稳定运行，并为应用程序提供高效、可靠的访问接口。</p><h2 id="25-对我面试表现评价如何给出建议（要对基础知识进一步加深-因为我有几个答得不是很好）"><a href="#25-对我面试表现评价如何给出建议（要对基础知识进一步加深-因为我有几个答得不是很好）" class="headerlink" title="25.对我面试表现评价如何给出建议（要对基础知识进一步加深 因为我有几个答得不是很好）"></a>25.对我面试表现评价如何给出建议（要对基础知识进一步加深 因为我有几个答得不是很好）</h2><h2 id="26-公司加班一般时间是多久"><a href="#26-公司加班一般时间是多久" class="headerlink" title="26.公司加班一般时间是多久"></a>26.公司加班一般时间是多久</h2><h2 id="1-贵公司的培养机制"><a href="#1-贵公司的培养机制" class="headerlink" title="1.贵公司的培养机制"></a>1.贵公司的培养机制</h2><h2 id="反问：食宿补贴-应届生第一年免费住宿-明天15交通费-餐补"><a href="#反问：食宿补贴-应届生第一年免费住宿-明天15交通费-餐补" class="headerlink" title="反问：食宿补贴(应届生第一年免费住宿 明天15交通费+餐补)"></a>反问：食宿补贴(应届生第一年免费住宿 明天15交通费+餐补)</h2><h2 id="试用期时长及待遇-三个月-比正式少500"><a href="#试用期时长及待遇-三个月-比正式少500" class="headerlink" title="试用期时长及待遇(三个月 比正式少500)"></a>试用期时长及待遇(三个月 比正式少500)</h2><h2 id="2-对我的评价"><a href="#2-对我的评价" class="headerlink" title="2.对我的评价"></a>2.对我的评价</h2><h2 id="6-反问-面试结果反馈多久，华勤加班情况，跟我具体聊了华勤真实的加班情况"><a href="#6-反问-面试结果反馈多久，华勤加班情况，跟我具体聊了华勤真实的加班情况" class="headerlink" title="6 反问: 面试结果反馈多久，华勤加班情况，跟我具体聊了华勤真实的加班情况"></a>6 反问: 面试结果反馈多久，华勤加班情况，跟我具体聊了华勤真实的加班情况</h2><h1 id="实习生培养模式（说的有点长，忘了，反正就是说有人带）"><a href="#实习生培养模式（说的有点长，忘了，反正就是说有人带）" class="headerlink" title="实习生培养模式（说的有点长，忘了，反正就是说有人带）"></a>实习生培养模式（说的有点长，忘了，反正就是说有人带）</h1><h1 id="业务是什么（bios开发，他这边主要是固件一块）"><a href="#业务是什么（bios开发，他这边主要是固件一块）" class="headerlink" title="业务是什么（bios开发，他这边主要是固件一块）"></a>业务是什么（bios开发，他这边主要是固件一块）</h1>]]></content>
      
      
      <categories>
          
          <category> 面试准备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 华勤技术 </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> Linux驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算放大器（运放）原理</title>
      <link href="/2024/08/07/test/%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%EF%BC%88%E8%BF%90%E6%94%BE%EF%BC%89%E5%8E%9F%E7%90%86/"/>
      <url>/2024/08/07/test/%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8%EF%BC%88%E8%BF%90%E6%94%BE%EF%BC%89%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>面试官您好，我叫林言威，来自西北民族大学电子信息工程专业。非常感谢您给我这次面试的机会。</p><p>我对嵌入式开发充满热情，并在校期间积累了丰富的实践经验。我的主要项目经历包括主导开发一款基于AI的智能语音台灯。该项目基于STM32单片机（ARM Cortex-M系列内核），集成了光敏、温湿度、超声波等多种传感器，实现了自动调光、坐姿提醒、疲劳监测等多项智能功能，并支持语音交互和手机远程控制。在项目中，我<strong>自主设计了电路原理图和PCB板</strong>，熟练使用了嘉立创EDA等硬件开发工具，项目开发过程中，我深入掌握了STM32硬件设计、串口通信、PWM控制、电机控制、多任务开发等关键技术。</p><p>此外，我还参与了基于Linux的MQTT智能家居系统开发，使用IMX6ULL（ARM Cortex-A内核）开发板及Linux实时操作系统。项目中，我负责驱动移植、应用开发和QT图形界面设计，并实现了小程序远程控制功能。这一经历让我系统掌握了嵌入式Linux开发、驱动开发、MQTT协议移植和多进程&#x2F;多线程编程。</p><p>我的专业技能包括：</p><ul><li>熟悉电路原理图设计、PCB设计及电路仿真，掌握常用EDA工具；</li><li>熟悉STM32单片机应用开发，熟悉寄存器操作、GPIO、串口、IIC等接口及电机控制；</li><li>熟悉嵌入式Linux系统开发，具备驱动开发、QT界面开发和协议移植能力；</li><li>具备较强的软硬件协同开发和团队沟通能力。</li></ul><p>运放等常用电子元器件原理</p><h3 id="运算放大器（运放）原理"><a href="#运算放大器（运放）原理" class="headerlink" title="运算放大器（运放）原理"></a>运算放大器（运放）原理</h3><p><strong>运算放大器</strong>是一种高增益的电子元件，通常用于信号放大、滤波、比较等场合。其核心特点是：</p><ul><li><strong>高输入阻抗</strong>、<strong>低输出阻抗</strong>，可以有效隔离信号源和负载；</li><li>具有<strong>差分输入</strong>（两个输入端：同相输入+，反相输入-）和<strong>单端输出</strong>；</li><li>理想运放的两个输入端电压相等，输入电流为零。</li></ul><p><strong>常见应用</strong>：</p><ul><li>信号放大（如传感器信号调理）</li><li>滤波电路</li><li>电压跟随器</li><li>比较器</li><li>积分、微分等模拟计算</li></ul><hr><h3 id="其他常用电子元器件原理"><a href="#其他常用电子元器件原理" class="headerlink" title="其他常用电子元器件原理"></a>其他常用电子元器件原理</h3><ol><li><strong>电阻</strong><br>用于限制电流、分压、偏置等，遵循欧姆定律（V&#x3D;IR）。</li><li><strong>电容</strong><br>用于滤波、耦合、去耦、定时。储存和释放电荷，阻隔低频通过高频。</li><li><strong>电感</strong><br>常用于滤波、储能、振荡、变压，能阻碍交流变化。</li><li><strong>二极管</strong><br>单向导电，常用于整流、保护、信号调制等。</li><li><strong>三极管</strong><br>作为开关或放大器，利用小电流控制大电流。</li></ol><hr><h3 id="运放在实际项目中的应用举例"><a href="#运放在实际项目中的应用举例" class="headerlink" title="运放在实际项目中的应用举例"></a>运放在实际项目中的应用举例</h3><ul><li>在<strong>传感器信号采集</strong>中，弱小信号往往要用运放进行放大；</li><li>在<strong>电机控制</strong>中，运放可用于电流检测和反馈信号调理；</li><li>在<strong>ADC采样</strong>前，用运放构成缓冲器防止信号源受影响。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 电子技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运放 </tag>
            
            <tag> 电子元器件 </tag>
            
            <tag> 模拟电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux驱动学习笔记--11.Linux中断实验</title>
      <link href="/2024/08/07/test/liunx%E9%A9%B1%E5%8A%A8/Linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0--Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/"/>
      <url>/2024/08/07/test/liunx%E9%A9%B1%E5%8A%A8/Linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0--Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="正点原子-Linux驱动学习笔记–11-Linux中断实验"><a href="#正点原子-Linux驱动学习笔记–11-Linux中断实验" class="headerlink" title="[正点原子]Linux驱动学习笔记–11.Linux中断实验"></a>[正点原子]Linux驱动学习笔记–11.Linux中断实验</h1><h1 id="1-Cortex-A7中断系统详解"><a href="#1-Cortex-A7中断系统详解" class="headerlink" title="1. Cortex-A7中断系统详解"></a>1. Cortex-A7中断系统详解</h1><h2 id="1-1-Cortex-A7中断系统简介"><a href="#1-1-Cortex-A7中断系统简介" class="headerlink" title="1.1 Cortex-A7中断系统简介"></a>1.1 Cortex-A7中断系统简介</h2><p>跟 STM32 一样， Cortex-A7 也有中断向量表，中断向量表也是在代码的最前面。 CortexA7 内核有 8 个异常中断，这 8 个异常中断的中断向量表如下所示：</p><p><img src="/2024/08/07/test/liunx%E9%A9%B1%E5%8A%A8/Linux%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0--Linux%E4%B8%AD%E6%96%AD%E5%AE%9E%E9%AA%8C/n" alt="image51dbe76ff1870146.png"></p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vi学习</title>
      <link href="/2024/08/06/test/2024-08-06-vi%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/08/06/test/2024-08-06-vi%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2024/08/06/test/2024-08-06-vi%E5%AD%A6%E4%B9%A0/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20240906200054194.png" alt="image-20240906200054194"></p><p>a  光标后一位插入  A 行尾插入</p><p>i   光标原位置插入 I行首插入</p><p>o 光标下一行插入 O 光标上一行插入</p><p><img src="/2024/08/06/test/2024-08-06-vi%E5%AD%A6%E4%B9%A0/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20240906200102904.png" alt="image-20240906200102904"></p><p>nyy 复制 ndd删除  p光标下边复制 P光标下边复制 u撤回</p><p><img src="/2024/08/06/test/2024-08-06-vi%E5%AD%A6%E4%B9%A0/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20240906200109699.png" alt="image-20240906200109699"></p><p><img src="/2024/08/06/test/2024-08-06-vi%E5%AD%A6%E4%B9%A0/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20240906200754220.png" alt="image-20240906200754220"></p><p>​      k（上）</p><p>​h（左）     l（右）</p><p>​j（下）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一些liunx问题</title>
      <link href="/2024/08/06/test/Linux%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/2024/08/06/test/Linux%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="1-内核空间与用户空间的区别"><a href="#1-内核空间与用户空间的区别" class="headerlink" title="1. 内核空间与用户空间的区别"></a>1. 内核空间与用户空间的区别</h3><h4 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h4><ul><li><strong>定义</strong>：内核空间是操作系统的核心部分，直接管理硬件资源和系统资源。</li><li><strong>稳定性与安全性</strong>：内核代码需要高度的稳定性和安全性，不能依赖于用户空间的库。</li><li><strong>特权模式</strong>：内核代码运行在特权模式下，可以直接访问硬件资源和系统内存。</li><li><strong>开发原则</strong>：内核开发中尽量避免使用用户空间的库，以减少复杂性和潜在的稳定性问题。</li></ul><h4 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h4><ul><li><strong>定义</strong>：用户空间是应用程序运行的环境，通常依赖于各种标准库（如 glibc）来实现复杂的功能。</li><li><strong>非特权模式</strong>：用户空间代码运行在非特权模式下，需要通过系统调用与内核交互。</li></ul><hr><h3 id="2-Linux-驱动开发中的库使用"><a href="#2-Linux-驱动开发中的库使用" class="headerlink" title="2. Linux 驱动开发中的库使用"></a>2. Linux 驱动开发中的库使用</h3><h4 id="内核提供的-API"><a href="#内核提供的-API" class="headerlink" title="内核提供的 API"></a>内核提供的 API</h4><p>Linux 内核本身提供了一套丰富的 API，用于驱动开发。这些 API 包括：</p><ul><li><strong>内存管理</strong>：<code>kmalloc</code>、<code>kfree</code> 等函数用于动态内存分配和释放。</li><li><strong>文件操作</strong>：<code>file_operations</code> 结构体用于实现设备文件的读写操作。</li><li><strong>中断处理</strong>：<code>request_irq</code>、<code>free_irq</code> 等函数用于注册和释放中断。</li><li><strong>定时器</strong>：<code>timer_setup</code>、<code>del_timer</code> 等函数用于定时器的创建和删除。</li><li><strong>设备树</strong>：在嵌入式 Linux 开发中，设备树（Device Tree）用于描述硬件设备的配置信息。</li></ul><p>这些 API 是内核的一部分，专门用于驱动开发，因此驱动代码通常不需要额外的用户空间库。</p><h4 id="硬件抽象层（HAL）"><a href="#硬件抽象层（HAL）" class="headerlink" title="硬件抽象层（HAL）"></a>硬件抽象层（HAL）</h4><p>在某些情况下，硬件供应商会提供硬件抽象层（HAL）库，用于简化硬件访问。这些库通常是内核模块的一部分，而不是用户空间库。例如，NXP 的 i.MX 系列处理器提供了专门的 HAL 库，用于访问硬件寄存器和外设。</p><hr><h3 id="3-为什么看起来像是“不用库”"><a href="#3-为什么看起来像是“不用库”" class="headerlink" title="3. 为什么看起来像是“不用库”"></a>3. 为什么看起来像是“不用库”</h3><h4 id="直接硬件访问"><a href="#直接硬件访问" class="headerlink" title="直接硬件访问"></a>直接硬件访问</h4><ul><li>在驱动开发中，开发者需要直接与硬件交互，因此会直接操作硬件寄存器，而不是通过复杂的用户空间库。</li><li>例如，访问 GPIO、定时器、中断控制器等硬件资源时，通常会直接使用内核提供的 API 或硬件寄存器操作。</li></ul><h4 id="轻量级开发"><a href="#轻量级开发" class="headerlink" title="轻量级开发"></a>轻量级开发</h4><ul><li>驱动代码通常需要轻量级和高效，以减少对系统资源的占用。使用内核提供的 API 可以实现这一点，而不需要依赖于复杂的用户空间库。</li></ul><h4 id="稳定性和安全性"><a href="#稳定性和安全性" class="headerlink" title="稳定性和安全性"></a>稳定性和安全性</h4><ul><li>内核代码需要保持高度的稳定性和安全性，避免引入用户空间库可能带来的潜在问题（如内存泄漏、线程安全问题等）。</li></ul><hr><h3 id="4-特殊情况"><a href="#4-特殊情况" class="headerlink" title="4. 特殊情况"></a>4. 特殊情况</h3><h4 id="用户空间驱动"><a href="#用户空间驱动" class="headerlink" title="用户空间驱动"></a>用户空间驱动</h4><ul><li>在某些情况下，驱动程序可以运行在用户空间，而不是内核空间。这种情况下，驱动程序可以使用用户空间的库（如 glibc）。</li><li>例如，某些 USB 设备驱动或网络设备驱动可以运行在用户空间。</li></ul><h4 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h4><ul><li>在某些复杂的驱动开发场景中，可能会使用第三方库来实现特定功能。例如，某些图形驱动可能会使用 OpenGL 或 DirectFB 等库。</li></ul><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Linux 驱动开发并不是完全不使用库，而是尽量减少对用户空间库的依赖，转而使用内核提供的 API 和硬件抽象层。这种做法可以提高驱动代码的稳定性和效率，同时减少对系统资源的占用。在某些特殊情况下，驱动开发可能会使用用户空间库或第三方库，但这取决于具体的开发需求和应用场景。</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Makefile学习</title>
      <link href="/2024/08/06/test/Makefile/"/>
      <url>/2024/08/06/test/Makefile/</url>
      
        <content type="html"><![CDATA[<p>以下是一些推荐的学习Makefile的网站和资源，可以帮助你快速掌握Makefile的常用规则、结构和示例：</p><ol><li><strong>廖雪峰的官方网站</strong><br>廖雪峰的Makefile教程从基础概念讲起，通过简单易懂的例子逐步深入，非常适合作为入门学习。<br>网址：<a href="https://liaoxuefeng.com/books/makefile/makefile-basic/">Makefile基础 - Makefile教程 - 廖雪峰的官方网站</a></li><li><strong>腾讯云技术文档</strong><br>腾讯云上有一篇关于Makefile的详细解释和示例，涵盖了从基础到进阶的内容，包括如何编写Makefile以及一些高级用法。<br>网址：<a href="https://cloud.tencent.com/developer/article/1065286">超清晰的makefile解释、编写与示例 - 腾讯云</a></li><li>博客园 - Makefile语法总结<br>这篇文章总结了Makefile的常用语法和规则，并通过具体示例进行解析，适合有一定基础的读者深入学习。<br>网址：<a href="https://www.cnblogs.com/zxdplay/p/17782281.html">Makefile语法详细总结及示例解析（快速掌握）</a></li><li><strong>CSDN博客 - Makefile教程</strong><br>CSDN上有许多关于Makefile的教程和示例，其中一些文章提供了详细的规则和实际项目中的Makefile模板。<br>网址：<a href="https://blog.csdn.net/weixin_46097907/article/details/135816235">makefile常用的命令总结及简单示例 - CSDN博客</a></li><li><strong>GitHub Pages - Makefile教程</strong><br>这是一个开源的Makefile教程，提供了从入门到高级的详细内容，并且包含了许多实用的示例。<br>网址：<a href="https://gavinliu6.github.io/Makefile-Tutorial-zh-CN/">Makefile 教程 - GitHub Pages</a></li><li><strong>CSDN博客 - 通用Makefile模板</strong><br>这篇文章提供了一个通用的Makefile模板，适用于C++项目的编译和链接，是一个很好的参考。<br>网址：<a href="https://blog.csdn.net/wg_cheeky/article/details/108014390">makeFile基本介绍, 语法, 示例,通用makefile - CSDN博客</a></li></ol><h3 id="和我一起写Makefile-pdf"><a href="#和我一起写Makefile-pdf" class="headerlink" title="和我一起写Makefile.pdf"></a><a href="..........%5Ck210111%5Ck210%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%5C%E6%96%B0%E5%BB%BA%E6%96%87%E4%BB%B6%E5%A4%B9%5Cweibo%5C%E5%92%8C%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile.pdf">和我一起写Makefile.pdf</a></h3><p>makefile很重要</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  什么是makefile？或许很多Winodws的程序员都不知道这个东西，因为那些Windows的IDE都为你做了这个工作，但我觉得要作一个好的和professional的程序员，makefile还是要懂。这就好像现在有这么多的HTML的编辑器，但如果你想成为一个专业人士，你还是要了解HTML的标识的含义。特别在Unix下的软件编译，你就不能不自己写makefile了，会不会写makefile，从一个侧面说明了一个人是否具备完成大型工程的能力。因为，makefile关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。</span><br><span class="line"></span><br><span class="line">  现在讲述如何写makefile的文章比较少，这是我想写这篇文章的原因。当然，不同产商的make各不相同，也有不同的语法，但其本质都是在“文件依赖性”上做文章，这里，我仅对GNU的make进行讲述，我的环境是RedHat Linux 8.0，make的版本是3.80。必竟，这个make是应用最为广泛的，也是用得最多的。而且其还是最遵循于IEEE 1003.2-1992 标准的（POSIX.2）。</span><br><span class="line"></span><br><span class="line">在这篇文档中，将以C/C++的源码作为我们基础，所以必然涉及一些关于C/C++的编译的知识，相关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">target... : prerequisites ...</span><br><span class="line"></span><br><span class="line">    command</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    -------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">    target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。</span><br><span class="line"></span><br><span class="line">   prerequisites就是，要生成那个target所需要的文件或是目标。</span><br><span class="line"></span><br><span class="line">   command也就是make需要执行的命令。（任意的Shell命令）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是Makefile的规则。也就是Makefile中最核心的内容。</span><br><span class="line"></span><br><span class="line">   说到底，Makefile的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是Makefile的主线和核心，但要写好一个Makefile还不够，我会以后面一点一点地结合我的工作经验给你慢慢到来。内容还多着呢。：）</span><br><span class="line"></span><br><span class="line">  【注】：在看别人写的Makefile文件时，你可能会碰到以下三个变量：$@，$^，$&lt;代表的意义分别是： </span><br><span class="line"></span><br><span class="line">               他们三个是十分重要的三个变量，所代表的含义分别是：</span><br><span class="line"></span><br><span class="line">               $@--目标文件，$^--所有的依赖文件，$&lt;--第一个依赖文件。</span><br></pre></td></tr></table></figure><h3 id="Makefile-的基本概念"><a href="#Makefile-的基本概念" class="headerlink" title="Makefile 的基本概念"></a>Makefile 的基本概念</h3><ul><li><strong>定义</strong>：Makefile 是一个用于自动化编译和构建项目的文件，它描述了工程的编译、链接等规则，包括哪些源文件需要编译、如何编译、如何生成目标文件等。</li><li><strong>作用</strong>：通过编写 Makefile，可以使用 <code>make</code> 命令工具来自动化编译过程，避免手动输入繁琐的编译命令，提高开发效率。</li></ul><h3 id="Makefile-的基本结构"><a href="#Makefile-的基本结构" class="headerlink" title="Makefile 的基本结构"></a>Makefile 的基本结构</h3><ul><li><strong>变量定义</strong>：用于简化和统一文件名或命令的书写。例如：<ul><li><code>CC = gcc</code>：定义编译器为 gcc。</li><li><code>CFLAGS = -Wall -g</code>：定义编译选项，<code>-Wall</code> 显示所有警告，<code>-g</code> 启用调试信息。</li><li><code>TARGET = my_program</code>：定义目标文件名为 <code>my_program</code>。</li><li><code>OBJECTS = main.o utils.o</code>：定义目标文件列表。</li></ul></li><li><strong>规则定义</strong>：指定目标文件、依赖文件和生成目标文件的命令。基本格式如下：<ul><li><code>target: dependencies</code>：目标文件和依赖文件。</li><li><code>command</code>：生成目标文件的命令，必须以 Tab 键开始。</li></ul></li><li><strong>伪目标</strong>：用于执行一些特定的操作，如清理编译生成的文件。例如：<ul><li><code>.PHONY: clean</code>：声明 <code>clean</code> 是一个伪目标。</li><li><code>clean:</code>：定义清理操作的命令。</li></ul></li></ul><h3 id="Makefile-的基本语法"><a href="#Makefile-的基本语法" class="headerlink" title="Makefile 的基本语法"></a>Makefile 的基本语法</h3><ul><li><p><strong>目标和依赖</strong>：目标是要生成的文件，依赖是生成目标所需要的文件。基本格式如下：</p><ul><li><code>target: dependencies</code>：目标文件和依赖文件。</li><li><code>command</code>：生成目标文件的命令，必须以 Tab 键开始。</li></ul></li><li><p><strong>内置变量</strong>：Makefile 提供了一些内置变量，常用的包括：</p><ul><li><code>$@</code>：目标文件的名称。</li><li><code>$^</code>：所有依赖文件的名称。</li><li><code>$&lt;</code>：第一个依赖文件的名称。</li></ul><p>  <img src="/2024/08/06/test/Makefile/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20250423142456075.png" alt="image-20250423142456075"></p></li><li><p><strong>通配符</strong>：用于匹配文件名或文件路径中的多个字符，以便在规则中批量处理文件。常见的通配符有：</p><ul><li><code>*</code>：匹配零个或多个字符。</li><li><code>?</code>：匹配一个任意字符。</li><li><code>[...]</code>：匹配方括号内的任意一个字符。</li><li><code>[!...]</code>：匹配除了方括号内的字符之外的任意一个字符。</li></ul></li><li><p><strong>模式规则</strong>：用于定义一种模式，告诉 Make 工具如何将一类文件转换成另一类文件。例如：</p><ul><li><code>%.o: %.c</code>：表示所有以 <code>.c</code> 结尾的源文件都可以生成对应的 <code>.o</code> 目标文件。</li></ul></li><li><p><strong>自动化变量</strong>：在规则的命令中使用，代表了与规则相关联的文件名。常用的自动化变量包括：</p><ul><li><code>$@</code>：表示规则中的目标文件名。</li><li><code>$&lt;</code>：表示规则中的第一个依赖文件名。</li><li><code>$^</code>：表示规则中的所有依赖文件名，以空格分隔。</li></ul></li></ul><h3 id="Makefile-的实际应用"><a href="#Makefile-的实际应用" class="headerlink" title="Makefile 的实际应用"></a>Makefile 的实际应用</h3><ul><li><strong>简单示例</strong>：<ul><li>假设有一个简单的 C 项目，包含 <code>main.c</code> 和 <code>utils.c</code> 两个源文件 ，目标是生成可执行文件 <code>my_program</code>。Makefile 内容如下：<ul><li><pre><code class="makefile">CC = gccCFLAGS = -Wall -gTARGET = my_programOBJECTS = main.o utils.oall: $(TARGET)$(TARGET): $(OBJECTS)    $(CC) $(CFLAGS) -o $(TARGET) $(OBJECTS)main.o: main.c    $(CC) $(CFLAGS) -c main.cutils.o: utils.c    $(CC) $(CFLAGS) -c utils.c.PHONY: cleanclean:    rm -f $(TARGET) $(OBJECTS)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    - 在项目目录中执行 `make` 命令即可编译项目，执行 `make clean` 命令可以清理编译生成的文件。</span><br><span class="line">- **复杂项目**：</span><br><span class="line">    - 对于复杂的嵌入式 Linux 项目，可能包含多个源文件、头文件、汇编文件等，需要更复杂的 Makefile 来管理。例如：</span><br><span class="line">        - ```makefile</span><br><span class="line">          CROSS_COMPILE  ?= arm-linux-gnueabihf-</span><br><span class="line">          TARGET   ?= bsp</span><br><span class="line">          CC := $(CROSS_COMPILE)gcc</span><br><span class="line">          LD:= $(CROSS_COMPILE)ld</span><br><span class="line">          OBJCOPY := $(CROSS_COMPILE)objcopy</span><br><span class="line">          OBJDUMP := $(CROSS_COMPILE)objdump</span><br><span class="line">          INCDIRS := imx6ul \</span><br><span class="line">                             bsp/clk \</span><br><span class="line">                             bsp/led \</span><br><span class="line">                             bsp/delay</span><br><span class="line">          SRCDIRS:= project \</span><br><span class="line">                             bsp/clk \</span><br><span class="line">                             bsp/led \</span><br><span class="line">                             bsp/delay</span><br><span class="line">          INCLUDE:= $(patsubst %, -I %, $(INCDIRS))</span><br><span class="line">          SFILES:= $(foreach dir, $(SRCDIRS), $(wildcard $(dir)/*.S))</span><br><span class="line">          CFILES:= $(foreach dir, $(SRCDIRS), $(wildcard $(dir)/*.c))</span><br><span class="line">          SFILENDIR:= $(notdir  $(SFILES))</span><br><span class="line">          CFILENDIR:= $(notdir  $(CFILES))</span><br><span class="line">          SOBJS:= $(patsubst %, obj/%, $(SFILENDIR:.S=.o))</span><br><span class="line">          COBJS:= $(patsubst %, obj/%, $(CFILENDIR:.c=.o))</span><br><span class="line">          OBJS:= $(SOBJS) $(COBJS)</span><br><span class="line">          VPATH:= $(SRCDIRS)</span><br><span class="line">          .PHONY: clean</span><br><span class="line">          $(TARGET).bin : $(OBJS)</span><br><span class="line">              $(LD) -Timx6ul.lds -o $(TARGET).elf $^</span><br><span class="line">              $(OBJCOPY) -O binary -S $(TARGET).elf $@</span><br><span class="line">              $(OBJDUMP) -D -m arm $(TARGET).elf &gt; $(TARGET).dis</span><br><span class="line">          $(SOBJS) : obj/%.o : %.S</span><br><span class="line">              $(CC) -Wall -nostdlib -c -O2  $(INCLUDE) -o $@ $&lt;</span><br><span class="line">          $(COBJS) : obj/%.o : %.c</span><br><span class="line">              $(CC) -Wall -nostdlib -c -O2  $(INCLUDE) -o $@ $&lt;</span><br><span class="line">          clean:</span><br><span class="line">              rm -rf $(TARGET).elf $(TARGET).dis $(TARGET).bin $(COBJS) $(SOBJS)</span><br></pre></td></tr></table></figure></code></pre></li></ul></li><li>该 Makefile 使用了交叉编译工具链，支持多个源文件和汇编文件的编译，生成二进制可执行文件、ELF 格式文件和反汇编文件。</li></ul></li></ul><h3 id="Makefile-的调试"><a href="#Makefile-的调试" class="headerlink" title="Makefile 的调试"></a>Makefile 的调试</h3><ul><li><strong>查看 <code>make</code> 过程</strong>：使用 <code>make -n</code> 命令可以显示将会执行的命令，但不会实际执行。</li><li><strong>增加详细输出</strong>：使用 <code>make --debug</code> 命令可以提供详细的调试信息，帮助排查问题。</li></ul><h3 id="Makefile-的高级功能"><a href="#Makefile-的高级功能" class="headerlink" title="Makefile 的高级功能"></a>Makefile 的高级功能</h3><ul><li><p><strong>条件语句</strong>：可以根据不同的条件执行不同的规则或设置变量。常见的条件语句有 <code>ifeq</code>、<code>ifneq</code>、<code>ifdef</code>、<code>ifndef</code>。</p><ul><li>示例：根据操作系统设置不同的编译选项。<ul><li><pre><code class="makefile">CC = gccCFLAGS = -Wall -gifeq ($(OS),Windows_NT)    CFLAGS += -DWIN32else    CFLAGS += -DUNIXendifTARGET = my_programSRCS = main.c utils.call: $(TARGET)$(TARGET): $(SRCS)    $(CC) $(CFLAGS) -o $(TARGET) $(SRCS)clean:    rm -f $(TARGET)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">- **使用函数**：Makefile 提供了一些内建函数，帮助处理字符串和文件操作等任务。常用函数包括：</span><br><span class="line">    - `$(wildcard pattern)`：返回匹配模式的所有文件。</span><br><span class="line">    - `$(patsubst pattern,replacement,text)`：用指定的替换文本替换模式。</span><br><span class="line">    - `$(basename names)`：去除文件名的扩展名部分。</span><br><span class="line">    - `$(dir names)`：返回文件的目录路径。</span><br><span class="line">    - 示例：使用 `wildcard` 和 `patsubst`。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### **Makefile基础笔记**</span><br><span class="line"></span><br><span class="line">#### **1. Makefile概述**</span><br><span class="line">- **Makefile的作用**：</span><br><span class="line">  - 在Linux环境下，`make`命令会查找当前目录下的`Makefile`文件。</span><br><span class="line">  - 根据Makefile中定义的规则，`make`可以自动化地执行命令，例如编译源代码、生成目标文件等。</span><br><span class="line">  - Makefile的核心思想是通过定义规则来描述如何生成目标文件。</span><br><span class="line"></span><br><span class="line">- **基本逻辑示例**：</span><br><span class="line">  - 假设有文件`a.txt`、`b.txt`和`c.txt`，需要先合并`a.txt`和`b.txt`生成中间文件`m.txt`，再将`m.txt`与`c.txt`合并生成最终文件`x.txt`。</span><br><span class="line">  - Makefile通过规则定义这种依赖关系和生成过程。</span><br><span class="line"></span><br><span class="line">#### **2. Makefile规则的基本格式**</span><br><span class="line">- **规则格式**：</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>目标文件: 依赖文件1 依赖文件2 …<br>    命令1<br>    命令2<br>    …</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  - **目标文件**：需要生成的文件。</span><br><span class="line">  - **依赖文件**：生成目标文件所需的文件。</span><br><span class="line">  - **命令**：用于生成目标文件的具体命令，必须以Tab键开头。</span><br><span class="line"></span><br><span class="line">- **示例**：</span><br><span class="line">  </span><br><span class="line">  ```makefile</span><br><span class="line">  m.txt: a.txt b.txt</span><br><span class="line">      cat a.txt b.txt &gt; m.txt</span><br><span class="line">  </span><br><span class="line">  x.txt: m.txt c.txt</span><br><span class="line">      cat m.txt c.txt &gt; x.txt</span><br></pre></td></tr></table></figure><ul><li><code>m.txt</code>依赖于<code>a.txt</code>和<code>b.txt</code>，通过<code>cat</code>命令合并生成。</li><li><code>x.txt</code>依赖于<code>m.txt</code>和<code>c.txt</code>，同样通过<code>cat</code>命令生成。</li></ul></li></ul><h4 id="3-Makefile的执行逻辑"><a href="#3-Makefile的执行逻辑" class="headerlink" title="3. Makefile的执行逻辑"></a><strong>3. Makefile的执行逻辑</strong></h4><ul><li><p><strong>增量编译</strong>：</p><ul><li><code>make</code>会检查目标文件和依赖文件的修改时间。</li><li>如果目标文件的修改时间晚于所有依赖文件，则认为目标文件是最新的，不会重新生成。</li><li>如果依赖文件中的任何一个被修改，则会重新执行规则生成目标文件。</li></ul></li><li><p><strong>默认规则</strong>：</p><ul><li><code>make</code>默认执行Makefile中的第一条规则。</li><li>例如，如果要生成<code>x.txt</code>，<code>make</code>会先检查<code>m.txt</code>是否存在，如果不存在则先生成<code>m.txt</code>，然后再生成<code>x.txt</code>。</li></ul></li></ul><h4 id="4-伪目标（Phony-Target）"><a href="#4-伪目标（Phony-Target）" class="headerlink" title="4. 伪目标（Phony Target）"></a><strong>4. 伪目标（Phony Target）</strong></h4><ul><li><p><strong>定义</strong>：</p><ul><li>伪目标不是实际的文件名，而是用于执行特定任务的规则。</li><li>例如，<code>clean</code>规则通常用于删除生成的文件。</li></ul></li><li><p><strong>示例</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f m.txt x.txt</span><br></pre></td></tr></table></figure><ul><li>执行<code>make clean</code>会删除<code>m.txt</code>和<code>x.txt</code>。</li></ul></li><li><p><strong>避免冲突</strong>：</p><ul><li>如果存在名为<code>clean</code>的文件，<code>make clean</code>可能不会执行。</li><li>可以使用<code>.PHONY</code>声明伪目标：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f m.txt x.txt</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="5-执行多条命令"><a href="#5-执行多条命令" class="headerlink" title="5. 执行多条命令"></a><strong>5. 执行多条命令</strong></h4><ul><li><p><strong>独立命令</strong>：</p><ul><li>每条命令默认在独立的Shell环境中执行。</li><li>例如，<code>cd</code>命令不会影响后续命令的执行环境。</li></ul></li><li><p><strong>多条命令的写法</strong>：</p><ul><li>使用<code>;</code>分隔命令：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">    pwd; cd ..; pwd</span><br></pre></td></tr></table></figure></li><li>使用<code>\</code>换行：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">    pwd; \</span><br><span class="line">    cd ..; \</span><br><span class="line">    pwd</span><br></pre></td></tr></table></figure></li><li>使用<code>&amp;&amp;</code>确保命令顺序执行：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">cd_ok:</span></span><br><span class="line">    pwd &amp;&amp; cd .. &amp;&amp; pwd</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="6-控制命令输出"><a href="#6-控制命令输出" class="headerlink" title="6. 控制命令输出"></a><strong>6. 控制命令输出</strong></h4><ul><li><strong>隐藏命令输出</strong>：<ul><li>在命令前加<code>@</code>可以隐藏命令的打印输出，但命令仍然会执行。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">no_output:</span></span><br><span class="line">    @echo &#x27;not display&#x27;</span><br><span class="line">    echo &#x27;will display&#x27;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="7-错误处理"><a href="#7-错误处理" class="headerlink" title="7. 错误处理"></a><strong>7. 错误处理</strong></h4><ul><li><p><strong>默认行为</strong>：</p><ul><li>如果命令返回非0值，<code>make</code>会中断执行并报错。</li></ul></li><li><p><strong>忽略错误</strong>：</p><ul><li>在命令前加<code>-</code>可以忽略错误，继续执行后续命令。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ignore_error:</span></span><br><span class="line">    -rm zzz.txt</span><br><span class="line">    echo &#x27;ok&#x27;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h4><p>Makefile通过定义规则来自动化生成目标文件，核心在于描述目标文件与依赖文件之间的关系以及生成目标文件的具体命令。掌握以下要点：</p><ul><li>规则的基本格式：目标文件、依赖文件和命令。</li><li>增量编译的逻辑：基于文件的修改时间。</li><li>伪目标的使用：如<code>clean</code>。</li><li>多条命令的写法：使用<code>;</code>、<code>\</code>或<code>&amp;&amp;</code>。</li><li>控制命令输出：使用<code>@</code>。</li><li>错误处理：使用<code>-</code>忽略错误。</li></ul><hr><hr><h3 id="编译C程序-Makefile教程笔记"><a href="#编译C程序-Makefile教程笔记" class="headerlink" title="编译C程序 - Makefile教程笔记"></a><strong>编译C程序 - Makefile教程笔记</strong></h3><h4 id="1-C程序编译的基本步骤"><a href="#1-C程序编译的基本步骤" class="headerlink" title="1. C程序编译的基本步骤"></a><strong>1. C程序编译的基本步骤</strong></h4><p>编译C程序通常分为两步：</p><ol><li><strong>编译阶段</strong>：将每个<code>.c</code>文件编译为<code>.o</code>文件（目标文件）。</li><li><strong>链接阶段</strong>：将所有<code>.o</code>文件链接为最终的可执行文件。</li></ol><h4 id="2-示例项目结构"><a href="#2-示例项目结构" class="headerlink" title="2. 示例项目结构"></a><strong>2. 示例项目结构</strong></h4><p>假设一个简单的C项目，包含以下文件：</p><ul><li><code>hello.c</code>：定义了一个<code>hello</code>函数。</li><li><code>hello.h</code>：声明了<code>hello</code>函数。</li><li><code>main.c</code>：主程序，调用了<code>hello</code>函数。</li></ul><p><strong>文件内容</strong>：</p><ul><li>**<code>hello.c</code>**：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>**<code>hello.h</code>**：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li><li>**<code>main.c</code>**：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;hello.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start...\n&quot;</span>);</span><br><span class="line">    hello();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-Makefile编写"><a href="#3-Makefile编写" class="headerlink" title="3. Makefile编写"></a><strong>3. Makefile编写</strong></h4><p>根据上述项目结构，Makefile可以定义如下规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成可执行文件</span></span><br><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 hello.c</span></span><br><span class="line"><span class="section">hello.o: hello.c</span></span><br><span class="line">cc -c hello.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 main.c</span></span><br><span class="line"><span class="section">main.o: main.c hello.h</span></span><br><span class="line">cc -c main.c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理生成的文件</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -f *.o world.out</span><br></pre></td></tr></table></figure><h4 id="4-Makefile执行逻辑"><a href="#4-Makefile执行逻辑" class="headerlink" title="4. Makefile执行逻辑"></a><strong>4. Makefile执行逻辑</strong></h4><ul><li><p><strong>增量编译</strong>：</p><ul><li><code>make</code>会根据文件的修改时间来判断是否需要重新编译。</li><li>如果<code>hello.c</code>被修改，<code>make</code>会重新编译<code>hello.c</code>生成<code>hello.o</code>，并重新链接生成<code>world.out</code>。</li><li>如果<code>hello.h</code>被修改，<code>make</code>会重新编译所有依赖<code>hello.h</code>的文件（如<code>main.c</code>），并重新链接生成<code>world.out</code>。</li></ul></li><li><p><strong>执行过程</strong>：</p><ul><li>初始运行<code>make</code>时，会依次执行以下步骤：<ol><li>编译<code>hello.c</code>生成<code>hello.o</code>。</li><li>编译<code>main.c</code>生成<code>main.o</code>。</li><li>链接<code>hello.o</code>和<code>main.o</code>生成<code>world.out</code>。</li></ol></li><li>如果修改了<code>hello.c</code>，再次运行<code>make</code>时，只会重新编译<code>hello.c</code>并重新链接<code>world.out</code>。</li><li>如果修改了<code>hello.h</code>，<code>make</code>会重新编译<code>main.c</code>并重新链接<code>world.out</code>。</li></ul></li></ul><h4 id="5-清理规则"><a href="#5-清理规则" class="headerlink" title="5. 清理规则"></a><strong>5. 清理规则</strong></h4><ul><li><strong><code>clean</code>规则</strong>：<ul><li>用于删除所有生成的文件，包括<code>.o</code>文件和可执行文件。</li><li>执行命令：<code>make clean</code>。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.o world.out</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="6-规则优化"><a href="#6-规则优化" class="headerlink" title="6. 规则优化"></a><strong>6. 规则优化</strong></h4><p>随着项目规模的扩大，手动维护Makefile中的规则会变得繁琐。后续可以学习如何使用变量、模式规则等高级特性来简化Makefile的编写。</p><h4 id="7-小结"><a href="#7-小结" class="headerlink" title="7. 小结"></a><strong>7. 小结</strong></h4><ul><li><strong>Makefile的作用</strong>：通过定义规则，<code>make</code>可以自动化编译C程序。</li><li><strong>规则的基本格式</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标文件: 依赖文件</span><br><span class="line">    命令</span><br></pre></td></tr></table></figure></li><li><strong>增量编译</strong>：<code>make</code>根据文件的修改时间来决定是否重新编译。</li><li><strong>清理规则</strong>：使用<code>clean</code>规则删除生成的文件，方便重新编译。</li></ul><p>以下是根据廖雪峰的《使用隐式规则》教程整理的笔记，主要介绍了Makefile中隐式规则的概念、使用方法以及其潜在问题。</p><hr><h3 id="使用隐式规则-Makefile教程笔记"><a href="#使用隐式规则-Makefile教程笔记" class="headerlink" title="使用隐式规则 - Makefile教程笔记"></a><strong>使用隐式规则 - Makefile教程笔记</strong></h3><h4 id="1-隐式规则的概念"><a href="#1-隐式规则的概念" class="headerlink" title="1. 隐式规则的概念"></a><strong>1. 隐式规则的概念</strong></h4><ul><li><p><strong>隐式规则（Implicit Rule）</strong>：</p><ul><li>Makefile中的一种特殊规则，用于自动推导目标文件的生成规则。</li><li>当Makefile中没有明确定义某个目标文件的规则时，<code>make</code>会尝试使用内置的隐式规则来生成该目标文件。</li></ul></li><li><p><strong>内置规则的作用</strong>：</p><ul><li>为了简化Makefile的编写，<code>make</code>为常见的编译任务（如C、C++、ASM等）提供了默认的隐式规则。</li><li>例如，对于C程序，<code>make</code>会自动应用以下隐式规则：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xyz.o: xyz.c</span><br><span class="line">    cc -c -o xyz.o xyz.c</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="2-示例：隐式规则的应用"><a href="#2-示例：隐式规则的应用" class="headerlink" title="2. 示例：隐式规则的应用"></a><strong>2. 示例：隐式规则的应用</strong></h4><p>假设有一个C项目，包含<code>hello.c</code>、<code>main.c</code>和<code>hello.h</code>，目标是生成可执行文件<code>world.out</code>。</p><p><strong>项目结构</strong>：</p><ul><li><code>hello.c</code>：定义了一个<code>hello</code>函数。</li><li><code>hello.h</code>：声明了<code>hello</code>函数。</li><li><code>main.c</code>：主程序，调用了<code>hello</code>函数。</li></ul><p><strong>Makefile</strong>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只保留生成 world.out 的规则</span></span><br><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">    cc -o world.out hello.o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.o world.out</span><br></pre></td></tr></table></figure><p><strong>执行过程</strong>：</p><ul><li>执行<code>make</code>命令时，<code>make</code>会自动推导出<code>hello.o</code>和<code>main.o</code>的生成规则：<ul><li><code>hello.o</code>依赖于<code>hello.c</code>，使用<code>cc -c -o hello.o hello.c</code>生成。</li><li><code>main.o</code>依赖于<code>main.c</code>，使用<code>cc -c -o main.o main.c</code>生成。</li></ul></li><li>最后，<code>make</code>会链接<code>hello.o</code>和<code>main.o</code>生成<code>world.out</code>。</li></ul><p><strong>输出</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">cc    -c -o hello.o hello.c</span><br><span class="line">cc    -c -o main.o main.c</span><br><span class="line">cc -o world.out hello.o main.o</span><br></pre></td></tr></table></figure><h4 id="3-隐式规则的优势"><a href="#3-隐式规则的优势" class="headerlink" title="3. 隐式规则的优势"></a><strong>3. 隐式规则的优势</strong></h4><ul><li><strong>减少重复规则</strong>：<ul><li>隐式规则可以减少Makefile中大量重复的编译规则。</li><li>例如，对于多个<code>.c</code>文件，无需为每个文件单独编写<code>.o</code>文件的生成规则。</li></ul></li></ul><h4 id="4-隐式规则的潜在问题"><a href="#4-隐式规则的潜在问题" class="headerlink" title="4. 隐式规则的潜在问题"></a><strong>4. 隐式规则的潜在问题</strong></h4><ul><li><strong>无法跟踪头文件的修改</strong>：<ul><li>隐式规则的一个主要问题是无法自动跟踪头文件（如<code>.h</code>文件）的修改。</li><li>例如，如果修改了<code>hello.h</code>，隐式规则<code>main.o: main.c</code>不会自动检测到<code>hello.h</code>的修改，导致<code>main.c</code>不会被重新编译。</li><li>这可能导致生成的可执行文件中包含过时的代码。</li></ul></li></ul><h4 id="5-解决隐式规则的潜在问题"><a href="#5-解决隐式规则的潜在问题" class="headerlink" title="5. 解决隐式规则的潜在问题"></a><strong>5. 解决隐式规则的潜在问题</strong></h4><ul><li><p><strong>手动添加依赖</strong>：</p><ul><li>为了确保头文件的修改能够触发重新编译，需要手动在Makefile中添加头文件的依赖关系。</li><li>例如：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">main.o: main.c hello.h</span></span><br><span class="line">    cc -c main.c</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>自动生成依赖文件</strong>：</p><ul><li>在实际项目中，可以通过工具（如<code>gcc -M</code>）自动生成依赖文件，并将其包含在Makefile中。</li><li>例如，使用<code>gcc -M</code>生成依赖文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -M main.c &gt; main.d</span><br></pre></td></tr></table></figure></li><li>然后在Makefile中包含这些依赖文件：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-include</span> main.d</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="6-小结"><a href="#6-小结" class="headerlink" title="6. 小结"></a><strong>6. 小结</strong></h4><ul><li><strong>隐式规则的作用</strong>：减少重复的编译规则，简化Makefile的编写。</li><li><strong>隐式规则的潜在问题</strong>：无法自动跟踪头文件的修改，可能导致生成的可执行文件包含过时代码。</li><li><strong>解决方法</strong>：手动添加头文件依赖或使用工具自动生成依赖文件。</li></ul><hr><p>以下是根据廖雪峰的《使用变量》教程整理的笔记，主要介绍了Makefile中变量的使用方法、内置变量和自动变量的概念。</p><hr><h3 id="使用变量-Makefile教程笔记"><a href="#使用变量-Makefile教程笔记" class="headerlink" title="使用变量 - Makefile教程笔记"></a><strong>使用变量 - Makefile教程笔记</strong></h3><h4 id="1-变量的作用"><a href="#1-变量的作用" class="headerlink" title="1. 变量的作用"></a><strong>1. 变量的作用</strong></h4><ul><li><strong>解决重复问题</strong>：<ul><li>在Makefile中，文件名或命令可能会重复出现多次，手动修改容易出错。</li><li>使用变量可以简化Makefile的编写，提高可维护性。</li></ul></li></ul><h4 id="2-定义和使用变量"><a href="#2-定义和使用变量" class="headerlink" title="2. 定义和使用变量"></a><strong>2. 定义和使用变量</strong></h4><ul><li><p><strong>定义变量</strong>：</p><ul><li>使用<code>变量名 = 值</code>或<code>变量名 := 值</code>定义变量。</li><li>通常变量名使用全大写，例如<code>TARGET</code>、<code>OBJS</code>等。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TARGET = world.out</span><br><span class="line">OBJS = hello.o main.o</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>引用变量</strong>：</p><ul><li>使用<code>$(变量名)</code>引用变量。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">    cc -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="3-动态生成变量"><a href="#3-动态生成变量" class="headerlink" title="3. 动态生成变量"></a><strong>3. 动态生成变量</strong></h4><ul><li><p><strong>使用<code>wildcard</code>函数</strong>：</p><ul><li><code>wildcard</code>函数可以匹配当前目录下的文件模式。</li><li>示例：<code>$(wildcard *.c)</code>会列出当前目录下所有<code>.c</code>文件。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJS = <span class="variable">$(<span class="built_in">patsubst</span> %.c,%.o,$(<span class="built_in">wildcard</span> *.c)</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>使用<code>patsubst</code>函数</strong>：</p><ul><li><code>patsubst</code>函数用于模式替换。</li><li>示例：<code>$(patsubst %.c,%.o,$(wildcard *.c))</code>会将所有<code>.c</code>文件名替换为<code>.o</code>文件名。</li><li>这样，每当添加新的<code>.c</code>文件时，<code>OBJS</code>变量会自动更新，无需手动修改Makefile。</li></ul></li></ul><h4 id="4-内置变量"><a href="#4-内置变量" class="headerlink" title="4. 内置变量"></a><strong>4. 内置变量</strong></h4><ul><li><p><strong>内置变量</strong>：</p><ul><li><code>make</code>提供了一些内置变量，例如<code>$(CC)</code>表示C编译器，默认值是<code>cc</code>。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>修改内置变量</strong>：</p><ul><li>可以重新定义内置变量的值。</li><li>示例：使用交叉编译器时，可以设置<code>CC = riscv64-linux-gnu-gcc</code>。</li></ul></li></ul><h4 id="5-自动变量"><a href="#5-自动变量" class="headerlink" title="5. 自动变量"></a><strong>5. 自动变量</strong></h4><ul><li><p><strong>自动变量</strong>：</p><ul><li>在规则中自动指向特定值的变量。</li><li>常用的自动变量：<ul><li><code>$@</code>：目标文件名。</li><li><code>$&lt;</code>：依赖列表中的第一个文件。</li><li><code>$^</code>：所有依赖文件。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">    @echo &#x27;$<span class="variable">$@</span> = <span class="variable">$@</span>&#x27; <span class="comment"># 目标文件名</span></span><br><span class="line">    @echo &#x27;$<span class="variable">$&lt;</span> = <span class="variable">$&lt;</span>&#x27; <span class="comment"># 第一个依赖文件</span></span><br><span class="line">    @echo &#x27;$<span class="variable">$^</span> = <span class="variable">$^</span>&#x27; <span class="comment"># 所有依赖文件</span></span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>输出示例</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$@</span> = world.out</span><br><span class="line">$&lt; = hello.o</span><br><span class="line">$^ = hello.o main.o</span><br><span class="line">$(CC) -o world.out hello.o main.o</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-变量的调试"><a href="#6-变量的调试" class="headerlink" title="6. 变量的调试"></a><strong>6. 变量的调试</strong></h4><ul><li><strong>打印变量</strong>：<ul><li>使用<code>@echo</code>打印变量的值，便于调试。</li><li>示例：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">world.out: hello.o main.o</span></span><br><span class="line">    @echo &#x27;$<span class="variable">$@</span> = <span class="variable">$@</span>&#x27;</span><br><span class="line">    @echo &#x27;$<span class="variable">$&lt;</span> = <span class="variable">$&lt;</span>&#x27;</span><br><span class="line">    @echo &#x27;$<span class="variable">$^</span> = <span class="variable">$^</span>&#x27;</span><br><span class="line">    <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="7-小结-1"><a href="#7-小结-1" class="headerlink" title="7. 小结"></a><strong>7. 小结</strong></h4><ul><li><strong>变量的作用</strong>：简化Makefile的编写，减少重复，提高可维护性。</li><li><strong>变量的定义和引用</strong>：使用<code>变量名 = 值</code>定义，使用<code>$(变量名)</code>引用。</li><li><strong>动态生成变量</strong>：使用<code>wildcard</code>和<code>patsubst</code>函数自动生成文件列表。</li><li><strong>内置变量</strong>：使用内置变量（如<code>$(CC)</code>）简化命令。</li><li><strong>自动变量</strong>：使用自动变量（如<code>$@</code>、<code>$&lt;</code>、<code>$^</code>）简化规则。</li></ul><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STUDY210学习</title>
      <link href="/2024/08/06/test/STUDY210(%E6%9C%B1%E6%9C%89%E9%B9%8F)/"/>
      <url>/2024/08/06/test/STUDY210(%E6%9C%B1%E6%9C%89%E9%B9%8F)/</url>
      
        <content type="html"><![CDATA[<h1 id="隐藏文件与非隐藏文件"><a href="#隐藏文件与非隐藏文件" class="headerlink" title="隐藏文件与非隐藏文件"></a>隐藏文件与非隐藏文件</h1><p>Windows中：文件隐藏与不隐藏通过设置文件属性实现的，可以点击文件，右键属性，选择勾选隐藏选项来设置文件为隐藏文件。。在Windows中查看隐藏文件方法：菜单栏 工具-&gt;文件夹选项-&gt;查看-&gt;显示所有文件<br>和文件夹。<br>Linux中：linux中隐藏文件特点是文件名以.开头，跟文件属性无关。在linux中查看隐藏文件用ls -a命令（普通显示ls）</p><h1 id="相对路径与绝对路径"><a href="#相对路径与绝对路径" class="headerlink" title="相对路径与绝对路径"></a>相对路径与绝对路径</h1><p>什么是路径：路径是用来标识一个文件在操作系统的文件系统中存储位置的。pathname<br>举例：<br>D:\winshare\enum.c 全路径 pathname<br>D:\winshare路径 path<br>enum.c文件名name</p><p>绝对路径：路径是从绝对位置开始的。譬如Windows中从某一个盘符开始（C:\），linux中从根目录&#x2F;开始<br>相对路径：指明路径的时候，是从当前所在的位置开始的。</p><p>举例：<br>D:\我的文档\123\123.txt<br>D:\我的文档\abc\abc.txt<br>当前在123.txt，但是要去abc.txt<br>方式1：采用绝对路径。D:\我的文档\abc\abc.txt<br>方式2：采用相对路径。..&#x2F;abc&#x2F;abc.txt (..表示上一层)<br>从当前路径开始，往上走一层，再往下走一层（abc）就到了</p><p>测试：<br>&#x2F;abc&#x2F;123&#x2F;def.txt是linux绝对路径<br>abc&#x2F;123&#x2F;def.txt不是linux绝对路径<br>F:\abc\123\def.txt是windows绝对路径<br>abc\123\def.txt不是windows绝对路径</p><h1 id="linux内核、发行版"><a href="#linux内核、发行版" class="headerlink" title="linux内核、发行版"></a>linux内核、发行版</h1><p>linux本身指的是一个操作系统内核，只有内核是无法直接使用的。我们需要的，可以使用的操作系统是一个包含了内核和一批有用的应用程序的一个集合体，这个就叫linux发行版。<br>ubuntu、redhat就是linux的不同的发行版。</p><h1 id="GUI（图形用户界面）和cmdline（命令行）"><a href="#GUI（图形用户界面）和cmdline（命令行）" class="headerlink" title="GUI（图形用户界面）和cmdline（命令行）"></a>GUI（图形用户界面）和cmdline（命令行）</h1><p>GUI：grahics user interface，图形用户界面。<br>cmdline：command line，命令行。<br>人机交互：人和机器（计算机）进行交互，常用的有命令行和GUI。<br>Windows下既有GUI，又有命令行。linux中也是既有GUI，又有命令行。<br>但是，在linux中我们常用命令行(生产用)，在Windows中常用GUI（娱乐用）</p><h1 id="linux常用命令："><a href="#linux常用命令：" class="headerlink" title="linux常用命令："></a>linux常用命令：</h1><p>(1) ls（list，列表）<br>作用：使用列表把当前文件夹下所有文件显示出来<br>    ls -a显示所有文件，包括隐藏文件<br>    ls -l以详细信息显示<br>    ls -a -l<br>    ls -l -a<br>    ls -la<br>    ls -al四种方式都是可以的</p><p>man 作用：查询帮助信息</p><p>man 1 查询linux命令 </p><p>man2 查询api   </p><p>man3查询C库函数</p><p>(2)cd（change directory，更改目录）</p><p>作用：用来切换目录<br>涉及到相对路径和绝对路径<br>cd ....代表上一层目录<br>cd.   .代表当前目录</p><p>(3) pwd（print work directory，打印工作目录）<br>作用：打印出当前的绝对路径</p><p>(4) mkdir（make directory，创建文件夹）<br>作用：创建空文件夹<br>    mkdir -p 级联创建文件夹  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir runoob        #在工作目录下，建立一个名为 runoob 的子目录 </span><br><span class="line">mkdir -p runoob2/test   #在工作目录下的 runoob2 目录中，建立一个名为 test 的子目录。</span><br><span class="line">若 runoob2 目录原本不存在，则建立一个。（注：本例若不加 -p 参数，且原本 runoob2 目录不存在，则产生错误。）</span><br></pre></td></tr></table></figure><p>(5) mv（move，移动）<br>作用：在目录间移动文件，重命名文件<br>    mv 源文件pathname 目的文件pathname</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv source_file(文件) dest_file(文件) #将源文件名 source_file 改为目标文件名 dest_file</span><br><span class="line">mv source_file(文件) dest_directory(目录) #将文件 source_file 移动到目标目录 dest_directory 中</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>freeRTOS</title>
      <link href="/2024/08/06/test/freerots/"/>
      <url>/2024/08/06/test/freerots/</url>
      
        <content type="html"><![CDATA[<h3 id="1》什么是RTOS"><a href="#1》什么是RTOS" class="headerlink" title="1》什么是RTOS"></a>1》什么是RTOS</h3><p><strong>RTOS</strong>全称 Real Time Operating System，中文名就是实时操作系统。</p><h4 id="1、RTOS全称-Real-Time-Operating-System，中文名就是实时操作系统"><a href="#1、RTOS全称-Real-Time-Operating-System，中文名就是实时操作系统" class="headerlink" title="1、RTOS全称 Real Time Operating System，中文名就是实时操作系统"></a>1、RTOS全称 Real Time Operating System，中文名就是实时操作系统</h4><h4 id="2、RTOS是指一类操作系统。而不是单指某一个操作系统，比如UCOS，FreeRTOS，RT-Thread等这些都是RTOS操作系统"><a href="#2、RTOS是指一类操作系统。而不是单指某一个操作系统，比如UCOS，FreeRTOS，RT-Thread等这些都是RTOS操作系统" class="headerlink" title="2、RTOS是指一类操作系统。而不是单指某一个操作系统，比如UCOS，FreeRTOS，RT-Thread等这些都是RTOS操作系统"></a>2、RTOS是指一类操作系统。而不是单指某一个操作系统，比如UCOS，FreeRTOS，RT-Thread等这些都是RTOS操作系统</h4><h4 id="3、在单片机开发过程中有两种开发方式"><a href="#3、在单片机开发过程中有两种开发方式" class="headerlink" title="3、在单片机开发过程中有两种开发方式"></a>3、在单片机开发过程中有两种开发方式</h4><p>​1、裸机开发</p><p>​2、RTOS开发</p><p>​两者的区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">裸机开发</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        打游戏();</span><br><span class="line">        聊天();</span><br><span class="line">    <span class="comment">//两者相互有影响，要打完游戏再聊天，要么聊完天再打游戏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">RTOS开发</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    创建任务（打游戏）;</span><br><span class="line">    创建任务（聊天）;</span><br><span class="line">    启动任务调度；</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> 打游戏()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        只打游戏();<span class="comment">//不说话</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> 聊天()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        只聊天();<span class="comment">//不打游戏</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这两个任务不断的相互切换交替执行，只有任务切换的时间足够快，</span></span><br><span class="line">你玩游戏的队友和聊天的女朋友就感觉不到你没有去做别的事情</span><br></pre></td></tr></table></figure><h3 id="2》什么是freeRTOS"><a href="#2》什么是freeRTOS" class="headerlink" title="2》什么是freeRTOS"></a>2》什么是freeRTOS</h3><p>​1、根据名字，我们可以分成两部分：free和rtos,free就是免费、自由，不受约束的意思。</p><p>​2、是RTOS中的一种，freeRTOS十分小巧，可以在很多有限的微控制器上进行运行，单从文件上来说就要比UCOS小得多</p><h3 id="3》为什么要用freeRTOS"><a href="#3》为什么要用freeRTOS" class="headerlink" title="3》为什么要用freeRTOS"></a>3》为什么要用freeRTOS</h3><p>​1、freertos是免费的这点是选择它的最重要的一点，企业做产品肯定是要控制成本的，所以就这一点我们的freertos就是最好选择</p><p>​2、使用者很多，资料多，解决问题时方面查找，市场占有率很高，很多厂商提供的SDK包都支持freertos，尤其是一些带蓝牙、WIFI协议栈的芯片或者模块</p><p>​3、<strong>简单，文件数量少，方便移植和上手</strong></p><p>​4、可以移植到很多不同的微控制器上，比如STM32  F1\F3\F4\F7上都可以移植</p><h3 id="4》什么是任务"><a href="#4》什么是任务" class="headerlink" title="4》什么是任务"></a>4》什么是任务</h3><p>​任务是一个运行的函数（包括函数和栈），<em>是一段保存在</em>FLASH上的代码，在CPU上运行</p><p>​ARM架构</p><p>​F407中有：</p><p>​CPU:中央处理器(计算单元进行计算)</p><p>​FLASH:存放代码 通过JLINK等专业的工具烧入到FLASH（保证代码不会被轻易破坏）</p><p>​RAM：存放数据  可读可写</p><p>​串口等等模块</p><p>​CPU和内存的关系</p><p>​CPU RAM：存放数据</p><p>​&#x2F;&#x2F;对于内存来说只有两个功能，将数据读出来和写进去</p><p>​&#x2F;&#x2F;要实现a&#x3D;a+b这条语句CPU需要怎么操作</p><p>​——————————————</p><p>1.读出a<strong>变量的值</strong>(对应的汇编指令LDR load register)     </p><p>2.读出b变量的值</p><p>3.进行计算a、b的和(对应的汇编指令add)</p><p>4.将结果放到a的地址(对应汇编指令STR  store)</p><p>​CUP内部的寄存器 R0、R1……R15；R0-R12可以任意用来计算  R13-R15具有特殊功能：R13-SP(栈)，R14-LR(返回地址)，R15-PC(当前指令的地址)</p><p>​ARM7架构处理器采用三级流水线的结构。包括取指(fetch)-&gt;译码(decode)-&gt;执行(execute)三级。</p><p>​当第指令执行时，第二指令正在译码，第三条指令正在取指阶段。也就是说当第一条指令在执行时，PC寄存器应当指向第三条指令</p><p>​也就是说只要处理器是三级流水结构时，PC寄存器总是指向第三条指令</p><h3 id="5》任务的状态"><a href="#5》任务的状态" class="headerlink" title="5》任务的状态"></a>5》任务的状态</h3><p>​1、运行态</p><p>​2、就绪态</p><p>​3、阻塞态</p><p>​4、挂起态（暂停态）</p><p>​        5、停止态</p><h3 id="RTOS任务状态转换"><a href="#RTOS任务状态转换" class="headerlink" title="RTOS任务状态转换"></a>RTOS任务状态转换</h3><p>在“灯心智启”智能语音台灯项目中，我独立负责了基于FreeRTOS的多任务管理。针对RTOS任务状态转换，我有以下实际经验：</p><p>在项目初期，为实现台灯自动调光、坐姿提醒等多功能并发，我采用FreeRTOS进行任务划分。每个功能模块被设计为独立任务，涉及任务的创建、挂起、就绪、运行和阻塞等状态转换。比如，传感器采集任务在等待数据时进入阻塞状态，数据到达后自动切换到就绪状态，由调度器分配CPU资源进入运行状态；当任务需要等待外部事件时，主动调用vTaskSuspend()进入挂起状态，事件触发后通过vTaskResume()恢复。</p><h3 id="6》任务之间的转换（参考freertos任务转换图）"><a href="#6》任务之间的转换（参考freertos任务转换图）" class="headerlink" title="6》任务之间的转换（参考freertos任务转换图）"></a>6》任务之间的转换（参考freertos任务转换图）</h3><p><img src="/./../../images/1701947563704-99caeacf-b96d-4cfb-a981-ba13e3ce8815.png" alt="img"></p><h3 id="图中四个状态的类比"><a href="#图中四个状态的类比" class="headerlink" title="图中四个状态的类比"></a>图中四个状态的类比</h3><ol><li><strong>挂起态</strong>：<br>就像你暂时离开餐厅去打个电话，不参与排队也不等叫号，什么时候回来随你决定。</li><li><strong>就绪态</strong>：<br>相当于你在餐厅门口排队，随时准备进餐厅，只要有空位就可以进去吃饭。</li><li><strong>运行态</strong>：<br>就是你已经坐到餐厅里，正在吃饭，享受服务。</li><li><strong>阻塞态</strong>：<br>你在等朋友带钥匙或者等菜，暂时不能吃饭（虽然你的座位已经准备好了），只能等事件发生后才能继续。</li></ol><hr><h3 id="状态切换的类比"><a href="#状态切换的类比" class="headerlink" title="状态切换的类比"></a>状态切换的类比</h3><ul><li><strong>vTaskSuspend() called</strong>（挂起）：<br>你突然有事要先离开餐厅，告诉服务员“先别叫我，等我回来”，于是你进入“挂起态”。</li><li><strong>vTaskResume() called</strong>（恢复）：<br>你回来了，告诉服务员“我又可以排队&#x2F;吃饭了”，于是你回到“就绪态”，准备再次排队等吃饭。</li><li><strong>调用阻塞API函数（进入阻塞）</strong>：<br>你正在餐厅吃饭（运行态），突然发现忘带钱包，需要等朋友送钱来（阻塞态），于是你暂时不能继续吃饭。</li><li><strong>Event（事件发生，解除阻塞）</strong>：<br>朋友送钱来了（事件发生），你终于可以继续吃饭（回到就绪态）。</li><li><strong>就绪态与运行态切换</strong>：<br>排队等到你，轮到你进餐厅了（就绪→运行）；你吃完饭或者暂时让出座位（运行→就绪）。</li></ul><p> FreeRTOS（一个用于嵌入式系统的实时操作系统）中任务（Task）的几种状态以及它们之间的转换关系</p><ol><li><p><strong>运行态（运行状态）</strong>：</p><ul><li><p>这是任务正在 CPU 上执行的状态。在单核处理器上，同一时间只能有一个任务处于运行态。</p><p><strong>就绪态（就绪状态）</strong>： </p></li><li><p>任务已经准备好运行，但正在等待 CPU 的时间片（时间分配）。一旦 CPU 可用，就绪态的任务就可能变为运行态。</p></li></ul></li><li><p><strong>阻塞态（阻塞状态）</strong>：</p><ul><li>任务因为等待某个事件（比如等待数据或硬件操作完成）而不能继续执行。当它等待的事件发生时，任务会从阻塞态转换为就绪态，等待 CPU 再次分配时间给它。</li></ul></li><li><p><strong>挂起态（挂起状态）</strong>：</p><ul><li>任务被暂时停止执行。它不会消耗 CPU 时间，也不会被调度器调度。任务可以被“唤醒”（即从挂起态转换为就绪态），以便它能够再次运行。</li></ul></li></ol><p>图中还显示了状态之间的转换是如何通过 API 函数调用实现的：</p><ul><li><code>vTaskSuspend()</code> 和 <code>vTaskResume()</code> 函数用于将任务从就绪态转换为挂起态，或从挂起态转换为就绪态。</li><li>调用阻塞 API 函数会将任务从就绪态转换为阻塞态。</li><li>当任务等待的事件发生时，它会自动从阻塞态转换为就绪态。</li></ul><h3 id="7》任务优先级（数字越大。优先级越高）"><a href="#7》任务优先级（数字越大。优先级越高）" class="headerlink" title="7》任务优先级（数字越大。优先级越高）"></a>7》任务优先级（数字越大。优先级越高）</h3><h3 id="源码获取"><a href="#源码获取" class="headerlink" title="源码获取"></a>源码获取</h3><h3 id="1》free官网https-www-freertos-org"><a href="#1》free官网https-www-freertos-org" class="headerlink" title="1》free官网https://www.freertos.org/"></a>1》free官网<a href="https://www.freertos.org/">https://www.freertos.org/</a></h3><h3 id="2》源码文件夹介绍"><a href="#2》源码文件夹介绍" class="headerlink" title="2》源码文件夹介绍"></a>2》源码文件夹介绍</h3><p>​1、FreeRTOS和FreeRTOS-Plus是freertos的源码</p><p>​FreeRTOS文件中</p><p>​Demo文件夹中是放的针对不同MCU提供的相关例程</p><p>​License文件夹中是放相关的许可信息</p><p>​Source文件夹中是放FREERTOS的源码，也就是我们后面打交道的重要资料</p><p>​include放头文件</p><p>​portable放freertos系统和具体硬件之间的桥梁，只需要留下keil、memmang、RVDS三个文件夹，其余的文件夹都可以删除</p><p>​keil使用MDK编译环境所需要文件信息</p><p>​Menmang内存管理文件</p><p>​RVDS针对不同架构的MCU做了详细分类，stm32f407可以参考ARM_CM4F中的内容</p><h3 id="移植步骤"><a href="#移植步骤" class="headerlink" title="移植步骤"></a>移植步骤</h3><p>​1、找一个demo工程，在文件夹下新建一个freertos的文件夹</p><p>​2、将FreeRTOSv9.0.0\FreeRTOS\Source下的所有文件拷贝到新建freertos文件夹下</p><p>​3、打开KEIL工程，在工程目录下新建一个freertos文件夹并添加如下文件</p><p>​demo\freertos下的所有.c文件</p><p>​demo\freertos\portable\MemMang下的heap_4.c文件</p><p>​demo\freertos\portable\RVDS\ARM_CM4F下的port.c文件</p><p>​4、添加freertos需要的头文件路径</p><p>​5、编译报如下错</p><p>​..\freertos\include\FreeRTOS.h(98): error:  #5: cannot open source input file “FreeRTOSConfig.h”: No such file or directory</p><p>​<strong>到源码\FreeRTOSv9.0.0\FreeRTOS\Demo\CORTEX_M4F_STM32F407ZG-SK下将FreeRTOSConfig.h拷贝到\demo\freertos\include下</strong></p><p>​6、编译报如下错</p><p>​..\freertos\portable\RVDS\ARM_CM4F\port.c(713): error:  #20: identifier “SystemCoreClock” is undefined</p><p>​<strong>对FreeRTOSConfig.h文件的第87-90行代码进行如下修改</strong></p><p>​<strong>&#x2F;&#x2F;#ifdef ICCARM</strong></p><p>​<strong>#include &lt;stdint.h&gt;</strong></p><p>​<strong>extern uint32_t SystemCoreClock;</strong></p><p>​<strong>&#x2F;&#x2F;#endif</strong></p><p>​7、编译报如下错</p><p>​.\Objects\demo.axf: Error: L6200E: Symbol PendSV_Handler multiply defined (by port.o and stm32f4xx_it.o).</p><p>​.\Objects\demo.axf: Error: L6200E: Symbol SVC_Handler multiply defined (by port.o and stm32f4xx_it.o).</p><p>​.\Objects\demo.axf: Error: L6200E: Symbol SysTick_Handler multiply defined (by port.o and stm32f4xx_it.o).</p><p>​将stm32f4xx_it.c文件下的PendSV_Handler、SVC_Handler、SysTick_Handler屏蔽</p><p>​8、编译报如下错</p><p>​.\Objects\demo.axf: Error: L6218E: Undefined symbol vApplicationIdleHook (referred from tasks.o).</p><p>​.\Objects\demo.axf: Error: L6218E: Undefined symbol vApplicationStackOverflowHook (referred from tasks.o).</p><p>​.\Objects\demo.axf: Error: L6218E: Undefined symbol vApplicationTickHook (referred from tasks.o).</p><p>​.\Objects\demo.axf: Error: L6218E: Undefined symbol vApplicationMallocFailedHook (referred from heap_4.o).</p><p>​在FreeRTOSConfig.h文件中将vApplicationIdleHook、vApplicationStackOverflowHook,vApplicationTickHook,vApplicationMallocFailedHook这四个的钩子函数功能关闭</p><p>​9、编译0警告、0错误代表移植成功</p><p>​“.\Objects\demo.axf” - 0 Error(s), 0 Warning(s).</p><p>​FreeRTOSConfig.h文件用于对freertos系统的配置文件，可以通过对里面的开关进行修改实现对freertos功能的裁剪</p><h3 id="1、动态创建任务"><a href="#1、动态创建任务" class="headerlink" title="1、动态创建任务"></a>1、动态创建任务</h3><p>​</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">(</span></span><br><span class="line"><span class="params">    TaskFunction_t pxTaskCode,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">​<span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">​<span class="type">const</span> <span class="type">uint16_t</span> usStackDepth,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">​<span class="type">void</span> * <span class="type">const</span> pvParameters,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">​UBaseType_t uxPriority,</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">​TaskHandle_t * <span class="type">const</span> pxCreatedTask )</span></span><br></pre></td></tr></table></figure><p>​参数1：  指向任务函数的入口，任务的函数名</p><p>​参数2： 字符串，任务的函数名</p><p>​参数3：  任务堆栈大小，实际分配的大小是需要乘上4</p><p>​参数4： 需要传递给任务的参数</p><p>​参数5：   任务优先级，取值范围0~configMAX_PRIORITIES-1</p><p>​参数6：   任务句柄</p><p>​返回值：pdPASS：任务创建成功，会返回任务的句柄</p><p>​错误码参考projdefs.h中的定义</p><h3 id="2、启动动任务调度"><a href="#2、启动动任务调度" class="headerlink" title="2、启动动任务调度"></a>2、启动动任务调度</h3><p>​vTaskStartScheduler();</p><p>-————————————————————————————————————</p><h3 id="任务的几个关键函数"><a href="#任务的几个关键函数" class="headerlink" title="任务的几个关键函数"></a>任务的几个关键函数</h3><p>​xTaskCreate()&#x2F;&#x2F;使用动态的方法创建一个任务（默认）</p><p>​xTaskCreateStatic()&#x2F;&#x2F;使用静态的方法创建一个任务  </p><p>​xTaskCreateRestricted();&#x2F;&#x2F;创建一个使用MPU(内存管理单元)进行限制的任务，相关内存采用动态内存分配</p><p>​vTaskDelete();&#x2F;&#x2F;删除一个任务</p><p>​vTaskStartScheduler();&#x2F;&#x2F;启动任务调度</p><p>​vTaskSuspend();&#x2F;&#x2F;任务挂起</p><p>​vTaskResume()；&#x2F;&#x2F;恢复一个挂起任务</p><p>​xTaskResumeFromISR()&#x2F;&#x2F;在中断中恢复挂起任务</p><h3 id="1、动态创建任务-1"><a href="#1、动态创建任务-1" class="headerlink" title="1、动态创建任务"></a>1、动态创建任务</h3><p>​aseType_t xTaskCreate(TaskFunction_t pxTaskCode,</p><p>​const char * const pcName,</p><p>​const uint16_t usStackDepth,</p><p>​void * const pvParameters,</p><p>​UBaseType_t uxPriority,</p><p>​TaskHandle_t * const pxCreatedTask )</p><p>​参数1：  指向任务函数的入口，任务的函数名</p><p>​参数2：  字符串，任务的函数名</p><p>​参数3：  任务堆栈大小，实际分配的大小是需要乘上4</p><p>​参数4：  需要传递给任务的参数</p><p>​参数5：   任务优先级，取值范围0~configMAX_PRIORITIES-1</p><p>​参数6：   任务句柄</p><p>​返回值：pdPASS：任务创建成功，会返回任务的句柄</p><p>​错误码参考projdefs.h中的定义</p><h3 id="2、静态创建任务接口函数"><a href="#2、静态创建任务接口函数" class="headerlink" title="2、静态创建任务接口函数"></a>2、静态创建任务接口函数</h3><p>​TaskHandle_t xTaskCreateStatic(TaskFunction_t pxTaskCode,</p><p>​const char * const pcName,</p><p>​const uint32_t ulStackDepth,</p><p>​void * const pvParameters,</p><p>​UBaseType_t uxPriority,</p><p>​StackType_t * const puxStackBuffer,</p><p>​StaticTask_t * const pxTaskBuffer )</p><p>​参数1：指向任务函数的入口，任务的函数名</p><p>​参数2： 字符串，任务的函数名</p><p>​参数3：任务堆栈大小，实际分配的大小是需要乘上4</p><p>​参数4： 需要传递给任务的参数</p><p>​参数5：   任务优先级，取值范围0~configMAX_PRIORITIES-1</p><p>​参数6：任务堆栈，一般是数组，成员类型需要是StackType_t类型</p><p>​参数7：任务控制块，必须要指向类型为StaticTask_t的变量，这个变量用于保存创建任务的数据结构（TCB），因此它必须是持久</p><p>​返回值:NULL，代表创建失败</p><p>​   其它值，代表成功，任务句柄 </p><p>​注意：使用静态创建任务时需要用户自己实现两个函数vApplicationGetIdleTaskMemory()和vApplicationGetTimerTaskMemory();</p><p>​通过这个两个函数来给空闲任务和定时器服务任务的任务堆栈和任务控制块分配内存</p><p>​我们可以在main.c文件的main涵数之前进行定义</p><p>​static StaticTask_t IdleTaskTCB;</p><p>​static StackType_t dleTaskStack[configMINIMAL_STACK_SIZE];</p><p>​static StaticTask_t TimerTaskTCB;</p><p>​static StackType_t TimerTaskStack[configTIMER_TASK_STACK_DEPTH];</p><p>​void vApplicationGetIdleTaskMemory(StaticTask_t * * ppxIdleTaskTCBBuffer, StackType_t * * ppxIdleTaskStackBuffer, uint32_t * pulIdleTaskStackSize)</p><p>​{</p><p>​* ppxIdleTaskTCBBuffer &#x3D; &IdleTaskTCB;&#x2F;&#x2F;空闲任务控制块</p><p>​* ppxIdleTaskStackBuffer &#x3D; dleTaskStack;&#x2F;&#x2F;空闲任务的堆栈</p><p>​* pulIdleTaskStackSize &#x3D; configMINIMAL_STACK_SIZE;&#x2F;&#x2F;堆栈大小</p><p>​}</p><p>​void vApplicationGetTimerTaskMemory(StaticTask_t * * ppxTimerTaskTCBBuffer, StackType_t * * ppxTimerTaskStackBuffer, uint32_t * pulTimerTaskStackSize)</p><p>​{</p><p>​* ppxTimerTaskTCBBuffer &#x3D; &TimerTaskTCB;&#x2F;&#x2F;任务控制块</p><p>​* ppxTimerTaskStackBuffer &#x3D; TimerTaskStack;&#x2F;&#x2F;任务堆栈</p><p>​* pulTimerTaskStackSize &#x3D; configTIMER_TASK_STACK_DEPTH;&#x2F;&#x2F;堆栈大小</p><p>​}</p><h3 id="任务怎么暂停和恢复"><a href="#任务怎么暂停和恢复" class="headerlink" title="任务怎么暂停和恢复"></a>任务怎么暂停和恢复</h3><p>​ 假如创建3三个任务</p><p>​任务1</p><p>​任务2</p><p>​任务3</p><p>​执行过程</p><p>​任务1-》任务2-》任务3</p><p>​void 任务1()</p><p>​{</p><p>​while(1)</p><p>​{</p><p>​A();</p><p>​———&gt;运行到这个地方时，系统进行了一次调度（切换任务）。</p><p>​B();</p><p>​}</p><p>​}</p><p>​&#x2F;&#x2F;前面我们有说任务是一段保存在FLASH上的代码（函数），如仅仅只是一段代码，更不不需要报存，但是这段代码一旦运行了，就会产生数据比如局部变量，PC寄存器的值，代码运行的位置。</p><h3 id="切任务时需要做的事情"><a href="#切任务时需要做的事情" class="headerlink" title="切任务时需要做的事情"></a>切任务时需要做的事情</h3><p>​1、保存程序执行的位置</p><p>​2、保存任务中产生的变量的值</p><p>​等等</p><p>​当程序运行时被打断，需要现场保护，也就是前面所说的16个寄存器的值，将他们保存起来，保存在哪里？-》保存在栈里面</p><p>堆栈的作用</p><h3 id="1》栈（stack）"><a href="#1》栈（stack）" class="headerlink" title="1》栈（stack）"></a>1》栈（stack）</h3><p>​1、函数的形参，以及函数里面定义的局部变量就是存储在栈里，（我们的局部变量，数组这些不能超过1K），否则程序会进入hardfault</p><p>​2、实时操作系统的现场保护，返回地址也是保存在栈里</p><p>​3、栈的增长方向是从高地址到低地址</p><h3 id="2》堆（heap）"><a href="#2》堆（heap）" class="headerlink" title="2》堆（heap）"></a>2》堆（heap）</h3><p>​1、malloc()函数动态分配的内存就是从堆空间分配</p><h3 id="3》静态空间区域"><a href="#3》静态空间区域" class="headerlink" title="3》静态空间区域"></a>3》静态空间区域</h3><p>​全局变量，静态变量是不存在堆里的，堆以外的静态空间区域</p><h3 id="4》栈的大小怎么分"><a href="#4》栈的大小怎么分" class="headerlink" title="4》栈的大小怎么分"></a>4》栈的大小怎么分</h3><p> —取决于局部变量的大小和调用的深度，只能估算，没有刚好的确定值（由大到小去调节）</p><h3 id="5》栈从哪里分配"><a href="#5》栈从哪里分配" class="headerlink" title="5》栈从哪里分配"></a>5》栈从哪里分配</h3><p> —-heap4.c中有一个很大的数组，从这个数组中划分出去各个任务的栈</p><h3 id="任务调度的机制"><a href="#任务调度的机制" class="headerlink" title="任务调度的机制"></a>任务调度的机制</h3><h4 id="1》在创建任务时做了以下事情"><a href="#1》在创建任务时做了以下事情" class="headerlink" title="1》在创建任务时做了以下事情"></a>1》在创建任务时做了以下事情</h4><p>​1、分配栈空间</p><p>​2、将函数地址给PC，也就是R15</p><p>​3、将参数给到R0</p><p>​4、分配优先级</p><p>​5、分配了TCB结构体</p><p>​任务切换时需要将R0-R15寄存器的值保存到栈里，再次运行时，需要从栈里面恢复R0-R15寄存器的值</p><h4 id="2》优先级"><a href="#2》优先级" class="headerlink" title="2》优先级"></a>2》优先级</h4><p>​1、高优先级的任务可以抢占低优先级任务</p><p>​2、高优先级的任务不主动放弃CPU资源，低优先级的任务永远无法运行</p><p>​3、同等优先级的任务按时间片轮询依次执行</p><p>​4、空闲任务礼让其他同级别的任务—空闲任务主动放弃一次运行机会</p><h4 id="3》怎么去管理任务"><a href="#3》怎么去管理任务" class="headerlink" title="3》怎么去管理任务"></a>3》怎么去管理任务</h4><p>​1、找到最高优先级的任务运行</p><p>​2、优先级相同轮流执行，排队，排在就绪列表前的先执行，运行一个tick后，让出CPU的使用权，去链表尾部排队</p><h4 id="4》高优先级任务怎么主动释放CPU使用权"><a href="#4》高优先级任务怎么主动释放CPU使用权" class="headerlink" title="4》高优先级任务怎么主动释放CPU使用权"></a>4》高优先级任务怎么主动释放CPU使用权</h4><p>​用vTaskDelay()函数可以释放CPU使用权</p><h4 id="5》空闲任务"><a href="#5》空闲任务" class="headerlink" title="5》空闲任务"></a>5》空闲任务</h4><p>​1、主要起清理作用，比如一个任务自杀了，由空闲任务来释放任务的栈空间</p><p>​2、当创建的任务优先级都为0时，最先运行的是空闲任务，因为空闲任务是在启动任务调度器时才创建</p><h3 id="启动文件"><a href="#启动文件" class="headerlink" title="启动文件"></a>启动文件</h3><p>​Stack_Size      EQU     0x00000400&#x2F;&#x2F;分配了一个栈空间</p><p>​                AREA    STACK, NOINIT, READWRITE, ALIGN&#x3D;3&#x2F;&#x2F;定义一个段，代码节或数据节，说明定义段的相关属性</p><p>​Stack_Mem       SPACE   Stack_Size</p><p>​&#x2F;&#x2F;SPACE(申请一段空间)用于分配大小等于Stack_Size连续内存空间，单位为字节&#x2F;&#x2F;类似MALLOC</p><p>​__initial_sp  &#x2F;&#x2F;表示这块区域的高地址指向栈顶 “先进后出”</p><p>​ STACK表示这块区域的名称没有限制写啥都行</p><p>​ NOINIT表示这块区域不需要初始化</p><p>​ READWRITE表示这块区域可读可写，可读写(内存)，ROM是指读区域</p><p>​ ALIGN&#x3D;3表示按照2^3(8)字节对齐</p><p>​ 启动文件中的堆栈空间是用来管理裸机开发时有用，freertos中的堆栈是由heap4.c管理</p><h4 id="6》在freertos中，最低优先级的中断也比最好优先级的任务先运行，中断永远都是先执行"><a href="#6》在freertos中，最低优先级的中断也比最好优先级的任务先运行，中断永远都是先执行" class="headerlink" title="6》在freertos中，最低优先级的中断也比最好优先级的任务先运行，中断永远都是先执行"></a>6》在freertos中，最低优先级的中断也比最好优先级的任务先运行，中断永远都是先执行</h4><h3 id="任务之间的通信"><a href="#任务之间的通信" class="headerlink" title="任务之间的通信"></a>任务之间的通信</h3><p>​1、消息队列</p><p>​2、共享内存</p><p>​3、信号量</p><p>​4、二值信号量</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>台灯需要同时完成环境光检测、自动调光和语音交互等多项功能，但STM32资源有限，如何高效调度多任务成为关键挑战。为此，我将环境光检测、调光控制和语音识别分别设计为独立任务，并合理设置优先级和同步机制。环境光检测任务大部分时间处于阻塞态，定时唤醒采集数据后通过队列通知调光任务，调光任务则在收到数据时由阻塞态切换为就绪态，及时调整灯光亮度。语音识别任务则根据唤醒词实现挂起和激活的切换，实现资源的动态分配。</p><p>环境光检测任务采用FreeRTOS的阻塞式设计。具体实现上，我利用FreeRTOS的软件定时器，每隔200ms自动触发一次任务唤醒。唤醒后，任务通过ADC接口采集光敏传感器数据，采集结束后，数据通过FreeRTOS队列（Queue）发送给调光控制任务。发送完成后，该任务立即调用vTaskDelay或直接进入阻塞（Blocked）状态，等待下一个定时周期，从而极大降低CPU占用，提高系统整体能效。</p><p>调光控制任务同样采用阻塞等待队列消息的机制。它在FreeRTOS中通过xQueueReceive函数阻塞自己，只有当环境光检测任务有新数据写入时，调光任务才从阻塞切换到就绪（Ready），并被调度执行。调光任务根据收到的光照强度数据，实时调整PWM占空比，驱动LED灯实现无级调光。调光完成后，再次进入阻塞等待下一个消息，保证系统响应及时且资源利用最大化。</p><p>语音识别任务则设计为“挂起-激活”机制。任务在系统空闲时处于挂起（Suspended）状态，几乎不占用任何CPU资源。系统通过外部中断（如麦克风检测到唤醒词）触发ISR（中断服务例程），在ISR中调用xTaskResumeFromISR函数将语音任务恢复到就绪状态。语音任务被唤醒后，立即处理语音指令，执行相应操作（如开关灯、调节亮度等）。处理完成后，任务再次自挂起，等待下次激活。这样，既保证了语音响应的及时性，又优化了主控芯片的算力分配。</p><h2 id="1-环境光检测任务"><a href="#1-环境光检测任务" class="headerlink" title="1. 环境光检测任务"></a>1. 环境光检测任务</h2><h3 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h3><ol><li><strong>FreeRTOS软件定时器</strong>每隔200ms超时回调，唤醒环境光检测任务（或直接采集数据）。</li><li>任务被唤醒，<strong>启动ADC采样</strong>，读取光敏传感器数据。</li><li>将采集到的数据<strong>通过Queue发送</strong>给调光控制任务。</li><li>任务调用<code>vTaskDelay</code>或等待事件进入阻塞，<strong>等待下一个定时周期</strong>。</li></ol><h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><ul><li><strong>任务优先级</strong>：建议为中等，优先级略高于调光任务，低于关键中断。</li><li><strong>ADC采样</strong>：可用DMA方式提升效率，采样完成用事件或信号量通知任务。</li><li><strong>Queue长度</strong>：设为1或2，避免数据堆积。</li><li><strong>软件定时器</strong>：用<code>xTimerCreate</code>&#x2F;<code>xTimerStart</code>创建，回调里用<code>xTaskNotifyGive</code>或<code>vTaskResume</code>唤醒任务。</li></ul><h3 id="伪代码示例"><a href="#伪代码示例" class="headerlink" title="伪代码示例"></a>伪代码示例</h3><details data-line="20" class="md-editor-code" open style="box-sizing: border-box; font-family: OPPOSans, -apple-system, BlinkMacSystemFont, &quot;Segoe UI Variable&quot;, &quot;Segoe UI&quot;, system-ui, ui-sans-serif, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;; font-size: 12px; line-height: 1; margin: 20px 0px; padding: 0px; border: 0px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-variant-alternates: inherit; font-variant-position: inherit; font-weight: 400; font-stretch: inherit; font-optical-sizing: inherit; font-kerning: inherit; font-feature-settings: inherit; font-variation-settings: inherit; vertical-align: baseline; display: block; color: rgb(169, 183, 198); letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary class="md-editor-code-head" style="box-sizing: border-box; font-family: inherit; font-size: 12px; line-height: inherit; margin: 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-optical-sizing: inherit; font-size-adjust: inherit; font-kerning: inherit; font-feature-settings: inherit; font-variation-settings: inherit; vertical-align: baseline; display: grid; grid-template: &quot;1rf 1rf&quot;; justify-content: space-between; height: 32px; width: 636px; background-color: rgb(40, 44, 52); border-radius: 5px 5px 0px 0px; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); list-style: none; cursor: pointer;"><div class="md-editor-code-flag" style="box-sizing: border-box; font: inherit; margin: 0px 0px 0px 12px; padding: 0px; border: 0px; vertical-align: baseline;"><span style="box-sizing: border-box; font: inherit; margin: 11px 0px 0px; padding: 0px; border: 0px; vertical-align: baseline; display: inline-block; width: 10px; height: 10px; border-radius: 50%; background-color: rgb(236, 106, 94);"></span><span style="box-sizing: border-box; font: inherit; margin: 11px 0px 0px 4px; padding: 0px; border: 0px; vertical-align: baseline; display: inline-block; width: 10px; height: 10px; border-radius: 50%; background-color: rgb(244, 191, 79);"></span><span style="box-sizing: border-box; font: inherit; margin: 11px 0px 0px 4px; padding: 0px; border: 0px; vertical-align: baseline; display: inline-block; width: 10px; height: 10px; border-radius: 50%; background-color: rgb(97, 197, 84);"></span></div><div class="md-editor-code-action" style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: flex; align-items: center;"><span class="md-editor-code-lang" style="box-sizing: border-box; font-family: inherit; font-size: inherit; line-height: 32px; margin: 0px 10px 0px 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-optical-sizing: inherit; font-size-adjust: inherit; font-kerning: inherit; font-feature-settings: inherit; font-variation-settings: inherit; vertical-align: baseline;">c</span><span class="md-editor-copy-button" data-tips="复制代码" style="box-sizing: border-box; font-family: inherit; font-size: inherit; line-height: 32px; margin: 0px 10px 0px 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-optical-sizing: inherit; font-size-adjust: inherit; font-kerning: inherit; font-feature-settings: inherit; font-variation-settings: inherit; vertical-align: baseline; cursor: pointer; position: initial;">复制代码</span><span class="md-editor-collapse-tips" style="box-sizing: border-box; font: inherit; margin: 0px 12px 0px 0px; padding: 0px; border: 0px; vertical-align: baseline;"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-circle-chevron-left md-editor-icon"><circle cx="12" cy="12" r="10"/><path d="m14 16-4-4 4-4"/></svg></span></div></summary><pre style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; position: relative; white-space: break-spaces;"><code class="language-c" language="c" style="box-sizing: border-box; font-family: source-code-pro, Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 14px; line-height: 1.6; margin: 0px; padding: 1em; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-optical-sizing: inherit; font-size-adjust: inherit; font-kerning: inherit; font-feature-settings: inherit; font-variation-settings: inherit; vertical-align: baseline; color: rgb(169, 183, 198); background-color: rgb(40, 44, 52); border-radius: 0px 0px 5px 5px; display: block; overflow: auto; position: relative; box-shadow: rgba(0, 0, 0, 0.333) 0px 2px 2px;"><span class="md-editor-code-block" style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: bottom; display: inline-block; width: 573px; overflow: auto; color: rgb(169, 183, 198);">void vLightDetectTask(void *pvParameters) &#123;    for (;;) &#123;        // 1. 阻塞等待定时器通知        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);<pre><code>    // 2. 采集ADC数据    uint16_t lightValue = ADC_Read();    // 3. 发送到队列    xQueueSend(lightQueue, &amp;amp;lightValue, portMAX_DELAY);    // 4. 进入阻塞等待下次通知（由定时器回调触发）&#125;</code></pre><p>}</p><p>&#x2F;&#x2F; 软件定时器回调<br>void vTimerCallback(TimerHandle_t xTimer) {<br>    BaseType_t xHigherPriorityTaskWoken &#x3D; pdFALSE;<br>    vTaskNotifyGiveFromISR(lightDetectTaskHandle, &amp;xHigherPriorityTaskWoken);<br>    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);<br>}</p></span><span rn-wrapper aria-hidden="true" style="box-sizing: border-box; font-family: inherit; font-size: 14px; line-height: inherit; margin: 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-optical-sizing: inherit; font-size-adjust: inherit; font-kerning: inherit; font-feature-settings: inherit; font-variation-settings: inherit; vertical-align: baseline; position: absolute; pointer-events: none; top: 1em; left: 0px; width: 3em; letter-spacing: -1px; user-select: none; counter-reset: linenumber 0;"><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span></span></code></pre></details><p></p><hr><h2 id="2-调光控制任务"><a href="#2-调光控制任务" class="headerlink" title="2. 调光控制任务"></a>2. 调光控制任务</h2><h3 id="核心流程-1"><a href="#核心流程-1" class="headerlink" title="核心流程"></a>核心流程</h3><ol><li>通过<code>xQueueReceive</code><strong>阻塞式等待</strong>环境光检测任务的新数据。</li><li>收到后，<strong>计算PWM占空比</strong>，调整LED亮度。</li><li>调整完成后，<strong>再次阻塞等待</strong>下一次消息。</li></ol><h3 id="实现细节-1"><a href="#实现细节-1" class="headerlink" title="实现细节"></a>实现细节</h3><ul><li><strong>任务优先级</strong>：可与环境光检测任务相同，保证及时响应。</li><li><strong>PWM调节</strong>：可调用HAL库的PWM设置函数，动态调整占空比。</li><li><strong>算法</strong>：可加简单滤波或阈值防止频繁闪烁。</li></ul><h3 id="伪代码示例-1"><a href="#伪代码示例-1" class="headerlink" title="伪代码示例"></a>伪代码示例</h3><details data-line="60" class="md-editor-code" open style="box-sizing: border-box; font-family: OPPOSans, -apple-system, BlinkMacSystemFont, &quot;Segoe UI Variable&quot;, &quot;Segoe UI&quot;, system-ui, ui-sans-serif, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;; font-size: 12px; line-height: 1; margin: 20px 0px; padding: 0px; border: 0px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-variant-alternates: inherit; font-variant-position: inherit; font-weight: 400; font-stretch: inherit; font-optical-sizing: inherit; font-kerning: inherit; font-feature-settings: inherit; font-variation-settings: inherit; vertical-align: baseline; display: block; color: rgb(169, 183, 198); letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary class="md-editor-code-head" style="box-sizing: border-box; font-family: inherit; font-size: 12px; line-height: inherit; margin: 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-optical-sizing: inherit; font-size-adjust: inherit; font-kerning: inherit; font-feature-settings: inherit; font-variation-settings: inherit; vertical-align: baseline; display: grid; grid-template: &quot;1rf 1rf&quot;; justify-content: space-between; height: 32px; width: 636px; background-color: rgb(40, 44, 52); border-radius: 5px 5px 0px 0px; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); list-style: none; cursor: pointer;"><div class="md-editor-code-flag" style="box-sizing: border-box; font: inherit; margin: 0px 0px 0px 12px; padding: 0px; border: 0px; vertical-align: baseline;"><span style="box-sizing: border-box; font: inherit; margin: 11px 0px 0px; padding: 0px; border: 0px; vertical-align: baseline; display: inline-block; width: 10px; height: 10px; border-radius: 50%; background-color: rgb(236, 106, 94);"></span><span style="box-sizing: border-box; font: inherit; margin: 11px 0px 0px 4px; padding: 0px; border: 0px; vertical-align: baseline; display: inline-block; width: 10px; height: 10px; border-radius: 50%; background-color: rgb(244, 191, 79);"></span><span style="box-sizing: border-box; font: inherit; margin: 11px 0px 0px 4px; padding: 0px; border: 0px; vertical-align: baseline; display: inline-block; width: 10px; height: 10px; border-radius: 50%; background-color: rgb(97, 197, 84);"></span></div><div class="md-editor-code-action" style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: flex; align-items: center;"><span class="md-editor-code-lang" style="box-sizing: border-box; font-family: inherit; font-size: inherit; line-height: 32px; margin: 0px 10px 0px 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-optical-sizing: inherit; font-size-adjust: inherit; font-kerning: inherit; font-feature-settings: inherit; font-variation-settings: inherit; vertical-align: baseline;">c</span><span class="md-editor-copy-button" data-tips="复制代码" style="box-sizing: border-box; font-family: inherit; font-size: inherit; line-height: 32px; margin: 0px 10px 0px 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-optical-sizing: inherit; font-size-adjust: inherit; font-kerning: inherit; font-feature-settings: inherit; font-variation-settings: inherit; vertical-align: baseline; cursor: pointer; position: initial;">复制代码</span><span class="md-editor-collapse-tips" style="box-sizing: border-box; font: inherit; margin: 0px 12px 0px 0px; padding: 0px; border: 0px; vertical-align: baseline;"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-circle-chevron-left md-editor-icon"><circle cx="12" cy="12" r="10"/><path d="m14 16-4-4 4-4"/></svg></span></div></summary><pre style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; position: relative; white-space: break-spaces;"><code class="language-c" language="c" style="box-sizing: border-box; font-family: source-code-pro, Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 14px; line-height: 1.6; margin: 0px; padding: 1em; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-optical-sizing: inherit; font-size-adjust: inherit; font-kerning: inherit; font-feature-settings: inherit; font-variation-settings: inherit; vertical-align: baseline; color: rgb(169, 183, 198); background-color: rgb(40, 44, 52); border-radius: 0px 0px 5px 5px; display: block; overflow: auto; position: relative; box-shadow: rgba(0, 0, 0, 0.333) 0px 2px 2px;"><span class="md-editor-code-block" style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: bottom; display: inline-block; width: 573px; overflow: auto; color: rgb(169, 183, 198);">void vDimmingTask(void *pvParameters) &#123;    uint16_t lightValue;    for (;;) &#123;        // 1. 阻塞等待新数据        if (xQueueReceive(lightQueue, &amp;lightValue, portMAX_DELAY) == pdPASS) &#123;            // 2. 计算调光值            uint8_t duty = CalcDuty(lightValue);<pre><code>        // 3. 调整PWM        __HAL_TIM_SET_COMPARE(&amp;amp;htimx, TIM_CHANNEL_y, duty);        // 4. 阻塞等待下次消息    &#125;&#125;</code></pre><p>}</p></span><span rn-wrapper aria-hidden="true" style="box-sizing: border-box; font-family: inherit; font-size: 14px; line-height: inherit; margin: 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-optical-sizing: inherit; font-size-adjust: inherit; font-kerning: inherit; font-feature-settings: inherit; font-variation-settings: inherit; vertical-align: baseline; position: absolute; pointer-events: none; top: 1em; left: 0px; width: 3em; letter-spacing: -1px; user-select: none; counter-reset: linenumber 0;"><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span></span></code></pre></details><p></p><hr><h2 id="3-语音识别任务"><a href="#3-语音识别任务" class="headerlink" title="3. 语音识别任务"></a>3. 语音识别任务</h2><h3 id="核心流程-2"><a href="#核心流程-2" class="headerlink" title="核心流程"></a>核心流程</h3><ol><li>初始处于<strong>挂起状态</strong>（<code>vTaskSuspend</code>）。</li><li>麦克风检测到唤醒词后，<strong>外部中断ISR</strong>中调用<code>xTaskResumeFromISR</code>恢复任务。</li><li>任务唤醒后，<strong>处理语音数据</strong>（如解析指令、控制灯光）。</li><li>处理完成后，<strong>自挂起</strong>（<code>vTaskSuspend(NULL)</code>），等待下次激活。</li></ol><h3 id="实现细节-2"><a href="#实现细节-2" class="headerlink" title="实现细节"></a>实现细节</h3><ul><li><strong>任务优先级</strong>：建议高于其他任务，确保响应及时。</li><li><strong>ISR操作</strong>：中断服务例程里只做任务唤醒，主处理逻辑在任务里。</li><li><strong>语音处理</strong>：可用外部模块&#x2F;库，处理时间长时可拆分子任务。</li></ul><h3 id="伪代码示例-2"><a href="#伪代码示例-2" class="headerlink" title="伪代码示例"></a>伪代码示例</h3><details data-line="95" class="md-editor-code" open style="box-sizing: border-box; font-family: OPPOSans, -apple-system, BlinkMacSystemFont, &quot;Segoe UI Variable&quot;, &quot;Segoe UI&quot;, system-ui, ui-sans-serif, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;; font-size: 12px; line-height: 1; margin: 20px 0px; padding: 0px; border: 0px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-variant-numeric: inherit; font-variant-east-asian: inherit; font-variant-alternates: inherit; font-variant-position: inherit; font-weight: 400; font-stretch: inherit; font-optical-sizing: inherit; font-kerning: inherit; font-feature-settings: inherit; font-variation-settings: inherit; vertical-align: baseline; display: block; color: rgb(169, 183, 198); letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; white-space: normal; background-color: rgb(255, 255, 255); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><summary class="md-editor-code-head" style="box-sizing: border-box; font-family: inherit; font-size: 12px; line-height: inherit; margin: 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-optical-sizing: inherit; font-size-adjust: inherit; font-kerning: inherit; font-feature-settings: inherit; font-variation-settings: inherit; vertical-align: baseline; display: grid; grid-template: &quot;1rf 1rf&quot;; justify-content: space-between; height: 32px; width: 636px; background-color: rgb(40, 44, 52); border-radius: 5px 5px 0px 0px; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); list-style: none; cursor: pointer;"><div class="md-editor-code-flag" style="box-sizing: border-box; font: inherit; margin: 0px 0px 0px 12px; padding: 0px; border: 0px; vertical-align: baseline;"><span style="box-sizing: border-box; font: inherit; margin: 11px 0px 0px; padding: 0px; border: 0px; vertical-align: baseline; display: inline-block; width: 10px; height: 10px; border-radius: 50%; background-color: rgb(236, 106, 94);"></span><span style="box-sizing: border-box; font: inherit; margin: 11px 0px 0px 4px; padding: 0px; border: 0px; vertical-align: baseline; display: inline-block; width: 10px; height: 10px; border-radius: 50%; background-color: rgb(244, 191, 79);"></span><span style="box-sizing: border-box; font: inherit; margin: 11px 0px 0px 4px; padding: 0px; border: 0px; vertical-align: baseline; display: inline-block; width: 10px; height: 10px; border-radius: 50%; background-color: rgb(97, 197, 84);"></span></div><div class="md-editor-code-action" style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: flex; align-items: center;"><span class="md-editor-code-lang" style="box-sizing: border-box; font-family: inherit; font-size: inherit; line-height: 32px; margin: 0px 10px 0px 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-optical-sizing: inherit; font-size-adjust: inherit; font-kerning: inherit; font-feature-settings: inherit; font-variation-settings: inherit; vertical-align: baseline;">c</span><span class="md-editor-copy-button" data-tips="复制代码" style="box-sizing: border-box; font-family: inherit; font-size: inherit; line-height: 32px; margin: 0px 10px 0px 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-optical-sizing: inherit; font-size-adjust: inherit; font-kerning: inherit; font-feature-settings: inherit; font-variation-settings: inherit; vertical-align: baseline; cursor: pointer; position: initial;">复制代码</span><span class="md-editor-collapse-tips" style="box-sizing: border-box; font: inherit; margin: 0px 12px 0px 0px; padding: 0px; border: 0px; vertical-align: baseline;"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-circle-chevron-left md-editor-icon"><circle cx="12" cy="12" r="10"/><path d="m14 16-4-4 4-4"/></svg></span></div></summary><pre style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; position: relative; white-space: break-spaces;"><code class="language-c" language="c" style="box-sizing: border-box; font-family: source-code-pro, Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: 14px; line-height: 1.6; margin: 0px; padding: 1em; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-optical-sizing: inherit; font-size-adjust: inherit; font-kerning: inherit; font-feature-settings: inherit; font-variation-settings: inherit; vertical-align: baseline; color: rgb(169, 183, 198); background-color: rgb(40, 44, 52); border-radius: 0px 0px 5px 5px; display: block; overflow: auto; position: relative; box-shadow: rgba(0, 0, 0, 0.333) 0px 2px 2px;"><span class="md-editor-code-block" style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: bottom; display: inline-block; width: 573px; overflow: auto; color: rgb(169, 183, 198);">void vVoiceTask(void *pvParameters) &#123;    for (;;) &#123;        // 1. 刚启动即挂起        vTaskSuspend(NULL);<pre><code>    // 2. 被恢复后，处理语音指令    ProcessVoiceCommand();    // 3. 处理完后再次挂起&#125;</code></pre><p>}</p><p>&#x2F;&#x2F; 外部中断ISR<br>void EXTIx_IRQHandler(void) {<br>    BaseType_t xHigherPriorityTaskWoken &#x3D; pdFALSE;<br>    xTaskResumeFromISR(voiceTaskHandle);<br>    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);<br>}</p></span><span rn-wrapper aria-hidden="true" style="box-sizing: border-box; font-family: inherit; font-size: 14px; line-height: inherit; margin: 0px; padding: 0px; border: 0px; font-style: inherit; font-variant: inherit; font-weight: inherit; font-stretch: inherit; font-optical-sizing: inherit; font-size-adjust: inherit; font-kerning: inherit; font-feature-settings: inherit; font-variation-settings: inherit; vertical-align: baseline; position: absolute; pointer-events: none; top: 1em; left: 0px; width: 3em; letter-spacing: -1px; user-select: none; counter-reset: linenumber 0;"><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span><span style="box-sizing: border-box; font: inherit; margin: 0px; padding: 0px; border: 0px; vertical-align: baseline; display: block; pointer-events: none; counter-increment: linenumber 1;"></span></span></code></pre></details><p></p><hr><h2 id="4-任务之间的典型关系和调度"><a href="#4-任务之间的典型关系和调度" class="headerlink" title="4. 任务之间的典型关系和调度"></a>4. <strong>任务之间的典型关系和调度</strong></h2><ul><li><strong>环境光检测任务</strong> ←定时器唤醒→ <strong>ADC采样</strong> →队列→ <strong>调光任务</strong></li><li><strong>调光任务</strong> ←队列阻塞→ <strong>PWM调节</strong></li><li><strong>语音任务</strong> ←中断激活→ <strong>语音指令处理</strong>（可控制灯光、调光）</li></ul><hr><h2 id="5-优化和注意点"><a href="#5-优化和注意点" class="headerlink" title="5. 优化和注意点"></a>5. 优化和注意点</h2><ul><li>队列、定时器、任务优先级设计要根据<strong>实时性和资源分配</strong>合理调整。</li><li>关键外设（如ADC、PWM）建议用DMA或硬件加速，减少CPU负担。</li><li>语音任务建议设置<strong>更高优先级</strong>。</li><li>若对电源有极致要求，可在任务空闲时进入低功耗模式（如Tickless Idle）。</li></ul><hr><h2 id="6-面试表达建议（简明版）"><a href="#6-面试表达建议（简明版）" class="headerlink" title="6. 面试表达建议（简明版）"></a>6. 面试表达建议（简明版）</h2><blockquote><p>“环境光检测任务用软件定时器周期唤醒，采集光敏传感器ADC数据后，通过队列发送给调光任务，任务间完全解耦，且均采用阻塞设计，极大降低了CPU占用。调光任务阻塞等待队列消息，收到后计算PWM占空比驱动LED，实现无级调光。语音识别任务则由外部中断唤醒，处理完指令后再次自挂起，最大化算力利用和响应速度。”</p></blockquote><h1 id="ADC-DMA-FreeRTOS智能调光流程"><a href="#ADC-DMA-FreeRTOS智能调光流程" class="headerlink" title="ADC+DMA+FreeRTOS智能调光流程"></a><strong>ADC+DMA+FreeRTOS智能调光流程</strong></h1><h2 id="详细实现流程"><a href="#详细实现流程" class="headerlink" title="详细实现流程"></a>详细实现流程</h2><h3 id="1-系统初始化阶段"><a href="#1-系统初始化阶段" class="headerlink" title="1. 系统初始化阶段"></a>1. <strong>系统初始化阶段</strong></h3><ul><li>ADC初始化<ul><li>设置分辨率（如12位），采样时间（如239.5周期，适合低速高精度），以及触发模式（软件或定时器触发）。</li><li>选择目标通道（如光敏电阻接入的ADC通道）。</li></ul></li><li>DMA初始化<ul><li>配置DMA通道，设置外设为ADC数据寄存器，内存目标为事先分配的缓冲区。</li><li>配置传输方向（外设到内存）、数据宽度和缓冲区长度（如采样N点做均值滤波）。</li></ul></li><li>FreeRTOS资源初始化<ul><li>创建定时器（200ms周期）、数据队列（用于任务间通信）、调光任务和采样任务。</li></ul></li></ul><hr><h3 id="2-周期采集启动"><a href="#2-周期采集启动" class="headerlink" title="2. 周期采集启动"></a>2. <strong>周期采集启动</strong></h3><ul><li><p>定时器周期到达</p><p>时（FreeRTOS软件定时器回调里）：</p><ul><li>调用<code>HAL_ADC_Start_DMA</code>，启动ADC和DMA联动采集，DMA自动搬运N个采样数据到缓冲区。</li><li>CPU无需轮询，立即返回，继续执行其他任务，实现高效并行。</li></ul></li></ul><hr><h3 id="3-DMA硬件搬运过程"><a href="#3-DMA硬件搬运过程" class="headerlink" title="3. DMA硬件搬运过程"></a>3. <strong>DMA硬件搬运过程</strong></h3><ul><li>ADC采样后，数据直接写入DMA指定内存。</li><li>CPU资源完全释放，系统其余任务正常调度，极大提升能效和响应能力。</li></ul><hr><h3 id="4-DMA采集完成中断"><a href="#4-DMA采集完成中断" class="headerlink" title="4. DMA采集完成中断"></a>4. <strong>DMA采集完成中断</strong></h3><ul><li><strong>DMA传输完成</strong>后，自动触发中断，执行回调函数（如<code>HAL_ADC_ConvCpltCallback</code>）。</li><li>在回调函数中：<ul><li>数据预处理<ul><li>对N点采样数据做均值或中值滤波，去除偶发噪声，提高数据有效性。</li><li>检查数据有效性（如光强值是否在合理范围，过滤异常值）。</li></ul></li><li>数据通信<ul><li>将处理后的光照强度结果通过FreeRTOS队列（<code>xQueueSendFromISR</code>）发送给调光控制任务。</li></ul></li></ul></li></ul><hr><h3 id="5-调光控制任务"><a href="#5-调光控制任务" class="headerlink" title="5. 调光控制任务"></a>5. <strong>调光控制任务</strong></h3><ul><li>任务采用<strong>阻塞式队列接收</strong>（<code>xQueueReceive</code>）。</li><li>收到新数据后，<strong>根据光强计算PWM占空比</strong>，调用HAL库调整LED PWM输出，实现无级调光。</li><li>调整完成后任务再次阻塞，等待下一个采样周期，确保CPU资源利用最大化。</li></ul><hr><h3 id="6-关键优化点"><a href="#6-关键优化点" class="headerlink" title="6. 关键优化点"></a>6. <strong>关键优化点</strong></h3><ul><li>低功耗<ul><li>采集和处理过程全程DMA自动化，CPU空闲时间长，有利于MCU进入低功耗模式（如Tickless Idle）。</li></ul></li><li>实时性<ul><li>采样、滤波、调光全链路延迟低于20ms，保证照明响应迅速。</li></ul></li><li>代码可维护性<ul><li>采样、处理、调光三部分职责清晰，易于后续功能扩展或参数调整。</li></ul></li></ul><hr><h2 id="关键代码流程片段（伪代码）"><a href="#关键代码流程片段（伪代码）" class="headerlink" title="关键代码流程片段（伪代码）"></a>关键代码流程片段（伪代码）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定时器回调：启动ADC+DMA</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTimerCallback</span><span class="params">(TimerHandle_t xTimer)</span> &#123;</span><br><span class="line">    HAL_ADC_Start_DMA(&amp;hadc1, (<span class="type">uint32_t</span>*)adc_buffer, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. DMA完成中断回调</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_ADC_ConvCpltCallback</span><span class="params">(ADC_HandleTypeDef* hadc)</span> &#123;</span><br><span class="line">    <span class="type">float</span> filtered = filter(adc_buffer, N);</span><br><span class="line">    xQueueSendFromISR(lightQueue, &amp;filtered, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 调光任务</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vDimmingTask</span><span class="params">(<span class="type">void</span> *pvParameters)</span> &#123;</span><br><span class="line">    <span class="type">float</span> lightValue;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        xQueueReceive(lightQueue, &amp;lightValue, portMAX_DELAY);</span><br><span class="line">        <span class="type">uint8_t</span> duty = CalcPWMDuty(lightValue);</span><br><span class="line">        __HAL_TIM_SET_COMPARE(&amp;htim_pwm, TIM_CHANNEL_x, duty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="总结表述建议"><a href="#总结表述建议" class="headerlink" title="总结表述建议"></a>总结表述建议</h2><blockquote><p>在智能调光系统中，我通过配置ADC+DMA实现高效数据采集，利用FreeRTOS定时器精确控制采样周期，DMA全自动搬运数据，极大释放了CPU资源。采集完成后在DMA中断回调中进行滤波与有效性判断，通过队列将结果无缝传给调光任务，调光任务则实时调整PWM，保证照明响应灵敏且系统能效提升30%以上。这种架构兼顾了高响应、低功耗和后续易扩展，完全满足智能照明的实时和稳健需求。期待能将这套高效的架构和优化思路应用到贵公司的相关产品开发中。</p></blockquote><h1 id="FreeRTOS三大冲突解决方案分析"><a href="#FreeRTOS三大冲突解决方案分析" class="headerlink" title="FreeRTOS三大冲突解决方案分析"></a><strong>FreeRTOS三大冲突解决方案分析</strong></h1><h2 id="1-资源冲突（共享资源访问）"><a href="#1-资源冲突（共享资源访问）" class="headerlink" title="1.资源冲突（共享资源访问）"></a>1.资源冲突（共享资源访问）</h2><p><strong>问题描述</strong></p><p>多个任务同时访问OLED显示资源导致数据不一致</p><h3 id="代码解决方案"><a href="#代码解决方案" class="headerlink" title="代码解决方案"></a>代码解决方案</h3><p>CMSIS-RTOS</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 互斥锁创建</span></span><br><span class="line">osMutexDef(Ui_Mutexes_);</span><br><span class="line">Ui_Mutexes_Handle = osMutexCreate(osMutex(Ui_Mutexes_));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 典型使用模式</span></span><br><span class="line"><span class="keyword">if</span>(osMutexWait(Ui_Mutexes_Handle, osWaitForever) == osOK) &#123;</span><br><span class="line">    <span class="comment">// 访问共享资源</span></span><br><span class="line">    LCD_ShowString(<span class="number">60</span>, <span class="number">50</span>, <span class="string">&quot;Hello&quot;</span>, <span class="number">24</span>);</span><br><span class="line">    osMutexRelease(Ui_Mutexes_Handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FreeRTOS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">osMutexId display_mutex;  // 全局互斥量</span><br><span class="line"></span><br><span class="line">void Display_Init(void) &#123;</span><br><span class="line">    display_mutex = xSemaphoreCreateMutex();//创建一个 互斥锁（Mutex）</span><br><span class="line">    configASSERT(display_mutex != NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Safe_Display_Update(const char* msg) &#123;</span><br><span class="line">    if(xSemaphoreTake(display_mutex, pdMS_TO_TICKS(50)) == pdTRUE) //获取（锁定） 一个信号量或互斥锁。   </span><br><span class="line">    // 信号量/互斥锁句柄// 超时时间（单位：Tick）</span><br><span class="line">    &#123;</span><br><span class="line">        taskENTER_CRITICAL();</span><br><span class="line">        LCD_Clear(BLACK);</span><br><span class="line">        LCD_ShowString(10, 10, msg, 16);</span><br><span class="line">        taskEXIT_CRITICAL();</span><br><span class="line">        xSemaphoreGive(display_mutex);//释放（解锁） 一个信号量或互斥锁，允许其他任务获取它。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用二进制信号量实现的互斥量</p><p><code>taskENTER_CRITICAL()</code>&#x2F;<code>taskEXIT_CRITICAL()</code>双重保护</p><p>通过<code>configASSERT</code>检查互斥量创建</p><h2 id="2-优先级冲突（优先级反转）"><a href="#2-优先级冲突（优先级反转）" class="headerlink" title="2.优先级冲突（优先级反转）"></a>2.优先级冲突（优先级反转）</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>高优先级任务因等待低优先级任务持有的资源而阻塞</p><h3 id="任务优先级设置"><a href="#任务优先级设置" class="headerlink" title="任务优先级设置"></a>任务优先级设置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// freertos.c中的优先级定义</span></span><br><span class="line"><span class="type">const</span> osThreadAttr_t UI_Task_attributes = &#123;</span><br><span class="line">  .priority = osPriorityAboveNormal, <span class="comment">// 优先级4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> osThreadAttr_t Sensor_Task_attributes = &#123;</span><br><span class="line">  .priority = osPriorityHigh, <span class="comment">// 优先级5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> osThreadAttr_t Cloud_Rx_Task_attributes = &#123;</span><br><span class="line">  .priority = osPriorityRealtime, <span class="comment">// 优先级6(最高)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="优先级继承机制"><a href="#优先级继承机制" class="headerlink" title="优先级继承机制"></a>优先级继承机制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// FreeRTOSConfig.h配置</span><br><span class="line">#define configUSE_PRIORITY_INHERITANCE 1</span><br></pre></td></tr></table></figure><h2 id="3-死锁防护方案"><a href="#3-死锁防护方案" class="headerlink" title="3. 死锁防护方案"></a>3. 死锁防护方案</h2><h3 id="潜在风险"><a href="#潜在风险" class="headerlink" title="潜在风险"></a>潜在风险</h3><ul><li>递归获取同一互斥锁</li><li>多锁获取顺序不一致</li></ul><h3 id="防御性编程"><a href="#防御性编程" class="headerlink" title="防御性编程"></a>防御性编程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多锁获取顺序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Multi_Lock_Operation</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 固定顺序获取锁</span></span><br><span class="line">  osMutexAcquire(Ui_Mutexes_Handle, osWaitForever);</span><br><span class="line">  osMutexAcquire(DTH11_Mutexex_Handle, osWaitForever);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 操作完成后按相反顺序释放</span></span><br><span class="line">  osMutexRelease(DTH11_Mutexex_Handle);</span><br><span class="line">  osMutexRelease(Ui_Mutexes_Handle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Safe_Sensor_Read</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(xSemaphoreTake(sensor_mutex, pdMS_TO_TICKS(<span class="number">100</span>)) == pdTRUE) &#123;</span><br><span class="line">        <span class="comment">// 读取传感器</span></span><br><span class="line">        xSemaphoreGive(sensor_mutex);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(<span class="number">10</span>)); <span class="comment">// 退避等待</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 强制锁获取顺序</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_ORDER_DISPLAY 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOCK_ORDER_SENSOR  2</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Multi_Lock_Operation</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    Take_Lock_In_Order(LOCK_ORDER_DISPLAY);</span><br><span class="line">    Take_Lock_In_Order(LOCK_ORDER_SENSOR);</span><br><span class="line">    <span class="comment">// 操作...</span></span><br><span class="line">    Release_Lock_In_Reverse_Order();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol><li>单次锁获取（禁止嵌套）</li><li>统一锁获取顺序</li><li>临界区与互斥锁配合使用</li></ol><h1 id="FreeRTOS和CMSIS-RTOS对比"><a href="#FreeRTOS和CMSIS-RTOS对比" class="headerlink" title="FreeRTOS和CMSIS-RTOS对比"></a>FreeRTOS和CMSIS-RTOS对比</h1><p><strong>FreeRTOS</strong>：</p><p>适用于 <strong>纯FreeRTOS项目</strong>，特别是资源受限的嵌入式设备（如STM32、ESP32等）。</p><p>提供更底层的控制，适合对性能要求较高的场景。</p><p>适用于 <strong>单RTOS环境</strong>，不涉及跨平台兼容性需求。</p><p><strong>CMSIS-RTOS</strong>：</p><p>适用于 <strong>跨RTOS兼容性</strong> 需求（如Keil RTX、FreeRTOS、ThreadX等）。</p><p>适合 <strong>基于ARM Cortex-M</strong> 的项目，特别是使用 <strong>STM32CubeMX</strong> 或 <strong>Keil MDK</strong> 开发的项目。</p><p>提供标准化的API，便于代码在不同RTOS间移植。</p><p><strong>关键特性对比</strong></p><table><thead><tr><th><strong>特性</strong></th><th><strong>FreeRTOS 互斥锁</strong></th><th><strong>CMSIS-RTOS 互斥锁</strong></th></tr></thead><tbody><tr><td><strong>API 风格</strong></td><td>底层、直接（<code>xSemaphoreCreateMutex()</code>）</td><td>标准化（<code>osMutexCreate()</code>）</td></tr><tr><td><strong>超时控制</strong></td><td>灵活（<code>pdMS_TO_TICKS(ms)</code>）</td><td>固定（<code>osWaitForever</code> 或 <code>timeout</code>）</td></tr><tr><td><strong>优先级继承</strong></td><td>支持（防止优先级反转）</td><td>取决于底层RTOS实现</td></tr><tr><td><strong>临界区保护</strong></td><td>可额外使用 <code>taskENTER_CRITICAL()</code></td><td>仅依赖互斥锁</td></tr><tr><td><strong>可移植性</strong></td><td>仅适用于FreeRTOS</td><td>跨RTOS兼容</td></tr><tr><td><strong>调试支持</strong></td><td>依赖FreeRTOS调试工具</td><td>兼容CMSIS-RTOS调试工具</td></tr></tbody></table><table><thead><tr><th><strong>FreeRTOS 函数</strong></th><th><strong>CMSIS-RTOS 等效函数</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>xSemaphoreCreateMutex()</code></td><td><code>osMutexNew()</code> &#x2F; <code>osMutexCreate()</code></td><td>创建互斥锁</td></tr><tr><td><code>xSemaphoreTake()</code></td><td><code>osMutexAcquire()</code> &#x2F; <code>osMutexWait()</code></td><td>获取锁</td></tr><tr><td><code>xSemaphoreGive()</code></td><td><code>osMutexRelease()</code></td><td>释放锁</td></tr><tr><td><code>pdMS_TO_TICKS(ms)</code></td><td><code>osWaitForever</code> &#x2F; <code>timeout</code></td><td>超时设置</td></tr></tbody></table><h2 id="关键区别"><a href="#关键区别" class="headerlink" title="关键区别"></a><strong>关键区别</strong></h2><ol><li><strong>优先级继承</strong>：</li></ol><p>FreeRTOS 的 <code>xSemaphoreCreateMutex()</code> <strong>默认支持优先级继承</strong>（防止优先级反转）。</p><p>CMSIS-RTOS 的 <code>osMutexCreate()</code> <strong>取决于底层RTOS实现</strong>（如 Keil RTX 支持，但 FreeRTOS 适配层可能不支持）。</p><ol start="2"><li><strong>超时控制</strong>：</li></ol><p>FreeRTOS 使用 <code>pdMS_TO_TICKS(ms)</code> 转换毫秒到 Tick。</p><p>CMSIS-RTOS 直接使用 <code>osWaitForever</code> 或毫秒超时。</p><ol start="3"><li><strong>临界区保护</strong>：</li></ol><p>FreeRTOS 允许额外使用 <code>taskENTER_CRITICAL()</code> 完全禁止中断（更严格保护）。</p><p>CMSIS-RTOS 仅依赖互斥锁。</p><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="1-队列的基本概念"><a href="#1-队列的基本概念" class="headerlink" title="1.队列的基本概念"></a>1.队列的基本概念</h2><p>•<strong>定义</strong>：</p><p>•队列是一种先进先出（FIFO）的数据结构</p><p>•FreeRTOS 中，队列可以存储固定大小的数据项，每个数据项的大小在创建队列时指定。</p><p><strong>主要特点包括</strong>：</p><ul><li><strong>线程安全</strong>：支持多任务并发访问</li><li><strong>数据传递</strong>：可在任务间或任务与中断间传递数据</li><li><strong>阻塞机制</strong>：支持发送和接收时的任务阻塞</li><li><strong>多种数据类型</strong>：可传输基本类型或自定义结构体</li></ul><p>•<strong>用途</strong>：</p><p>•用于任务间的通信和同步.</p><p>•一个任务可以将数据发送到队列，另一个任务从队列中接收数据。</p><p><strong>1.队列是和任务绑定的么？</strong></p><p>队列在 FreeRTOS 中是一种独立且可被多个任务、中断服务程序共享的通信机制，不与特定的任务绑定。</p><p><strong>2.队列中，除了FIFO，有没有后入先出的可能？</strong></p><p>FreeRTOS 中，标准的队列默认采用先进先出（FIFO）的机制，但也提供了实现后入先出（LIFO）的方式</p><h2 id="2-队列的创建"><a href="#2-队列的创建" class="headerlink" title="2.队列的创建"></a>2.队列的创建</h2><p>FreeRTOS 提供了 xQueueCreate 函数来创建队列</p><p><img src="/./../../images/image-20250701183915837.png" alt="image-20250701183915837"></p><p>•<strong>参数解释</strong>：</p><p>•第一个参数是队列的长度，即队列中最多可以存储的数据项数量。</p><p>•第二个参数是每个数据项的大小（以字节为单位）。</p><p>•<strong>返回值</strong>：</p><p>•如果队列创建成功，返回一个队列句柄；</p><p>•如果创建失败，返回 NULL。</p><p><strong>使用xQueueCreate创建的队列，分配的内存是静态的还是动态的？不用的时候需要删除么？</strong></p><p>使用 xQueueCreate 创建队列，其分配内存是动态的。</p><p>不再使用时，建议使用 vQueueDelete 函数删除队列，以释放之前动态分配的内存。这样可以避免内存泄漏，尤其是在长时间运行的系统或者资源受限的嵌入式系统中，合理释放内存资源非常重要。</p><p>需要使用静态内存来创建队列，可以使用 xQueueCreateStatic 函数。</p><h2 id="3-向队列发送数据"><a href="#3-向队列发送数据" class="headerlink" title="3.向队列发送数据"></a>3.向队列发送数据</h2><h2 id="4-从队列接收数据"><a href="#4-从队列接收数据" class="headerlink" title="4.从队列接收数据"></a>4.从队列接收数据</h2><h2 id="5-队列的其它操作"><a href="#5-队列的其它操作" class="headerlink" title="5.队列的其它操作"></a>5.队列的其它操作</h2><h2 id="6-队列在中断服务中的使用"><a href="#6-队列在中断服务中的使用" class="headerlink" title="6.队列在中断服务中的使用"></a>6.队列在中断服务中的使用</h2><h2 id="7-队列的注意事项"><a href="#7-队列的注意事项" class="headerlink" title="7.队列的注意事项"></a>7.队列的注意事项</h2><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>做⼀个“按键反应测试”类的⼩游戏，利⽤按键控制来增加游戏难度，同时在屏幕上展⽰分数和游戏状态。比如，游戏中会随机闪烁⼀个LED灯，玩家需要在LED</p><p>灯亮起时尽快按下对应的按键来得分，错过或按错就扣分。</p><p>对于这个游戏，你可以在不同章节中引入相关的</p><p>FreeRTOS</p><p>功能：</p><p>概述：介绍游戏的⽬标，</p><p>FreeRTOS的基本框架。 任务：创建不同的任务（比如LED闪烁、分数更新、按键监控等）。 队列：⽤队列管理按键输入。 信号量与互斥量：控制多个任务间的资源访问，比如对OLED屏幕的访问。 定时器与时间管理：⽤于控制游戏时间、LED闪烁间隔等。 外部中断处理：⽤外部中断处理按键的输入。资源管理与内存池：管理游戏中使⽤的资源，避免内存泄漏。 任务通知与事件组：处理游戏的状态切换和任务间的同步，比如任务间通知LED</p><p>闪烁。</p><p>这个游戏完全可以使⽤蜂鸣器来增加互动性和反馈效果！你可以在以下⼏个⽅⾯利⽤蜂鸣器：</p><p>正确按键反馈：当玩家按对了按键时，蜂鸣器可以发出⼀个短促的</p><p>“嘀”声，表⽰玩家得分。 错误按键反馈：如果玩家按错了按键，蜂鸣器可以发出较⻓的“哔哔”声，表⽰失败。 游戏结束提醒：当游戏结束时，蜂鸣器可以发出⼀个响亮的“结束⾳”，提⽰玩家游戏已结束。 时间倒计时提醒：在游戏过程中，蜂鸣器还可以在倒计时结束时发出⼀声提⽰⾳，提醒玩家游戏时间即将耗尽。</p>]]></content>
      
      
      <categories>
          
          <category> RTOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>韦东山</title>
      <link href="/2024/08/06/test/%E9%9F%A6%E4%B8%9C%E5%B1%B1linux/"/>
      <url>/2024/08/06/test/%E9%9F%A6%E4%B8%9C%E5%B1%B1linux/</url>
      
        <content type="html"><![CDATA[<p><img src="/./../../images/image-20250521175813146.png" alt="image-20250521175813146"></p><p>hexdump是Linux下的一个二进制文件查看工具，它可以将二进制文件转换为ASCII、八进制、十进制、十六进制格式进行查看。</p><p><code>echo</code> 是 Linux 系统中一个非常常用的命令，主要用于在终端输出字符串或变量的值。</p>]]></content>
      
      
      <categories>
          
          <category> 韦东山linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 韦东山linux </tag>
            
            <tag> 编程技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法碎片</title>
      <link href="/2024/08/06/test/c%E5%92%8Cc++/%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E7%A2%8E%E7%89%87/"/>
      <url>/2024/08/06/test/c%E5%92%8Cc++/%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E7%A2%8E%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h1 id="蔡勒公式："><a href="#蔡勒公式：" class="headerlink" title="蔡勒公式："></a>蔡勒公式：</h1><p>计算星期几的常用方法之一是使用“<strong>蔡勒公式</strong>”（Zeller’s Congruence）。这个公式可以计算给定日期对应的星期几，具体步骤如下：</p><h1 id="蔡勒公式的步骤："><a href="#蔡勒公式的步骤：" class="headerlink" title="蔡勒公式的步骤："></a><strong>蔡勒公式的步骤</strong>：</h1><ol><li><p><strong>调整月份与年份</strong>：</p><ul><li>如果月份是1月（1）或2月（2），则将其视为前一年的13月或14月，并将年份减1。</li><li>对于其他月份，直接使用该月份和年份。</li></ul></li><li><p><strong>设定公式变量</strong>：</p><ul><li>设定以下变量：<ul><li>：日期（一个月中的日）</li><li>：月份（3-12代表3月到12月，1月和2月用13和14表示）</li><li>：年份的后两位（year % 100）</li><li>：年份的前两位（year &#x2F; 100）</li></ul></li></ul></li><li><p><strong>应用公式计算</strong>：</p><ul><li><p>使用公式计算： </p></li><li><p><img src="/2024/08/06/test/c%E5%92%8Cc++/%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E7%A2%8E%E7%89%87/Users\Administrator.OMEN\AppData\Roaming\Typora\typora-user-images\image-20241113212816146.png" alt="image-20241113212816146"></p></li><li><p>其中，</p><p>的值代表星期：</p><ul><li>0 &#x3D; Saturday</li><li>1 &#x3D; Sunday</li><li>2 &#x3D; Monday</li><li>3 &#x3D; Tuesday</li><li>4 &#x3D; Wednesday</li><li>5 &#x3D; Thursday</li><li>6 &#x3D; Friday</li></ul></li></ul></li></ol><h2 id="示例C语言实现："><a href="#示例C语言实现：" class="headerlink" title="示例C语言实现："></a><strong>示例C语言实现</strong>：</h2><p>以下是使用蔡勒公式计算任何给定日期的星期几的示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getDayOfWeek</span><span class="params">(<span class="type">int</span> year, <span class="type">int</span> month, <span class="type">int</span> day)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (month &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        month += <span class="number">12</span>; <span class="comment">// 将1月和2月视为上一年的13月和14月</span></span><br><span class="line">        year--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> q = day;                       <span class="comment">// 日期</span></span><br><span class="line">    <span class="type">int</span> m = month;                     <span class="comment">// 月份</span></span><br><span class="line">    <span class="type">int</span> K = year % <span class="number">100</span>;                <span class="comment">// 年份的后两位</span></span><br><span class="line">    <span class="type">int</span> J = year / <span class="number">100</span>;                <span class="comment">// 年份的前两位</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 蔡勒公式</span></span><br><span class="line">    <span class="type">int</span> h = (q + (<span class="number">13</span> * (m + <span class="number">1</span>)) / <span class="number">5</span> + K + (K / <span class="number">4</span>) + (J / <span class="number">4</span>) - <span class="number">2</span> * J) % <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h; <span class="comment">// 返回星期几</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> year = <span class="number">2024</span>;</span><br><span class="line">    <span class="type">int</span> month = <span class="number">10</span>; <span class="comment">// 例如10月</span></span><br><span class="line">    <span class="type">int</span> day = <span class="number">1</span>;    <span class="comment">// 例如1日</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> weekday = getDayOfWeek(year, month, day);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;日期 %d-%d-%d 是星期：%d\n&quot;</span>, year, month, day, weekday);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CopyInsert</p><p>运行这段代码可以计算给定日期（例如2024年10月1日）对应的星期几。在这个示例中，输出的星期会以数字形式显示，可以根据前面提到的对应关系来判断具体是哪一天。</p>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程技巧 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 代码优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法自带格式(如何写博客)</title>
      <link href="/2024/08/06/test/%E5%8D%9A%E5%AE%A2/Markdown%E8%AF%AD%E6%B3%95%E8%87%AA%E5%B8%A6%E6%A0%BC%E5%BC%8F(%E5%A6%82%E4%BD%95%E5%86%99%E5%8D%9A%E5%AE%A2)/"/>
      <url>/2024/08/06/test/%E5%8D%9A%E5%AE%A2/Markdown%E8%AF%AD%E6%B3%95%E8%87%AA%E5%B8%A6%E6%A0%BC%E5%BC%8F(%E5%A6%82%E4%BD%95%E5%86%99%E5%8D%9A%E5%AE%A2)/</url>
      
        <content type="html"><![CDATA[<p><img src="/./../images/bywind.png" alt="图"></p><p>用Typora软件更简单</p><p><a href="https://www.bilibili.com/video/BV1iHaTe9EZ3/?spm_id_from=333.337.search-card.all.click&vd_source=390e7ea253547d9c75882d502ff42a1b">Typora安装激活流程_哔哩哔哩_bilibili</a></p><p>Typora安装文件及下载地址~<br>链接:<a href="https://pan.baidu.com/s/17CunIoob5JbtQZ1N5ZIyfg?pwd=zspz">https://pan.baidu.com/s/17CunIoob5JbtQZ1N5ZIyfg?pwd=zspz</a> 提取码:zspz</p><p>一键3连 上传代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl&amp;&amp;hexo g&amp;&amp;hexo d</span><br></pre></td></tr></table></figure><h2 id="多级标题"><a href="#多级标题" class="headerlink" title="多级标题"></a>多级标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure><h2 id="文字样式"><a href="#文字样式" class="headerlink" title="文字样式"></a>文字样式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span>&gt;</span></span>5号字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>这里的背景色是：MistyRosen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure><h2 id="1-5-分割线"><a href="#1-5-分割线" class="headerlink" title="1.5 分割线"></a>1.5 分割线</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><p>​分栏 tab</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><ol><li>Unique name :<ul><li>选项卡块标签的唯一名称，不带逗号。</li><li>将在#id中用作每个标签及其索引号的前缀。</li><li>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</li><li>仅当前帖子&#x2F;页面的URL必须是唯一的！</li></ul></li><li>[index]:<ul><li>活动选项卡的索引号。</li><li>如果未指定，将选择第一个标签（1）。</li><li>如果index为-1，则不会选择任何选项卡。</li><li>可选参数。</li></ul></li><li>[Tab caption]:<ul><li>当前选项卡的标题。</li><li>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</li><li>如果未指定标题，但指定了图标，则标题将为空。</li><li>可选参数。</li></ul></li><li>[@icon]:<ul><li>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</li><li>可以指定带空格或不带空格；</li><li>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</li><li>可选参数。</li></ul></li></ol><p>示例1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 1.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 2.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line">**This is Tab 3.**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>示例2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line">**tab名字为第一个Tab**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line">**只有图标 没有Tab名字**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line">**名字+icon**</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>示例1</p><p>.<div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">test1 1</button><button type="button" class="tab">test1 2</button><button type="button" class="tab">test1 3</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>This is Tab 1.</strong></p></div><div class="tab-item-content"><p><strong>This is Tab 2.</strong></p></div><div class="tab-item-content"><p><strong>This is Tab 3.</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></p><p>示例2</p><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">第一个Tab</button><button type="button" class="tab"><i class="fab fa-apple-pay"></i></button><button type="button" class="tab"><i class="fas fa-bomb"></i>炸弹</button></div><div class="tab-contents"><div class="tab-item-content active"><p><strong>tab名字为第一个Tab</strong></p></div><div class="tab-item-content"><p><strong>只有图标 没有Tab名字</strong></p></div><div class="tab-item-content"><p><strong>名字+icon</strong></p></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div><h2 id="音频-audio"><a href="#音频-audio" class="headerlink" title="音频 audio"></a>音频 audio</h2><div class="tabs"><div class="nav-tabs"><button type="button" class="tab active">参数配置</button><button type="button" class="tab">示例代码</button><button type="button" class="tab">演示</button></div><div class="tab-contents"><div class="tab-item-content active"></div><div class="tab-item-content"></div><div class="tab-item-content"></div></div><div class="tab-to-top"><button type="button" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div>]]></content>
      
      
      <categories>
          
          <category> 博客写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 写作技巧 </tag>
            
            <tag> 博客指南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>车载基础知识</title>
      <link href="/2024/06/06/test/%E8%BD%A6%E8%BD%BD%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/06/06/test/%E8%BD%A6%E8%BD%BD%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/./../../images/image-20250506131349931.png" alt="image-20250506150752230"></p><p><img src="/./../../images/image-20250506131321041.png" alt="image-20250506150752230"></p><p><img src="/./../../images/image-20250506132441378.png" alt="image-20250506150752230"></p><p><img src="/./../../images/image-20250506132455224.png" alt="image-20250506150752230"></p><p><img src="/./../../images/image-20250506133501197.png" alt="image-20250506150752230"></p><p><img src="/./../../images/image-20250506133535453.png" alt="image-20250506150752230"></p><p><img src="/./../../images/image-20250506143413334.png" alt="image-20250506150752230"></p><p>车载技术基础<br><img src="/./../../images/image-20250506143948308.png" alt="image-20250506150752230"></p><p>更偏向软件方面</p><ol><li><strong>自动驾驶</strong>：这个领域涉及到开发和集成自动驾驶技术，包括传感器融合、决策算法、控制策略等，以实现车辆的自主导航和操作。</li><li><strong>智能座舱</strong>：智能座舱是指车辆内部的智能化系统，包括信息娱乐系统、驾驶员监控系统、乘客交互界面等，旨在提升驾驶体验和安全性。</li><li><strong>SOA和软总线</strong>：SOA（面向服务的架构）是一种软件设计模式，软总线则可能指的是软件定义的通信总线，这些技术有助于实现车辆内部不同系统之间的高效通信和集成。</li><li><strong>网络产品</strong>：这可能涉及到车辆的网络连接解决方案，包括车联网（V2X）、车载信息娱乐系统的网络服务等，以实现车辆与外部世界的连接。</li><li><strong>视觉产品</strong>：这个领域可能包括车载摄像头系统、图像处理算法等，用于车辆的环境感知、驾驶员监控、乘客识别等功能。</li><li><strong>车身控制</strong>：车身控制涉及到车辆的各种电子控制单元（ECU），如车窗控制、车内照明、车门锁定等，以实现车辆的智能化管理。<br><img src="/./../../images/image-20250506144424064.png" alt="image-20250506150752230"></li></ol><p>汽车业务市场情况可以分为以下三个势力：</p><ol><li><strong>传统车企</strong>：<ul><li>这些是基于原有的燃油车智能化以及转型生产电动车的车企。它们通常拥有悠久的历史和深厚的技术积累，正在逐步向智能化和电动化转型。图片中列举了包括通用汽车（GM）、奥迪（Audi）、宝马（BMW）、奔驰（Mercedes-Benz）、大众（Volkswagen）、丰田（Toyota）等在内的多家知名传统汽车制造商。</li></ul></li><li><strong>新兴造车企业</strong>：<ul><li>这些是从特斯拉（Tesla）出现后，特别是国内近几年产生的全新造车企业。它们通常以电动车为主要产品，已经量产了多个车型并且拥有一定的技术积累。图片中提到的新兴造车企业包括特斯拉（Tesla）、Rivian、Lucid、蔚来（NIO）、理想（Li Auto）、小鹏汽车（XPeng Motors）、零跑汽车（Leapmotor）、威马汽车（WM Motor）等。</li></ul></li><li><strong>高技术企业</strong>：<ul><li>这些是新进入局以及较大可能进入汽车行业的高技术企业。它们可能原本并非汽车制造商，但凭借在高科技领域的技术优势，有潜力进入汽车行业。图片中提到的可能进入汽车行业的高技术企业包括苹果（Apple）、索尼（Sony）、富士康（Foxconn）、小米（Xiaomi）、华为（Huawei）等。</li></ul></li></ol><p> </p><p><img src="/./../../images/image-20250506144652829.png" alt="image-20250506150752230"></p><ul><li><strong>主机厂，OEM，车厂</strong>：这些词都指的是那些生产和销售汽车的大公司。它们有完整的生产线，可以自己采购各种零部件，然后组装成一辆完整的汽车。就像是汽车界的“大厨”，负责把各种“食材”（零部件）做成一道“大餐”（整车）。比如北京奔驰、上汽乘用车厂、小米汽车这些。</li><li><strong>Tier1（一级供应商）</strong>：这些公司是直接给主机厂提供零部件或服务的。就像是给“大厨”提供“食材”的供应商。比如安徽智途公司可能会把他们生产的电子控制单元（ECU）卖给江淮乘用车厂，智途就是Tier1供应商；中科创达为通用汽车（GM）开发软件，中科创达也是Tier1供应商。</li><li><strong>Tier2（二级供应商）</strong>：这些公司是给Tier1供应商提供商品或服务的。就像是给“食材”供应商提供原材料的公司。比如创达南京分公司可能会为安徽智途开发软件，创达就是Tier2供应商。</li><li><strong>ECU（电子控制单元）</strong>：ECU就像是汽车的“大脑”，负责控制汽车的各种功能。它通过接收各种传感器的数据，来判断汽车的状态，然后指挥汽车的各个部分工作。比如控制发动机的运转、刹车系统的工作等等。</li></ul><p><img src="/./../../images/image.png" alt="img"></p><p>EE架构，全称是电子电气（Electrical&#x2F;Electronic）架构，是汽车中所有电子和电气系统的框架设计。它定义了车辆内部各个电子控制单元（ECU）的布局、通信方式、功能分配以及它们如何相互作用。EE架构是汽车电子系统的核心，它直接影响到车辆的性能、安全性、舒适性和燃油效率。</p><p>随着汽车技术的发展，EE架构也在不断演进，以适应新的功能和需求，比如增加的电子设备、更复杂的传感器系统、车载信息娱乐系统、自动驾驶技术等。EE架构的演进大致可以分为以下几个阶段：</p><ol><li><strong>分布式架构</strong>：<ul><li>在这个阶段，汽车的每个功能都有自己的电子控制单元（ECU）。这些ECU是独立的，通过CAN（控制器局域网）或LIN（局域互联网络）总线通信。</li><li>每个ECU都有自己的传感器和算法，它们之间的通信不多。</li><li>这种架构的缺点是布线复杂，需要大量的内部通信，导致成本增加。</li></ul></li><li><strong>域集中式架构</strong>：<ul><li>这个阶段将汽车的电子部件功能划分为几个域，如动力域、底盘域、座舱域、驾驶域和车身控制域。</li><li>每个域都有自己的域控制器，域控制器通过CAN或以太网（Ethernet）网络将分散的ECU集中到一起。</li><li>这种架构的优点是更容易实现OTA（空中下载）升级，提高运算能力，支持更灵活的通信网络，同时对信息安全和功能安全的要求更高。</li></ul></li><li><strong>中央集中式架构</strong>：<ul><li>在这个阶段，主控制器的运算能力进一步提高，出现了超级电脑的设计。</li><li>整个系统中复杂的运算功能都集中到一个设备上，这个设备配置有强大的CPU和运算加速器，可以更有效地利用硬件性能。</li><li>这种架构的优点是简化了布线设计，降低了成本，同时支持软件功能的迭代与扩展。</li></ul></li></ol><p><img src="/./../../images/image-20250506145833055.png" alt="image-20250506145833055"></p><p><img src="/./../../images/image-20250506150752230.png" alt="image-20250506150752230"></p><ol><li><strong>SOP</strong>：Start of Production的缩写，指的是芯片开始量产的时间。</li></ol><p><img src="/./../../images/image-20250506153008648.png" alt="image-20250506153008648"></p><ol><li><strong>处理器</strong>：<ul><li>包括CPU（中央处理器）、GPU（图形处理器）、NPU（神经网络加速器）等，就像是电脑的大脑，负责思考和处理各种信息。</li><li>处理视频、音频等，就像是电脑处理图片和声音一样。</li><li>有各种接口，可以连接摄像头、麦克风等设备，就像是电脑的USB接口可以连接鼠标、键盘。</li></ul></li><li><strong>存储器</strong>：<ul><li>RAM（随机访问存储器）：就像是电脑的内存，用来临时存放正在处理的数据，断电后数据会消失。</li><li>ROM（只读存储器）：包括SSD、Flash、SD卡、硬盘等，用来长期存放数据，断电后数据不会消失。</li></ul></li><li><strong>安全和控制系统</strong>：<ul><li>就像是电脑的安全软件，负责保护系统安全，防止未经授权的访问。</li><li>控制电源管理，就像是电脑的电源管理功能，控制电源的开关和分配。</li></ul></li><li><strong>通信部分</strong>：<ul><li>板子内部通信接口：就像是电脑内部的连接线，用来连接不同的部件。</li><li>外部通信接口：包括LVDS、USB、CAN、以太网等，用来连接显示屏、摄像头和其他电子控制单元（ECU），就像是电脑连接显示器、打印机等设备。</li><li>座舱平台需要处理大量的音视频数据，所以接口的带宽（数据传输速度）很高。</li></ul></li></ol><p><img src="/./../../images/image-20250506153500766.png" alt="image-20250506153500766"></p><p><img src="/./../../images/image-1746517001188-3.png" alt="img"></p><p>音频系统</p><ol><li><strong>通过板载音频DSP和功放</strong>：<ul><li>板载音频DSP（数字信号处理器）就像是音频系统的大脑，负责处理音频信号，比如调整音量、平衡、音效等。</li><li>功放（功率放大器）则负责将音频信号放大，以便能够驱动扬声器发出声音。</li><li>在这种连接方式中，音频DSP和功放都集成在同一个电路板上，通过I2S&#x2F;TDM（一种音频数据传输协议）与SoC（系统级芯片）通信。</li></ul></li><li><strong>通过外部音频DSP和功放</strong>：<ul><li>在这种方式中，音频DSP和功放是分开的，位于不同的电路板上。</li><li>SoC通过I2S&#x2F;TDM与外部DSP通信，DSP再通过I2C（一种简单的串行通信协议）与功放通信。</li><li>这种方式提供了更大的灵活性，因为DSP和功放可以独立选择和更换。</li></ul></li><li><strong>通过芯片内部的DSP处理音效</strong>：<ul><li>在这种方式中，SoC内部集成了DSP，可以直接处理音频信号。</li><li>音频信号通过I2S&#x2F;TDM传输到SoC内部的DSP进行处理，然后通过I2C与音频DAC&#x2F;ADC（数字模拟转换器&#x2F;模拟数字转换器）通信，最后通过内部功放输出到扬声器。</li><li>这种方式简化了系统设计，因为所有功能都集成在SoC内部。</li></ul></li></ol><p>自动驾驶</p><p><img src="/./../../images/image-20250506154033968.png" alt="image-20250506154033968"></p><p>要认真对待 </p><p><img src="/./../../images/image-20250506160335715.png" alt="image-20250506160335715"></p><p><img src="/./../../images/image-20250506160819356.png" alt="image-20250506160819356"></p><h1 id="故障分析"><a href="#故障分析" class="headerlink" title="故障分析"></a>故障分析</h1><p><img src="/./../../images/image-20250513140813946.png" alt="image-20250513140813946"></p><p><img src="/./../../images/image-20250513141619558.png" alt="image-20250513141619558"></p><p><img src="/./../../images/image-20250513143344174.png" alt="image-20250513143344174"></p><p><img src="/./../../images/image-20250513143428524.png" alt="image-20250513143428524"></p><p>​</p><p><img src="/./../../images/image-20250513143815538.png" alt="image-20250513143815538"></p><p><img src="/./../../images/image-20250513144051469.png" alt="image-20250513144051469"></p><p>根本原因分析（RCA）是一种结构化的问题解决方法，旨在通过识别、分析和解决根本原因来防止问题再次发生。该方法具有三个主要优点：能够明确问题定义，清晰地识别和说明问题的因果关系，以及有效定位问题的真正根源。实施RCA的基本步骤包括：首先把握现状，识别和澄清问题；其次进行原因调查，探究为何问题未被及时发现；然后进行问题纠正，采取措施处理导致问题的根本原因；最后是再发防止，通过改进措施确保问题不会重复发生。此外，该方法还包括对问题发生的不同层面进行分析，从直接原因到根本原因，以及制定相应的对策来防止问题再次流出。</p><h1 id="开发环境之——git与repo的使用＜1＞"><a href="#开发环境之——git与repo的使用＜1＞" class="headerlink" title="开发环境之——git与repo的使用＜1＞"></a>开发环境之——git与repo的使用＜1＞</h1><p><img src="/./../../images/image-20250513144831104.png" alt="image-20250513144831104"></p><p>版本控制系统是一种用于记录文件内容变化并帮助实现版本控制的系统，它可以让用户在未来查阅特定版本的修订情况。根据其架构和工作方式，版本控制系统可以分为三种类型：本地版本控制系统（RCS），集中式版本控制系统（如CVS、SVN、Perforce），以及分布式版本控制系统（如Git、Mercurial、Bazaar、Darcs、BitKeeper）。这些系统帮助团队有效地管理代码和文档的变更历史，确保项目的协作和版本追踪。</p><p><img src="/./../../images/image-20250513150040756.png" alt="image-20250513150040756"></p><p>分布式版本控制系统是一种允许每个用户计算机上都保存有完整的版本历史记录的系统，它不依赖于中央服务器来存储所有的版本信息。在这种系统中，每个用户的计算机（如Computer A和Computer B）都可以独立地保存文件的所有版本，包括版本1、版本2和版本3。这样的设计提高了系统的灵活性和容错性，因为即使中央服务器出现问题，各个用户的计算机上仍然可以访问到完整的版本历史。此外，这种系统还支持用户在没有网络连接的情况下工作，并且可以在任何时候与其他用户的版本进行合并和同步，从而促进了协作和版本控制的效率。</p><p><img src="/./../../images/image-20250513150658075.png" alt="image-20250513150658075"></p><p>Git是一个由Linus Torvalds在2005年开发的分布式版本控制系统，旨在支持Linux kernel项目。它允许用户在本地计算机上建立一个空目录，并从远程服务器同步一个或多个项目的内容，每个工作目录都是项目的完整拷贝，包含全部的版本历史信息。使用Git时，用户可以在不需要联网的情况下查看文件的变化和进行提交操作，这使得Git非常适合分布式协作和版本控制。</p><p>git不需要联网</p><p>Git 作为一个分布式版本控制系统，其设计允许用户在本地进行大部分的操作，这意味着在很多情况下，确实不需要联网。用户可以在本地仓库中进行文件的版本控制操作，如提交（commit）、查看历史记录（log）、分支（branch）和合并（merge）等，这些操作都不需要网络连接。</p><p>然而，Git 的强大之处也在于它支持远程仓库的管理。当你需要与他人协作或者将你的代码推送（push）到远程仓库（如GitHub、GitLab等），或者从远程仓库拉取（pull）最新的代码时，就需要联网。此外，一些Git命令，如克隆（clone）一个远程仓库，或者与远程仓库进行交互的命令（如fetch、pull、push），也需要网络连接。</p><p><img src="/./../../images/image-20250513150908742.png" alt="image-20250513150908742"></p><p><img src="/./../../images/image-20250513150957026.png" alt="image-20250513150957026"></p><p><img src="/./../../images/image-20250513151131934.png" alt="image-20250513151131934"></p><h4 id="为什么使用git"><a href="#为什么使用git" class="headerlink" title="为什么使用git"></a>为什么使用git</h4><p>Git是一个高效且设计简单的分布式版本控制系统，它能够支持大规模项目如Linux内核的开发，允许上千个并行开发的分支。Git的一个显著特点是它直接快照文件系统的状态，而不是比较文件差异，这样可以更高效地管理版本。几乎所有的操作都可以在本地执行，不需要联网，这使得Git在本地磁盘上保存着所有有关当前项目的历史更新。Git还通过计算内容的校验和（checksum）来保持数据的完整性，确保数据的唯一标识和索引。此外，Git的多数操作仅涉及将数据添加到数据库，这进一步增强了其性能和可靠性。这些特性使得Git成为现代软件开发中不可或缺的工具。</p><p><img src="/./../../images/image-20250513151304914.png" alt="image-20250513151304914"></p><p>git的三种状态、3个工作区域</p><p>Git通过三种状态和三个工作区域来管理文件和项目版本。三种状态包括：已提交（committed），表示文件已经被安全地保存在本地数据库中；已修改（modified），表示文件自上次提交后已经发生了变化，但还没有保存到数据库；已暂存（staged），表示文件的当前修改已被标记，准备在下一次提交时保存到数据库。</p><p>三个工作区域分别是：本地数据目录，即项目的完整历史记录；工作目录，即项目文件的当前工作副本；暂存区域，即索引文件，用于暂存下次提交要保存的文件列表。</p><p>Git的工作流程通常包括以下步骤：首先从本地数据目录检出项目到工作目录，然后在工作目录中对文件进行修改，接着将修改后的文件暂存，最后将暂存的文件提交到本地数据目录，完成一次版本更新。这个过程确保了文件的变更被有序地管理和记录，便于后续的版本控制和协作开发。</p><p><img src="/./../../images/image-20250513151429998.png" alt="image-20250513151429998"></p><p>在Git中，分支是指项目的不同开发版本，它们共享一个共同的历史记录，但每个分支可以独立地发展自己的历史。分支的创建总是从某个已有的提交（通常是主分支）开始，然后从那个点分叉出去，形成新的发展路径。这种机制允许开发者在不影响主分支的情况下进行实验性开发或修复bug。图中展示了项目的原始开发线（Original line of development），以及从这条线上分出的三个分支（1st branch、2nd branch、3rd branch），每个分支都代表了项目的一个不同发展方向。通过这种方式，Git支持并行开发和灵活的项目管理。</p><p><img src="/./../../images/image-20250513152442097.png" alt="image-20250513152442097"><img src="/./../../images/image-20250513152502889.png" alt="image-20250513152502889"></p><p>Git中的分支机制允许开发者从项目的任何提交点创建新的分支，每个分支都代表项目的一个独立开发路径。分支的创建和销毁成本非常低，这使得它们非常适合用于实验性开发、特性开发或修复bug等任务。</p><p>在Git中，每个提交（commit）都可以建立分支，这意味着开发者可以从项目的任何历史点分叉出新的开发线。分支的创建是通过指向提交的可变指针来实现的，这些指针可以移动到不同的提交，从而形成不同的开发路径。每个分支都有自己的历史，但它们可以共享共同的提交历史。</p><p>图中展示了Git分支的工作原理：</p><ol><li>第一张图展示了一个项目的提交历史，其中包含了多个分支（如master、testing、1st branch、2nd branch、3rd branch）。每个分支都从某个提交点开始，然后发展自己的历史。</li><li>第二张图展示了从master分支创建新分支的过程。每个提交（如f30ab、34ac2、98ca9）都可以作为新分支的起点，新分支可以独立地进行开发，而不会影响其他分支。</li></ol><p><img src="/./../../images/image-20250513152626995.png" alt="image-20250513152626995"></p><p>使用例子</p><p>在Git中，分支的使用允许开发者在不影响主分支的情况下处理不同的开发任务。例如，在正常开发过程中，如果需要解决一个特定的问题（如问题#53），但又不能干扰主分支，可以创建一个新的分支专门用于这个问题的修复。在这个新分支上，开发者可以提交修复代码，而主分支则可以继续其正常的开发流程。</p><p>当紧急修复完成时，可以通过合并操作将这个分支的更改整合回主分支。这种策略不仅提高了开发效率，还确保了主分支的稳定性。通过这种方式，Git的分支机制支持并行开发和灵活的问题处理，使得项目管理更加高效和有序。</p><h4 id="GIT分支合并及冲突解决"><a href="#GIT分支合并及冲突解决" class="headerlink" title="GIT分支合并及冲突解决"></a>GIT分支合并及冲突解决</h4><h3 id="Git分支合并"><a href="#Git分支合并" class="headerlink" title="Git分支合并"></a>Git分支合并</h3><p>分支合并是Git中一个非常常见的操作，它允许开发者将一个分支的更改整合到另一个分支中。这通常发生在开发新功能或修复问题时，开发者会在一个单独的分支上进行工作，然后将这些更改合并回主分支（如<code>main</code>或<code>master</code>）。</p><h4 id="使用git-merge命令"><a href="#使用git-merge命令" class="headerlink" title="使用git merge命令"></a>使用<code>git merge</code>命令</h4><p>最直接的分支合并方式是使用<code>git merge</code>命令。假设你有两个分支：<code>main</code>和<code>feature</code>，你在<code>feature</code>分支上开发了一些新功能，现在想要将这些更改合并到<code>main</code>分支。首先，你需要切换到<code>main</code>分支，使用命令<code>git checkout main</code>。然后，执行<code>git merge feature</code>，Git会尝试将<code>feature</code>分支的更改合并到<code>main</code>分支。如果合并过程中没有冲突，Git会自动完成合并，并创建一个新的合并提交。这个合并提交会记录两个分支的合并历史，使得代码的变更过程更加清晰。</p><h4 id="使用git-rebase命令"><a href="#使用git-rebase命令" class="headerlink" title="使用git rebase命令"></a>使用<code>git rebase</code>命令</h4><p>除了<code>git merge</code>，<code>git rebase</code>也是一种常用的分支合并方式。<code>git rebase</code>的作用是将当前分支的更改重新应用到另一个分支的顶部。例如，如果你希望让<code>feature</code>分支的更改基于<code>main</code>分支的最新状态，可以执行<code>git rebase main</code>。这样，<code>feature</code>分支的提交会重新应用到<code>main</code>分支的最新提交之后。这种方式可以使<code>feature</code>分支的提交历史更加清晰，避免了复杂的合并提交。在完成<code>rebase</code>之后，你可以使用<code>git merge</code>将<code>feature</code>分支合并到<code>main</code>分支，或者直接将<code>feature</code>分支的更改推送到远程仓库（如果<code>feature</code>分支已经推送到远程仓库）。</p><hr><h3 id="Git冲突解决"><a href="#Git冲突解决" class="headerlink" title="Git冲突解决"></a>Git冲突解决</h3><p>尽管Git在合并分支时会尽量自动处理更改，但当多个分支对同一部分代码进行了不同的更改时，合并过程中可能会出现冲突。冲突需要手动解决，以下是解决冲突的详细步骤：</p><h4 id="查看冲突"><a href="#查看冲突" class="headerlink" title="查看冲突"></a>查看冲突</h4><p>当合并分支时，如果出现冲突，Git会在冲突的文件中标记冲突的内容。冲突的文件中会包含如下标记：<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>表示当前分支的更改，<code>=======</code>是分隔符，表示冲突的分界点，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>表示另一个分支的更改。例如，冲突的代码可能看起来像这样：</p><p>plaintext</p><p>复制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">当前分支的代码</span><br><span class="line">=======</span><br><span class="line">另一个分支的代码</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature</span><br></pre></td></tr></table></figure><p>你可以使用<code>git status</code>命令查看哪些文件存在冲突。Git会明确指出哪些文件需要解决冲突。</p><h4 id="手动解决冲突"><a href="#手动解决冲突" class="headerlink" title="手动解决冲突"></a>手动解决冲突</h4><p>解决冲突通常需要手动编辑冲突的文件。打开冲突的文件，根据实际情况选择保留、修改或删除冲突的内容。例如，如果决定保留当前分支的更改，则删除<code>=======</code>和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>之间的内容，以及<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>和<code>=======</code>之间的标记。如果决定采用另一个分支的更改，则删除<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>和<code>=======</code>之间的内容，以及<code>=======</code>和<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>之间的标记。当然，也可以根据需要对代码进行修改，以整合两个分支的更改。</p><h4 id="标记冲突解决"><a href="#标记冲突解决" class="headerlink" title="标记冲突解决"></a>标记冲突解决</h4><p>在解决冲突后，需要使用<code>git add &lt;file&gt;</code>命令将冲突的文件标记为已解决。这一步非常重要，因为Git需要知道冲突已经被处理。之后，执行<code>git commit</code>命令完成合并提交。如果你使用的是<code>git rebase</code>，在解决冲突后，还需要执行<code>git rebase --continue</code>继续<code>rebase</code>过程。</p><h4 id="使用工具辅助解决冲突"><a href="#使用工具辅助解决冲突" class="headerlink" title="使用工具辅助解决冲突"></a>使用工具辅助解决冲突</h4><p>Git支持使用图形化工具来解决冲突，这可以大大简化冲突解决的过程。例如，你可以使用<code>git mergetool</code>命令，Git会自动启动配置的合并工具（如<code>meld</code>、<code>kdiff3</code>等）。在工具中，你可以直观地比较和选择保留或修改冲突的内容。工具会自动将解决后的文件标记为已解决，从而避免了手动编辑文件和标记解决的繁琐过程。</p><hr><p>通过以上方法，你可以有效地进行Git分支合并和冲突解决，从而更好地管理代码版本。分支合并和冲突解决是团队协作开发中不可或缺的部分，掌握这些技能可以帮助你更高效地进行代码管理和协作</p><p><img src="/./../../images/image-20250513210431768.png" alt="image-20250513210431768"></p><p>Repo工具确实是专门为Android操作系统设计的，用于管理多个Git仓库。以下是Repo工具的一些关键信息和用途：</p><ol><li><strong>多仓库管理</strong>：Repo是一个基于Python的脚本工具，它封装了多条Git命令，帮助开发者管理Android源码中的多个Git仓库。这对于大型项目和团队协作尤为重要。</li><li><strong>初始化和同步</strong>：使用<code>repo init</code>命令初始化项目，该命令会读取一个叫做<code>manifest</code>的XML配置文件，定义了项目中需要的Git仓库和版本。<code>repo sync</code>命令用于同步代码，克隆或更新项目中所有Git仓库。</li><li><strong>分支操作</strong>：<code>repo start &lt;branch_name&gt; --all</code>命令用于在所有仓库中创建新的本地分支，便于跨模块开发。</li><li><strong>代码审查</strong>：<code>repo upload</code>命令将本地提交推送到代码审核平台（如Gerrit），自动关联多个子仓库的变更，确保依赖关系正确。</li><li><strong>清单文件（Manifest）</strong>：Repo使用清单文件定义所有子仓库的版本、分支和依赖关系，简化了开发者的代码同步、提交和代码审核流程。</li><li><strong>与Gerrit集成</strong>：Repo与Gerrit代码审核系统集成，简化了代码审核和合并流程。</li><li><strong>解决冲突</strong>：Repo工具提供了解决冲突的场景，如本地代码过期、跨仓库依赖冲突等。</li><li><strong>下载和安装</strong>：Repo工具可以从官方的Git仓库下载，并且可以通过简单的命令添加到系统的PATH变量中，以便在终端中使用。</li></ol><p>git常用命令</p><p><img src="/./../../images/image-20250513210758616.png" alt="image-20250513210758616"></p><p>克隆远程现有仓库：<br>repository_ur是远程仓库地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repository_url&gt; </span><br></pre></td></tr></table></figure><p><img src="/./../../images/5a1381440c5449d486613ab1d72dd8b0.png" alt="在这里插入图片描述"></p><p>Jenkins、Opengrok、JIRA的使用</p><h3 id="1-JIRA"><a href="#1-JIRA" class="headerlink" title="1. JIRA"></a>1. <strong>JIRA</strong></h3><ul><li><strong>功能</strong>：项目管理和问题跟踪工具。</li><li><strong>嵌入式开发中的作用</strong>：<ul><li>管理需求、任务和缺陷。</li><li>跟踪硬件和软件开发进度。</li><li>支持敏捷开发流程。</li></ul></li></ul><h3 id="2-Jenkins"><a href="#2-Jenkins" class="headerlink" title="2. Jenkins"></a>2. <strong>Jenkins</strong></h3><ul><li><strong>功能</strong>：持续集成（CI）和持续部署（CD）工具。</li><li><strong>嵌入式开发中的作用</strong>：<ul><li>自动化构建和测试嵌入式软件。</li><li>确保代码更新后符合质量标准。</li><li>提高开发效率和交付速度。</li></ul></li></ul><h3 id="3-OpenGrok"><a href="#3-OpenGrok" class="headerlink" title="3. OpenGrok"></a>3. <strong>OpenGrok</strong></h3><ul><li><strong>功能</strong>：代码搜索和交叉引用工具。</li><li><strong>嵌入式开发中的作用</strong>：<ul><li>快速查找和理解复杂代码。</li><li>提供代码版本历史信息。</li><li>帮助开发人员定位问题。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>JIRA</strong> 用于项目管理和问题跟踪。</li><li><strong>Jenkins</strong> 用于自动化构建和测试。</li><li><strong>OpenGrok</strong> 用于代码搜索和理解。 这三种工具在嵌入式开发中可以相互配合，提升开发效率和产品质量。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 车载基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 车载基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2024/06/06/test/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/06/06/test/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="写嵌入式用的到数据结构吗？"><a href="#写嵌入式用的到数据结构吗？" class="headerlink" title="写嵌入式用的到数据结构吗？"></a>写嵌入式用的到数据结构吗？</h1><p>看下linux内核就知道了，一堆数据结构，不学习数据结构，linux内核就看不懂了</p><p>使用数据结构是为了使代码结构更清晰，更容易把握代码结构、逻辑。</p><p>几个应用场景</p><ol><li><p>“数组”。你肯定用过吧，属于数据结构“线性表”的一种形式。</p><p><img src="/2024/06/06/test/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241112202136552.png" alt="image-20241112202136552" style="zoom:50%;"><img src="/2024/06/06/test/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241112202215843.png" alt="image-20241112202215843" style="zoom:50%;"></p></li><li></li><li><p>“结构体”。学习过lwip可以知道从以太网上接收一堆数据后，把数据头的地址幅值给以太网包的数据结构定义的指针，可以直接使用此指针-&gt;成员变量的方式，使用接收到的数据。比使用一堆变量来利用接收到的数据方便太多了。</p></li><li><p>“队列”。热敏电阻测温，单片机用ADC测量电阻分压电压，然后对测量值用平滑均值滤波算法滤波，此时会用到“队列”，或用“环形队列”；</p></li><li><p>“树”。项目中经常会使用液晶屏作为显示，其中文本菜单有时用的比较多的一种方式，其中文本菜单常用“树”结构来实现。</p></li><li><p>“栈”。就不用说了，你已经用过了，不过不是你主动用的，它隐藏在你每次函数调用、中断调用中，可能你没有意识到。</p></li></ol><p>简单几个例子，说明了数据结构非常常见，这个是必须要学的，不过有些不常用，比如图。</p><h3 id="1-【简答题】请写出至少两种野指针的成因"><a href="#1-【简答题】请写出至少两种野指针的成因" class="headerlink" title="1.   【简答题】请写出至少两种野指针的成因"></a>1.   【简答题】请写出至少两种野指针的成因</h3><p>【答案】</p><p>（1）指针使用前未初始化</p><p>（2）指针越界访问</p><p>（3）指针指针已经释放的空间</p><h3 id="2-【简答题】非静态局部变量、全局变量、malloc-动态分配的内存分别存储在内存的什么区域。"><a href="#2-【简答题】非静态局部变量、全局变量、malloc-动态分配的内存分别存储在内存的什么区域。" class="headerlink" title="2.   【简答题】非静态局部变量、全局变量、malloc()动态分配的内存分别存储在内存的什么区域。"></a>2.   【简答题】非静态局部变量、全局变量、malloc()动态分配的内存分别存储在内存的什么区域。</h3><p>【答案】</p><p>（1）非静态局部变量存储在内存的栈区域。</p><p>（1）全局变量存储在内存的全局静态区。</p><p>（2）malloc()动态分配的内存存储在内存的堆区域。</p><h1 id="一、数据结构与算法的层次要求："><a href="#一、数据结构与算法的层次要求：" class="headerlink" title="一、数据结构与算法的层次要求："></a>一、数据结构与算法的层次要求：</h1><p>层次1：熟悉各种不同的数据结构：顺序表（一维数组）、链表、栈、队列；森林、树、二叉树；图等<br>      了解不同的数据结构的特点、如何存储、优缺点等</p><p>层次2：如何编写相关的代码，实现对应的数据结构。（需要考虑对应的增、删、改、查、长度、遍历等）</p><p>层次3：算法层面的训练。 —&gt; leetcode （力扣app）、牛客网等。 300+道打底</p><img src="https://s1.vika.cn/space/2024/11/12/bb5ee404f183423782032597b88580fc" alt="image-20241112200556715"><h1 id="二、针对于层次1："><a href="#二、针对于层次1：" class="headerlink" title="二、针对于层次1："></a>二、针对于层次1：</h1><ol><li><p>什么是数据结构？   datastructure   (D-&gt;S)</p><blockquote><p>数据 +  结构<br>数据：多个相同类型的数据或变量<br>结构：即关系<br>目的：为了更高效的访问数据</p></blockquote></li><li><p>数据结构中有哪些内容？即问研究方向？<br>研究方向1：数据之间的逻辑关系</p><blockquote><p>线性关系:（一对一的关系）。比如：顺序表、链表、栈、队列、数组、字符串、广义表等<br>非线性关系：集合关系、树形关系（一对多的关系）、图形关系（多对多的关系）</p></blockquote></li></ol><p>研究方向2：数据的存储结构（或物理结构）<br>    &gt; 基本的两种：顺序存储结构、链式存储结构<br>    &gt; 拓展的两种：索引存储结构、哈希存储结构(散列存储结构)<br>研究方向3：数据之间的运算：增、删、改、查(CRUD)</p><h1 id="三、具体的不同的数据结构的实现（对应着层次2）"><a href="#三、具体的不同的数据结构的实现（对应着层次2）" class="headerlink" title="三、具体的不同的数据结构的实现（对应着层次2）"></a>三、具体的不同的数据结构的实现（对应着层次2）</h1><ol><li><p>数组的实现和相关算法的封装。</p></li><li><p>链表的实现和相关算法的封装。</p><p>   ​                 优点                                      缺点</p><blockquote><p>数组 通过索引查找、修改效率高：O(1)  插入、删除的效率差：O(n)</p><p>​同样大小的内存，数组可以存储更多的数据  当数据存满时，需要考虑扩容</p></blockquote><blockquote><p>链表   插入、删除效率高：O(1) 通过索引查找、修改效率低：O(n)  </p><p>​ 不需要考虑扩容问题   同样大小的内存，链表存储的数据较数组少</p></blockquote></li></ol><h2 id="如何理解数据结构"><a href="#如何理解数据结构" class="headerlink" title="如何理解数据结构"></a>如何理解数据结构</h2><h4 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h4><p>1.数据结构定义：研究多个变量之间的结构，即数据与数据之间的关系。</p><p> 2.研究目的：高效地进行数据的操作，如增删改查。</p><h4 id="数据结构的主要内容"><a href="#数据结构的主要内容" class="headerlink" title="数据结构的主要内容"></a>数据结构的主要内容</h4><p>1.逻辑结构：研究数据之间的逻辑关系，分为集合关系、线性关系、树形关系和网状关系。 </p><p>2.存储结构：研究数据在实际编程语言中的存储方式，分为顺序存储和链式存储。 </p><p>3.运算：基于存储结构，研究数据的增删改查等操作。</p><h4 id="线性结构和非线性结构"><a href="#线性结构和非线性结构" class="headerlink" title="线性结构和非线性结构"></a>线性结构和非线性结构</h4><p>1.线性结构：如顺序表、链表、栈、队列、数组、广义表等。</p><p> 2.非线性结构：如集合、树、图等。</p><h4 id="存储结构的两种基本形式"><a href="#存储结构的两种基本形式" class="headerlink" title="存储结构的两种基本形式"></a>存储结构的两种基本形式</h4><p>1.顺序存储：将数据元素依次排列，通过数组等方式实现。 </p><p>2.链式存储：通过链表方式，每个元素包含指向下一个元素的指针。</p><p> 3.索引存储结构和哈希存储结构：基于顺序存储和链式存储的组合。</p><img src="https://s1.vika.cn/space/2024/11/12/ad74377b36704d109dd9765a42b58faa" alt="image-20241112202757865" style="zoom:50%;"><img src="/2024/06/06/test/c%E5%92%8Cc++/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20241112202851334.png" alt="image-20241112202851334" style="zoom:50%;"><h1 id="线性结构之数组"><a href="#线性结构之数组" class="headerlink" title="线性结构之数组"></a>线性结构之数组</h1><p><strong>优</strong> <strong>点</strong></p><p>Ø 查找容易（通过下标），时间复杂度为O(1)。不需要额外申请或删除空间。</p><p>Ø 使用下标位置索引(index)十分高效的访问任意元素，修改快</p><p><img src="https://s1.vika.cn/space/2024/11/12/48ec67a0d691481bab93fce23ca5fb1f" alt="image-20241105203354020"></p><p><strong>缺</strong> <strong>点</strong></p><p>Ø 插入、删除元素难，效率低。（需要移动大量元素以使元素空间连续）。</p><p>Ø 插入操作平均需要移动n&#x2F;2个元素。</p><p>Ø 删除操作平均需要移动(n-1)&#x2F;2个元素。</p><p>​                             <img src="https://s1.vika.cn/space/2024/11/12/4dcfedcbb1a2444397856fa27a77c364" alt="image-20241105203403567">     </p><p>Ø 扩展相对繁琐。一方面需要确保能提供更大区域的连续内存空间，另一方面需要将原有数据复制到新的顺序表中。</p><p>1.1.1 功能定义</p><p>前文提到过数组这一数据结构的一个局限性是长度固定，本节我们来实现一个增强版的数组——可变长的动态数组，需要实现以下函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//初始化动态数组</span><br><span class="line">void initDynamicArray(DynamicArray *array, size_t initialCapacity)</span><br><span class="line">//释放动态数组内存</span><br><span class="line">void destroyDynamicArray(DynamicArray *array)</span><br><span class="line">//调整动态数组内存大小</span><br><span class="line">void resizeDynamicArray(DynamicArray *array, size_t newCapacity)</span><br><span class="line">//获取动态数组长度（元素个数）</span><br><span class="line">size_t getLength(const DynamicArray *array)</span><br><span class="line">//在指定位置插入新元素</span><br><span class="line">void insertAt(DynamicArray *array, size_t index, int element)</span><br><span class="line">//在末尾插入新元素</span><br><span class="line">void insertEnd(DynamicArray *array, int element)</span><br><span class="line">//删除指定位置的元素并返回被删除的元素</span><br><span class="line">int deleteAt(DynamicArray *array, size_t index)</span><br><span class="line">//删除末尾的元素并返回被删除的元素</span><br><span class="line">int deleteEnd(DynamicArray *array)</span><br><span class="line">//遍历所有的元素</span><br><span class="line">void print(DynamicArray *array)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-1-1-实现原理"><a href="#1-1-1-实现原理" class="headerlink" title="1.1.1 实现原理"></a>1.1.1 实现原理</h2><p>可变长的动态数组是一种数据结构，它允许在运行时根据需要动态地调整数组的大小，而不需要提前指定固定的大小。这种动态数组通常被称为动态数组、动态分配数组、动态增长数组或动态内存数组。int arr[10];  </p><p>C语言中是通过使用指针和内存分配函数来实现动态数组，常见的内存分配函数是<code>malloc</code>、<code>realloc</code>和<code>free</code>。下面是一些相关的概念和操作：</p><p>（1）<strong>分配内存（malloc）：</strong> 在C语言中，可以使用<code>malloc</code>函数来分配一块指定大小的内存。例如，<code>int *arr = (int *)malloc(n * sizeof(int));</code> 将分配能够存储<code>n</code>个整数的内存空间。</p><p>（2）<strong>重新分配内存（realloc）：</strong> 如果需要改变动态数组的大小，可以使用<code>realloc</code>函数来重新分配内存。这允许你在保留原有数据的情况下扩展或缩小数组的大小。</p><p>（3）<strong>释放内存（free</strong>）： 当不再需要动态数组时，应使用<code>free</code>函数释放之前分配的内存，以避免内存泄露。à 内存溢出</p><p>代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">// 动态数组结构体</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int *data;       // 指向动态数组的指针</span><br><span class="line">    size_t size;     // 当前数组中的元素个数</span><br><span class="line">    size_t capacity; // 当前数组的容量（可以容纳的最大元素个数）</span><br><span class="line">&#125; DynamicArray;</span><br><span class="line"></span><br><span class="line">// 初始化动态数组</span><br><span class="line">void initDynamicArray(DynamicArray *array, size_t initialCapacity)</span><br><span class="line">&#123;     //分配内存（malloc）</span><br><span class="line">    array-&gt;data = (int *)malloc(initialCapacity * sizeof(int)); // 分配初始内存</span><br><span class="line">    array-&gt;size = 0;       // 初始化元素个数为0</span><br><span class="line">    array-&gt;capacity = initialCapacity;     // 设置初始容量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放动态数组内存</span><br><span class="line">void destroyDynamicArray(DynamicArray *array)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    //释放内存（free）</span><br><span class="line">    free(array-&gt;data);   // 释放动态数组内存</span><br><span class="line">    array-&gt;size = 0;     // 重置元素个数为0</span><br><span class="line">    array-&gt;capacity = 0; // 重置容量为0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 调整动态数组内存大小</span><br><span class="line">void resizeDynamicArray(DynamicArray *array, size_t newCapacity)</span><br><span class="line">&#123; //重新分配内存（realloc）</span><br><span class="line">    array-&gt;data = (int *)realloc(array-&gt;data, newCapacity * sizeof(int)); // 调整数组内存大小  </span><br><span class="line">    array-&gt;capacity = newCapacity;       // 更新容量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取动态数组长度（元素个数）</span><br><span class="line">size_t getLength(const DynamicArray *array)</span><br><span class="line">&#123;</span><br><span class="line">    return array-&gt;size; // 返回数组中的元素个数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在指定位置插入新元素</span><br><span class="line">void insertAt(DynamicArray *array, size_t index, int element)</span><br><span class="line">&#123;</span><br><span class="line">    if (index &gt; array-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        return; // 忽略无效的插入位置</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (array-&gt;size &gt;= array-&gt;capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        size_t newCapacity = array-&gt;capacity * 2; // 如果容量不足，扩大容量</span><br><span class="line">        resizeDynamicArray(array, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (size_t i = array-&gt;size; i &gt; index; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        array-&gt;data[i] = array-&gt;data[i - 1]; // 后移元素以腾出插入位置</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array-&gt;data[index] = element; // 在指定位置插入新元素</span><br><span class="line">    array-&gt;size++;                // 更新元素个数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在末尾插入新元素</span><br><span class="line">void insertEnd(DynamicArray *array, int element)</span><br><span class="line">&#123;</span><br><span class="line">    insertAt(array, array-&gt;size, element); // 在末尾插入新元素</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除指定位置的元素并返回被删除的元素</span><br><span class="line">int deleteAt(DynamicArray *array, size_t index)</span><br><span class="line">&#123;</span><br><span class="line">    if (index &gt;= array-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        return -1; // 忽略无效的删除位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    int deletedElement = array-&gt;data[index]; // 获取被删除的元素</span><br><span class="line"></span><br><span class="line">    for (size_t i = index; i &lt; array-&gt;size - 1; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        array-&gt;data[i] = array-&gt;data[i + 1]; // 前移元素以填补删除位置</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array-&gt;size--; // 更新元素个数</span><br><span class="line"></span><br><span class="line">    return deletedElement; // 返回被删除的元素</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除末尾的元素并返回被删除的元素</span><br><span class="line">int deleteEnd(DynamicArray *array)</span><br><span class="line">&#123;</span><br><span class="line">    return deleteAt(array, array-&gt;size - 1); // 删除末尾的元素</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 遍历所有的元素</span><br><span class="line">void print(DynamicArray *array)</span><br><span class="line">&#123;</span><br><span class="line">    for (int i = 0; i &lt; array-&gt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;, array-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    DynamicArray myArray; // 声明动态数组</span><br><span class="line"></span><br><span class="line">    // 初始化动态数组</span><br><span class="line">    initDynamicArray(&amp;myArray, 2);</span><br><span class="line">    printf(&quot;初始化动态数组,初始容量为2\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 向动态数组尾部插入元素</span><br><span class="line">    insertEnd(&amp;myArray, 1);</span><br><span class="line">    insertEnd(&amp;myArray, 2);</span><br><span class="line">    printf(&quot;向动态数组尾部插入了2个元素\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 打印动态数组当前长度</span><br><span class="line"> printf(&quot;动态数组当前长度:%zu\n&quot;, getLength(&amp;myArray));</span><br><span class="line"></span><br><span class="line">    // 在索引1的位置插入元素3</span><br><span class="line">    insertAt(&amp;myArray, 1, 3);</span><br><span class="line">    printf(&quot;在索引1的位置插入元素3\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 再次打印动态数组当前长度</span><br><span class="line">    printf(&quot;动态数组当前长度:%zu\n&quot;, getLength(&amp;myArray));</span><br><span class="line"></span><br><span class="line">    // 删除索引1的元素</span><br><span class="line">    printf(&quot;删除索引1的元素,该元素是%d\n&quot;, deleteAt(&amp;myArray, 1));</span><br><span class="line"></span><br><span class="line">    // 删除动态数组末尾元素</span><br><span class="line">    printf(&quot;删除动态数组末尾元素,该元素是%d\n&quot;, deleteEnd(&amp;myArray));</span><br><span class="line"></span><br><span class="line">    // 释放动态数组内存</span><br><span class="line">    destroyDynamicArray(&amp;myArray);</span><br><span class="line">    printf(&quot;动态数组内存释放完成\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="1-1-线性结构之链表"><a href="#1-1-线性结构之链表" class="headerlink" title="1.1 线性结构之链表"></a>1.1 线性结构之链表</h1><p>1.1.1 链表是什么</p><p>链表的主要特点包括：</p><ol><li><strong>动态大小</strong>：链表可以根据需要动态调整大小，不需要预先分配固定的内存空间。</li><li><strong>插入和删除效率高</strong>：在已知位置插入或删除元素时，链表不需要移动其他元素，只需调整指针即可。</li><li><strong>顺序访问</strong>：链表不支持随机访问，要访问链表中的某个元素，必须从头节点开始逐个遍历。</li></ol><p>链表有几种常见的类型：</p><ul><li><strong>单向链表</strong>：每个节点只指向下一个节点。</li><li><strong>双向链表</strong>：每个节点有两个指针，分别指向前一个节点和后一个节点。</li><li><strong>循环链表</strong>：链表的最后一个节点指向第一个节点，形成一个环。</li></ul><p><img src="https://s1.vika.cn/space/2024/11/12/65ec27aa9d2548efbe0342f9a53b9878" alt="image-20241108184735610"></p><p><strong>相关概念</strong></p><p>n个结点离散分配，彼此通过指针相连，每个结点只有一个前驱结点，每个结点只有一个后续结点，头结点没有前驱结点，尾结点没有后续结点。确定一个链表我们只需要头指针，通过头指针就可以把整个链表都能推出来。</p><p>1）优点</p><p>（1）插入和删除操作效率高。</p><p>（2）动态扩展性能更好，链表不需要像数组那样预先指定固定的大小，而是可以随时动态的增长或缩小。链表是真正的动态数据结构，不需要处理固定容量的问题。</p><p>2）缺点</p><p>（1）查找慢。由于链表中的结点不是连续存储的，无法像数组一样根据索引直接计算出每个结点的地址。必须从头结点开始遍历链表，直到找到目标结点，这导致了链表的随机访问效率较低。</p><p>（2）额外的存储空间。链表的每个结点都需要存储指向下一个结点的指针，这会占用额外的存储空间。所以，相比于数组，链表需要更多的内存空间来存储相同数量的数据元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">初始化链表</span><br><span class="line">void initLinkedList(LinkedList *list)</span><br><span class="line">返回链表的长度</span><br><span class="line">size_t getLength(const LinkedList *list)</span><br><span class="line">在指定位置插入元素</span><br><span class="line">void insertAt(LinkedList *list, size_t index, int element)</span><br><span class="line">在末尾插入元素</span><br><span class="line">void insertEnd(LinkedList *list, int element)</span><br><span class="line">删除指定位置的元素并返回被删除的元素</span><br><span class="line">int deleteAt(LinkedList *list, size_t index)</span><br><span class="line">删除末尾元素</span><br><span class="line">int deleteEnd(LinkedList *list)</span><br><span class="line">获取指定位置的元素</span><br><span class="line">int getElementAt(const LinkedList *list, size_t index)</span><br><span class="line">修改指定位置的元素</span><br><span class="line">void modifyAt(LinkedList *list, size_t index, int newValue)</span><br><span class="line">释放链表内存</span><br><span class="line">void destroyLinkedList(LinkedList *list)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">自定义链表结构</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 定义存储数据的结构体</span><br><span class="line">typedef struct Node</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int data;          // 存储的数据</span><br><span class="line">    struct Node *next; // 指向下个元素的指针</span><br><span class="line"></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line">// 定义虚拟头结点的结构体</span><br><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int size;   // 记录单链表中存储的数据的个数</span><br><span class="line">    Node *next; // 指向保存数据的首元素</span><br><span class="line">&#125; LinkedList;</span><br><span class="line"></span><br><span class="line">// 明确：在包含虚拟头结点的情况下，首个保存数据的结点的索引为0！</span><br><span class="line"></span><br><span class="line">// 初始化链表</span><br><span class="line">void initLinkedList(LinkedList *list)</span><br><span class="line">&#123;</span><br><span class="line">    // 初始化LinkedList内部的成员</span><br><span class="line">    list-&gt;size = 0;</span><br><span class="line">    list-&gt;next = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回链表的长度</span><br><span class="line">size_t getLength(const LinkedList *list)</span><br><span class="line">&#123;</span><br><span class="line">    return list-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在指定位置插入元素</span><br><span class="line">void insertAt(LinkedList *list, size_t index, int element)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (index &lt; 0 || index &gt; list-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;输入的index数据非法\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 插入数据的过程</span><br><span class="line">    // 1. 将数据封装到Node结构体的变量中</span><br><span class="line">    Node *node = (Node *)malloc(1 * sizeof(Node));</span><br><span class="line">    node-&gt;data = element;</span><br><span class="line"></span><br><span class="line">    // 2. 找到index的位置进行插入操作</span><br><span class="line">    if (index == 0)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        node-&gt;next = list-&gt;next;</span><br><span class="line">        list-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        Node *currentNode = list-&gt;next; // 指向有数据的首元素</span><br><span class="line">        for (int i = 0; i &lt; index - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            currentNode = currentNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node-&gt;next = currentNode-&gt;next;</span><br><span class="line">        currentNode-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    list-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在末尾插入元素</span><br><span class="line">void insertEnd(LinkedList *list, int element)</span><br><span class="line">&#123;</span><br><span class="line">    insertAt(list, list-&gt;size, element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除指定位置的元素并返回被删除的元素</span><br><span class="line">int deleteAt(LinkedList *list, size_t index)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (index &lt; 0 || index &gt;= list-&gt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;输入的index不合法\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int deleteElement;</span><br><span class="line">    Node *deleteNode;</span><br><span class="line">    if (index == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        deleteNode = list-&gt;next;</span><br><span class="line"></span><br><span class="line">        list-&gt;next = deleteNode-&gt;next;</span><br><span class="line"></span><br><span class="line">        // 获取要删除的node的数据</span><br><span class="line">        deleteElement = deleteNode-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        Node *currentNode = list-&gt;next; // 指向有数据的首元素</span><br><span class="line">        for (int i = 0; i &lt; index - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            currentNode = currentNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deleteNode = currentNode-&gt;next;</span><br><span class="line">        currentNode-&gt;next = deleteNode-&gt;next;</span><br><span class="line"></span><br><span class="line">        deleteElement = deleteNode-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    free(deleteNode); // 释放node的内存空间</span><br><span class="line"></span><br><span class="line">    list-&gt;size--;</span><br><span class="line"></span><br><span class="line">    return deleteElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 删除末尾元素</span><br><span class="line">int deleteEnd(LinkedList *list) &#123;</span><br><span class="line">    deleteAt(list,list-&gt;size - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 获取指定位置的元素</span><br><span class="line">int getElementAt(const LinkedList *list, size_t index) &#123;</span><br><span class="line"></span><br><span class="line">    if(index &lt; 0 || index &gt;= list-&gt;size)&#123;</span><br><span class="line">        printf(&quot;输入的index不合法\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node * currentNode = list-&gt;next;</span><br><span class="line">    for(int i = 0;i &lt; index ;i++)&#123;</span><br><span class="line">        currentNode = currentNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return currentNode-&gt;data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改指定位置的元素</span><br><span class="line">void modifyAt(LinkedList *list, size_t index, int newValue) &#123;</span><br><span class="line"></span><br><span class="line">    if(index &lt; 0 || index &gt;= list-&gt;size)&#123;</span><br><span class="line">        printf(&quot;输入的index不合法\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node * currentNode = list-&gt;next;</span><br><span class="line">    for(int i = 0;i &lt; index ;i++)&#123;</span><br><span class="line">        currentNode = currentNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentNode-&gt;data = newValue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放链表内存</span><br><span class="line">void destroyLinkedList(LinkedList *list) &#123;</span><br><span class="line"></span><br><span class="line">    Node *currentNode = list-&gt;next;  //找到有数据的第1个结点</span><br><span class="line"></span><br><span class="line">    for(int i = 0;i &lt; list-&gt;size;i++)&#123;</span><br><span class="line"></span><br><span class="line">        Node *tempNode = currentNode;</span><br><span class="line">        currentNode = currentNode-&gt;next;</span><br><span class="line"></span><br><span class="line">        free(tempNode);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //辅助操作</span><br><span class="line">    list-&gt;next = NULL;</span><br><span class="line">    list-&gt;size = 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    LinkedList list;</span><br><span class="line">    initLinkedList(&amp;list);</span><br><span class="line"></span><br><span class="line">    insertAt(&amp;list,0,10);</span><br><span class="line">    insertAt(&amp;list,0,20);</span><br><span class="line">    insertAt(&amp;list,0,30);</span><br><span class="line"></span><br><span class="line">    size_t count = getLength(&amp;list);</span><br><span class="line">    printf(&quot;%d\n&quot;,count);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    getchar();  </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="释放链表内存-有什么用"><a href="#释放链表内存-有什么用" class="headerlink" title="释放链表内存 有什么用"></a>释放链表内存 有什么用</h3><p>释放链表内存”的主要用途在于管理动态分配的内存，确保程序运行期间不会造成内存泄漏。下面是这一过程的重要性和作用：</p><ol><li><strong>防止内存泄漏</strong>：在程序中动态申请的内存（例如，通过 <code>malloc</code>）需要在不再使用时及时释放。如果在不再需要链表时不释放内存，程序会占用不必要的内存资源，从而导致内存泄漏。</li><li><strong>优化内存使用</strong>：及时释放内存可以确保系统资源的有效使用，特别是在运行长时间的程序或需要频繁创建和销毁对象的情况下。</li><li><strong>防止悬挂指针</strong>：在释放链表内存的同时，设置指向链表的指针（如头指针）为 <code>NULL</code> 坏境，可以避免访问已释放内存的风险。这有助于防止程序在试图访问无效内存时造成的未定义行为。</li><li><strong>提高程序稳定性</strong>：良好的内存管理使得程序更加稳定和健壮，降低了崩溃的概率。</li></ol><h1 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h1><p>特点：<code>后进先出</code> (LIFO，Last In First Out)或<code>先进后出</code> (FILO，First In Last Out)的线性表。</p><p> 栈顶(Top)：允许进行插入、删除操作的一端，又称为<code>表尾</code>。栈顶由一个称为栈顶指针的位置指示器（其实就是一个变量）来指示，它是动态变化的。</p><p>- 栈底(Bottom)：是固定不变的，不允许进行插入和删除的一端，又称为<code>表头</code>。</p><p>- 空栈：不含任何元素的空表。</p><p>- 设栈S&#x3D;(a1,a2,…,an )，则a1称为栈底元素，an为栈顶元素，栈中元素按a1,a2,…,a_n的次序进栈(压栈、push)，出栈(弹栈，pop)的第一个元素应为栈顶元素，出栈顺序为：an,…,a2,a1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">初始化栈</span><br><span class="line">void initStack(Stack *stack, size_t capacity)</span><br><span class="line">返回栈内元素个数</span><br><span class="line">size_t getSize(const Stack *stack)</span><br><span class="line">添加新元素</span><br><span class="line">void push(Stack *stack, int element)</span><br><span class="line">在末尾插入元素</span><br><span class="line">void insertEnd(LinkedList *list, int element)</span><br><span class="line">栈顶元素出栈并返回</span><br><span class="line">int pop(Stack *stack)</span><br><span class="line">释放栈内存</span><br><span class="line">void destroyStack(Stack *stack)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"></span><br><span class="line">  自定义实现栈结构：使用顺序存储结构实现--&gt; 顺序栈</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line"></span><br><span class="line">    //存储数据的指针</span><br><span class="line">    int *data;</span><br><span class="line">    //指明存储容器的容量</span><br><span class="line">    size_t capacity;</span><br><span class="line">    //指明存储容器中实际存储的数据量</span><br><span class="line">    size_t size;</span><br><span class="line"></span><br><span class="line">&#125;Stack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 初始化栈</span><br><span class="line">void initStack(Stack *stack, size_t capacity)</span><br><span class="line">&#123;</span><br><span class="line">    stack-&gt;data = (int *)malloc(capacity *sizeof(int));//动态内存分配</span><br><span class="line">    if(stack-&gt;data == NULL)&#123;</span><br><span class="line">        printf(&quot;内存分配失败\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack-&gt;capacity = capacity;         </span><br><span class="line">    stack-&gt;size = 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回栈内元素个数</span><br><span class="line">size_t getSize(const Stack *stack)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    return stack-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加新元素</span><br><span class="line">void push(Stack *stack, int element)</span><br><span class="line">&#123;</span><br><span class="line">    //考虑是否存满了</span><br><span class="line">    if(stack-&gt;size == stack-&gt;capacity)&#123;</span><br><span class="line">        //扩容</span><br><span class="line">        resizeCapacity(stack,stack-&gt;capacity + stack-&gt;capacity &gt;&gt; 1); //扩容为原来的1.5倍</span><br><span class="line">        printf(&quot;容量已满，进行扩容操作\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack-&gt;data[stack-&gt;size] = element;</span><br><span class="line">    stack-&gt;size++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void resizeCapacity(Stack *stack,int newCapacity)&#123;</span><br><span class="line"></span><br><span class="line">    stack-&gt;data = (int *)realloc(stack-&gt;data,newCapacity * sizeof(int)); //扩容操作</span><br><span class="line">    stack-&gt;capacity = newCapacity; //指明新的容量值</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 栈顶元素出栈并返回</span><br><span class="line">int pop(Stack *stack)</span><br><span class="line">&#123;</span><br><span class="line">    //判断是否为空</span><br><span class="line">    if(stack-&gt;size == 0)&#123;</span><br><span class="line">        printf(&quot;当前栈为空,弹栈失败\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // int popElement = stack-&gt;data[stack-&gt;size-1];</span><br><span class="line">    // stack-&gt;size--;</span><br><span class="line"></span><br><span class="line">    // return popElement;</span><br><span class="line"></span><br><span class="line">    return stack-&gt;data[--stack-&gt;size];//</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//这是一个前缀自减操作。它的作用是将 stack-&gt;size 的值减一，然后返回这个新的值。</span><br><span class="line">//例如，如果 stack-&gt;size 原本是 3，经过 --stack-&gt;size 处理后，</span><br><span class="line">//stack-&gt;size 会变为 2。这意味着我们将要弹出栈中索引为 2 的元素（即第三个元素，因为索引从 0 开始）。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放栈内存</span><br><span class="line">void destroyStack(Stack *stack)</span><br><span class="line">&#123;</span><br><span class="line">    free(stack-&gt;data);</span><br><span class="line">    stack-&gt;data = NULL;</span><br><span class="line">    stack-&gt;capacity = 0;</span><br><span class="line">    stack-&gt;size = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//遍历栈中的元素</span><br><span class="line">void print(Stack *stack)&#123;</span><br><span class="line">    for(int i = 0;i &lt; stack-&gt;size;i++)&#123;</span><br><span class="line">        printf(&quot;%d  &quot;,stack-&gt;data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //声明结构体变量</span><br><span class="line">    Stack myStack;</span><br><span class="line"></span><br><span class="line">    initStack(&amp;myStack,3);</span><br><span class="line"></span><br><span class="line">    push(&amp;myStack,1);</span><br><span class="line">    push(&amp;myStack,2);</span><br><span class="line">    push(&amp;myStack,3);</span><br><span class="line">    push(&amp;myStack,4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    printf(&quot;栈中元素的个数为：%d\n&quot;,getSize(&amp;myStack));</span><br><span class="line"></span><br><span class="line">    print(&amp;myStack);</span><br><span class="line"></span><br><span class="line">    printf(&quot;弹栈，弹出的数据是：%d\n&quot;,pop(&amp;myStack));</span><br><span class="line">    printf(&quot;弹栈，弹出的数据是：%d\n&quot;,pop(&amp;myStack));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    print(&amp;myStack);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线性结构之队列"><a href="#线性结构之队列" class="headerlink" title="线性结构之队列"></a>线性结构之队列</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>队列(Queue)：也是操作受限的线性表，限制为仅允许在表的一端进行插入(入队或进队），在表的另一端进行删除(出队或离队)操作。</p><p>- 队首(front) ：允许进行删除的一端称为队首。</p><p>- 队尾(rear)： 允许进行插入的一端称为队尾。</p><p>在空队列中依次加入元素a1,a2, …, an之后，a1是队首元素，an是队尾元素。显然退出队列的次序也只能是a1,a2, …, an。队列，是一种先进先出(First In First Out ，简称FIFO)的线性结构。类似于生活中的排队行为。</p><p><img src="https://s1.vika.cn/space/2024/11/12/b4e17e3fbd7d4f78815a4f01eb85cb5f" alt="image-20241111205010221"></p><p>队列中没有元素时，称为空队列。</p><h3 id="队列的存储结构"><a href="#队列的存储结构" class="headerlink" title="队列的存储结构"></a>队列的存储结构</h3><p>可用顺序表(数组)和链表来存储队列，队列按存储结构可分为顺序队列和链式队列两种。</p><h3 id="功能定义"><a href="#功能定义" class="headerlink" title="功能定义"></a>功能定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">初始化队列</span><br><span class="line">void initQueue(Queue *queue, size_t capacity)</span><br><span class="line">返回队列内元素个数</span><br><span class="line">size_t getSize(const Queue *queue)</span><br><span class="line">添加新元素</span><br><span class="line">void enqueue(Queue *queue, int element)</span><br><span class="line">元素出队列</span><br><span class="line">int dequeue(Queue *queue)</span><br><span class="line">释放队列内存</span><br><span class="line">void destroyQueue(Queue *queue)</span><br><span class="line">遍历队列</span><br><span class="line">void printQueue(Queue *queue)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">/* </span><br><span class="line">    自定义结构实现队列：使用循环队列</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//声明队列对应的结构体</span><br><span class="line">typedef struct&#123;</span><br><span class="line"></span><br><span class="line">    int *data;</span><br><span class="line">    int capacity; //记录存储的最大容量</span><br><span class="line">    int size ; //记录存储的元素的个数</span><br><span class="line">    int front ;  //记录要出队的索引位置</span><br><span class="line">    int rear;  //记录入队后的索引位置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 初始化队列</span><br><span class="line">void initQueue(Queue *queue, size_t capacity)</span><br><span class="line">&#123;</span><br><span class="line">    queue-&gt;data = (int *)malloc(capacity * sizeof(int));</span><br><span class="line">    queue-&gt;capacity = capacity;</span><br><span class="line">    queue-&gt;size = 0;</span><br><span class="line">    queue-&gt;front = 0;</span><br><span class="line">    queue-&gt;rear = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回队列内元素个数</span><br><span class="line">size_t getSize(const Queue *queue)</span><br><span class="line">&#123;</span><br><span class="line">    return queue-&gt;size;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加新元素</span><br><span class="line">void enqueue(Queue *queue, int element)</span><br><span class="line">&#123;</span><br><span class="line">    if(queue-&gt;size == queue-&gt;capacity)&#123;</span><br><span class="line">        //容量已满</span><br><span class="line">        printf(&quot;队列已满，入队失败\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue-&gt;data[queue-&gt;rear] = element;</span><br><span class="line">    queue-&gt;size++;</span><br><span class="line">    //queue-&gt;rear++; //存在问题，需要使用下面的方式替换</span><br><span class="line"></span><br><span class="line">    queue-&gt;rear = (queue-&gt;rear + 1) % queue-&gt;capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 元素出队列</span><br><span class="line">int dequeue(Queue *queue)</span><br><span class="line">&#123;</span><br><span class="line">    // if(queue-&gt;front == queue-&gt;rear);//此语句满足的情况：① 队列为空 ② 队列已满</span><br><span class="line">    if(queue-&gt;size == 0)&#123;</span><br><span class="line">        printf(&quot;队列为空，出队失败\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int dequeueData = queue-&gt;data[queue-&gt;front];</span><br><span class="line">    queue-&gt;size--;</span><br><span class="line"></span><br><span class="line">    queue-&gt;front = (queue-&gt;front + 1) % queue-&gt;capacity;</span><br><span class="line"></span><br><span class="line">    return dequeueData;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放队列内存</span><br><span class="line">void destroyQueue(Queue *queue)</span><br><span class="line">&#123;</span><br><span class="line">    free(queue-&gt;data);</span><br><span class="line">    queue-&gt;data = NULL;</span><br><span class="line">    queue-&gt;capacity = 0;</span><br><span class="line">    queue-&gt;size = 0;</span><br><span class="line">    queue-&gt;front = 0;</span><br><span class="line">    queue-&gt;rear = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//遍历队列</span><br><span class="line">void printQueue(Queue *queue)&#123;</span><br><span class="line">    </span><br><span class="line">    for(int i = queue-&gt;front,j = 0;j &lt; queue-&gt;size;i++,j++)&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        printf(&quot;%d  &quot;,queue-&gt;data[i % queue-&gt;capacity]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Queue myQueue;</span><br><span class="line"></span><br><span class="line">    initQueue(&amp;myQueue,3);</span><br><span class="line"></span><br><span class="line">    enqueue(&amp;myQueue,1);</span><br><span class="line">    enqueue(&amp;myQueue,2);</span><br><span class="line">    enqueue(&amp;myQueue,3);</span><br><span class="line">    enqueue(&amp;myQueue,4); //已满，未入队</span><br><span class="line"></span><br><span class="line">    printQueue(&amp;myQueue);</span><br><span class="line"></span><br><span class="line">    printf(&quot;出队，元素是：%d\n&quot;,dequeue(&amp;myQueue));</span><br><span class="line">    printf(&quot;出队，元素是：%d\n&quot;,dequeue(&amp;myQueue));</span><br><span class="line"></span><br><span class="line">    printQueue(&amp;myQueue);</span><br><span class="line"></span><br><span class="line">    enqueue(&amp;myQueue,5);</span><br><span class="line">    enqueue(&amp;myQueue,6);</span><br><span class="line"></span><br><span class="line">    printQueue(&amp;myQueue);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p><img src="https://s1.vika.cn/space/2024/11/12/72fe34dc1658472cbf5d14212e1506e3" alt="image-20241112175354551"></p><p>假设一个 int 变量占 4个字节，则所需内存空间 &#x3D; 4 + 4 &#x3D; 8，则S(n) &#x3D; O(1)。</p><p><img src="https://s1.vika.cn/space/2024/11/12/4c26e3b872e54932aeac50b4e0cfc5b9" alt="image-20241112175523230"></p><p>假设一个 int 变量占 4个字节，则所需内存空间 &#x3D; 4 + 4n + 4 &#x3D; 4n + 8，则S(n) &#x3D; O(n)。</p><p><img src="https://s1.vika.cn/space/2024/11/12/18bb9907b97d432b83b835a8f999c8d4" alt="image-20241112175532793"></p><p><img src="https://s1.vika.cn/space/2024/11/12/2cb283d076a04171acfea6e1c3b8b96d" alt="image-20241112175538936"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找:"></a>顺序查找:</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">// 顺序查找:</span><br><span class="line">int sequenceSearch(int arr[], int size, int target)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    for(int i = 0;i &lt; size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(arr[i] == target)</span><br><span class="line">        &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return -1; //表示没有找到指定的元素 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int arr[] = &#123;23,45,76,44,22,88,9,12,22,5,80&#125;;</span><br><span class="line"></span><br><span class="line">    int size = sizeof(arr) / sizeof(int);</span><br><span class="line"></span><br><span class="line">    int target = 9;</span><br><span class="line"></span><br><span class="line">    int targetIndex = sequenceSearch(arr,size,target);</span><br><span class="line">    if(targetIndex == -1)&#123;</span><br><span class="line">        printf(&quot;未找到\n&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;找到了%d，对应的索引为%d\n&quot;,target,targetIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sizeof是运算符，返回 unsigned int，其值在编译时即计算好了，参数可以是数组、指针、类型、对象、函数等。<br>它的功能是：获得保证能容纳实现所建立的最大对象的字节大小</p><p>sizeof(ary) &#x2F; sizeof(int) &lt;&#x3D;&#x3D;&gt; sizeof(ary) &#x2F; sizeof(ary[0]) ; 得到 ary 内的元素的个数</p><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>二分查找（Binary Search）是一种高效的搜索算法，通常用于有序数据集中查找目标元素。其原理是通过将数据集划分为两半并与目标进行比较，以确定目标在哪一半中，从而逐步缩小搜索范围，直到找到目标元素或确定不存在。基本原理如下：</p><p>（1）<strong>选择中间元素：</strong> 在有序数据集中，选择数组的中间元素。</p><p>（1）<strong>比较目标：</strong> 将中间元素与目标元素进行比较。</p><p>（2）<strong>查找成功：</strong> 如果中间元素等于目标元素，则查找成功，返回中间元素的索引。</p><p>（3）<strong>缩小搜索范围：</strong> 对于一个升序的数据集，如果中间元素大于目标元素，说明目标可能在左半部分；如果中间元素小于目标元素，说明目标可能在右半部分。根据比较结果，将搜索范围缩小到一半，继续查找。</p><p>（4）<strong>重复步骤：</strong> 重复上述步骤，不断将搜索范围缩小，直到找到目标元素或搜索范围为空。</p><p>​                                   </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"></span><br><span class="line">    使用二分查找法，查找数组中的元素</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int binarySearch(int arr[],int size,int target)&#123;</span><br><span class="line"></span><br><span class="line">    int low = 0;</span><br><span class="line">    int high = size - 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    while(low &lt;= high)&#123;</span><br><span class="line"></span><br><span class="line">        int middle = (low + high) / 2;</span><br><span class="line">        if(arr[middle] == target)&#123;</span><br><span class="line">            return middle;</span><br><span class="line">        &#125;else if(arr[middle] &gt; target)&#123;</span><br><span class="line">            high = middle - 1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            low = middle + 1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //表示未找到</span><br><span class="line">    return -1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int arr[] = &#123;4,7,9,12,16,19,22,28,34,57,69,78,90&#125;;</span><br><span class="line">    int target = 12;</span><br><span class="line">    target = 91;</span><br><span class="line">    int size = sizeof(arr) / sizeof(int);</span><br><span class="line"></span><br><span class="line">    int targetIndex = binarySearch(arr,size,target);</span><br><span class="line">    if(targetIndex == -1)&#123;</span><br><span class="line">        printf(&quot;未找到\n&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;找到了%d，对应的索引为%d\n&quot;,target,targetIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"></span><br><span class="line">    冒泡排序:实现从小到大排序</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">void bubbleSort(int arr[],int size)&#123;</span><br><span class="line"></span><br><span class="line">    //外层循环：控制轮数</span><br><span class="line">    for(int i = 0;i &lt; size - 1;i++)&#123;</span><br><span class="line"></span><br><span class="line">        //内层循环：依次比较相邻的两个元素的大小</span><br><span class="line">        for(int j = 0;j &lt; size - 1 - i;j++)&#123;</span><br><span class="line">            </span><br><span class="line">            if(arr[j] &gt; arr[j + 1])&#123;</span><br><span class="line">                //交互j 和 j+1索引位置的元素</span><br><span class="line">                int temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + 1];</span><br><span class="line">                arr[j + 1] = temp;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int arr[] = &#123;23,45,2,46,77,2,99,-9,-32,0,66&#125;;</span><br><span class="line"></span><br><span class="line">    int size = sizeof(arr) / sizeof(int);</span><br><span class="line">    //遍历</span><br><span class="line">    for(int i = 0;i &lt; size;i++)&#123;</span><br><span class="line">        printf(&quot;%d  &quot;,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    //排序</span><br><span class="line">    bubbleSort(arr,size);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //遍历</span><br><span class="line">    for(int i = 0;i &lt; size;i++)&#123;</span><br><span class="line">        printf(&quot;%d  &quot;,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">    快速排序:实现从小到大排序</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">void quickSort(int arr[], int size)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    subSort(arr, 0, size - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void subSort(int arr[], int start, int end)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    if (start &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        int base = arr[start];</span><br><span class="line">        int low = start;</span><br><span class="line">        int high = end + 1;</span><br><span class="line"></span><br><span class="line">        while (1)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            while (low &lt; end &amp;&amp; arr[++low] &lt;= base)</span><br><span class="line">                ; // 找到从前往后第1个比base大的元素</span><br><span class="line">            while (high &gt; start &amp;&amp; arr[--high] &gt;= base)</span><br><span class="line">                ; // 找到从后往前第1个比base小的元素</span><br><span class="line"></span><br><span class="line">            if (low &lt; high)</span><br><span class="line">            &#123;</span><br><span class="line">                // 交换low和high位置的元素</span><br><span class="line">                int temp = arr[low];</span><br><span class="line">                arr[low] = arr[high];</span><br><span class="line">                arr[high] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 交换start和high索引位置上的元素</span><br><span class="line">        int temp1 = arr[start];</span><br><span class="line">        arr[start] = arr[high];</span><br><span class="line">        arr[high] = temp1;</span><br><span class="line"></span><br><span class="line">        // 递归调用</span><br><span class="line">        subSort(arr, start, high - 1); // 前半段继续排序</span><br><span class="line">        subSort(arr, high + 1, end);   // 后半段继续排序</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int arr[] = &#123;23, 45, 2, 46, 77, 2, 99, -9, -32, 0, 66&#125;;</span><br><span class="line"></span><br><span class="line">    int size = sizeof(arr) / sizeof(int);</span><br><span class="line">    // 遍历</span><br><span class="line">    for (int i = 0; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    // 排序</span><br><span class="line">    quickSort(arr, size);</span><br><span class="line"></span><br><span class="line">    // 遍历</span><br><span class="line">    for (int i = 0; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux驱动模型详解</title>
      <link href="/2024/06/06/test/liunx%E9%A9%B1%E5%8A%A8/Linux%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/06/06/test/liunx%E9%A9%B1%E5%8A%A8/Linux%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><strong>让所有很久很久以前都走到幸福结局的时刻</strong></p><h2 id="1-Linux-驱动模型"><a href="#1-Linux-驱动模型" class="headerlink" title="1.Linux 驱动模型"></a>1.Linux 驱动模型</h2><p>本节内容，重在理解。面试时，面试官很大可能会让你挑一个你熟悉的驱动讲讲，如何编写的？能回答出大概的驱动框架就可以。</p><h3 id="1-1-字符设备驱动模型"><a href="#1-1-字符设备驱动模型" class="headerlink" title="1.1 字符设备驱动模型"></a>1.1 字符设备驱动模型</h3><p>驱动初始化中涉及到一个设备描述结构的概念。在任何一种驱动模型中，设备都会用内核中的一种结构来描述，这种结构成为<strong>设备描述结构</strong>。字符设备在内核中使用<code>struct cdev</code>这种结构来描述。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span> <span class="comment">//设备操作集</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">dev_t</span> dev; <span class="comment">//设备号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count; <span class="comment">//设备数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>count表明该类型设备的数目，如有两个串口，则count的值为2。</p></li><li><p>dev是设备号，包含有主设备号和次设备号的信息。主设备号用于区分设备的类型，次设备号用于标记相同类型的设备的不同个体。如串口1和串口2使用同一驱动程序，则其主设备号相同，但次设备号不同。Linux内核中使用<code>dev_t</code>类型来定义设备号，<code>dev_t</code>这种类型其实质为32位的<code>unsigned int</code>，其中高12位为主设备号，低20位为次设备号。</p><ol><li>知道主设备号与次设备号，可通过<code>dev_t dev = MKDEV(主设备号，次设备号)</code> 获得设备号；</li><li>从设备号分解出主设备号：主设备号 &#x3D; <code>MAJOR(dev_t dev)</code></li><li>从设备号分解出次设备号：次设备号 &#x3D; <code>MINOR(dev_t dev)</code></li></ol></li><li><p>主设备号是一个重要的资源，可以通过静态申请和动态分配为设备分配一个主设备号：</p><ol><li>静态申请：开发者自己选择一个数字作为主设备号，然后通过函数<code>register_chrdev_region</code>向内核申请使用。这种方法的缺点是如果申请使用的设备号已经被内核中的其它驱动使用了，则申请失败。</li><li>动态分配：使用<code>alloc_chrdev_region</code>由内核分配一个可用的主设备号。因为内核知道哪些号已经被使用了，所以不会导致分配到已经被使用的号。既然设备号是一种资源，则设备驱动在退出后都应该释放该资源。使用<code>unregister_chrdev_region</code>函数释放这些设备号。</li></ol></li><li><p>ops是操作函数集。<code>file_operations</code>是一个很重要的结构，该结构的成员基本都是函数指针，并且是一些文件操作的函数的指针。</p></li><li><pre><code class="c">struct file_operations &#123;  struct module *owner;  loff_t(*llseek) (struct file *, loff_t, int);  ssize_t(*read) (struct file *, char __user *, size_t, loff_t *);  ssize_t(*aio_read) (struct kiocb *, char __user *, size_t, loff_t);  ssize_t(*write) (struct file *, const char __user *, size_t, loff_t *);  ssize_t(*aio_write) (struct kiocb *, const char __user *, size_t, loff_t);  int (*readdir) (struct file *, void *, filldir_t);  unsigned int (*poll) (struct file *, struct poll_table_struct *);  int (*ioctl) (struct inode *, struct file *, unsigned int, unsigned long);  int (*mmap) (struct file *, struct vm_area_struct *);  int (*open) (struct inode *, struct file *);  int (*flush) (struct file *);  int (*release) (struct inode *, struct file *);  int (*fsync) (struct file *, struct dentry *, int datasync);  int (*aio_fsync) (struct kiocb *, int datasync);  int (*fasync) (int, struct file *, int);  int (*lock) (struct file *, int, struct file_lock *);  ssize_t(*readv) (struct file *, const struct iovec *, unsigned long, loff_t *);  ssize_t(*writev) (struct file *, const struct iovec *, unsigned long, loff_t *);  ssize_t(*sendfile) (struct file *, loff_t *, size_t, read_actor_t, void __user *);  ssize_t(*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);  unsigned long (*get_unmapped_area) (struct file *, unsigned long,unsigned long, unsigned long,unsigned long);&#125;;    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`struct file_operations`是一个函数指针的集合，定义能在设备上进行的操作。结构中的函数指针指向驱动中的函数，这些函数实现一个针对设备的操作, 对于不支持的操作则设置函数指针为 NULL。例如：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">struct file_operations dev_fops = &#123;</span><br><span class="line">    .llseek = NULL,</span><br><span class="line">    .read = dev_read,</span><br><span class="line">    .write = dev_write,</span><br><span class="line">    .ioctl = dev_ioctl,</span><br><span class="line">    .open = dev_open,</span><br><span class="line">    .release = dev_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>- 该结构体表示应用程序能够对设备文件使用函数`read()`, `write()`等，但不能使用函数`llseek()`。当执行到`read()`函数时，内核根据该结构体转移到驱动程序中的`dev_read`函数去执行。- 驱动初始化有四大步骤：  1.**分配**  - cdev变量的定义可以采用静态和动态两种办法：  - 静态分配：`struct cdev mdev`；  - 动态分配：`struct cdev *pdev = cdev_alloc()`；  2.**初始化**  - `struct cdev`的初始化使用`cdev_init`函数来完成。  - 原型：`cdev_init(struct cdev *cdev, const struct file_operations *fops)`  - 参数：    - `cdev`：待初始化的cdev结构    - `fops`：设备对应的操作函数集  3.注册  - 字符设备的注册使用`cdev_add`函数来完成。  - 原型：`cdev_add(struct cdev *p, dev_t dev, unsigned count)`  - 参数：    - `p`：待添加到内核的字符设备结构    - `dev`：设备号    - `count`：该类设备的设备个数  4.**硬件初始化**  - 根据相应硬件的数据手册完成初始化。</code></pre></li></ul><h3 id="1-2-实现设备操作"><a href="#1-2-实现设备操作" class="headerlink" title="1.2 实现设备操作"></a>1.2 实现设备操作</h3><p>由struct file_operations可以看出，要实现的操作并不少，这里只介绍一些重要的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*open)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *) <span class="comment">//打开设备，响应open系统调用</span></span><br><span class="line"><span class="type">int</span> (*release)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);<span class="comment">//关闭设备，响应close系统调用</span></span><br><span class="line"><span class="type">loff_t</span> (*llseek)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>) <span class="comment">//重定位读写指针，响应lseek系统调用</span></span><br><span class="line"><span class="type">ssize_t</span> (*read)(<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *) <span class="comment">//从设备读取数据，响应read系统调用</span></span><br><span class="line"><span class="type">ssize_t</span> (*write)(<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *) <span class="comment">//向设备写入数据，响应write系统调用</span></span><br></pre></td></tr></table></figure><ul><li><p>以上几个函数涉及到了<code>struct inode</code>和<code>struct file</code>这两种结构体。</p></li><li><p>在Linux系统中，每一个<strong>打开的文件</strong>，在内核中都会关联一个<code>struct file</code>结构体，它由内核在打开文件时创建，在文件关闭后释放。该结构体的重要成员有：</p></li><li><pre><code class="c">loff_t f_pos /*文件读写指针*/struct file_operations *f_op /*该文件所对应的操作*/<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">每一个存在于文件系统里面的文件都会关联一个`inode` 结构，该结构主要用来**记录文件物理上的信息**。因此，它和代表打开文件的file结构是不同的。一个文件**没有被打开时不会关联file结构，但是却会关联一个inode结构**。该结构体重要的成员有：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">dev_t i_rdev /*设备号*/</span><br></pre></td></tr></table></figure>- 一个设备支持的函数操作又称为设备方法。- `open`设备方法是驱动程序用来为以后的操作完成**初始化**准备工作的。在大部分驱动程序中，open完成如下工作：**标明次设备号、启动设备**。- `release`设备方法的作用与open相反，这个设备方法有时也称为close，它完成的工作是**关闭设备**。- `read`设备方法通常完成两件事情：从设备中**读取数据**(属于硬件访问类操作)，将读取到的数据**返回给应用程序**。- ```c  ssize_t (*read)(struct file *filp,char __user *buff,size_t count,loff_t *offp)  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 参数说明：</span><br><span class="line"></span><br><span class="line">  1. `filp`：与字符设备文件关联的file结构指针，由内核创建。</span><br><span class="line">  2. `buff`：从设备读取到的数据，需要**保存到的位置**。由read系统调用提供该参数。</span><br><span class="line">  3. `count`：请求传输的**数据量**，由read系统调用提供该参数。</span><br><span class="line">  4. `offp`：文件的**读写位置**，由内核从file结构中取出后(相当于读取指针)，传递进来。</span><br><span class="line"></span><br><span class="line">- 要注意的是，`buff`参数是来源于用户空间的指针，这类指针都**不能被内核代码直接引用**，必须使用专门的函数：</span><br><span class="line"></span><br><span class="line">- ```c</span><br><span class="line">  int copy_to_user(void __user *to, const void *from, int n)// 内核态-&gt;用户态</span><br><span class="line">  int copy_from_user(void *to, const void __user *from, int n)// 用户态-&gt;内核态</span><br></pre></td></tr></table></figure>    - 其中`copy_to_user()`用于将内核数据传送给用户空间；`copy_from_user()`用于将用户空间的数据传送给内核空间。    - `write`设备方法通常完成两件事情：**从应用程序提供的地址中取出数据，将数据写入设备**(属于硬件访问类操作)    - 函数原型：`ssize_t (*write)(struct file *, const char __user *, size_t, loff_t *)`    - 驱动注销：当我们从内核中卸载驱动程序的时候，需要使用`cdev_del`函数来完成字符设备的注销。    - 一个驱动程序范例：    - ```c      #include &lt;linux/module.h&gt;      #include &lt;linux/types.h&gt;      #include &lt;linux/fs.h&gt;      #include &lt;linux/errno.h&gt;      #include &lt;linux/init.h&gt;      #include &lt;linux/cdev.h&gt;      #include &lt;asm/uaccess.h&gt;      #include &lt;linux/slab.h&gt;             int dev1_registers[5];      int dev2_registers[5];             struct cdev cdev; // 字符驱动设备      dev_t devno;// 设备号             /*文件打开函数*/      int mem_open(struct inode *inode, struct file *filp)      &#123;          /*获取次设备号*/          int num = MINOR(inode-&gt;i_rdev);                 if (num==0)              filp-&gt;private_data = dev1_registers;          else if(num == 1)              filp-&gt;private_data = dev2_registers;          else              return -ENODEV;  //无效的次设备号                 return 0;       &#125;             /*文件释放函数*/      int mem_release(struct inode *inode, struct file *filp)      &#123;        return 0;      &#125;             /*读函数 返回读取了多少个数据*/      static ssize_t mem_read(struct file *filp, char __user *buf, size_t size, loff_t *ppos)      &#123;        unsigned long p =  *ppos;        unsigned int count = size;        int ret = 0;        int *register_addr = filp-&gt;private_data; /*获取设备的寄存器基地址*/               /*判断读位置是否有效*/        if (p &gt;= 5*sizeof(int))          return 0;        if (count &gt; 5*sizeof(int) - p)          count = 5*sizeof(int) - p;               /*读数据到用户空间 从基地址偏移p个(p为开始读的位置 即ppos描述的相对位置)*/        if (copy_to_user(buf, register_addr+p, count))        &#123;          ret = -EFAULT;        &#125;        else        &#123;          *ppos += count;          ret = count;        &#125;               return ret;      &#125;             /*写函数*/      static ssize_t mem_write(struct file *filp, const char __user *buf, size_t size, loff_t *ppos)      &#123;        unsigned long p =  *ppos;        unsigned int count = size;        int ret = 0;        int *register_addr = filp-&gt;private_data; /*获取设备的寄存器地址*/               /*分析和获取有效的写长度*/        if (p &gt;= 5*sizeof(int))          return 0;        if (count &gt; 5*sizeof(int) - p)          count = 5*sizeof(int) - p;               /*从用户空间写入数据*/        if (copy_from_user(register_addr + p, buf, count))          ret = -EFAULT;        else        &#123;          *ppos += count;          ret = count;        &#125;               return ret;      &#125;             /* seek文件定位函数 */      static loff_t mem_llseek(struct file *filp, loff_t offset, int whence)      &#123;           loff_t newpos;                 switch(whence) &#123;            case SEEK_SET:               newpos = offset;              break;                   case SEEK_CUR:               newpos = filp-&gt;f_pos + offset;              break;                   case SEEK_END:               newpos = 5*sizeof(int)-1 + offset;              break;                   default:               return -EINVAL;          &#125;          if ((newpos&lt;0) || (newpos&gt;5*sizeof(int)))              return -EINVAL;                 filp-&gt;f_pos = newpos;          return newpos;             &#125;             /*文件操作结构体*/      static const struct file_operations mem_fops =      &#123;        .llseek = mem_llseek,        .read = mem_read,        .write = mem_write,        .open = mem_open,        .release = mem_release,      &#125;;             /*设备驱动模块加载函数*/      static int memdev_init(void)      &#123;        /*初始化cdev结构*/        cdev_init(&amp;cdev, &amp;mem_fops);               /* 注册字符设备 */        alloc_chrdev_region(&amp;devno, 0, 2, &quot;memdev&quot;);        cdev_add(&amp;cdev, devno, 2);      &#125;             /*模块卸载函数*/      static void memdev_exit(void)      &#123;        cdev_del(&amp;cdev);   /*注销设备*/        unregister_chrdev_region(devno, 2); /*释放设备号*/      &#125;             MODULE_LICENSE(&quot;GPL&quot;);             module_init(memdev_init);      module_exit(memdev_exit);      <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">### 1.3 总线设备驱动模型</span><br><span class="line"></span><br><span class="line">- 自内核2.6版本开始，需要关注的是**总线、设备和驱动**这3个实体，总线将设备和驱动绑定。在Linux内核系统中注册一个设备的时候，会寻找与之对应驱动进行匹配；相反地，系统中注册一个驱动的时候，会去寻找一个对应的设备进行匹配。**匹配的的工作由总线来完成**。</span><br><span class="line"></span><br><span class="line">- **在Linux设备中有的是没有对应的物理总线的，但为了适配Linux的总线模型，内核针对这种没有物理总线的设备开发了一种虚拟总线——platform总线**。将设备和驱动独立开，驱动尽可能写的通用，当来了一个类似的设备后也可以使用这个驱动，让驱动程序可以重用。这体现了Linux驱动的软件架构设计的思想。</span><br><span class="line"></span><br><span class="line">- 按照这个思路，Linux中的设备和驱动都需要挂接在一种总线上，比如i2c总线上的eeprom，eeprom作为设备，**eeprom的驱动都挂接在i2c驱动上**。但是在嵌入式系统中，**soc系统一般都会集成独立的i2c控制器，控制器也是需要驱动的，但是再按照设备-总线-驱动模型进行设计，就会发现无法找到一个合适总线去挂接控制器设备和控制器驱动了（i2c控制器是挂接在CPU内部的总线上，而不是i2c总线）**，所以Linux发明了一种虚拟总线，称为platform总线，相应的设备称为**platform_device（控制器设备），对应的驱动为platform_driver（控制器驱动），用platform总线来承载这些相对特殊的系统**。</span><br><span class="line"></span><br><span class="line">- 注意：**所谓的platform_device并不是与字符设备、块设备和网络设备并列的概念，而是Linux系统提供的一种附加手段**。例如，在 S3C6410处理器中，把内部集成的I2C、RTC、SPI、LCD、看门狗等控制器都归纳为platform_device，而它们本身就是字符设备。我们要记住，platform 驱动只是在**字符设备驱动外套一层platform_driver 的外壳**。引入platform模型符合Linux 设备模型 —— 总线、设备、驱动，设备模型中配套的sysfs节点都可以用，方便我们的开发；**当然你也可以选择不用，不过就失去了一些platform带来的便利**。</span><br><span class="line"></span><br><span class="line">- 设备驱动中引入platform 概念，隔离BSP和驱动。在BSP中定义platform设备和设备使用的资源、设备的具体匹配信息，而在驱动中，只需要通过API去获取资源和数据，做到了板相关代码和驱动代码的分离，使得驱动具有更好的可扩展性和跨平台性。</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  - **下面分析下总线设备驱动模型的匹配过程**</span><br><span class="line">    1. 一边的`device`结构体和另一边的`较稳定的 driver 代码`的联系：`device_add()`除将`device`结构放到 bus 的`dev 链表`之外，还会从另一边的`drv`链表中取表元即某个`driver`结构，用总线里的一个`（.match）`函数来作比较，看另一边的`driver`是否支持一边的`device`。若是能够支持，则接着调用软件驱动部分的`.probe`函数。`driver_register()`会将`bus_drv_dev`模型中的较稳定代码`driver`结构体放到虚拟总线的某个链表（drv 链表）中。从另一边的`dev`链表中取出每一个`device`结构用 bus 中的`.match`函数来作比较。</span><br><span class="line">    2. 若支持则调用`.probe`函数。左右两个注册就建立起来的一种机制。在`.probe`函数中做的事件由自已决定，打印一句话，或注册一个字符设备，再或注册一个`input_dev`结构体等等都是由自已决定。强制的把一个驱动程序分为左右两边这种机制而已，可以把这套东西放在任何地方，这里的`driver`只是个结构体不要被这个名字迷惑，`device`也只是个结构体，里面放什么内容都是由自已决定的。</span><br><span class="line"></span><br><span class="line">### 1.4 输入子系统模型</span><br><span class="line"></span><br><span class="line">每个硬件都有一个`input_dev`结构体，每个软件都有一个`input_handler`结构体。`input_dev`和`input_handler`分别通过`input_register_device()`，`input_register_handler()`向核心层注册硬件和软件。</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ul><p>int input_register_device(struct input_dev *dev)   &#x2F;&#x2F;*dev:要注册的驱动设备<br>{<br> … …<br>       list_add_tail(&amp;dev-&gt;node, &amp;input_dev_list);   &#x2F;&#x2F;(1)放入链表中<br> … …<br>       list_for_each_entry(handler, &amp;input_handler_list, node)  &#x2F;&#x2F;(2)<br>       input_attach_handler(dev, handler);<br> … …<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 从`input_dev`方向分析：`input`设备在增加到`input_dev_list`链表上之后，会查找 `input_handler_list`事件处理链表上的`handler`进行匹配，这里的匹配方式与总线设备驱动模型的`device`和`driver`匹配过程很相似，所有的`input_device`都挂在`input_dev_list`上，所有类型的事件都挂在`input_handler_list`上，进行“匹配相亲”。如果匹配上了，就调用`input_handler`的`connect`函数进行连接。设备就是在此时注册的。</span><br><span class="line">- 从`input_handler`方向分析：将`handler`挂到链表`input_handler_list`下，然后遍历`input_dev_list`链表,查找并匹配输入设备对应的事件处理层，如果匹配上了，就调用`connect`函数进行连接，并创建`input_handle`结构。</span><br><span class="line">- 所以，不管新添加`input_dev`还是`input_handler`，都会进入`input_attach_handler()`判断两者id是否有支持, 若两者支持便进行连接。</span><br><span class="line"></span><br><span class="line">### 1.5 platform总线的匹配规则是什么？在具体应用上要不要先注册驱动再注册设备？有先后顺序没？</span><br><span class="line"></span><br><span class="line">- 匹配规则就是当有一个新的设备挂起时，总线被唤醒，`match`函数被调用，用`device`名字去跟本总线下的所有驱动名字去比较。相反就是用驱动的名字去`device`链表中和所有`device`的名字比较。如果匹配上，才会调用驱动中的`probe`函数，否则不调用。至于先后顺序，鉴于个人理解，**不会有影响**，不管谁先谁后，bus都会完成匹配工作。</span><br><span class="line">- 设备驱动模型的出现主要有三个好处：</span><br><span class="line">  1. 设备与驱动分离，驱动**可移植性增强**；</span><br><span class="line">  2. 设备驱动抽象结构以总线结构表示看起来更加**清晰明了**，谁是属于哪一条bus的；</span><br><span class="line">  3. 设备与驱动分离，很好的奠定了**热插拔**机制。</span><br><span class="line"></span><br><span class="line">## 2.Linux内核</span><br><span class="line"></span><br><span class="line">### 2.1 内核镜像格式有几种？分别有什么区别？</span><br><span class="line"></span><br><span class="line">1. uboot经过编译直接生成的elf格式的可执行程序是u-boot，这个程序类似于windows下的exe格式，在操作系统下是**可以直接执行**的。但是这种格式**不能用来烧录下载**。我们用来烧录下载的是u-boot.bin，这个东西是由u-boot使用arm-linux-objcopy工具进行加工（主要目的是去掉一些无用的东西）得到的。这个u-boot.bin就叫镜像（image），镜像就是用来烧录到iNand中执行的。</span><br><span class="line">2. linux内核经过编译后也会生成一个elf格式的可执行程序，叫**vmlinux或vmlinuz**，这个就是**原始的未经任何处理加工的原版内核elf文件**；嵌入式系统部署时烧录的一般不是这个vmlinuz/vmlinux，而是要用objcopy工具去制作成烧录镜像格式（就是u-boot.bin这种，但是内核没有.bin后缀），经过制作加工成烧录镜像的文件就叫**Image**（制作把78M大的精简成了7.5M，因此这个制作烧录镜像主要目的就是缩减大小，节省磁盘）。</span><br><span class="line">3. 原则上Image就可以直接被烧录到Flash上进行启动执行（类似于u-boot.bin），但是实际上并不是这么简单。实际上linux的作者们觉得Image还是太大了所以对Image进行了压缩，并且在image压缩后的文件的**前端附加了一部分解压缩代码**。构成了一**个压缩格式的镜像就叫zImage**。（因为当年Image大小刚好比一张软盘（软盘有2种，1.2M的和1.44MB两种）大，为了节省1张软盘的钱于是乎设计了这种压缩Image成zImage的技术）。</span><br><span class="line">4. uboot为了启动linux内核，还发明了一种内核格式叫uImage。**uImage是由zImage加工得到的**，uboot中有一个工具，可以将zImage加工生成uImage。注意：uImage不关linux内核的事，linux内核只管生成zImage即可，然后uboot中的mkimage工具再去由zImage加工生成uImage来给uboot启动。这个加工过程其实就是**在zImage前面加上64字节的uImage的头信息即可**。</span><br><span class="line">5. 原则上uboot启动时应该给他uImage格式的内核镜像，但是实际上uboot中也可以支持zImage，是否支持就看x210_sd.h中是否定义了LINUX_ZIMAGE_MAGIC这个宏。所以大家可以看出：有些uboot是支持zImage启动的，有些则不支持。但是**所有的uboot肯定都支持uImage启动**。</span><br><span class="line">6. 如果直接在kernel底下去`make uImage`会提供`mkimage command not found`。解决方案是去`uboot/tools`下`cp mkimage /usr/local/bin/`，复制mkimage工具到系统目录下。再去`make uImage`即可。</span><br><span class="line"></span><br><span class="line">&gt; 通过上面的介绍我们了解了内核镜像的各种格式，如果通过uboot启动内核，Linux必须为**uImage**格式。</span><br><span class="line"></span><br><span class="line">### 2.2 内核中申请内存有哪几个函数？有什么区别？</span><br><span class="line"></span><br><span class="line">1. **kmalloc**</span><br><span class="line"></span><br><span class="line">   ```c</span><br><span class="line">   void *kmalloc(size_t size, gfp_t flags)</span><br></pre></td></tr></table></figure><p>   <code>kmalloc</code>是内核中最常用的一种内存分配方式，它通过调用<code>kmem_cache_alloc</code>函数来实现。<code>kmalloc</code>一次最多能申请的内存大小由<code>include/linux/Kmalloc_size.h</code>的内容来决定，在默认的2.6.18内核版本中，kmalloc一次最多能申请大小为131702B也就是<strong>128KB</strong>字节的连续物理内存。测试结果表明，如果试图用kmalloc函数分配大于128KB的内存，编译不能通过。</p><ol start="2"><li><p><strong>vmalloc</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">vmalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br></pre></td></tr></table></figure><p>前面几种内存分配方式都是物理连续的，能保证较低的平均访问时间。但是在某些场合中，对内存区的请求不是很频繁，较高的内存访问时间也可以接受，这是就可以分配一段<strong>线性连续，物理不连续</strong>的地址，带来的好处是一次可以<strong>分配较大块的内存</strong>。图3-1表示的是<code>vmalloc</code>分配的内存使用的地址范围。<code>vmalloc</code>对一次能分配的内存大小没有明确限制。出于性能考虑，应谨慎使用<code>vmalloc</code>函数。在测试过程中，<strong>最大能一次分配1GB的空间</strong>。</p></li><li><p><strong>dma_alloc_coherent</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">dma_alloc_coherent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">size_t</span> size,<span class="type">ma_addr_t</span> </span></span><br><span class="line"><span class="params">*dma_handle, <span class="type">gfp_t</span> gfp)</span></span><br></pre></td></tr></table></figure><p>DMA(直接内存访问 Direct Memory Access)是一种硬件机制，允许外围设备和主存之间直接传输IO数据，而不需要CPU的参与，使用DMA机制能<strong>大幅提高与设备通信的吞吐量</strong>。DMA操作中，涉及到CPU<strong>高速缓存和对应的内存数据一致性</strong>的问题，必须保证两者的数据一致，在x86_64体系结构中，硬件已经很好的解决了这个问题，<code>dma_alloc_coherentget_free_pages</code>函数实现差别不大，前者实际是调用<code>alloc_pages</code>函数来分配内存，因此一次分配内存的大小限制和后者一样。<code>__get_free_pages</code>分配的内存同样可以用于DMA操作。测试结果证明，<code>dma_alloc_coherent</code>函数一次能分配的最大内存也为<strong>4M</strong>。</p></li><li><p><strong>ioremap</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">ioremap</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> offset, <span class="type">unsigned</span> <span class="type">long</span> size)</span></span><br></pre></td></tr></table></figure><p><code>ioremap</code>是一种更直接的内存“分配”方式，使用时直接<strong>指定物理起始地址和需要分配内存</strong>的大小，然后将该段<strong>物理地址映射到内核地址空间</strong>。<code>ioremap</code>用到的物理地址空间都是事先确定的，和上面的几种内存分配方式并不太一样，并不是分配一段新的物理内存。<code>ioremap</code>多用于<strong>设备驱动</strong>，可以让CPU直接访问外部设备的IO空间。<code>ioremap</code>能映射的内存由原有的物理内存空间决定，所以没有进行测试。</p></li></ol><h3 id="2-3-什么是内核空间，用户空间？"><a href="#2-3-什么是内核空间，用户空间？" class="headerlink" title="2.3 什么是内核空间，用户空间？"></a>2.3 什么是内核空间，用户空间？</h3><ul><li>对 32 位操作系统而言，它的寻址空间（虚拟地址空间，或叫线性地址空间）为 4G（2的32次方）。也就是说一个进程的最大地址空间为 4G。</li><li>操作系统的核心是内核(kernel)，它独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证内核的安全，现在的操作系统一般都强制<strong>用户进程不能直接操作内核</strong>。具体的实现方式基本都是由<strong>操作系统将虚拟地址空间划分为两部分</strong>，一部分为内核空间，另一部分为用户空间。针对 Linux 操作系统而言，<strong>最高的 1G 字节</strong>(从虚拟地址 <code>0xC0000000</code> 到 <code>0xFFFFFFFF</code>)由内核使用，称为<strong>内核空间</strong>。而<strong>较低的 3G 字节</strong>(从虚拟地址 <code>0x00000000</code> 到 <code>0xBFFFFFFF</code>)由各个进程使用，称为用户空间。</li><li>对上面这段内容我们也可以这样理解：<br>每个进程的 4G 地址空间中，最高 1G 都是一样的，即内核空间。只有剩余的 3G 才归进程自己使用。换句话说就是，<strong>最高 1G 的内核空间是被所有进程共享的</strong>！</li><li>下图描述了每个进程 4G 地址空间的分配情况：</li></ul><h3 id="2-4-为什么需要区分内核空间与用户空间？"><a href="#2-4-为什么需要区分内核空间与用户空间？" class="headerlink" title="2.4 为什么需要区分内核空间与用户空间？"></a>2.4 为什么需要区分内核空间与用户空间？</h3><ul><li>在 CPU 的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，比如<strong>清内存、设置时钟</strong>等。如果允许所有的程序都可以使用这些指令，那么系统<strong>崩溃的概率将大大增加</strong>。</li><li>所以，CPU 将指令分为<strong>特权指令</strong>和<strong>非特权指令</strong>，对于那些危险的指令，只允许操作系统及其相关模块使用，普通应用程序只能使用那些不会造成灾难的指令。比如 Intel 的 CPU 将特权等级分为 4 个级别：Ring0~Ring3。</li><li>其实 Linux 系统只使用了 Ring0 和 Ring3 两个运行级别(Windows 系统也是一样的)。当进程运行在 Ring3 级别时被称为运行在用户态，而运行在 Ring0 级别时被称为运行在内核态。</li></ul><h3 id="2-5-什么是内核态和用户态？"><a href="#2-5-什么是内核态和用户态？" class="headerlink" title="2.5 什么是内核态和用户态？"></a>2.5 什么是内核态和用户态？</h3><ul><li><p>当进程<strong>运行在内核空间时</strong>就处于内核态，而进程<strong>运行在用户空间</strong>时则处于用户态。</p></li><li><p>在内核态下，进程运行在内核地址空间中，此时 CPU 可以执行任何指令。运行的代码也不受任何的限制，可以自由地访问任何有效地址，也可以直接进行端口的访问。</p></li><li><p>在用户态下，进程运行在用户地址空间中，被执行的代码要受到 CPU 的诸多检查，它们只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址，且只能对任务状态段(TSS)中 I&#x2F;O 许可位图(I&#x2F;O Permission Bitmap)中规定的可访问端口进行直接访问。</p></li><li><p>对于以前的 DOS 操作系统来说，是没有内核空间、用户空间以及内核态、用户态这些概念的。可以认为所有的代码都是运行在内核态的，因而，用户编写的应用程序代码可以很容易的让操作系统崩溃掉。</p></li><li><p>对于 Linux 来说，通过区分内核空间和用户空间的设计，<strong>隔离了操作系统代码</strong>(操作系统的代码要比应用程序的代码健壮很多)<strong>与应用程序代码</strong>。即便是单个应用程序出现错误，也不会影响到操作系统的稳定性，这样其它的程序还可以正常的运行(Linux 可是个多任务系统啊！)。所以，<strong>区分内核空间和用户空间本质上是要提高操作系统的稳定性及可用性</strong>。</p></li><li><h3 id="2-6-用户空间与内核通信方式有哪些？"><a href="#2-6-用户空间与内核通信方式有哪些？" class="headerlink" title="2.6 用户空间与内核通信方式有哪些？"></a>2.6 用户空间与内核通信方式有哪些？</h3></li></ul><ol><li><p><strong>使用API</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">get_user(x，ptr) <span class="comment">//在内核中被调用，获取用户空间指定地址的数值并保存到内核变量x中。</span></span><br><span class="line">put_user(x，ptr) <span class="comment">//在内核中被调用，将内核空间的变量x的数值保存到到用户空间指定地址处。</span></span><br><span class="line">copy_from_user()/copy_to_user() <span class="comment">//主要应用于设备驱动读写函数中，通过系统调用触发。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用proc文件系统</strong><br>和<code>sysfs</code>文件系统类似，也可以作为内核空间和用户空间交互的手段。<code>/proc</code> 文件系统是一种虚拟文件系统，通过他可以作为一种linux内核空间和用户空间的桥梁。与普通文件不同，这里的虚拟文件的内容都是动态创建的。使用<code>/proc</code>文件系统的方式很简单。调用<code>create_proc_entry</code>，返回一个<code>proc_dir_entry</code>指针，然后去填充这个指针指向的结构就好了。(相当于proc为用户空间的进程开了个口访问内核空间)</p></li><li><p><strong>使用sysfs文件系统+kobject</strong><br>每个在内核中注册的<code>kobject</code>都对应着<code>sysfs</code>系统中的一个目录。可以通过读取根目录下的<code>sys</code>目录中的文件来获得相应的信息。除了<code>sysfs</code>文件系统和<code>proc</code>文件系统之外，一些其他的虚拟文件系统也能同样达到这个效果。</p></li><li><p><strong>netlink</strong><br><code>netlink socket</code>提供了一组类似于BSD风格的API，用于用户态和内核态的IPC。相比于其他的用户态和内核态IPC机制，netlink有几个好处：1.使用自定义一种协议完成数据交换，不需要添加一个文件等。2.可以支持多点传送。3.支持内核先发起会话。4.异步通信，支持缓存机制。</p></li><li><p><strong>文件</strong><br>应该说这是一种比较笨拙的做法，不过确实可以这样用。当处于内核空间的时候，直接操作文件，将想要传递的信息写入文件，然后用户空间可以读取这个文件便可以得到想要的数据了。下面是一个简单的测试程序，在内核态中，程序会向<code>/home/melody/str_from_kernel</code>文件中写入一条字符串，然后我们在用户态读取这个文件，就可以得到内核态传输过来的数据了。</p></li><li><p><strong>使用mmap系统调用</strong><br>可以将内核空间的地址映射到用户空间。在以前做嵌入式的时候用到几次。一方面可以在<code>driver</code>中修改<code>Struct file_operations</code>结构中的<code>mmap</code>函数指针来重新实现一个文件对应的映射操作。另一方面，也可以直接打开<code>/dev/mem</code>文件，把物理内存中的某一页映射到进程空间中的地址上。其实，除了重写<code>Struct file_operations</code>中<code>mmap</code>函数，我们还可以重写其他的方法如<code>ioctl</code>等，来达到驱动内核空间和用户空间通信的方式。</p></li><li><p><strong>信号</strong><br>从内核空间向进程发送信号。这个倒是经常遇到，用户程序出现重大错误，内核发送信号杀死相应进程。</p></li></ol><h3 id="2-7-内核链表为什么具有通用性？"><a href="#2-7-内核链表为什么具有通用性？" class="headerlink" title="2.7 内核链表为什么具有通用性？"></a>2.7 内核链表为什么具有通用性？</h3><p>内核中由于要管理大量的设备，但是各种设备各不相同，必须将他们统一起来管理，于是内核设计者就想到了使用通用链表来处理，通用链表看似神秘，实际上就是<strong>双向循环链表</strong>，这个链表的每个节点都是只有指针域，没有任何数据域。</p><ul><li>使用通用链表的好处是：<ol><li>通用链表中每个节点中<strong>没有数据域</strong>，也就是说无论数据结构有多复杂在链表中只有前后级指针。</li><li>如果一个数据结构（即是描述设备的设备结构体）想要用通用链表管理，只需要在结构体中包含<strong>节点的字段</strong>即可。</li><li>双向链表可以从任意一个节点的前后遍历整个链表，<strong>遍历非常方便</strong>。</li><li>使用循环链表使得可以不断地循环遍历管理节点，像进程的调度：操作系统会把<strong>就绪的进程</strong>放在一个管理进程的就绪队列的通用链表中管理起来，循环不断地，为他们<strong>分配时间片</strong>，获得cpu进行周而复始的进程调度。</li></ol></li></ul><h3 id="2-8-应用程序中open-在linux中执行过程中是如何从用户空间到内核空间？"><a href="#2-8-应用程序中open-在linux中执行过程中是如何从用户空间到内核空间？" class="headerlink" title="2.8 应用程序中open()在linux中执行过程中是如何从用户空间到内核空间？"></a>2.8 应用程序中open()在linux中执行过程中是如何从用户空间到内核空间？</h3><ol><li>应用层调用<code>open</code>函数，在VFS层中找到<code>struct inode</code>结构体，判断是字符设备还是块设备，根据设备号，可以找到对应的驱动程序。</li><li>在驱动层中，每个字符设备都有一个<code>struct cdev</code>结构体，这个结构体通过<code>struct inode</code>结构体中的<code>i_cdev</code>把连接起VFS层和驱动层，<code>struct cdev</code>结构体描述了字符设备所有信息，其中最重要的一项就是字符设备的操作函数接口，即<code>const struct file_operations *ops</code></li><li><code>struct cdev</code>结构体中的<code>struct file</code>结构体记录了操作字符设备的一些函数，比如<code>open read write</code>函数等。<code>struct file</code>结构体其实是在VFS层的，通过<code>struct file</code>结构体指针指向驱动层的<code>struct file</code>结构体将驱动层函数和VFS层链接起来</li><li>任务完成，VFS层会给应用返回一个<strong>文件描述符（fd）</strong>。这个fd是和<code>struct file</code>结构体对应的。</li></ol><h2 id="3-设备驱动"><a href="#3-设备驱动" class="headerlink" title="3.设备驱动"></a>3.设备驱动</h2><h3 id="3-1-请简述主设备号和次设备号的用途"><a href="#3-1-请简述主设备号和次设备号的用途" class="headerlink" title="3.1 请简述主设备号和次设备号的用途"></a>3.1 请简述主设备号和次设备号的用途</h3><ul><li><strong>主设备号：主设备号标识设备对应的特定的驱动程序</strong>。虽然现代的linux内核允许多个驱动程序共享主设备号，但我们看待的大多数设备仍然按照“一个主设备对应一个驱动程序”的原则组织</li><li><strong>次设备号：次设备号由内核使用，用于确定由主设备号对应驱动程序中的各个设备</strong>。依赖于驱动程序的编写方式，我们可以通过次设备号获得一个指向内核设备的直接指针，也可将此设备号当作设备本地数组的索引。</li></ul><h3 id="3-2-字符型驱动设备怎么创建设备文件？"><a href="#3-2-字符型驱动设备怎么创建设备文件？" class="headerlink" title="3.2 字符型驱动设备怎么创建设备文件？"></a>3.2 字符型驱动设备怎么创建设备文件？</h3><ol><li>手动创建<br><code>mknod /dev/led c 250 0</code> ，其中<code>dev/led</code>为设备节点 ,<code>c</code> 代表字符设备, <code>250</code>代表主设备号, <code>0</code>代表次设备号。</li><li>自动创建<br><code>UDEV/MDEV</code>是运行在用户态的程序，可以动态管理设备文件，包括创建和删除设备文件，运行在用户态意味着系统要运行之后，在 <code>/etc/init.d/rcS</code> 脚本文件中会执行 <code>mdev -s</code> 自动创建设备节点。</li></ol><h3 id="3-3-设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义"><a href="#3-3-设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义" class="headerlink" title="3.3 设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义"></a>3.3 设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义</h3><ul><li><p>注册一个字符设备驱动有两种方法：</p><ol><li><code>void cdev_init(struct cdev *cdev, struct file_operations *fops)</code> 该注册函数可以将<code>cdev</code>结构嵌入到自己的设备特定的结构中。<code>cdev</code>是一个指向结构体<code>cdev</code>的指针，而<code>fops</code>是指向一个类似于 <code>file_operations</code>结构（可以是<code>file_operations</code>结构，但不限于该结构）的指针。</li><li><code>int register_chrdev(unsigned int major, const char *name, struct file operations *fops)</code>；该注册函数是早期的注册函数，<code>major</code>是设备的主设备号，<code>name</code>是驱动程序的名称，而<code>fops</code>是默认的<code>file_operations</code>结构（这是只限于<code>file_operations</code>结构）。对于<code>register_chrdev</code>的调用将为给定的主设备号注册0－255作为次设备号，并为每个设备建立一个对应的默认<code>cdev</code>结构。</li></ol><h3 id="3-4-dev-下面的设备文件是怎么创建出来的？"><a href="#3-4-dev-下面的设备文件是怎么创建出来的？" class="headerlink" title="3.4 &#x2F;dev&#x2F;下面的设备文件是怎么创建出来的？"></a>3.4 &#x2F;dev&#x2F;下面的设备文件是怎么创建出来的？</h3></li><li><p>普遍说法有三种方式，<strong>devfs机制</strong>，<strong>udev机制</strong>，再有一个就是<strong>手动创建</strong>设备节点。谈谈个人见解：</p></li></ul><ol><li><code>devfs</code>机制从来没用过，应该是2.6以前的内核使用的；</li><li><code>udev</code>：其实就是现在常用的<code>device_create()</code>、<code>class_create()</code>这一套接口，所谓<code>udev</code>是上层用户空间程序，是基于驱动中创建使用了这两个接口而起作用的，但是<code>udev</code>在日常开发中几乎接触不到，我们只需在驱动中调用创建节点的这两个API就ok了，剩下的工作就交给<code>udev</code>去做了，有想深究它具体实现原理的那就自己去研究吧，我觉得会用就行了；</li><li><code>mknod</code>：新手最常用的一种创建设备节点方法，但并非入门后就再没有用途，在某些情境下，或许有人不想使用<code>udev</code>机制，于是把节点创建工作写在脚本里，这样也是无可厚非的。</li></ol><h3 id="3-5-Linux设备中字符设备和块设备有什么主要区别？分别举例。"><a href="#3-5-Linux设备中字符设备和块设备有什么主要区别？分别举例。" class="headerlink" title="3.5 Linux设备中字符设备和块设备有什么主要区别？分别举例。"></a>3.5 Linux设备中字符设备和块设备有什么主要区别？分别举例。</h3><ul><li>Linux中I&#x2F;O设备分为两类：块设备和字符设备。两种设备本身没有严格限制，但是，基于不同的功能进行了分类。</li><li><strong>字符设备</strong>：提供<strong>连续</strong>的数据流，应用程序可以顺序读取，通常不支持随机存取。相反，此类设备支持<strong>按字节&#x2F;字符</strong>来读写数据。字符终端、串口、鼠标、键盘、摄像头、声卡和显卡等就是典型的字符设备。</li><li><strong>块设备</strong>：应用程序可以<strong>随机访问</strong>设备数据，程序可自行确定读取数据的位置。硬盘是典型的块设备，应用程序可以寻址磁盘上的<strong>任何位置</strong>，并由此读取数据。此外，数据的读写只能以块(通常是512B)的倍数进行。与字符设备不同，块设备并不支持基于字符的寻址。如：u盘，SD卡，磁盘等。</li></ul><h3 id="3-6-驱动中操作物理绝对地址为什么要先ioremap？"><a href="#3-6-驱动中操作物理绝对地址为什么要先ioremap？" class="headerlink" title="3.6 驱动中操作物理绝对地址为什么要先ioremap？"></a>3.6 驱动中操作物理绝对地址为什么要先ioremap？</h3><ul><li><code>ioremp</code>是内核中用来将外设寄存器物理地址映射到主存上去的接口，即将io地址空间映射到虚拟地址空间上去，便于操作。为什么非要映射呢，因为<strong>保护模式下的cpu只认虚拟地址，不认物理地址</strong>，给它物理地址它并不帮你做事，所以你要操作外设上的寄存器必须先映射到虚拟内存空间，拿着虚拟地址去跟cpu对接，从而操作寄存器。</li></ul><h3 id="3-7-insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？"><a href="#3-7-insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？" class="headerlink" title="3.7 insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？"></a>3.7 insmod，rmmod一个驱动模块，会执行模块中的哪个函数？在设计上要注意哪些问题？</h3><ul><li>分别会执行<code>module_init()</code>和<code>module_exit()</code>指定的<code>init</code>函数和<code>exit</code>函数。要注意的就是，尽量使在<code>init</code>函数中出现的资源申请及使用，都要有对应的释放操作在<code>exit</code>中，即<code>init</code>申请，<code>eixt</code>释放。</li></ul><h3 id="3-8-NAND驱动的probe流程"><a href="#3-8-NAND驱动的probe流程" class="headerlink" title="3.8 NAND驱动的probe流程"></a>3.8 NAND驱动的probe流程</h3><ul><li><code>probe</code> 函数就会与NAND芯片进行，主要做的事情主要包括这几个方面：读取NAND芯片的ID ，然后查表得到这片NAND芯片的如厂商，page size，erase size以及chip size等信息，接着根据<code>struct nand_chip</code> 中<code>options</code>的值的不同，或者在NAND 芯片中的特定位置查找<code>bad block table</code>，或者scan整个NAND 芯片，并在内存中建立<code>bad block table</code>。说起来复杂，但其实所有的这些动作，都可以在MTD提供的一个叫做<code>nand_scan</code>的函数中完成。</li></ul><h3 id="3-9-Linux驱动开发中，常用的调试方法有哪些？"><a href="#3-9-Linux驱动开发中，常用的调试方法有哪些？" class="headerlink" title="3.9 Linux驱动开发中，常用的调试方法有哪些？"></a>3.9 Linux驱动开发中，常用的调试方法有哪些？</h3><ul><li><p>利用<code>printk</code>，查看OOP消息，利用<code>strace</code>，利用内核内置的<code>hacking</code>选项，利用<code>ioctl</code>方法，利用<code>/proc</code> 文件系统，使用<code>kgdb</code>。</p></li><li><p><code>strace</code> 是一个可用于诊断、调试和教学的 Linux 用户空间跟踪器，监控用户空间进程和内核的交互，比如系统调用、信号传递、进程状态变更等。</p></li><li><p><code>ioctl</code> 是设备驱动程序中设备控制接口函数，一个字符设备驱动通常会实现设备打开、关闭、读、写等功能，在一些需要细分的情境下，如果需要扩展新的功能，通常以增设<code>ioctl()</code>命令的方式实现。</p><blockquote><p>建议大家，亲手动手调试下。面试中，很大可能会问你，在写驱动过程中遇到了什么问题的，如何解决的？如果你能讲出以上几种调试方法中的一两种，一定会让面试官刮目相看！</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 驱动开发 </tag>
            
            <tag> 内核编程 </tag>
            
            <tag> Linux系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 常用命令自查手册</title>
      <link href="/2024/01/01/test/linux%E5%9F%BA%E7%A1%80/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%87%AA%E6%9F%A5%E6%89%8B%E5%86%8C/"/>
      <url>/2024/01/01/test/linux%E5%9F%BA%E7%A1%80/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%87%AA%E6%9F%A5%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux-常用命令自查手册"><a href="#Linux-常用命令自查手册" class="headerlink" title="Linux 常用命令自查手册"></a><strong>Linux 常用命令自查手册</strong></h1><h2 id="APT软件工具"><a href="#APT软件工具" class="headerlink" title="APT软件工具"></a>APT软件工具</h2><p><img src="/./../../../images/image-20250530183119170.png" alt="image-20250530183119170"></p><h2 id="关机-重启-注销"><a href="#关机-重启-注销" class="headerlink" title="关机&#x2F;重启&#x2F;注销"></a>关机&#x2F;重启&#x2F;注销</h2><p><img src="/./../../../images/image-20250530183259481.png" alt="image-20250530183259481"></p><h2 id="系统信息和性能查看"><a href="#系统信息和性能查看" class="headerlink" title="系统信息和性能查看"></a>系统信息和性能查看</h2><p><img src="/./../../../images/2.jpg" alt="2"></p><h2 id="磁盘和分区"><a href="#磁盘和分区" class="headerlink" title="磁盘和分区"></a>磁盘和分区</h2><p><img src="/./../../../images/3.jpg" alt="3"></p><h2 id="用户和用户名"><a href="#用户和用户名" class="headerlink" title="用户和用户名"></a>用户和用户名</h2><p><img src="/./../../../images/4.jpg" alt="4"></p><h2 id="网络和进程管理"><a href="#网络和进程管理" class="headerlink" title="网络和进程管理"></a>网络和进程管理</h2><p><img src="/./../../../images/5.jpg" alt="5"></p><h2 id="常见系统服务命令"><a href="#常见系统服务命令" class="headerlink" title="常见系统服务命令"></a>常见系统服务命令</h2><p><img src="/./../../../images/6.jpg" alt="6"></p><h2 id="文件和目录操作"><a href="#文件和目录操作" class="headerlink" title="文件和目录操作"></a>文件和目录操作</h2><p><img src="/./../../../images/7.jpg" alt="7"></p><h2 id="文件查看和处理"><a href="#文件查看和处理" class="headerlink" title="文件查看和处理"></a>文件查看和处理</h2><p><img src="/./../../../images/8.jpg" alt="8"></p><h2 id="打包和解压"><a href="#打包和解压" class="headerlink" title="打包和解压"></a>打包和解压</h2><p><img src="/./../../../images/9.jpg" alt="9"></p><h2 id="RPM包管理命令"><a href="#RPM包管理命令" class="headerlink" title="RPM包管理命令"></a>RPM包管理命令</h2><p><img src="/./../../../images/10.jpg" alt="10"></p><h2 id="YUM包管理命令"><a href="#YUM包管理命令" class="headerlink" title="YUM包管理命令"></a>YUM包管理命令</h2><p><img src="/./../../../images/11.jpg" alt="11"></p><h2 id="DPKG包管理命令"><a href="#DPKG包管理命令" class="headerlink" title="DPKG包管理命令"></a>DPKG包管理命令</h2><p><img src="/./../../../images/12.jpg" alt="12"></p><p><img src="/./../../../images/image-20250530184153540.png" alt="image-20250530184153540"></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4MjEzNTMzNw==&mid=2653228392&idx=1&sn=15269ce188ed77c239c92639d9612b8f">deb和rpm有什么区别？——Linux软件包格式详解</a></p><p>RPM、YUM和DPKG是Linux系统中用于管理软件包的三种不同工具：</p><ol><li><strong>RPM（Red Hat Package Manager）</strong>：是Red Hat系列Linux发行版（如Red Hat Enterprise Linux、CentOS、Fedora）中用于安装、卸载、升级和管理软件包的工具。它处理<code>.rpm</code>格式的包，但不自动处理依赖关系。</li><li><strong>YUM（Yellowdog Updater Modified）</strong>：基于RPM，用于自动处理软件包的依赖关系。它简化了软件包管理，允许自动下载和安装依赖的包。YUM在CentOS 8及更高版本中被DNF取代。</li><li><strong>DPKG（Debian Package）</strong>：是Debian系列Linux发行版（如Debian、Ubuntu）中用于管理软件包的工具。它处理<code>.deb</code>格式的包，并可以自动处理依赖关系。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> Linux开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言第1-4章内容</title>
      <link href="/2023/09/20/test/c%E5%92%8Cc++/C%E8%AF%AD%E8%A8%80(1-4%E7%AB%A0)/"/>
      <url>/2023/09/20/test/c%E5%92%8Cc++/C%E8%AF%AD%E8%A8%80(1-4%E7%AB%A0)/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-计算机内部结构"><a href="#第一章-计算机内部结构" class="headerlink" title="第一章 计算机内部结构"></a><strong>第一章 计算机内部结构</strong></h1><p><strong>1.1 计算机内部结构（存储器、CPU、输入输出设备）</strong><br><strong>1.2 C语言的起源和发展</strong><br><strong>1.3 C语言的特点和优缺点</strong><br><strong>1.4 C语言的应用领域</strong><br><strong>1.5 C语言中的八进制、十进制、十六进制数和计算机二进制</strong><br><strong>1.6 C语言的第一个hello world程序</strong></p><p><img src="H:/Hexo-Blog/blog-demo/source/images/1694402772337-c1eff0d2-cb85-47f3-9b8f-10a0fea49e61-1748589409790-9.jpeg" alt="img"></p><h2 id="一、计算机内部结构"><a href="#一、计算机内部结构" class="headerlink" title="一、计算机内部结构"></a>一、计算机内部结构</h2><h3 id="1-1-冯·诺伊曼架构"><a href="#1-1-冯·诺伊曼架构" class="headerlink" title="1.1 冯·诺伊曼架构"></a>1.1 冯·诺伊曼架构</h3><h4 id="1-1-1-冯·诺伊曼"><a href="#1-1-1-冯·诺伊曼" class="headerlink" title="1.1.1 冯·诺伊曼"></a>1.1.1 冯·诺伊曼</h4><p><img src="H:/Hexo-Blog/blog-demo/source/images/image-20250530151730082.png" alt="image-20250530151730082"></p><p>基本信息：约翰·冯·诺伊曼，1903-1957，匈牙利裔美国数学家和理论物理学家。<br>重要贡献：开创了存储程序的计算机设计概念，即冯·诺伊曼架构。</p><h4 id="冯诺伊曼架构"><a href="#冯诺伊曼架构" class="headerlink" title="冯诺伊曼架构"></a>冯诺伊曼架构</h4><p><img src="H:/Hexo-Blog/blog-demo/source/images/image-20250530151754770.png" alt="image-20250530151754770"></p><p><strong>定义</strong>：冯·诺伊曼模型，也称冯·诺伊曼架构，是现代计算机的基础，分为输入设备，输出设备，存储器，处理器和总线五部分。<br><strong>输入设备</strong>：让用户向计算机输入数据，如键盘，鼠标等。<br><strong>输出设备</strong>：让计算机将处理过的数据展示给用户，如显示器，打印机等。<br><strong>存储器</strong>：用于存储数据和指令，在冯·诺伊曼模型中，数据和指令存储在同一内存中。</p><ul><li>硬盘 ： 外部存储设备</li><li>内存 ： 存储程序运行数据</li><li>缓存 ： 集成在CPU内部</li></ul><p><strong>处理器</strong>：负责执行指令和处理数据，由算术逻辑单元和控制单元组成。总线：连接各个部分，负责数据传输。</p><h2 id="二、C语言的起源和发展"><a href="#二、C语言的起源和发展" class="headerlink" title="二、C语言的起源和发展"></a>二、C语言的起源和发展</h2><p>C 语言于 20 世纪 70 年代诞生于美国的贝尔实验室。在此之前，人们编写系统软件主要使用汇编语言，汇编语言编写的程序依赖于计算机硬件，其可读性和可移植性都比较差。而高级语言的可读性和可移植性虽然较汇编语言好，但一般又不具备低级语言的能够直观地对硬件实现控制和操作而且执行速度快等特点。</p><p>（1）C语言最初由美国贝尔实验室的D.M. Ritchie在B语言的基础上设计，主要为描述和实现UNIX操作系统。那时，C语言仅在贝尔实验室内部使用。<br>（2）然后到了1975年，UNIX的第6版发布后，C语言因其突出的优点引起了广泛关注。随后，到1977年出现了可移植的C语言。<br>（3）1978年，UNIX的第7版发布，其中使用的C语言被视为后来广泛使用的C语言版本的基础，也被称为标准C语言。<br>（4）1983年，美国国家标准学会（ANSI）对C语言进行了发展和扩充，并制定了新的标准，称为ANSI C。<br>（5）最后到了1990年，国际标准化组织（ISO）制定了ISO C标准，至今流行的C语言编译系统都是以此为标准。</p><h2 id="三、C语言的特点和优缺点"><a href="#三、C语言的特点和优缺点" class="headerlink" title="三、C语言的特点和优缺点"></a>三、C语言的特点和优缺点</h2><h3 id="3-1-C语言的特点："><a href="#3-1-C语言的特点：" class="headerlink" title="3.1 C语言的特点："></a>3.1 C语言的特点：</h3><p><strong>简洁和高效</strong>：C语言的语法简洁，而且执行速度快。它允许程序员直接操作硬件，因此经常用于系统编程。<br><strong>过程式</strong>：C语言是一种过程式语言，这意味着它侧重于过程和函数。<br><strong>低级功能</strong>：C语言提供了对内存的直接访问和操作，这对于开发底层应用程序和系统非常有用。<br><strong>可移植性</strong>：C语言编写的程序可以在多种不同的硬件平台上运行，只要有适当的编译器。<br><strong>丰富的库支持</strong>：C语言有一个广泛的标准库，提供了许多内置的函数。<br><strong>扩展性</strong>：C语言允许程序员轻松地扩展其功能通过使用外部库。</p><h3 id="3-2-C语言的优点："><a href="#3-2-C语言的优点：" class="headerlink" title="3.2 C语言的优点："></a>3.2 C语言的优点：</h3><p><strong>性能：</strong>C语言编写的程序通常具有很高的执行速度和优化的内存使用。<br><strong>控制：</strong>提供了对硬件资源的底层访问和控制。<br><strong>广泛应用：</strong>C语言用于开发各种类型的应用程序，包括操作系统、数据库系统、图形包和游戏等。</p><h3 id="3-3-C语言的缺点："><a href="#3-3-C语言的缺点：" class="headerlink" title="3.3 C语言的缺点："></a>3.3 C语言的缺点：</h3><p><strong>安全性：</strong>C语言中的内存管理是手动的，并且它允许直接操作内存地址，这可能导致安全问题，如缓冲区溢出。<br><strong>复杂性：</strong>尽管C语言的语法相对简单，但它的低级特性使得编写复杂程序变得困难。<br><strong>缺乏现代特性：</strong>与一些现代语言相比，C语言缺少一些高级特性，如垃圾收集、异常处理和面向对象编程。<br><strong>调试和维护：</strong>由于C语言的低级性质，调试和维护C语言程序可能会比使用高级语言更加困难。</p><h2 id="四、C语言的应用领域"><a href="#四、C语言的应用领域" class="headerlink" title="四、C语言的应用领域"></a>四、C语言的应用领域</h2><p><strong>操作系统：</strong>许多现代操作系统，包括Linux，Windows以及大部分Unix和Unix-like系统，都是用C语言编写的。这是因为C语言可以提供底层硬件访问和高效的内存管理。<br><strong>嵌入式系统：</strong>由于C语言的执行效率高且占用资源少，因此非常适合于嵌入式系统和实时系统的开发。<br><strong>硬件驱动：</strong>硬件驱动程序通常需要直接与特定硬件设备交互，而C语言提供了直接访问物理地址和硬件的能力。<br><strong>系统软件：</strong>除了操作系统外，很多系统级的软件，如数据库、网络服务器等，也是用C语言开发的。<br><strong>编译器和解释器：</strong>很多现代编程语言的编译器和解释器都是用C或C编写的。例如，Python的解释器CPython和Java的虚拟机JVM等。<br><strong>图形和游戏编程：</strong>C语言也在图形和游戏编程中被广泛使用，尤其是在需要对性能要求很高的场合。<br><strong>科学计算：</strong>很多科学计算软件和库，例如MATLAB等，底层都是用C或C编写的，以保证计算效率。</p><h2 id="五、八进制、十进制、十六进制数和计算机二进制"><a href="#五、八进制、十进制、十六进制数和计算机二进制" class="headerlink" title="五、八进制、十进制、十六进制数和计算机二进制"></a>五、<strong>八进制、十进制、十六进制数和计算机二进制</strong></h2><p><strong>十进制： 遇十进一 10个基础数</strong><br><strong>八进制： 遇十进一 8个基础数</strong><br><strong>十六进制： 遇十进一 16个基础数 0x</strong><br><strong>二进制： 遇十进一 2个基础数</strong></p><h2 id="六-C语言的第一个hello-world程序"><a href="#六-C语言的第一个hello-world程序" class="headerlink" title="六 C语言的第一个hello world程序"></a><strong>六 C语言的第一个hello world程序</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//  标准输入输出</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello hqyj\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="H:/Hexo-Blog/blog-demo/source/images/1694401532597-5a388e94-d5d5-4b76-aa56-537f6d476394.jpeg" alt="img"></p><p><strong>#include &lt;stdio.h&gt;</strong><br><strong>&#x2F;&#x2F; 标准输入输出</strong><br><strong>定义头文件</strong></p><p><strong>主函数</strong><br>**int main(int argc, char const <em>argv[])</em></p><p><strong>打印并输出到终端（屏幕）</strong><br><strong>printf(“hello hqyj\n”);</strong></p><p><strong>1、返回一个值</strong><br><strong>2、退出函数</strong><br><strong>return n;</strong></p><p><strong>n的类型，和你的函数类型一致</strong><br><strong>如果函数是void 空类型 直接 return；</strong></p><h1 id="第二章-C语言基础"><a href="#第二章-C语言基础" class="headerlink" title="第二章 C语言基础"></a><strong>第二章 C语言基础</strong></h1><p>@[toc]<strong>目标</strong></p><ul><li>1、C语言程序的基本结构</li><li>2、C语言关键字和标识符</li><li>3、C语言的数据类型和变量的以及存储类型</li><li>4、C语言中的标准输入输出函数</li><li>5、C语言中的常量</li><li>6、C语言中的运算符</li><li>7、C语言中的表达式式</li></ul><h2 id="一、C语言程序的基本结构"><a href="#一、C语言程序的基本结构" class="headerlink" title="一、C语言程序的基本结构"></a>一、C语言程序的基本结构</h2><h3 id="1-1-基本结构"><a href="#1-1-基本结构" class="headerlink" title="1.1 基本结构"></a>1.1 基本结构</h3><p>C语言程序的基本结构包括以下几个部分：<br><strong>1.预处理指令</strong>：这些编译器指令，通常放在程序的开头，#include &lt;stdio.h&gt; 。预处理器指令以#字符开始，最常见的#include,用于包含其他的头文件。<strong>2.函数</strong>：C程序中至少包含一个函数，即main()函数。main()函数是程序执行的起点。此外，一个C程序中可以包含其他的函数，这些函数可以自己定义也可以是从库中调用。<br><strong>3.变量</strong>：变量用于存储数据。在C语言中，每个变量都有特有类型。<br><strong>4.语句&amp;表达式</strong>：语句是执行特定任务的语句，如赋值语句、调用函数等，表达式则是计算产生值的计算公式。<br><strong>5.注释</strong>：注释用于解释程序的功能，对代码进行解释和描述。在C语言中，注释可以用&#x2F; <em>注释内容</em> &#x2F;或者&#x2F;&#x2F;注释内容来书写。<img src="https://cdn.nlark.com/yuque/0/2023/png/8368890/1694402052443-c71c85bb-05c5-4dcb-aa9e-c1c70e110bb2.png#averageHue=%23ebebeb&clientId=u1e415e4d-0a0d-4&from=paste&id=u49d8c282&originHeight=892&originWidth=948&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=319759&status=done&style=none&taskId=ua10423ec-bf6b-477f-bd6b-1cb5bb08a1a&title=?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_27%2Ctext_enpo%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" alt="img"></p><p>1、预处理<br>#include<br>2、main<br>主函数 不管在外面写了多少个函数 只能运行main<br>要运行外部函数，则需要通过main直接或间接的调用<br>3、语句<br>需要执行的程序</p><p>实例程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>   <span class="comment">//预处理指令</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这是一个简单的C程序 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>          <span class="comment">//函数开始</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">int</span> a = <span class="number">10</span>;     <span class="comment">//定义变量和赋值语句</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Hello World&quot;</span>);  <span class="comment">//语句：调用printf函数</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;       <span class="comment">//语句：返回，结束main函数</span></span><br><span class="line"> &#125;                   <span class="comment">//函数结束</span></span><br></pre></td></tr></table></figure><p>在这个程序中：<br>#include &lt;stdio.h&gt;是预处理指令，用于包含stdio.h头文件。<br>main()是函数，程序的入口。<br>int a &#x3D; 10为变量赋值语句。<br>printf是一个函数调用该语句，用于输出字符以及字符串和变量a的值。</p><h3 id="1-2-gcc编译器"><a href="#1-2-gcc编译器" class="headerlink" title="1.2 gcc编译器"></a>1.2 gcc编译器</h3><p><strong>gcc编译器的使用</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gcc [文件名]     编译</span><br><span class="line">./a.out 执行</span><br><span class="line"></span><br><span class="line">gcc [文件名] -o [程序名]    改名执行文件名称</span><br><span class="line"></span><br><span class="line">多文件</span><br><span class="line">gcc *.c -o [程序名]多文件编译    要求这整个文件夹都是同一个工程</span><br></pre></td></tr></table></figure><h4 id="1-2-1-gcc编译流程"><a href="#1-2-1-gcc编译流程" class="headerlink" title="1.2.1 gcc编译流程"></a>1.2.1 gcc编译流程</h4><p>gcc的编译流程分为4个步骤：<br>①预处理 -E .i 展开头文件 替换宏定义 删除注释<br>②编译-S .s 纠错<br>③汇编-c .o<br>④链接a.out<br>支持以下后缀：<br>.cC语言源代码<br>.h程序中所包含的头文件<br>.i已经预处理过的C源代码文件<br>.s汇编语言源代码文件<br>.o汇编后的目标文件<br><img src="H:/Hexo-Blog/blog-demo/source/images/1694412923517-c33863b7-41f0-4096-820b-e77c7c48e39a.jpeg" alt="img"></p><hr><p>接下通过一个实例程序来对gcc进行讲解，实例程序如下，分为两个文件一个hello.c和hello.h：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//hello.c//</span><br><span class="line"> #include &lt;stdio.h&gt;</span><br><span class="line"> #include &quot;hello.h&quot;</span><br><span class="line"> int main()</span><br><span class="line"> &#123;</span><br><span class="line">     u8 i;</span><br><span class="line">     printf(&quot;%ld\n&quot;,sizeof(i));</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br><span class="line">#ifndef __HELLO_H_</span><br><span class="line"> #define __HELLO_H_</span><br><span class="line"> </span><br><span class="line"> typedef unsigned int u8;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> #endif</span><br></pre></td></tr></table></figure><hr><p><strong>预处理阶段：</strong><br>gcc的选项”-E”可以使用编译器在预处理结束时就停止编译，选项-o是指定gcc输出结果，<br>gcc -E -o [目标文件] [编译文件] gcc -E -o hello.i hello.c<br><strong>编译阶段：</strong><br>编译器在预处理结束后开始使用，gcc首先要检查代码的规范性、是否还有语法错误等，在检查无误后，就开始把代码翻译成汇编语言。<br>gcc -S -o [目标文件] [编译文件] gcc -S -o hello.s hello.i<br><strong>汇编阶段:</strong><br>汇编的过程就是将.s文件生成生产目标文件，我们在使用-c就可以看到汇编的代码转换成为.o的二进制目标代码了。<br>gcc -c -o [目标文件] [编译文件]gcc -c -o hello.o hello.s<br><strong>链接阶段：</strong><br>成功编译后，就进入到了链接阶段，在这里涉及到一个很重要的概念：函数库。<br>当我们使用一些库文件时，则会</p><h2 id="二、C语言关键字和标识符"><a href="#二、C语言关键字和标识符" class="headerlink" title="二、C语言关键字和标识符"></a>二、C语言关键字和标识符</h2><h3 id="2-1关键字"><a href="#2-1关键字" class="headerlink" title="2.1关键字"></a>2.1关键字</h3><p><strong>关键字</strong>：关键字是C语言中预先定义并保留的特殊单词，每个关键字在C语言中都有特定的含义和用途。我们在编写C程序时不能将关键字作为变量名或者其他标识名。以下是C语言的关键字：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>        <span class="type">double</span>      <span class="type">int</span>         <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class"><span class="title">break</span>       <span class="title">else</span>        <span class="title">long</span>        <span class="title">switch</span></span></span><br><span class="line"><span class="class"><span class="title">case</span>        <span class="title">enum</span>        <span class="title">register</span>    <span class="title">typedef</span></span></span><br><span class="line"><span class="class"><span class="title">char</span>        <span class="title">extern</span>      <span class="title">return</span>      <span class="title">union</span></span></span><br><span class="line"><span class="class"><span class="title">const</span>       <span class="title">float</span>       <span class="title">short</span>       <span class="title">unsigned</span></span></span><br><span class="line"><span class="class"><span class="title">continue</span>    <span class="title">for</span>         <span class="title">signed</span>      <span class="title">void</span></span></span><br><span class="line"><span class="class"><span class="title">default</span>     <span class="title">goto</span>        <span class="title">sizeof</span>      <span class="title">volatile</span></span></span><br><span class="line"><span class="class"><span class="title">do</span>          <span class="title">if</span>          <span class="title">static</span>      <span class="title">while</span></span></span><br></pre></td></tr></table></figure><h3 id="2-2标识符"><a href="#2-2标识符" class="headerlink" title="2.2标识符"></a>2.2标识符</h3><p><strong>标识符</strong>：是程序编写过程中的变量名、函数名、数组名等元素定义的名称。标识符的命名需要遵循以下规则：<br>1.标识符的第一个字符必须是字母（大写或小写）或者下划线”_”。<br>2.后续的字符可以是字母、数字或下划线。<br>3.关键字不能作为标识符。<br>4.标识符在C语言中是区分大小写的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> myVar;</span><br><span class="line"><span class="type">double</span> _myVar;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> var123;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myFunction</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//错误</span></span><br><span class="line"><span class="type">int</span> <span class="number">123</span>var;    <span class="comment">// 以数字开头</span></span><br><span class="line"><span class="type">double</span> <span class="type">double</span>; <span class="comment">// 使用了关键字</span></span><br></pre></td></tr></table></figure><hr><p>随堂小测：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int score;              // 正确</span><br><span class="line">double _maxValue;       // 正确</span><br><span class="line">char response1;         // 正确</span><br><span class="line">int 7score;             // 错误，名称不能以数字开头</span><br><span class="line">void print_score();     // 正确</span><br><span class="line">double double;          // 错误，不能使用关键字作为名称</span><br><span class="line">char a b;               // 错误，名称中不能有空格</span><br><span class="line">int number of students; // 错误，名称中不能有空格</span><br><span class="line">void PrintScore();      // 正确，但不符合C语言的常见命名习惯，函数名通常全部小写，如print_score</span><br><span class="line">int NumberOfStudents;   // 正确，但不符合C语言的常见命名习惯，更常见的是使用下划线，如number_of_students</span><br></pre></td></tr></table></figure><hr><h2 id="三、C语言的数据类型和变量的以及存储类型"><a href="#三、C语言的数据类型和变量的以及存储类型" class="headerlink" title="三、C语言的数据类型和变量的以及存储类型"></a>三、C语言的数据类型和变量的以及存储类型</h2><h3 id="3-1-计算机数据的表示"><a href="#3-1-计算机数据的表示" class="headerlink" title="3.1 计算机数据的表示"></a>3.1 计算机数据的表示</h3><h4 id="3-1-1-进制"><a href="#3-1-1-进制" class="headerlink" title="3.1.1 进制"></a>3.1.1 进制</h4><p>计算机中数据通常以二进制形式表示，但根据需要，它们可以进一步划分为不同的类型。以下是常见的计算机中数据表示的方式：</p><h5 id="3-1-1-1-数值数据"><a href="#3-1-1-1-数值数据" class="headerlink" title="3.1.1.1 数值数据"></a>3.1.1.1 数值数据</h5><ol><li><strong>二进制</strong>：这是计算机最基础的数据表示方式，所有的信息都可以转换为0和1。这是因为计算机的硬件电路（例如，开关和逻辑门）最适合处理二进制系统。</li><li><strong>十进制</strong>：尽管计算机内部使用二进制，但在显示和输入数据时，通常使用我们更熟悉的十进制系统。计算机内部会将十进制数字转换为二进制，进行计算后再转回十进制。</li><li><strong>十六进制</strong>：十六进制被广泛用于计算机科学和编程，因为它可以更简洁地表示二进制数。每个十六进制数字可以精确地表示四个二进制位，这使得二进制数和十六进制数之间的转换非常直接。</li><li><strong>各进制的前缀和后缀</strong></li></ol><p><img src="H:/Hexo-Blog/blog-demo/source/images/1705913805089-42cec186-671d-4880-9f6f-fb9a0dde9403.png" alt="img"></p><p>6、进制间的转化</p><p>短除法和乘积法</p><h5 id="3-1-1-1-非数值数据"><a href="#3-1-1-1-非数值数据" class="headerlink" title="3.1.1.1 非数值数据"></a>3.1.1.1 非数值数据</h5><ol><li><strong>ASCII</strong>：ASCII是一种将字符（如字母、数字和特殊符号）映射到二进制数的标准。例如，在ASCII中，大写字母A的编码是65，对应的二进制是1000001。</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2023/png/8368890/1694413927041-f1076166-e505-4a03-a6d3-0da3526c6f8d.png#averageHue=%23d2d2d2&clientId=u87bc8a45-431d-4&from=paste&height=615&id=uf648587b&originHeight=923&originWidth=1434&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=1855008&status=done&style=none&taskId=u69f69612-fbc5-4daa-a5a0-59a75716fc2&title=&width=956?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_41%2Ctext_enpo%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" alt="img"></p><ol><li><strong>浮点数</strong>：计算机使用浮点数表示法来存储和操作实数。IEEE 754标准定义了浮点数的表示方式和操作，这是现代计算机最广泛使用的浮点数标准。</li></ol><h4 id="3-1-2-源码、反码、补码"><a href="#3-1-2-源码、反码、补码" class="headerlink" title="3.1.2 源码、反码、补码"></a>3.1.2 源码、反码、补码</h4><p>原码、反码和补码是用于表示和存储二进制有符号整数的方式。它们都用最高位（通常是左边的位）表示符号，0表示正，1表示负。<br><strong>原码</strong>：原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。比如如果是8位二进制：</p><ul><li>[+1]原 &#x3D; 0000 0001</li><li>[-1]原 &#x3D; 1000 0001</li></ul><p>有符号数的第一位为符号位<br><strong>反码</strong>：正数的反码是其本身，负数的反码是在其原码的基础上, <strong>符号位</strong>不变，其余各位取反。</p><ul><li>[+1]反 &#x3D; 0000 0001</li><li>[-1]反 &#x3D; 1111 1110</li></ul><p><strong>补码</strong>：正数的补码就是其本身，负数的补码是在其原码的基础上，符号位不变，其余各个位取反，然后最后一位加1。</p><ul><li>[+1]补 &#x3D; 0000 0001</li><li>[-1]补 &#x3D; 1111 1111</li></ul><p>原码 本身<br>反码原码取反<br>补码反码 + 1<br><img src="H:/Hexo-Blog/blog-demo/source/images/1694414463919-3a9085cb-c5aa-44c1-9bf2-e9c1db389d41.jpeg" alt="img"></p><h3 id="3-2-数据类型"><a href="#3-2-数据类型" class="headerlink" title="3.2 数据类型"></a>3.2 数据类型</h3><h4 id="数据类型的作用"><a href="#数据类型的作用" class="headerlink" title="数据类型的作用"></a>数据类型的作用</h4><p>在计算机最开始的时候，没有这么大的存储空间，需要一个东西规范存储空间的大小</p><p><img src="H:/Hexo-Blog/blog-demo/source/images/1694414895788-0970ee59-ece2-4e51-8f25-de4805bf240f.jpeg" alt="img"><br>在C语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，以及该位置可以参与的运算。<br>C语言中的数据类型主要可以分为以下几类：</p><h4 id="3-2-1-基本类型：它们是算术类型，包括两种类型：整数类型和浮点类型。"><a href="#3-2-1-基本类型：它们是算术类型，包括两种类型：整数类型和浮点类型。" class="headerlink" title="3.2.1 基本类型：它们是算术类型，包括两种类型：整数类型和浮点类型。"></a>3.2.1 <strong>基本类型</strong>：它们是算术类型，包括两种类型：整数类型和浮点类型。</h4><ul><li>整数类型包括：char、short int、int、long int、long long int。</li><li>浮点类型包括：float、double、long double。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//● 整数类型包括：char、short int、int、long int、long long int。</span></span><br><span class="line"><span class="comment">//● 浮点类型包括：float、double、long double。</span></span><br><span class="line"><span class="comment">//● ascll</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//int               整型</span></span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,<span class="keyword">sizeof</span>(num));</span><br><span class="line">    <span class="comment">//char              字符型</span></span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ch);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>,<span class="keyword">sizeof</span>(ch));</span><br><span class="line">    <span class="comment">//short int         短整型</span></span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> sh_in = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span> , <span class="keyword">sizeof</span>(sh_in));</span><br><span class="line">    <span class="comment">//long int          长整型</span></span><br><span class="line">    <span class="comment">//long long int     长长整型</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> lo_in = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span> , <span class="keyword">sizeof</span>(lo_in));</span><br><span class="line">    <span class="comment">//无符号 整型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> un_in = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span> , <span class="keyword">sizeof</span>(un_in));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//● 浮点类型包括：float、double、long double。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//单精度浮点型          4</span></span><br><span class="line">    <span class="type">float</span> fl = <span class="number">3.14</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span> , <span class="keyword">sizeof</span>(fl));</span><br><span class="line">    <span class="comment">//双精度浮点型          8</span></span><br><span class="line">    <span class="type">double</span> dou = <span class="number">3.14</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span> , <span class="keyword">sizeof</span>(dou));</span><br><span class="line">    <span class="comment">//长双精度浮点型        16</span></span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> dou_1 = <span class="number">3.14</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span> , <span class="keyword">sizeof</span>(dou_1));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、C语言中的标准输入输出函数"><a href="#四、C语言中的标准输入输出函数" class="headerlink" title="四、C语言中的标准输入输出函数"></a>四、C语言中的标准输入输出函数</h2><hr><h3 id="4-2-缓冲区"><a href="#4-2-缓冲区" class="headerlink" title="4.2 缓冲区"></a>4.2 缓冲区</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/png/8368890/1694402052315-6787a482-0758-47ac-95c2-8cfbf0b92003.png#averageHue=%23eeeeee&clientId=u1e415e4d-0a0d-4&from=paste&id=ubf32db6f&originHeight=746&originWidth=1080&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=270818&status=done&style=none&taskId=u2dbca5a3-476d-4828-9f43-d51e57558dd&title=?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_31%2Ctext_enpo%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10" alt="img"></p><ol><li><strong>输入缓冲区：</strong> 当我们在键盘上敲击字符时，这些字符首先被存储在输入缓冲区中。当我们按下回车键或者缓冲区满时，存储在缓冲区的数据才会被送入程序处理。</li><li><strong>输出缓冲区：</strong> 当我们执行一个输出函数(如printf)时，数据首先被放入输出缓冲区，直到缓冲区满或者调用刷新缓冲区函数（如fflush）时，才会真正输出到屏幕上。</li></ol><h3 id="4-2-输入函数："><a href="#4-2-输入函数：" class="headerlink" title="4.2 输入函数："></a>4.2 输入函数：</h3><ol><li>scanf()：此函数用于从标准输入（键盘）读取并转换。它需要一个格式字符串，该字符串确定了如何读取输入。</li><li>getchar()：此函数从标准输入读取并返回一个字符。</li><li>gets()：此函数从指定的流中读取并存储一行字符。该行以空字符终止。</li></ol><h3 id="4-3-输出函数："><a href="#4-3-输出函数：" class="headerlink" title="4.3 输出函数："></a>4.3 输出函数：</h3><ol><li>printf()：此函数用于在标准输出（显示器）上打印格式化的输出。它需要一个格式字符串，该字符串确定了如何打印变量的值。</li><li>putchar()：此函数将一个字符写入标准输出。</li><li>puts()：此函数写一个字符串和一个尾随的换行符到标准输出。</li></ol><h4 id="scanf-printf-格式化输入-输出"><a href="#scanf-printf-格式化输入-输出" class="headerlink" title="scanf printf 格式化输入\输出"></a>scanf printf 格式化输入\输出</h4><p><strong>scanf</strong> </p><p>*<em>函数原型 extern int scanf (const char <em>__restrict <strong>format, …)</strong> wur;</em></em><br><strong>函数参数</strong><br>**const char <em>__restrict __format 输入格式</em><br><strong>…多参数 输入数据</strong><br><strong>返回值</strong><br><strong>函数功能 从标准输入设备(键盘)中获取数据</strong></p><p><strong>printf</strong></p><p>**函数原型 printf (const char <em>__restrict __fmt, …)</em><br><strong>函数参数</strong><br>**const char <em>__restrict __fmt 输出格式</em><br><strong>…多参数 输出数据</strong><br><strong>返回值没有</strong><br><strong>函数功能 向标准输出设备（屏幕 终端）中输出数据</strong></p><h4 id="putchar-getchar-单字符输入-输出"><a href="#putchar-getchar-单字符输入-输出" class="headerlink" title="putchar getchar 单字符输入\输出"></a>putchar getchar 单字符输入\输出</h4><p><strong>putchar</strong></p><p>putchar (int __c)<br>{<br>return *IO_putc (<strong><strong>c, stdout);<br>*</strong><em><strong>}<br>*</strong></em><strong>*函数原型 putchar (int</strong> c)</strong><br><strong>函数参数</strong><br><strong>int c 需要输出的字符</strong><br><strong>返回值没有</strong><br><strong>函数功能 向标准输出设备（屏幕 终端）中输出数据</strong></p><p><strong>getchar</strong></p><p><strong>getchar (void)</strong><br><strong>{</strong><br> <strong>return _IO_getc (stdin);</strong><br><strong>}</strong></p><p><strong>函数原型 getchar (void)</strong><br><strong>函数参数</strong><br><strong>返回值return _IO_getc (stdin); 返回从键盘中读取到的一个字符</strong><br><strong>函数功能 从标准输入设备(键盘)中获取数据</strong></p><h5 id="4-5-3-printf描述符"><a href="#4-5-3-printf描述符" class="headerlink" title="4.5.3 printf描述符"></a>4.5.3 printf描述符</h5><p>格式符号111</p><table><thead><tr><th><strong>格式说明符</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>%d</td><td>以十进制形式输出带符号整数</td></tr><tr><td>%u</td><td>以十进制形式输出无符号整数</td></tr><tr><td>%f</td><td>以小数形式输出单、双精度浮点数</td></tr><tr><td>%e, %E</td><td>以指数形式输出单、双精度浮点数</td></tr><tr><td>%g, %G</td><td>根据值的不同，自动选择%f或%e、%E格式输出单、双精度浮点数</td></tr><tr><td>%c</td><td>输出一个字符</td></tr><tr><td>%s</td><td>输出一个字符串</td></tr><tr><td>%p</td><td>输出一个指针（以十六进制形式输出指针的值）</td></tr><tr><td>%x, %X</td><td>以十六进制形式输出无符号整数</td></tr><tr><td>%o</td><td>以八进制形式输出无符号整数</td></tr><tr><td>%ld</td><td>输出长整型（sizeof的输出常用）</td></tr><tr><td>%lu</td><td>输出无符号长整型</td></tr></tbody></table><p>格式的描述符a1</p><table><thead><tr><th><strong>修饰符</strong></th><th><strong>示例代码</strong></th><th><strong>输出</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>-</td><td>printf(“%-10d”, 123);</td><td>123</td><td>左对齐输出</td></tr><tr><td>+</td><td>printf(“%+d”, 123);</td><td>+123</td><td>在正数前面显示加号</td></tr><tr><td>空格</td><td>printf(“% d”, 123);</td><td>123</td><td>在正数前面显示空格</td></tr><tr><td>#</td><td>printf(“%#o”, 123);</td><td>0173</td><td>以八进制显示数值</td></tr><tr><td>0</td><td>printf(“%010d”, 123);</td><td>0000000123</td><td>左边用0填充</td></tr><tr><td>数字</td><td>printf(“%10d”, 123);</td><td></td><td></td></tr><tr><td>printf(“%-10d”, 123);</td><td>123</td><td>设定字段宽度为10</td><td></td></tr><tr><td>.</td><td>printf(“%.2f”, 123.456);</td><td>123.46</td><td>保留2位小数</td></tr><tr><td>l</td><td>printf(“%ld”, 123456789L);</td><td>123456789</td><td>长整型</td></tr><tr><td>ll</td><td>printf(“%lld”, 123456789012345LL);</td><td>123456789012345</td><td>长长整型</td></tr><tr><td>h</td><td>short s &#x3D; 123; printf(“%hd”, s);</td><td>123</td><td>短整型</td></tr><tr><td>hh</td><td>signed char c &#x3D; 123; printf(“%hhd”, c);</td><td>123</td><td>有符号字符</td></tr><tr><td>L</td><td>printf(“%Lf”, 123456.789L);</td><td>123456.789000</td><td>长双精度浮点数</td></tr></tbody></table><h5 id="4-5-4-scanf描述符"><a href="#4-5-4-scanf描述符" class="headerlink" title="4.5.4 scanf描述符"></a>4.5.4 scanf描述符</h5><p>描述符</p><table><thead><tr><th><strong>描述符</strong></th><th><strong>作用</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>%d</td><td>匹配带符号的十进制整数</td><td>scanf(“%d”, &amp;num);</td></tr><tr><td>%i</td><td>匹配带符号的整数，可以是十进制、八进制、十六进制</td><td>scanf(“%i”, &amp;num);</td></tr><tr><td>%o</td><td>匹配八进制整数</td><td>scanf(“%o”, &amp;num);</td></tr><tr><td>%u</td><td>匹配无符号十进制整数</td><td>scanf(“%u”, &amp;num);</td></tr><tr><td>%x%X</td><td>匹配无符号十六进制整数</td><td>scanf(“%x”, &amp;num);</td></tr><tr><td>%f</td><td>匹配浮点数</td><td>scanf(“%f”, &amp;num);</td></tr><tr><td>%e%E</td><td>匹配浮点数，可以是指数形式</td><td>scanf(“%e”, &amp;num);</td></tr><tr><td>%g%G</td><td>根据数值和精度选择 %f 或 %e (%E)</td><td>scanf(“%g”, &amp;num);</td></tr><tr><td>%c</td><td>匹配一个字符</td><td>scanf(“%c”, &amp;char);</td></tr><tr><td>%s</td><td>匹配字符串，遇到空格、制表符或换行符结束</td><td>scanf(“%s”, str);</td></tr><tr><td>%p</td><td>匹配指针</td><td>scanf(“%p”, &amp;ptr);</td></tr></tbody></table><p><strong>注意：scanf中的 %s 和 printf 中的 %s 的行为是完全不同的。printf 中的 %s 会输出字符串直到遇到空字符 ‘\0’，而 scanf 中的 %s 会读取输入直到遇到一个空格、制表符或换行符。</strong></p><h4 id="4-6-字符串I-O：puts-和gets"><a href="#4-6-字符串I-O：puts-和gets" class="headerlink" title="4.6 字符串I&#x2F;O：puts()和gets()"></a>4.6 字符串I&#x2F;O：puts()和gets()</h4><h5 id="4-6-1-puts"><a href="#4-6-1-puts" class="headerlink" title="4.6.1 puts"></a>4.6.1 puts</h5><hr><p>函数：<strong>puts()</strong><br>头文件：#include &lt;stdio.h&gt;<br>函数原型：int puts(const char <em>s);<br>功能：将字符串s和一个尾随的换行符写入到标准输出(stdout)。<br>参数：</em>s – 指向一个字符数组的指针，该数组包含了一个空字符(‘\0’)来结束输入的字符串。<br>返回值：如果执行成功，返回非负值，如果发生错误则返回EOF。</p><hr><h5 id="4-6-1-gets"><a href="#4-6-1-gets" class="headerlink" title="4.6.1 gets"></a>4.6.1 gets</h5><hr><p>函数：<strong>gets()</strong><br>头文件：#include &lt;stdio.h&gt;<br>函数原型：char <em>gets(char</em> s);<br>功能：从标准输入(stdin)读取一行，并把它保存到str所指向的字符数组，它会在读取的行尾自动加上null字符，但它不会保留换行符。<br>参数：*s – 一个数组，该数组用来存储读取的字符串，直到一个换行符(‘\n’)或EOF。<br>返回值：如果执行成功，返回str。如果发生错误或读到文件的末尾且未读到任何字符，返回NULL。<br>注意：C11已经从库函数中删除了gets()，使用该函数可能会存在安全风险，比如缓冲区溢出等问题，通常建议使用fgets()替代。</p><hr><h3 id="五、C语言中的常量"><a href="#五、C语言中的常量" class="headerlink" title="五、C语言中的常量"></a>五、C语言中的常量</h3><hr><p>#define LENGTH 10 const int WIDTH &#x3D; 5;</p><hr><p>比较</p><ul><li>#define是预处理器宏，而const是语言自身的一部分。</li><li>const可以用于更复杂的类型，比如对象，而#define只能用于基本类型。</li><li>#define不分配存储空间，而const通常分配存储空间（例如在RAM中）。</li><li>const常量的类型和大小都是固定的，但#define预处理器宏没有固定的类型或大小。</li></ul><h2 id="六、C语言中的运算符"><a href="#六、C语言中的运算符" class="headerlink" title="六、C语言中的运算符"></a>六、C语言中的运算符</h2><table><thead><tr><th><strong>运算符类别</strong></th><th><strong>运算符</strong></th></tr></thead><tbody><tr><td>算术运算符</td><td>+，-，*，&#x2F;，%</td></tr><tr><td>赋值运算符</td><td>&#x3D;，+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;，%&#x3D;</td></tr><tr><td>关系运算符</td><td>&#x3D;&#x3D;，!&#x3D;，&gt;，&lt;，&gt;&#x3D;，&lt;&#x3D;</td></tr><tr><td>逻辑运算符</td><td>&amp;&amp;，|| ，！</td></tr><tr><td>位运算符</td><td>&amp;，|，^，~，&lt;&lt;，&gt;&gt;</td></tr><tr><td>条件运算符</td><td>? :</td></tr><tr><td>自增自减运算符</td><td>++，– 前置和后置得一个关系</td></tr><tr><td>逗号运算符</td><td>,</td></tr><tr><td>指针运算符</td><td>*，&amp;</td></tr><tr><td>sizeof运算符</td><td>sizeof （单目）</td></tr></tbody></table><h3 id="6-1-算术运算符"><a href="#6-1-算术运算符" class="headerlink" title="6.1 算术运算符"></a>6.1 算术运算符</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a + b = %d\n&quot;</span>, a + b);  <span class="comment">// 30</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a - b = %d\n&quot;</span>, a - b);  <span class="comment">// -10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a * b = %d\n&quot;</span>, a * b);  <span class="comment">// 200</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b / a = %d\n&quot;</span>, b / a);  <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b %% a = %d\n&quot;</span>, b % a);  <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2-赋值运算符"><a href="#6-2-赋值运算符" class="headerlink" title="6.2 赋值运算符"></a>6.2 赋值运算符</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    a += <span class="number">20</span>;  <span class="comment">// a = a + 20</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);  <span class="comment">// 30</span></span><br><span class="line"></span><br><span class="line">    a -= <span class="number">5</span>;  <span class="comment">// a = a - 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);  <span class="comment">// 25</span></span><br><span class="line"></span><br><span class="line">    a *= <span class="number">2</span>;  <span class="comment">// a = a * 2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);  <span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line">    a /= <span class="number">10</span>;  <span class="comment">// a = a / 10</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);  <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    a %= <span class="number">3</span>;  <span class="comment">// a = a % 3</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);  <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-关系运算符"><a href="#6-3-关系运算符" class="headerlink" title="6.3 关系运算符"></a>6.3 关系运算符</h3><p>关系运算符在C语言中用于比较两个值，结果为一个布尔值（0或1）。如果比较的条件成立，那么结果为1，否则为0。以下是C语言中的关系运算符：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a &gt; b: %d\n&quot;</span>, a &gt; b);  <span class="comment">// 0 (false)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a &lt; b: %d\n&quot;</span>, a &lt; b);  <span class="comment">// 1 (true)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a &gt;= b: %d\n&quot;</span>, a &gt;= b);  <span class="comment">// 0 (false)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a &lt;= b: %d\n&quot;</span>, a &lt;= b);  <span class="comment">// 1 (true)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a == b: %d\n&quot;</span>, a == b);  <span class="comment">// 0 (false)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a != b: %d\n&quot;</span>, a != b);  <span class="comment">// 1 (true)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4-逻辑运算符"><a href="#6-4-逻辑运算符" class="headerlink" title="6.4 逻辑运算符"></a>6.4 逻辑运算符</h3><p>逻辑运算符用于链接和操作布尔值（真或假，即1或0）。C语言中的逻辑运算符包括“与”（&amp;&amp;），“或”（||）和“非”（！）。以下是这些运算符的解释：<br>**1.**逻辑与运算符（&amp;&amp;）：当两边的操作数都为真（非零）时，结果才为真。如果任一操作数为假（即零），结果就为假。<br>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> result = a || b; <span class="comment">// result 的值为 1，因为 a 为非零</span></span><br></pre></td></tr></table></figure><p>**2.**逻辑或运算符（||）：只要两个操作数中的任一操作数为真，结果就为真。只有当两个操作数都为假，结果才为假。<br>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">int b = 0;</span><br><span class="line">int result = a || b; // result 的值为 1，因为 a 为非零</span><br></pre></td></tr></table></figure><p>**3.**逻辑非运算符（!）：这是一个单目运算符，对一个布尔值进行取反操作。如果操作数为真，结果为假，反之亦然。<br>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> result = !a; <span class="comment">// result 的值为 0，因为 a 为真（非零）</span></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a &amp;&amp; b: %d\n&quot;</span>, a &amp;&amp; b);  <span class="comment">// 0 (false)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a || b: %d\n&quot;</span>, a || b);  <span class="comment">// 1 (true)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;!a: %d\n&quot;</span>, !a);  <span class="comment">// 0 (false)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;!b: %d\n&quot;</span>, !b);  <span class="comment">// 1 (true)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-5-位运算符"><a href="#6-5-位运算符" class="headerlink" title="6.5 位运算符"></a>6.5 位运算符</h3><p>位运算符直接对整数在内存中的二进制位进行操作。这些运算符包括：<br>按位与(&amp;) ： 全一得一<br>按位或(|)： 有一得一<br>按位异或(^)： 相同为0 不同为1<br>取反(~)： 取反<br>左移(&lt;&lt;)和右移(&gt;&gt;）：</p><p>下面详细解释每一种：<br>**1.**按位与运算符（&amp;）：如果两个相应的二进制位都为1，则结果为1，否则为0。<br>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">60</span>;  <span class="comment">// 60的二进制是 0011 1100</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">13</span>;  <span class="comment">// 13的二进制是 0000 1101</span></span><br><span class="line"><span class="type">int</span> result = a &amp; b;  <span class="comment">// result 的值为 12，二进制为 0000 1100</span></span><br></pre></td></tr></table></figure><p>**2.**按位或运算符（|）：如果两个相应的二进制位中至少有一个1，则结果为1，否则为0。<br>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">60</span>;  <span class="comment">// 60的二进制是 0011 1100</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">13</span>;  <span class="comment">// 13的二进制是 0000 1101</span></span><br><span class="line"><span class="type">int</span> result = a | b;  <span class="comment">// result 的值为 61，二进制为 0011 1101</span></span><br></pre></td></tr></table></figure><p>**3.**按位异或运算符（^）：如果两个相应的二进制位值相同，则结果为0，否则为1。<br>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">60</span>;  <span class="comment">// 60的二进制是 0011 1100</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">13</span>;  <span class="comment">// 13的二进制是 0000 1101</span></span><br><span class="line"><span class="type">int</span> result = a ^ b;  <span class="comment">// result 的值为 49，二进制为 0011 0001</span></span><br></pre></td></tr></table></figure><p>**4.**取反运算符（~）：对数的每一位取反，0变1，1变0。<br>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">60</span>;  <span class="comment">// 60的二进制是 0011 1100</span></span><br><span class="line"><span class="type">int</span> result = ~a;  <span class="comment">// result 的值为 -61，二进制为 1100 0011</span></span><br></pre></td></tr></table></figure><p>**5.**左移运算符（&lt;&lt;）：把位向左移动指定的位数，右边用0填充。<br>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">15</span>;  <span class="comment">// 15的二进制是 0000 1111</span></span><br><span class="line"><span class="type">int</span> result = a &lt;&lt; <span class="number">2</span>;  <span class="comment">// result 的值为 60，二进制为 0011 1100</span></span><br></pre></td></tr></table></figure><p>**6.**右移运算符（&gt;&gt;）：把位向右移动指定的位数，左边的空位如何填充取决于数字的符号（正数左边填充0，负数左边填充1）。<br>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">15</span>;  <span class="comment">// 15的二进制是 0000 1111</span></span><br><span class="line"><span class="type">int</span> result = a &gt;&gt; <span class="number">2</span>;  <span class="comment">// result 的值为 3，二进制为 0000 0011</span></span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">60</span>; <span class="comment">/* 60 = 0011 1100 */</span></span><br><span class="line">    <span class="type">int</span> b = <span class="number">13</span>; <span class="comment">/* 13 = 0000 1101 */</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">    result = a &amp; b; <span class="comment">/* 12 = 0000 1100 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = a &amp; b: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    result = a | b; <span class="comment">/* 61 = 0011 1101 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = a | b: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    result = a ^ b; <span class="comment">/* 49 = 0011 0001 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = a ^ b: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    result = ~a; <span class="comment">/*-61 = 1100 0011 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = ~a: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    result = a &lt;&lt; <span class="number">2</span>; <span class="comment">/* 240 = 1111 0000 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = a &lt;&lt; 2: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    result = a &gt;&gt; <span class="number">2</span>; <span class="comment">/* 15 = 0000 1111 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result = a &gt;&gt; 2: %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-6-条件运算符"><a href="#6-6-条件运算符" class="headerlink" title="6.6 条件运算符"></a>6.6 条件运算符</h3><p>条件运算符也称为<strong>三元运算符</strong>，其格式为：<br><strong>条件表达式 ? 表达式1 : 表达式2</strong><br>三元运算符的执行过程是这样的：</p><ul><li>首先，程序会计算条件表达式的值</li><li>如果条件表达式的值为真（非0），那么程序会计算调大是1</li></ul><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = 20;</span><br><span class="line">    int max = a &gt; b ? a : b;</span><br><span class="line">    printf(&quot;最大的数是：%d\n&quot;, max);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 10;</span><br><span class="line">    int b = (a == 1) ? 20 : 30;</span><br><span class="line">    printf(&quot;b is %d\n&quot;, b);  // b is 30</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-7-自增自减运算符"><a href="#6-7-自增自减运算符" class="headerlink" title="6.7 自增自减运算符"></a>6.7 自增自减运算符</h3><p>C语言中的自增（++）和自减（–）运算符用于增加或减少变量的值。这些运算符有前缀和后缀两种形式，对应着不同的操作顺序。</p><ul><li>前缀自增&#x2F;自减：先进行自增&#x2F;自减操作，然后再进行其他操作。例如，++a 或 –a。</li><li>后缀自增&#x2F;自减：先进行其他操作，然后再进行自增&#x2F;自减操作。例如，a++ 或 a–。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int b = ++a; // 先增加a的值，然后赋值给b。此时a和b都为11。</span><br><span class="line"></span><br><span class="line">a = 10; // 重置a的值为10</span><br><span class="line">b = a++; // 先将a的值赋给b，然后再增加a的值。此时a为11，b为10。</span><br></pre></td></tr></table></figure><h3 id="6-8-逗号运算符"><a href="#6-8-逗号运算符" class="headerlink" title="6.8 逗号运算符"></a>6.8 逗号运算符</h3><p>逗号运算符在C语言中被用来链接两个或更多的独立的表达式，从而使它们能在一行内执行。逗号运算符有两个主要的特点：</p><ol><li>从左至右的顺序执行：逗号运算符的所有操作数都按从左到右的顺序进行计算。</li><li>返回值：逗号运算符的返回值是最后一个表达式的值。</li></ol><p>让我们看一个简单的例 子来更好地理解这个概念：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line"></span><br><span class="line">    a = (b=<span class="number">4</span>, b+<span class="number">2</span>); </span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a 的值是 %d\n&quot;</span>, a );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，逗号运算符将两个表达式b&#x3D;4和b+2链接在一起。首先，b&#x3D;4被执行，然后执行b+2，最后，b+2的结果被赋给变量a。因此，a的最终值为6。<br>请注意，虽然逗号运算符可以将多个表达式链接在一起，但过度使用可能会使代码难以理解和维护。在编程时，最好尽可能地保持代码的清晰和简洁。</p><h3 id="6-9-指针运算符"><a href="#6-9-指针运算符" class="headerlink" title="6.9 指针运算符"></a>6.9 指针运算符</h3><p>在C语言中，我们主要有4个指针运算符，它们是：</p><ol><li><em>（解引用运算符）：这个运算符返回指针所指向的值。例如，如果p是一个指向整数的指针，并且该整数的值是10，那么</em>p将返回10。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">int *p = &amp;a;</span><br><span class="line">printf(&quot;%d\n&quot;, *p);  // 输出: 10</span><br></pre></td></tr></table></figure><ol><li>&amp;（取地址运算符）：这个运算符返回变量的内存地址。例如，如果a是一个整数，那么&amp;a将返回这个整数在内存中的地址。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">printf(&quot;%p\n&quot;, &amp;a);  // 输出: a在内存中的地址</span><br></pre></td></tr></table></figure><ol><li>和–（自增和自减运算符）：这些运算符用于改变指针的值，使其指向下一个或上一个内存位置。如果p是一个指向整数的指针，并且整数占用4个字节，那么p将使p指向内存中的下一个整数，而p–将使p指向内存中的上一个整数。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int arr[] = &#123;10, 20, 30&#125;;</span><br><span class="line">int *p = arr;</span><br><span class="line">printf(&quot;%d\n&quot;, *p);  // 输出: 10</span><br><span class="line">p++;</span><br><span class="line">printf(&quot;%d\n&quot;, *p);  // 输出: 20</span><br></pre></td></tr></table></figure><ol><li>指针比较运算符：这些包括 &#x3D;&#x3D;、!&#x3D;、&lt;、&gt;、&lt;&#x3D;、&gt;&#x3D;。它们可以用来比较两个指针的值（即它们所指向的内存地址）。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a = 10, b = 20;</span><br><span class="line">int *p1 = &amp;a, *p2 = &amp;b;</span><br><span class="line"></span><br><span class="line">if (p1 != p2) &#123;</span><br><span class="line">    printf(&quot;p1 and p2 point to different locations.\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是C语言中关于指针的主要运算符。</p><h3 id="6-10-sizeof运算符"><a href="#6-10-sizeof运算符" class="headerlink" title="6.10 sizeof运算符"></a>6.10 sizeof运算符</h3><p>sizeof运算符是C语言中的一种单目运算符，用于获取一个特定类型或特定对象的大小（以字节为单位）。其可以应用于任何数据类型，包括基本类型（如int、char、double等）、派生类型（如数组、指针等）和自定义类型（如结构体、联合等）。<br>以下是sizeof运算符的一些使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a;</span><br><span class="line">    double b;</span><br><span class="line">    char c[10];</span><br><span class="line">    </span><br><span class="line">    printf(&quot;Size of int: %lu\n&quot;, sizeof(a));  // 输出: Size of int: 4</span><br><span class="line">    printf(&quot;Size of double: %lu\n&quot;, sizeof(b));  // 输出: Size of double: 8</span><br><span class="line">    printf(&quot;Size of char[10]: %lu\n&quot;, sizeof(c));  // 输出: Size of char[10]: 10</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，sizeof(a)返回变量a的大小（以字节为单位），sizeof(b)返回变量b的大小，sizeof(c)返回数组c的大小。<br>需要注意的是，sizeof运算符返回的是size_t类型的值，这是一种无符号整型数据类型，所以在printf函数中应该使用%lu（代表长无符号整型）来格式化输出。<br>另外，你也可以使用sizeof运算符来获取一个类型的大小，而不仅仅是变量的大小。例如，sizeof(int)将返回int类型的大小，sizeof(double)将返回double类型的大小。</p><h1 id="第三章-流程控制语句和循环结构"><a href="#第三章-流程控制语句和循环结构" class="headerlink" title="第三章 流程控制语句和循环结构"></a><strong>第三章 流程控制语句和循环结构</strong></h1><h2 id="3-1-C语言中的分支语句-if-else语句、switch语句"><a href="#3-1-C语言中的分支语句-if-else语句、switch语句" class="headerlink" title="3.1 C语言中的分支语句: if-else语句、switch语句"></a>3.1 C语言中的分支语句: if-else语句、switch语句</h2><h3 id="3-1-1-if-else语句"><a href="#3-1-1-if-else语句" class="headerlink" title="3.1.1 if-else语句"></a>3.1.1 if-else语句</h3><p>在C语言中，if-else结构是一种条件控制语句，<br>在C语言（以及其他许多编程语言中），if-else结构是一种条件控制语句，它用于基于特定条件执行不同的代码块。下面是if-else语句的基本结构和用法说明：</p><ol><li><strong>if 语句</strong>：如果给定条件为真（即条件评估为非零值），则执行if块中的语句。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">     // 代码块 1: 当条件为真时执行这里的代码</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol><li><strong>if-else 语句</strong>：如果if中的条件为真，则执行if块中的语句；否则，执行else块中的语句。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (condition) &#123;</span><br><span class="line">     // 代码块 1: 当条件为真时执行这里的代码</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">     // 代码块 2: 当条件为假时执行这里的代码</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol><li><strong>if-else if-else 语句</strong>：可以使用多个else if来检查多个条件，如果前面的条件都不满足，则执行最后的else块中的语句。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (condition1) &#123;</span><br><span class="line">     // 代码块 1: 当条件1为真时执行这里的代码</span><br><span class="line"> &#125; else if (condition2) &#123;</span><br><span class="line">     // 代码块 2: 当条件1为假而条件2为真时执行这里的代码</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">     // 代码块 3: 当条件1和条件2都为假时执行这里的代码</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h3><p>下面是一个简单的示例，说明了if-else语句的使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> </span><br><span class="line"> int main() &#123;</span><br><span class="line">     int x = 10;</span><br><span class="line"> </span><br><span class="line">     if (x &gt; 10) &#123;</span><br><span class="line">         printf(&quot;x大于10\n&quot;);</span><br><span class="line">     &#125; else if (x == 10) &#123;</span><br><span class="line">         printf(&quot;x等于10\n&quot;);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         printf(&quot;x小于10\n&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，输出将是：<br>x等于10<br>因为x等于10，所以else if中的条件为真，执行了与该条件相关联的代码块。</p><h3 id="3-1-2-switch语句"><a href="#3-1-2-switch语句" class="headerlink" title="3.1.2 switch语句"></a>3.1.2 switch语句</h3><p>switch语句是另一种条件控制语句，它允许你根据一个变量或表达式的值来执行多个不同的代码块。这里是它的基本结构和作用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> constant1:</span><br><span class="line">        <span class="comment">// 代码块 1: 如果表达式的值等于constant1，执行这里的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> constant2:</span><br><span class="line">        <span class="comment">// 代码块 2: 如果表达式的值等于constant2，执行这里的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ... (更多的case分支)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 默认代码块: 如果表达式的值不匹配任何case常量，执行这里的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件说明"><a href="#组件说明" class="headerlink" title="组件说明"></a>组件说明</h3><ol><li><strong>switch (expression)</strong>: 以某个表达式或变量为基础启动一个新的switch语句。</li><li><strong>case constantN</strong>: 定义一个新的case分支，其中constantN是一个常量表达式，表示该分支的匹配值。</li><li><strong>break</strong>: 用于退出switch语句并继续执行switch块之后的代码。</li><li><strong>default</strong>: 如果没有任何case分支与表达式的值匹配，将执行default块中的代码。</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面是一个简单的示例，说明了switch语句的使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;x等于1\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;x等于2\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;x等于3\n&quot;</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;x不等于1、2或3\n&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，输出将是：<br>x等于2<br>因为x等于2，所以匹配了case 2分支，执行了与该分支相关联的代码块。注意，break语句用于防止代码从一个case块“跌落”到下一个case块（称为fallthrough），这是一个常见的程序错误来源。</p><h2 id="3-2-C语言中的循环语句-while循环、do-while循环、for循环"><a href="#3-2-C语言中的循环语句-while循环、do-while循环、for循环" class="headerlink" title="3.2 C语言中的循环语句: while循环、do-while循环、for循环"></a>3.2 C语言中的循环语句: while循环、do-while循环、for循环</h2><h3 id="3-2-1-while循环"><a href="#3-2-1-while循环" class="headerlink" title="3.2.1 while循环"></a>3.2.1 while循环</h3><h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 代码块：只要条件为真，就会重复执行这里的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件说明-1"><a href="#组件说明-1" class="headerlink" title="组件说明"></a>组件说明</h3><ol><li><strong>while (condition)</strong>: 在这里，“condition”是一个布尔表达式，用于决定是否执行循环体。如果条件为真（即结果为非零值），则会执行循环体。在每次循环迭代结束时，此条件将被重新评估。</li><li><strong>代码块</strong>: 这是需要多次执行的代码段。它可以包含各种语句和控制流结构。</li></ol><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>下面是一个更加详细的示例，其中我们将使用while循环来找出一个整数范围内的所有偶数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> upperLimit = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;1到10之间的偶数有：\n&quot;</span>);</span><br><span class="line">     <span class="keyword">while</span> (i &lt;= upperLimit) &#123;</span><br><span class="line">         <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">         &#125;</span><br><span class="line">         i++;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;\n循环结束\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，输出将是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>到<span class="number">10</span>之间的偶数有：</span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span> </span><br><span class="line">    循环结束</span><br></pre></td></tr></table></figure><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><ol><li><strong>初始化变量</strong>: 在循环开始之前，我们首先初始化了两个变量：i（用作循环计数器）和upperLimit（用作循环的上限）。</li><li><strong>循环条件</strong>: while (i &lt;&#x3D; upperLimit)是循环的条件。只要i的值小于或等于upperLimit的值，循环将继续。</li><li><strong>循环体</strong>: 循环体中有一个if语句，用于检查当前i的值是否为偶数。如果是，则将其打印到控制台。</li><li><strong>迭代步进</strong>: 在循环体的末尾，我们增加了i的值，这样可以逐渐接近循环的终止条件，避免无限循环。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>确保循环有一个可达到的终止条件，以避免无限循环。</li><li>可以使用break语句提前退出循环，或使用continue语句来跳过当前迭代的剩余部分，并立即开始下一次迭代。</li><li>在while循环内，你可以嵌套其他控制流结构，如if-else语句或甚至其他while循环，以创建更复杂的逻辑和控制流。</li><li>通过合理的代码注释和良好的代码组织来保持循环的清晰和可读性。</li></ul><h3 id="3-2-2-do-while循环"><a href="#3-2-2-do-while循环" class="headerlink" title="3.2.2 do-while循环"></a>3.2.2 do-while循环</h3><h3 id="do-while-循环的说明"><a href="#do-while-循环的说明" class="headerlink" title="do-while 循环的说明"></a>do-while 循环的说明</h3><ul><li>do-while循环是C语言中的另一种循环结构，它至少执行一次循环体，然后根据给定的条件来决定是否继续执行循环。以下是它的基本结构和作用：</li></ul><h4 id="语法结构-1"><a href="#语法结构-1" class="headerlink" title="语法结构"></a>语法结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">     // 循环体：先执行这里的代码</span><br><span class="line"> &#125; while (condition);</span><br></pre></td></tr></table></figure><h4 id="组件说明-2"><a href="#组件说明-2" class="headerlink" title="组件说明"></a>组件说明</h4><ol><li><strong>do { … }</strong>: 此部分包含你想要循环执行的代码块。无论条件是否满足，此代码块都将执行至少一次。</li><li><strong>while (condition)</strong>: 此处的“condition”是一个布尔表达式。在执行了do代码块一次后，它将被评估。如果条件为真（非零值），则再次执行do代码块。这将继续，直到条件变为假（零值）。</li></ol><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>下面是一个实例，其中我们使用do-while循环来打印1到5之间的所有整数：在这个示例中，输出将是：</p><h4 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h4><ol><li><strong>初始化变量</strong>: 在循环开始之前，我们首先初始化了一个变量i，它将用作循环计数器。</li><li><strong>循环体</strong>: 循环体内有一个printf语句，用于打印当前i的值。</li><li><strong>迭代步进</strong>: 在循环体内，我们增加了i的值，这样可以逐渐接近循环的终止条件，避免无限循环。</li><li><strong>循环条件</strong>: 在do代码块执行后，通过while(i &lt;&#x3D; 5)来检查条件。只要条件为真，循环将继续。当i大于5时，循环将停止。</li></ol><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>确保在循环体内有一个能够满足的终止条件，以避免无限循环。</li><li>do-while循环是先执行循环体，然后才检查条件，这意味着循环体将至少执行一次。</li><li>与while循环类似，你可以使用break和continue语句来控制循环的流程。</li><li>你可以在do-while循环内嵌套其他控制流结构，以创建更复杂的逻辑和控制流。</li></ol><h3 id="3-2-3-for循环"><a href="#3-2-3-for循环" class="headerlink" title="3.2.3 for循环"></a>3.2.3 for循环</h3><h3 id="for-循环的说明"><a href="#for-循环的说明" class="headerlink" title="for 循环的说明"></a>for 循环的说明</h3><p>for循环是一个很强大的循环结构，允许你在一行中初始化变量，定义循环条件和增加迭代步进。以下是它的基本结构和解释：</p><h4 id="语法结构-2"><a href="#语法结构-2" class="headerlink" title="语法结构"></a>语法结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (条件1; 条件2; 条件3) &#123;</span><br><span class="line">     // 循环体：只要条件为真，就会重复执行这里的代码</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="组件说明-3"><a href="#组件说明-3" class="headerlink" title="组件说明"></a>组件说明</h4><ol><li><strong>条件1</strong>: 在这个部分，你可以初始化循环控制变量。它在循环开始前仅执行一次。</li><li><strong>条件2</strong>: 这是一个布尔表达式，用于每次循环迭代前检查条件。如果条件为真（非零值），则执行循环体。</li><li><strong>条件3</strong>: 这里你可以更新循环控制变量的值。它在每次循环迭代后被执行。</li><li><strong>循环体</strong>: 这是需要多次执行的代码段。它可以包含各种语句和控制流结构。</li></ol><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;当前的i是：%d\n&quot;</span>, i);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当前的i是：1</span><br><span class="line"> 当前的i是：2</span><br><span class="line"> 当前的i是：3</span><br><span class="line"> 当前的i是：4</span><br><span class="line"> 当前的i是：5</span><br></pre></td></tr></table></figure><h4 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h4><ol><li><strong>初始化</strong>: 循环开始前，i被初始化为1。</li><li><strong>条件检查</strong>: 在每次循环开始时，检查i是否小于或等于5。如果是，则进入循环体。</li><li><strong>循环体</strong>: 循环体内有一个printf语句，用于打印当前i的值。</li><li><strong>迭代</strong>: 在循环体的末尾，i的值增加1，然后返回第二步进行条件检查。</li></ol><h3 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目"></a>练习题目</h3><ol><li><strong>逆序打印</strong>: 编写一个程序，使用for循环从10逆序打印到1。</li><li><strong>阶乘计算</strong>: 编写一个程序，使用for循环计算给定数字的阶乘。</li><li><strong>斐波那契序列</strong>: 编写一个程序，使用for循环生成一个长度为n的斐波那契序列。</li><li><strong>奇数和偶数之和</strong>: 编写一个程序，使用for循环计算1到n之间所有奇数和偶数的和。</li><li><strong>质数检查</strong>: 编写一个程序，使用for循环检查一个给定的数字是否是质数。</li><li><strong>矩阵乘法</strong>: 编写一个程序，使用嵌套for循环进行两个矩阵的乘法。</li></ol><h3 id="阶乘的定义"><a href="#阶乘的定义" class="headerlink" title="阶乘的定义"></a>阶乘的定义</h3><p>阶乘是一种数学运算，通常表示为n!，定义为从1乘到n的所有正整数的乘积。数学上，它可以定义为：<br>n! &#x3D; n  <em>(n-1)</em>  (n-2)  <em>…</em>  1</p><h3 id="程序步骤"><a href="#程序步骤" class="headerlink" title="程序步骤"></a>程序步骤</h3><ol><li>从主函数中获取用户输入的数字，存储在变量n中。</li><li>初始化一个变量，例如factorial，为1。因为1是乘法的单位元素。</li><li>使用for循环从1迭代到n，在每次迭代中将当前迭代的数乘以factorial。</li></ol><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>以下是一个简单的C程序，实现上述步骤：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> n;</span><br><span class="line">     <span class="type">long</span> <span class="type">long</span> factorial = <span class="number">1</span>;  <span class="comment">// 使用长整型来防止溢出</span></span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;请输入一个整数: &quot;</span>);</span><br><span class="line">     <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;负数没有阶乘!\n&quot;</span>);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">             factorial *= i;  <span class="comment">// 等价于 factorial = factorial * i;</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%d的阶乘是: %lld\n&quot;</span>, n, factorial);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><ol><li><strong>用户输入</strong>: 首先，我们让用户输入一个整数n，我们要计算这个数的阶乘。</li><li><strong>错误检查</strong>: 如果输入的数字是负数，我们打印一个错误消息，因为负数没有阶乘。</li><li><strong>初始化阶乘变量</strong>: 我们初始化一个变量factorial为1。</li><li><strong>for循环</strong>: 使用for循环从1迭代到n，并在每次迭代中将factorial乘以当前的迭代数。</li><li><strong>输出结果</strong>: 在循环结束后，我们得到n的阶乘，并将其打印到控制台。</li></ol><p>这样你就得到了一个简单但有效的阶乘计算程序！</p><h2 id="3-3-C语言中的转移语句-goto语句（禁用）、break语句、continue语句"><a href="#3-3-C语言中的转移语句-goto语句（禁用）、break语句、continue语句" class="headerlink" title="3.3 C语言中的转移语句: goto语句（禁用）、break语句、continue语句"></a>3.3 C语言中的转移语句: goto语句（禁用）、break语句、continue语句</h2><h3 id="break-跳出循环"><a href="#break-跳出循环" class="headerlink" title="break 跳出循环"></a>break 跳出循环</h3><h3 id="continue-跳出循环一次"><a href="#continue-跳出循环一次" class="headerlink" title="continue 跳出循环一次"></a>continue 跳出循环一次</h3><h1 id="第四章-数组和字符串"><a href="#第四章-数组和字符串" class="headerlink" title="第四章 数组和字符串"></a><strong>第四章 数组和字符串</strong></h1><p><strong>目标</strong></p><ul><li>1、C语言中数组的概念和使用</li><li>2、C语言中的多维数组</li><li>3、C语言中字符串的概念和使用</li><li>4、C语言中字符串处理函数（复制、连接）</li><li>5、C语言中字符串处理函数（比较、长度）</li><li>6、C语言中字符串处理函数（转换）</li></ul><h2 id="1、C语言中数组的概念和使用"><a href="#1、C语言中数组的概念和使用" class="headerlink" title="1、C语言中数组的概念和使用"></a>1、C语言中数组的概念和使用</h2><p>在C语言中，数组是一种复合数据类型，可以存储固定大小的同类型元素的序列。数组可以是一维的（即线性数组），也可以是多维的（例如二维的网格数组或者三维的立方体数组等）。<br>数组的使用在C语言编程中非常常见，无论是存储一系列的数值，还是字符串（字符数组），甚至更复杂的数据结构，如结构体数组等。</p><h3 id="1-1-定义和初始化数组"><a href="#1-1-定义和初始化数组" class="headerlink" title="1.1 定义和初始化数组"></a>1.1 定义和初始化数组</h3><p>在C语言中，我们可以定义一个数组，如下所示：<br>int arr[10]; &#x2F;&#x2F; 定义一个可以存放10个整数的数组<br>在定义数组的时候，可以对它进行初始化：<br>int arr[5] &#x3D; {1, 2, 3, 4, 5}; &#x2F;&#x2F; 定义并初始化一个数组<br>如果在初始化的时候没有给出数组的大小，编译器会根据初始化的元素数量自动确定：<br>int arr[] &#x3D; {1, 2, 3, 4, 5}; &#x2F;&#x2F; 定义并初始化一个数组，大小为5</p><p>第一种 定义数组时 内部变量写完整<br>int arr[3] &#x3D; {1，2，3};<br>第二种 定时数组时 内部变量不完整<br>int arr[5] &#x3D; {1，2，3}; -&gt; {1，2，3 , 0 , 0 };<br>第三种 定义数组时 只填写一个0<br>int arr[10] &#x3D; {0}； -&gt; {0,0,0,0,0,0,0,0};<br>第四种 定义数组时 []内不填写<br>int arr[] &#x3D; {1，2，3}; -&gt; int arr[3] &#x3D; {1，2，3};</p><h3 id="1-2-访问数组元素"><a href="#1-2-访问数组元素" class="headerlink" title="1.2 访问数组元素"></a>1.2 访问数组元素</h3><p>通过下标的方式访问 arr[n] 此时n就是该数组的下标索引</p><p>可以通过索引来访问数组元素，索引从0开始，即第一个元素的索引为0，第二个元素的索引为1，以此类推。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr[<span class="number">0</span>]); <span class="comment">// 输出第一个元素，结果为1</span></span><br></pre></td></tr></table></figure><h3 id="1-3-数组遍历"><a href="#1-3-数组遍历" class="headerlink" title="1.3 数组遍历"></a>1.3 数组遍历</h3><p>一般情况下，可以通过循环来遍历数组中的所有元素。例如，如果要输出数组中的所有元素，可以使用如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr[i]); <span class="comment">// 输出每个元素</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，访问数组时必须确保索引不超过数组的大小，否则会产生未定义行为。</p><h2 id="2、C语言中的多维数组"><a href="#2、C语言中的多维数组" class="headerlink" title="2、C语言中的多维数组"></a>2、C语言中的多维数组</h2><p>在C语言中，除了一维数组外，还可以定义多维数组。最常见的就是二维数组，常常被用来表示表格或者矩阵。多维数组的定义和使用方式基本上和一维数组类似，但是在索引元素的时候需要指定更多的索引。</p><p>在逻辑上，我们认为二维数组第一个下标是表示他的行，第二个下标是表示他的列<br>但是在实际存储上，他还是一个顺序存储</p><h3 id="2-1-定义和初始化多维数组"><a href="#2-1-定义和初始化多维数组" class="headerlink" title="2.1 定义和初始化多维数组"></a>2.1 定义和初始化多维数组</h3><p>在 C 语言中，可以使用多种方式来定义多维数组。在下面的例子中，我将演示如何使用不同的方式来定义一个二维数组：<br><strong>标准定义方式</strong>：直接在声明时指定数组的大小。<br>int array[2][3]; &#x2F;&#x2F; 定义了一个 2 行 3 列的二维整数数组<br><strong>初始化时定义</strong>：在定义时直接初始化数组。<br>int array[2][3] &#x3D; { {1, 2, 3}, {4, 5, 6} }; &#x2F;&#x2F; 定义并初始化二维数组<br><strong>部分初始化定义</strong>：定义时只初始化部分元素，其余元素默认为0。<br>int array[2][3] &#x3D; { {1, 2}, {4} }; &#x2F;&#x2F; 未初始化的元素值为0<br><strong>省略行大小定义</strong>：在初始化时可以省略行的大小。<br>int array[][3] &#x3D; { {1, 2, 3}, {4, 5, 6} }; &#x2F;&#x2F; 行的大小通过初始化元素的个数决定<br>请注意，在 C 语言中，多维数组的行和列的大小必须是一个已知的常量，不能是变量。如果你需要一个行或列大小可以改变的数组，那么你可能需要使用到动态内存分配（比如使用 malloc 或 calloc 函数）或者使用一维数组的数组（数组的指针）来模拟多维数组。</p><h3 id="二维数组赋值时，可以省略行但是不能省略列"><a href="#二维数组赋值时，可以省略行但是不能省略列" class="headerlink" title="二维数组赋值时，可以省略行但是不能省略列"></a>二维数组赋值时，可以省略行但是不能省略列</h3><p>1、二维数组看成是一维数组的集合</p><p>2、编译时需要确定每个数组的空间</p><p>3、可以根据数组下标的偏移量来找到数组元素</p><p>以上三点说明可以省略行数但是不能省略列数。</p><h3 id="2-2-访问多维数组元素"><a href="#2-2-访问多维数组元素" class="headerlink" title="2.2 访问多维数组元素"></a>2.2 访问多维数组元素</h3><p>访问多维数组元素时，需要为每一维指定索引：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> matrix[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, matrix[<span class="number">0</span>][<span class="number">2</span>]); <span class="comment">// 输出第一行第三列的元素，结果为3</span></span><br></pre></td></tr></table></figure><h3 id="2-3-多维数组的遍历"><a href="#2-3-多维数组的遍历" class="headerlink" title="2.3 多维数组的遍历"></a>2.3 多维数组的遍历</h3><p>遍历多维数组一般需要使用嵌套循环。例如，打印出二维数组中的所有元素：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> matrix[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, matrix[i][j]); <span class="comment">// 输出每个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">// 每一行结束后换行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码将会输出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>注意：和一维数组一样，访问多维数组时必须确保所有的索引都不超过数组的大小，否则会产生未定义行为。</p><h2 id="3、C语言中字符串的概念和使用"><a href="#3、C语言中字符串的概念和使用" class="headerlink" title="3、C语言中字符串的概念和使用"></a>3、C语言中字符串的概念和使用</h2><p>在 C 语言中，字符串被视为字符数组的特殊情况。C 语言中没有专门的字符串类型，而是使用字符数组来表示和操作字符串。下面来具体说明一下。</p><h3 id="3-1-字符串的概念"><a href="#3-1-字符串的概念" class="headerlink" title="3.1 字符串的概念"></a>3.1 字符串的概念</h3><p>在 C 语言中，字符串是由多个字符组成的一系列字符序列，以空字符**(‘\0’)<strong>作为结束标志。字符串通常被存储在</strong>字符数组**中，数组的最后一位存放这个空字符。例如，字符串 “Hello” 在 C 中被表示为字符数组 {‘H’, ‘e’, ‘l’, ‘l’, ‘o’, ‘\0’}。</p><h3 id="字符串的使用"><a href="#字符串的使用" class="headerlink" title="字符串的使用"></a>字符串的使用</h3><p><strong>定义和初始化字符串</strong><br>定义和初始化字符串有多种方式。最常见的是直接使用字符串字面量进行初始化：<br>char str[] &#x3D; “Hello”;<br>上述代码定义了一个名为 str 的字符数组，并用字符串 “Hello” 对其进行初始化。数组的长度自动设置为6，其中包括5个字符和一个结尾的空字符。<br><strong>字符串的输入和输出</strong><br>可以使用 printf 和 scanf 函数来进行字符串的输出和输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char str[50];</span><br><span class="line">printf(&quot;Enter a string: &quot;);</span><br><span class="line">scanf(&quot;%s&quot;, str);  // 输入字符串</span><br><span class="line">printf(&quot;You entered: %s&quot;, str);  // 输出字符串</span><br></pre></td></tr></table></figure><p>注意，当使用 scanf 函数输入字符串时，它会在遇到空白字符（如空格、制表符或换行符）时停止读取。如果要读取一行（包含空格的字符串），需要使用 fgets 函数。<br><strong>字符串函数</strong><br>C 标准库 &lt;string.h&gt; 提供了一系列操作字符串的函数，如 strlen（获取字符串长度）、strcpy（复制字符串）、strcat（连接字符串）、strcmp（比较字符串）等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">char str1[10] = &quot;Hello&quot;;</span><br><span class="line">char str2[10];</span><br><span class="line">int len = strlen(str1);  // 获取字符串长度</span><br><span class="line">strcpy(str2, str1);  // 复制字符串</span><br><span class="line">strcat(str1, str2);  // 连接字符串</span><br><span class="line">int cmp = strcmp(str1, str2);  // 比较字符串</span><br></pre></td></tr></table></figure><h2 id="4、C语言中字符串处理函数（复制、连接）"><a href="#4、C语言中字符串处理函数（复制、连接）" class="headerlink" title="4、C语言中字符串处理函数（复制、连接）"></a>4、C语言中字符串处理函数（复制、连接）</h2><h3 id="4-1strcpy"><a href="#4-1strcpy" class="headerlink" title="4.1strcpy"></a>4.1strcpy</h3><ul><li><p><strong>头文件</strong>：#include &lt;string.h&gt;</p></li><li><p><strong>函数原型</strong>：char <em>strcpy(char</em> dest, const char *src);</p></li><li><p><strong>功能</strong>：该函数用于将字符串 src（包括 ‘\0’ 终止字符）复制到 dest 中。</p></li><li><p><strong>参数</strong>： </p></li><li><p>dest：目标字符串，即复制到的地方。</p></li><li><p>src：源字符串，即需要复制的字符串。</p></li><li><p><strong>返回值</strong>：函数返回 dest，即目标字符串。</p></li></ul><p><strong>示例程序</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    char src[40];</span><br><span class="line">    char dest[100];</span><br><span class="line"></span><br><span class="line">    memset(dest, &#x27;\0&#x27;, sizeof(dest));</span><br><span class="line">    strcpy(src, &quot;This is example&quot;);</span><br><span class="line">    strcpy(dest, src);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Final copied string : %s\n&quot;, dest);</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例程序中，src 字符串 “This is example” 被复制到 dest 字符串中。然后，打印 dest 字符串，输出 “Final copied string : This is example”。</p><h3 id="4-2strcat-函数"><a href="#4-2strcat-函数" class="headerlink" title="4.2strcat 函数"></a>4.2strcat 函数</h3><ul><li><p><strong>头文件</strong>：#include &lt;string.h&gt;</p></li><li><p><strong>函数原型</strong>：char <em>strcat(char</em> dest, const char *src);</p></li><li><p><strong>功能</strong>：该函数用于将 src 字符串（包括 ‘\0’ 终止字符）连接到 dest 的末尾。</p></li><li><p><strong>参数</strong>： </p></li><li><p>dest：目标字符串，即要被添加内容的字符串。</p></li><li><p>src：源字符串，即要添加的字符串。</p></li><li><p><strong>返回值</strong>：函数返回 dest，即目标字符串。</p></li></ul><p><strong>例程</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char dest[30] = &quot;Hello&quot;;</span><br><span class="line">    char src[] = &quot;, World!&quot;;</span><br><span class="line"></span><br><span class="line">    strcat(dest, src);</span><br><span class="line"></span><br><span class="line">    printf(&quot;源字符串： %s\n&quot;, src);</span><br><span class="line">    printf(&quot;目标字符串： %s\n&quot;, dest);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例程中，源字符串 “, World!” 被连接到目标字符串 “Hello” 的末尾。然后，打印源字符串和目标字符串。输出结果将是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">源字符串： , World!</span><br><span class="line">目标字符串： Hello, World!</span><br></pre></td></tr></table></figure><h3 id="3-strlen"><a href="#3-strlen" class="headerlink" title="3. strlen"></a>3. strlen</h3><ul><li><strong>头文件</strong>： #include &lt;string.h&gt;</li><li><strong>函数原型</strong>： size_t strlen(const char *str);</li><li><strong>功能</strong>： 此函数用于获取字符串的长度，也就是从字符串的开始到遇到第一个空字符(‘\0’)的字符数。注意，这个长度不包括空字符(‘\0’)本身。</li><li><strong>参数</strong>：</li><li>str：指向要获取长度的字符串的指针。</li><li><strong>返回值</strong>： 此函数返回字符串的长度（不包括结束字符’\0’）。返回值的类型是 size_t，这是无符号整数类型，用于表示对象的大小。</li></ul><p>例程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char str[] = &quot;Hello, World!&quot;;</span><br><span class="line">    size_t length = strlen(str);</span><br><span class="line"></span><br><span class="line">    printf(&quot;The length of the string &#x27;%s&#x27; is: %zu\n&quot;, str, length);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此程序中，我们使用 strlen 函数获取字符串 “Hello, World!” 的长度，并将其打印出来。注意，%zu 是 size_t 类型的 printf 格式说明符。</p><h3 id="4-strcmp"><a href="#4-strcmp" class="headerlink" title="4. strcmp"></a>4. strcmp</h3><ul><li><p><strong>头文件</strong>： #include &lt;string.h&gt;</p></li><li><p><strong>函数原型</strong>： int strcmp(const char <em>str1, const char</em> str2);</p></li><li><p><strong>功能</strong>： 此函数用于比较两个字符串。比较是基于字符的ASCII值进行的。</p></li><li><p><strong>参数</strong>： </p></li><li><p>str1：指向第一个要比较的字符串的指针。</p></li><li><p>str2：指向第二个要比较的字符串的指针。</p></li><li><p><strong>返回值</strong>： </p></li><li><p>如果 str1 和 str2 相等，则返回0。</p></li><li><p>如果 str1 大于 str2，则返回大于0的数。</p></li><li><p>如果 str1 小于 str2，则返回小于0的数。</p></li></ul><p><strong>例程</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char str1[] = &quot;Hello, World!&quot;;</span><br><span class="line">    char str2[] = &quot;Hello, OpenAI!&quot;;</span><br><span class="line">    </span><br><span class="line">    int result = strcmp(str1, str2);</span><br><span class="line">    </span><br><span class="line">    if(result &gt; 0) &#123;</span><br><span class="line">        printf(&quot;&#x27;%s&#x27; is greater than &#x27;%s&#x27;\n&quot;, str1, str2);</span><br><span class="line">    &#125; else if(result &lt; 0) &#123;</span><br><span class="line">        printf(&quot;&#x27;%s&#x27; is less than &#x27;%s&#x27;\n&quot;, str1, str2);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;&#x27;%s&#x27; is equal to &#x27;%s&#x27;\n&quot;, str1, str2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此程序中，我们使用 strcmp 函数比较两个字符串 “Hello, World!” 和 “Hello, OpenAI!” 并打印结果。</p><h3 id="5-strchr-搜索"><a href="#5-strchr-搜索" class="headerlink" title="5. strchr 搜索"></a>5. strchr 搜索</h3><ul><li><p>strchr函数</p></li><li><p><strong>头文件</strong>： #include &lt;string.h&gt;</p></li><li><p><strong>函数原型</strong>： char <em>strchr(const char</em> str, int c);</p></li><li><p><strong>功能</strong>： 此函数在字符串 str 中查找第一次出现字符 c 的位置。</p></li><li><p><strong>参数</strong>： </p></li><li><p>str：指向要被搜索的字符串的指针。</p></li><li><p>c：要搜索的字符。</p></li><li><p><strong>返回值</strong>： </p></li><li><p>如果字符 c 在字符串 str 中找到，则返回一个指向该位置的指针。</p></li><li><p>如果字符 c 在字符串 str 中没有找到，则返回 NULL。</p></li><li><p><strong>例程</strong>：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char str[] = &quot;Hello, World!&quot;;</span><br><span class="line">    char c = &#x27;o&#x27;;</span><br><span class="line">    </span><br><span class="line">    char *result = strchr(str, c);</span><br><span class="line">    </span><br><span class="line">    if(result != NULL) &#123;</span><br><span class="line">        printf(&quot;First occurrence of &#x27;%c&#x27; in &#x27;%s&#x27; is at position: %ld\n&quot;, c, str, result - str);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        printf(&quot;Character &#x27;%c&#x27; not found in &#x27;%s&#x27;\n&quot;, c, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此程序中，我们使用 strchr 函数在字符串 “Hello, World!” 中查找字符 ‘o’ 的第一次出现的位置，并打印结果。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言第5-8章内容</title>
      <link href="/2023/09/20/test/c%E5%92%8Cc++/C%E8%AF%AD%E8%A8%80(5-8%E7%AB%A0)%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%B1%E7%94%A8%E4%BD%93%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%20%E9%AB%98%E7%BA%A7C%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"/>
      <url>/2023/09/20/test/c%E5%92%8Cc++/C%E8%AF%AD%E8%A8%80(5-8%E7%AB%A0)%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%B1%E7%94%A8%E4%BD%93%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%20%E9%AB%98%E7%BA%A7C%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="第五章-函数和指针"><a href="#第五章-函数和指针" class="headerlink" title="第五章 函数和指针"></a><strong>第五章 函数和指针</strong></h1><h2 id="一、C语言中函数的定义和调用"><a href="#一、C语言中函数的定义和调用" class="headerlink" title="一、C语言中函数的定义和调用"></a>一、C语言中函数的定义和调用</h2><p>在C语言中，函数是一组可重复使用的代码，用于执行特定任务。函数的优势在于它可以随需求调用，减少代码的冗余性，并增强代码的可读性。<br>函数的基本组成包括：<strong>返回（函数）类型</strong> ， <strong>函数名</strong> ， <strong>参数列表和函数体</strong>。</p><ul><li><strong>返回类型</strong> ： 函数可以返回一个值。返回类型是函数返回值的数据类型。如果函数不反悔任何值，则其返回值为void。</li><li><strong>函数名</strong>：这是表示函数的唯一名称，函数名和参数列表一起构成了函数的签名。、</li><li><strong>参数列表</strong>：参数是传递给函数的值。参数列表包括参数的类型、类型、参数的数量，参数是可选的，也就是说，函数可以不包含参数</li><li><strong>函数体</strong>：函数体包含了定义函数行为的一组语句。</li></ul><h3 id="1-1-函数的定义"><a href="#1-1-函数的定义" class="headerlink" title="1.1 函数的定义"></a>1.1 函数的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  返回类型是 int ，函数名为add 参数列表是两个int类型的参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1 , <span class="type">int</span> num2)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">int</span> sum = num1 + num;</span><br><span class="line">     <span class="keyword">return</span> sum;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>一旦我们定义了函数，就可以在其他地方调用它。要调用函数，我们只需要编写函数名和在括号中传递适当的参数。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = add(<span class="number">5</span> , <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;两数之和等于 %d\n&quot;</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，add(5, 10)是函数调用，5和10是传递给add函数的参数，add函数返回15，我们将这个返回值赋值给result变量，然后打印出来。</p><h2 id="二、C语言中函数参数的传递"><a href="#二、C语言中函数参数的传递" class="headerlink" title="二、C语言中函数参数的传递"></a>二、C语言中函数参数的传递</h2><p>C语言中函数参数传递基本上有两种方式：值传递和引用传递。</p><ul><li><strong>值传递</strong>：在值传递方式中，被调函数的<strong>形式参数</strong>作为被调用函数的局部变量处理，即在栈中开辟了内存空间，以存放主调函数传递过来的实参值，这个空间值只在函数调用的过程中有效，也就是说，值传递的方式，函数接收的是参数的副本，函数内部对参数的任何改变，都不会影响到实际参数的值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">     x = <span class="number">20</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Inside change() x=%d\n&quot;</span>, x);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">     change(x);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Outside change() x=%d\n&quot;</span>, x);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，即使在change函数中修改了x的值，但在main函数中打印x时，其值还是原来的值10，这就是值传递。</p><ul><li><strong>引用传递（Pass by Reference）</strong>： 在引用传递方式中，被调函数的形式参数虽然也作为局部变量在堆栈中开辟了内存空间，但是这次存放的是主调函数放进来实参的变量地址。被调函数对形参的任何操作都被处理成间接寻址，即对实参操作。</li></ul><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> *x)</span> &#123;</span><br><span class="line">     *x = <span class="number">20</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Inside change() x=%d\n&quot;</span>, *x);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">     change(&amp;x);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Outside change() x=%d\n&quot;</span>, x);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们传递了x的地址给change函数，然后在change函数中修改了x的值。在main函数中，我们看到x的值已经被修改为20，这就是引用传递。</p><ul><li><strong>形式参数</strong> : 形式参数也成为形参，是函数定义时声明的参数。形参只在函数定义时有意义，在函数内部形参作为局部变量使用。</li><li><strong>实际参数</strong>：实际参数也成为实参，实在函数调用时实际传给函数的参数。实参可以是常量、变量或者是表达式，无论实参是任何形式的量，在进行函数调用时，他们都必须有确定的值，以便把这些值传给形参。</li></ul><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void myFunction(int x) &#123;    // 这里的int x就是形式参数</span><br><span class="line">     printf(&quot;%d&quot;, x);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> int main() &#123;</span><br><span class="line">     int y = 10;</span><br><span class="line">     myFunction(y);   // 这里的y就是实际参数</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，myFunction的定义中int x就是形式参数，当我们在main函数中调用myFunction(y)时，y就是实际参数。<br>函数在被调用时，实际参数的值会被复制给形式参数。如果形式参数在函数体内发生改变，并不会影响实际参数的值。但如果你使用了指针作为形式参数，那么你可以在函数体内改变实际参数的值，这是因为你传递的是实际参数的地址，而不是实际参数的值。</p><h2 id="三、C语言中函数的返回值"><a href="#三、C语言中函数的返回值" class="headerlink" title="三、C语言中函数的返回值"></a>三、C语言中函数的返回值</h2><p>C语言中的函数可以返回一个值给调用他的函数或者是主程序。返回值可以是任何基本类型，也可以是街头提或者枚举类型。当然，函数也可以设定为不返回任何值，这种类型的函数被声明为”void”<br>函数的返回值</p><h2 id="四、C语言中全局变量和局部变量"><a href="#四、C语言中全局变量和局部变量" class="headerlink" title="四、C语言中全局变量和局部变量"></a>四、C语言中全局变量和局部变量</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><ul><li><strong>定义</strong>：全局变量是在函数之外定义的变量，它在程序的任何地方都可以访问（除了在它定义之前）。</li><li><strong>作用范围</strong>：全局变量在整个程序中都是可见的，从它被定义开始，直到程序结束。</li><li><strong>生命周期</strong>：全局变量的生命周期是整个程序运行期间，它们在程序开始时分配内存，在程序结束时释放。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int globalVar = 10; // 定义一个全局变量</span><br><span class="line"></span><br><span class="line">void func() &#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, globalVar); // 可以访问全局变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><ul><li><p><strong>定义</strong>：局部变量是在函数内部定义的变量，它只在定义它的函数内部可见。</p></li><li><p><strong>作用范围</strong>：局部变量只在定义它的函数内部有效，函数外部无法访问。</p></li><li><p><strong>生命周期</strong>：局部变量的生命周期仅限于函数执行期间，当函数执行完毕后，局部变量的内存会被释放。</p></li><li><p><strong>例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">20</span>; <span class="comment">// 定义一个局部变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, localVar); <span class="comment">// 可以访问局部变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// int localVar = 20; // 错误：无法访问func函数内的局部变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="五、C语言中指针的概念和使用"><a href="#五、C语言中指针的概念和使用" class="headerlink" title="五、C语言中指针的概念和使用"></a>五、C语言中指针的概念和使用</h2><h3 id="6-1-指针中的一些基础概念知识"><a href="#6-1-指针中的一些基础概念知识" class="headerlink" title="6.1 指针中的一些基础概念知识"></a>6.1 指针中的一些基础概念知识</h3><h4 id="6-1-1-指针的作用"><a href="#6-1-1-指针的作用" class="headerlink" title="6.1.1 指针的作用"></a>6.1.1 指针的作用</h4><ul><li><strong>使程序简洁、高效</strong>：指针可以直接访问内存，提高性能，减少内存使用。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;a; <span class="comment">// ptr是指向a的指针，它存储着a的内存地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *ptr); <span class="comment">// 输出a的值，即10</span></span><br></pre></td></tr></table></figure><ul><li><strong>表示复杂数据结构</strong>：指针是实现链表、树等复杂数据结构的关键。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>; <span class="comment">// 链表的头指针，开始时为空</span></span><br><span class="line"><span class="comment">// 可以继续添加节点到链表中</span></span><br></pre></td></tr></table></figure><ul><li><strong>动态内存分配</strong>：运行时需要动态分配或释放内存时，必须使用指针。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配一个int大小的内存，并让ptr指向它</span></span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    *ptr = <span class="number">20</span>; <span class="comment">// 通过指针修改内存中的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *ptr); <span class="comment">// 输出20</span></span><br><span class="line">    <span class="built_in">free</span>(ptr); <span class="comment">// 使用完后释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>返回多个函数值</strong>：通过传递指针给函数，函数可以修改并返回多个结果。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    swap(&amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x: %d, y: %d\n&quot;</span>, x, y); <span class="comment">// 输出x: 10, y: 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-1-2-指针、内存、地址的概念"><a href="#6-1-2-指针、内存、地址的概念" class="headerlink" title="6.1.2 指针、内存、地址的概念"></a>6.1.2 指针、内存、地址的概念</h4><ul><li><strong>内存</strong>：内存是计算机存储空间中，每个变量都占用的一定内存空间。</li><li><strong>地址</strong>：内存中每个字节都拥有唯一的地址，这个地址是内存空间的标识符</li><li><strong>指针</strong>：指针是一个特殊的变量，他存储了内存的地址，通过这个地址，我们可以直接访问内存中的数据</li></ul><p>指针就是链接内存和地址的桥梁，通过指针我们可以直接的操作内存中的数据，这是C语言中非常重要和强大的特性<br>其关系如图所示，其实指针也只是一个变量，这个变量存储的类型有一点点特殊，存储的是我们其他变量的地址。我们只需要知道一个变量是由地址和数据组成，而我们的指针变量所能做的就是存储你这个普通变量的地址并能进行操作。<img src="https://cdn.nlark.com/yuque/0/2023/png/8368890/1694678675709-6891934b-7d53-4e48-a6b8-ab0498a6ba13.png#averageHue=%23f3f3f3&clientId=ufdda5353-03bf-4&from=paste&id=u1b89d7e7&originHeight=865&originWidth=1710&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=89081&status=done&style=none&taskId=u93bf1897-7638-4b49-aec6-dc61622deef&title=" alt="img"></p><h3 id="6-2-指针的概念"><a href="#6-2-指针的概念" class="headerlink" title="6.2 指针的概念"></a>6.2 指针的概念</h3><p>在C语言中，指针就是一个变量，<strong>其值为另一个变量的内存地址</strong>，也就是它指向该地址的变量。指针允许以直接和间接的方式通过引用内存地址来访问和操作内存中存储数据。</p><h4 id="6-2-1-指针变量说明"><a href="#6-2-1-指针变量说明" class="headerlink" title="6.2.1 指针变量说明"></a>6.2.1 指针变量说明</h4><p>指针变量的一般形式如下：<br>type * v &#x3D; NULL;<br>在这里，</p><ul><li>type：表示指针变量所指向的变量的数据类型。它可以是任何的数据类型，例如 int, char, double, float 等。</li><li>*：表示这是一个指针变量。</li><li>v：是指针变量的名称。</li></ul><h3 id="6-3-指针的使用"><a href="#6-3-指针的使用" class="headerlink" title="6.3 指针的使用"></a>6.3 指针的使用</h3><p>在C语言中要使用指针，我们首先需要声明一个指针，然后可以通过地址操作符（&amp;）来获取变量的地址并将其存储在指针中，然后通过解引用操作符(*)来获取存储该地址中的值<br>以下是指针的基本步骤：</p><h4 id="6-3-1-指针使用的基本步骤"><a href="#6-3-1-指针使用的基本步骤" class="headerlink" title="6.3.1 指针使用的基本步骤"></a>6.3.1 指针使用的基本步骤</h4><hr><p><strong>步骤如下</strong>：</p><ul><li>声明指针</li><li>为指针分配地址</li><li>使用访问变量值</li><li>修改指针指向的变量的值</li></ul><p><strong>声明指针</strong>：在C语言中，使用星号（*）来声明一个指针。<br>int * p;<br><strong>为指针分配地址</strong>：我们可以使用“&amp;”来获取一个变量的地址，然后将该地址分配给指针。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> * p;</span><br><span class="line">p = &amp;i;    <span class="comment">//存地址</span></span><br></pre></td></tr></table></figure><p><strong>使用指针访问变量值</strong>：使用星号(<em>)前缀可以访问变量的值。这称为*<em>解引用</em></em><br>printf(“%d”,*p); &#x2F;&#x2F;去数据<br><strong>修改指针指向的变量的值</strong>：你也可以使用指针来修改它所指向的变量的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> * p;</span><br><span class="line">p = &amp;i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p);</span><br></pre></td></tr></table></figure><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> * p = &amp;a;</span><br><span class="line"></span><br><span class="line">    *p = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印地址： p = %p a = %p&quot;</span> , p , &amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印数据： p = %d a = %d&quot;</span> , *p, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="六、C语言中指针运算"><a href="#六、C语言中指针运算" class="headerlink" title="六、C语言中指针运算"></a>六、C语言中指针运算</h2><p>指针的运算就是以指针变量中所存放的值（地址量）作为运算量而进行运算。指针运算的知识就是地址的计算。<br>指针运算的种类是有限制的，只能进行<strong>算术运算</strong>、<strong>关系运算</strong>，以及我们前面所讲过的赋值，这里称为赋值运算。<br>如下表：</p><h3 id="6-1-算术运算"><a href="#6-1-算术运算" class="headerlink" title="6.1 算术运算"></a>6.1 算术运算</h3><p>不同类型的两个指针实行加减是无意义的：<br>px+n 表示实际内存单元的地址量是:(px)+sizeof(px的类型)*n;<br>px+n 表示实际内存单元的地址量是:(px)-sizeof(px的类型)*n;<br><strong>指针算术运算：</strong></p><table><thead><tr><th><strong>运算符</strong></th><th><strong>用法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>+</td><td>p + n</td><td>指针p向前（向高地址）移动n个同类型元素的位置</td></tr><tr><td>-</td><td>p - n</td><td>指针p向后（向低地址）移动n个同类型元素的位置</td></tr><tr><td>-</td><td>p - q</td><td>计算两个指针p和q之间相差多少个同类型元素的位置</td></tr></tbody></table><p><strong>指针的自增与自减运算：</strong></p><table><thead><tr><th><strong>运算符</strong></th><th><strong>用法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>++</td><td>p 或 p</td><td>指针p向前（向高地址）移动一个同类型元素的位置</td></tr><tr><td>–</td><td>–p 或 p–</td><td>指针p向后（向低地址）移动一个同类型元素的位置</td></tr></tbody></table><p><strong>注意</strong>：这些运算符直接改变指针本身的值。具体来说，p或–p首先改变指针的值，然后返回新的指针值；p或p–先返回原始的指针值，然后改变指针的值。<br><strong>例程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> * p = arr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印地址: p = %p , arr = %p \n &quot;</span> , &amp;p , arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印数据: p = %d\n&quot;</span>,*p);</span><br><span class="line">    <span class="comment">/*加法运算*/</span></span><br><span class="line">    p = p + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****************加法计算******************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印地址: p = %p , arr = %p \n&quot;</span> , &amp;p , arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印数据: p = %d\n&quot;</span>,*p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*减法运算*/</span></span><br><span class="line">    p = p - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****************加法计算******************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印地址: p = %p , arr = %p \n&quot;</span> , &amp;p , arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印数据: p = %d\n&quot;</span>,*p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*指针差*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****************指针差******************\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> * p_3 = &amp;arr[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> * p_4 = &amp;arr[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> i = p_3 - p_4;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;指针差%d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*自增运算*/</span></span><br><span class="line">    p++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****************加法计算******************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印地址: p = %p , arr = %p \n&quot;</span> , &amp;p , arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印数据: p = %d\n&quot;</span>,*p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*减法运算*/</span></span><br><span class="line">    j</span><br><span class="line">        p--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****************加法计算******************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印地址: p = %p , arr = %p \n&quot;</span> , &amp;p , arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印数据: p = %d\n&quot;</span>,*p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-2关系运算"><a href="#6-2关系运算" class="headerlink" title="6.2关系运算"></a>6.2关系运算</h3><p>关于指针的关系运算，需要注意以下几个问题</p><ol><li>指针关系运算应当在同类型和同数据区域的指针间进行。具有不同数据类型的指针之间的关系运算没有意义，指向不同数据区域（例如，一个指针指向堆，另一个指向栈）的两个指针之间，关系运算也没有意义。</li><li>指针与整数之间的关系运算没有意义，不能进行大于、小于等判断，但是可以与0进行等于或不等于的比较，用于判断指针是否为空。这是因为在C语言中，NULL指针通常被定义为0。</li></ol><p><strong>指针关系运算</strong></p><table><thead><tr><th><strong>运算符</strong></th><th><strong>用法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>p &#x3D;&#x3D; q</td><td>如果指针p和q指向同一位置则返回真</td></tr><tr><td>!&#x3D;</td><td>p !&#x3D; q</td><td>如果指针p和q指向不同位置则返回真</td></tr><tr><td>&lt;</td><td>p &lt; q</td><td>如果指针p位于q之前则返回真</td></tr><tr><td>&gt;</td><td>p &gt; q</td><td>如果指针p位于q之后则返回真</td></tr><tr><td>&lt;&#x3D;</td><td>p &lt;&#x3D; q</td><td>如果指针p位于q之前或与q同位置则返回真</td></tr><tr><td>&gt;&#x3D;</td><td>p &gt;&#x3D; q</td><td>如果指针p位于q之后或与q同位置则返回真</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line">    <span class="type">int</span> * p_1 = arr;</span><br><span class="line">    <span class="type">int</span> * p_2 = arr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印数据:p_1 = %d , p_2 = %d , arr = %d\n&quot;</span> , *p_1 , *p_2 ,* arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印地址:p_1 = %p , p_2 = %p , arr = %p\n&quot;</span> , p_1 , p_2 , arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*大于小于判断*/</span></span><br><span class="line">    p_1 = p_1 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p_2 &gt; p_1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打印数据:p_1 = %d , p_2 = %d , arr = %d\n&quot;</span> , *p_1 , *p_2 ,* arr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打印地址:p_1 = %p , p_2 = %p , arr = %p\n&quot;</span> , p_1 , p_2 , arr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p_2 &gt; p_1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//p_1 = p_1 - 1;</span></span><br><span class="line">    <span class="comment">//p_2 = p_2 + 1;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p_2 &lt; p_1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打印数据:p_1 = %d , p_2 = %d , arr = %d\n&quot;</span> , *p_1 , *p_2 ,* arr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打印地址:p_1 = %p , p_2 = %p , arr = %p\n&quot;</span> , p_1 , p_2 , arr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p_2 &gt; p_1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="七、C语言中指针和数组的关系"><a href="#七、C语言中指针和数组的关系" class="headerlink" title="七、C语言中指针和数组的关系"></a>七、C语言中指针和数组的关系</h2><p>在 C 语言中，指针和数组有着紧密的联系。理解这种联系有助于我们更好地理解如何在 C 程序中使用数组和指针。</p><h4 id="7-1-数组名作为指针"><a href="#7-1-数组名作为指针" class="headerlink" title="7.1 数组名作为指针"></a>7.1 <strong>数组名作为指针</strong></h4><p>在 C 语言中，数组名是一个常量指针，它指向数组的第一个元素。例如，如果你有一个数组 int arr[5]，那么 arr 就是指向 arr[0] 的指针。你可以通过对数组名进行解引用操作来获取第一个元素的值，例如 *arr 就是 arr[0] 的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *arr);  <span class="comment">// 输出: 1</span></span><br></pre></td></tr></table></figure><h4 id="7-2-使用指针访问数组元素"><a href="#7-2-使用指针访问数组元素" class="headerlink" title="7.2 使用指针访问数组元素:"></a>7.2 <strong>使用指针访问数组元素</strong>:</h4><p>你可以使用指针来访问和操作数组的元素。你可以通过对指针进行增减操作来移动指针，并使用解引用操作符来访问指针当前指向的元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = arr;  <span class="comment">// p 指向数组的第一个元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);  <span class="comment">// 输出当前元素的值</span></span><br><span class="line">    p++;  <span class="comment">// 指针向前移动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-数组作为函数参数"><a href="#7-3-数组作为函数参数" class="headerlink" title="7.3 数组作为函数参数"></a>7.3 <strong>数组作为函数参数</strong></h4><p>当数组作为函数参数时，它会被自动地转化为指向数组第一个元素的指针。这意味着函数内部不能直接获取到数组的长度，因为指针不保存数组的长度信息。为了在函数内部处理数组，你通常需要将数组的长度作为另一个参数传入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printArr</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> size)</span>·-</span><br><span class="line">    <span class="title function_">for</span> <span class="params">(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    printArr(arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，理解指针和数组的关系有助于我们编写更高效、更灵活的 C 代码。</p><h2 id="八、C语言中指针当函数参数和返回值"><a href="#八、C语言中指针当函数参数和返回值" class="headerlink" title="八、C语言中指针当函数参数和返回值"></a>八、C语言中指针当函数参数和返回值</h2><p>在 C 语言中，我们可以使用指针作为函数的参数，也可以使用指针作为函数的返回值。这种使用指针的方式可以使我们的代码更加灵活，特别是在处理数组，字符串，动态内存分配等问题时。</p><ol><li><strong>指针作为函数参数</strong>: 通过将指针作为函数参数，我们可以实现在函数内部修改外部变量的值。此外，当我们需要在函数中处理数组，字符串等数据结构时，也通常会使用指针作为参数。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>* p)</span> &#123;    <span class="comment">//引用传递</span></span><br><span class="line">    (*p)++;  <span class="comment">// increment the value of variable pointed by p</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before: %d\n&quot;</span>, a);</span><br><span class="line">    add(&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After: %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，add函数接收一个整数指针作为参数，然后增加该指针所指向的变量的值。</p><ol><li><strong>指针作为函数返回值</strong>: 如果函数需要返回数组，字符串，或者其他的复杂数据类型，那么通常会使用指针作为函数的返回值。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">getArr</span><span class="params">()</span> &#123;     <span class="comment">//指针函数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>* arr = getArr();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，getArr函数返回一个指向整型数组的指针。<br>注意事项：函数返回的指针必须指向静态数据或者动态分配的内存，不能返回指向栈上数据的指针，因为当函数执行完毕后，局部变量（存储在栈上）的生命周期就结束了，其内存区域可能会被其他的数据覆盖。<br>以上，就是在 C 语言中使用指针作为函数参数和返回值的基本用法。</p><h2 id="九、C语言中指针函数和函数指针"><a href="#九、C语言中指针函数和函数指针" class="headerlink" title="九、C语言中指针函数和函数指针"></a>九、C语言中指针函数和函数指针</h2><p>在 C 语言中，指针函数和函数指针是两个不同的概念，它们的含义和用法如下：</p><ol><li>**指针函数 (Pointer Function)**：指针函数其实就是返回指针的函数。在这种情况下，函数的返回类型是一个指针类型。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">getString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span>* str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">    str = getString();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，getString是一个返回char类型指针的函数，也被称为指针函数。</p><ol><li>**函数指针 (Function Pointer)**：函数指针是一个指针，它指向了一个函数。这样我们就可以像使用普通函数一样来使用这个指针。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void hello() &#123;</span><br><span class="line">    printf(&quot;Hello, World!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    void (*funcPtr)();  // declare a function pointer</span><br><span class="line">    funcPtr = hello;  // assign hello function to funcPtr</span><br><span class="line">    funcPtr();  // call the function via the function pointer</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，funcPtr就是一个函数指针，它被用来指向hello函数。然后通过funcPtr()来调用hello函数。<br>这两者虽然名字类似，但其实是两个完全不同的概念。指针函数是一种特殊类型的函数，它的返回值是一个指针。函数指针则是指向函数的指针，它可以被用来调用所指向的函数。</p><h2 id="十、C语言中命令行参数函数"><a href="#十、C语言中命令行参数函数" class="headerlink" title="十、C语言中命令行参数函数"></a>十、C语言中命令行参数函数</h2><p>在 C 语言中，我们可以通过命令行为程序提供参数，这些参数会在 main 函数中以特定的形式被处理。一个处理命令行参数的 main 函数的形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的两个参数分别是：</p><ol><li>argc (参数的数量)：这是一个整型，代表命令行参数的数量。当没有任何参数时，argc 的值为 1，因为程序的名称本身也被视作一个参数。</li><li>argv (参数的值)：这是一个指向字符串的指针数组，其中包含了每个参数的具体值。argv[0] 是程序的名称，argv[1] 是第一个参数，以此类推。</li></ol><p>比如，你有一个程序叫做 program，你通过命令行以这种方式运行它：.&#x2F;program arg1 arg2。在这种情况下，argc 的值为 3，argv[0] 是 .&#x2F;program，argv[1] 是 arg1，argv[2] 是 arg2。<br>这是一个简单的处理命令行参数的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序名称: %s\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;参数 %d: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有提供参数.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序会打印出它自己的名称以及所有的命令行参数。如果没有提供任何参数，它将输出 “没有提供参数.”。<br><strong>应用场景</strong>：<br>命令行参数在许多情况下都非常有用。这是因为它们提供了一种灵活的方式，让你可以在启动程序时向其提供一些信息。这意味着你可以控制程序的行为，而无需修改和重新编译代码。<br>以下是一些具体的使用场景：</p><ol><li><strong>配置选项</strong>：你可以使用命令行参数来控制程序的行为。例如，许多命令行工具都有诸如 -v 或 –verbose 的参数，这些参数可以控制程序显示更多的输出信息。</li><li><strong>输入和输出文件</strong>：你可以使用命令行参数来指定输入和&#x2F;或输出文件的路径。例如，编译器就需要一个源代码文件作为输入，并将生成的机器代码写入到另一个文件中。</li><li><strong>参数化测试</strong>：如果你正在编写一个需要进行大量测试的程序，那么命令行参数可能会派上用场。你可以编写一个脚本来运行你的程序，每次使用不同的参数，这样就可以自动化测试过程。</li><li><strong>环境设置</strong>：例如，你可能需要指定一些环境特定的设置，比如数据库的地址、密码等。</li></ol><p>总的来说，命令行参数提供了一种灵活的方式来影响程序的行为，而无需每次都去改变和重新编译代码。</p><h1 id="第六章-结构体和共用体"><a href="#第六章-结构体和共用体" class="headerlink" title="第六章 结构体和共用体"></a><strong>第六章 结构体和共用体</strong></h1><p><strong>目标</strong></p><ul><li>1、C语言中结构体和概念和使用</li><li>2、C语言中结构体数组和指针</li><li>3、C语言中结构体字节对齐和位域</li><li>4、C语言中共用体的概念和使用</li><li>5、C语言中枚举的概念和使用</li><li>6、C语言中的类型定义和typedef</li></ul><h2 id="一、C语言中结构体和概念和使用"><a href="#一、C语言中结构体和概念和使用" class="headerlink" title="一、C语言中结构体和概念和使用"></a>一、C语言中结构体和概念和使用</h2><h3 id="1-1-结构体的概念和基本定义"><a href="#1-1-结构体的概念和基本定义" class="headerlink" title="1.1 结构体的概念和基本定义"></a>1.1 结构体的概念和基本定义</h3><h4 id="1-1-1-什么是结构体，它的用途和场景"><a href="#1-1-1-什么是结构体，它的用途和场景" class="headerlink" title="1.1.1 什么是结构体，它的用途和场景"></a>1.1.1 什么是结构体，它的用途和场景</h4><p>结构体（Structure）是C语言中一种复合数据类型，它允许开发者将不同类型的数据项组织在一起。结构体中的每个数据项被称为“成员”，这些成员可以具有不同的数据类型，包括基本类型（如int，char，float等）和其他复合类型（包括其他结构体或数组）。结构体提供了一种方法，让开发者能够将相关数据项集中在一起并分配给一个变量。<br>结构体在以下场景中特别有用：</p><ol><li>表示复杂的数据对象：例如，如果要表示一个学生，可以创建一个包含姓名、年龄、成绩等成员的结构体。</li><li>将一组相关的变量组织在一起：如果有一组数据项属于同一实体或概念，那么将它们放在一个结构体中是有意义的。例如，一个结构体可以代表一个日期，其中包含年份、月份和日期这三个成员。</li><li>作为函数的参数或返回类型：在复杂的程序中，可能需要通过函数传递或返回多个数据。在这种情况下，将这些数据封装在一个结构体中会更有效，而且代码更易于阅读和理解。</li><li>实现更复杂的数据结构：在数据结构和算法中，结构体是实现链表、树、图等高级数据结构的基础。</li></ol><p>因此，结构体是C语言中一个非常重要的概念，掌握了结构体，就意味着你已经进入了C语言的一个更高级的阶段。</p><h4 id="1-1-2-结构体的基本语法"><a href="#1-1-2-结构体的基本语法" class="headerlink" title="1.1.2 结构体的基本语法"></a>1.1.2 结构体的基本语法</h4><p>结构体的基本语法在C语言中如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct_name</span> &#123;</span></span><br><span class="line">    data_type member1;</span><br><span class="line">    data_type member2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>struct 是一个关键字，表示这是一个结构体类型的定义。</li><li>struct_name 是你为这个结构体类型取的名字，这个名字在后面声明结构体变量时会用到。</li><li>data_type 是成员的数据类型，它可以是任何有效的C语言数据类型，包括基本数据类型（如int，float，char等）和其他复合类型（如数组，指针，甚至其他的结构体类型）。</li><li>member1，member2 等是成员的名字，你可以根据实际需要定义任意多个成员。</li></ul><p>例如，如果你想定义一个表示“学生”的结构体类型，你可以这么写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个结构体类型名字叫做 “Student”，它有三个成员：一个是长度为50的字符数组 “name”，用来存储学生的名字；一个是整型 “age”，用来存储学生的年龄；一个是浮点型 “grade”，用来存储学生的成绩。<br>这只是定义了一个结构体类型，如果你想要创建一个具体的学生，你需要声明一个结构体变量，就像这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">lile</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就创建了一个 “Student” 类型的变量 “tzp”，你可以通过 “.” 操作符来访问它的成员，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(lile.name, <span class="string">&quot;lile&quot;</span>);</span><br><span class="line">lile.age = <span class="number">20</span>;</span><br><span class="line">lile.grade = <span class="number">90.5</span>;</span><br></pre></td></tr></table></figure><h3 id="1-2-结构体变量的声明和访问"><a href="#1-2-结构体变量的声明和访问" class="headerlink" title="1.2 结构体变量的声明和访问"></a>1.2 结构体变量的声明和访问</h3><h4 id="1-2-1-如何声明结构体变量"><a href="#1-2-1-如何声明结构体变量" class="headerlink" title="1.2.1 如何声明结构体变量"></a>1.2.1 如何声明结构体变量</h4><p>声明结构体变量的方式和声明其他类型的变量类似。首先要写出结构体类型，然后跟上你要声明的变量名。如下面的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student1</span>;</span>  <span class="comment">// 声明了一个类型为struct Student的变量student1</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>此外，你也可以在定义结构体的同时声明变量，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125; student1, student2;  <span class="comment">// 在定义struct Student类型的同时，声明了两个此类型的变量student1和student2</span></span><br></pre></td></tr></table></figure><h4 id="1-2-2-如何访问结构体成员"><a href="#1-2-2-如何访问结构体成员" class="headerlink" title="1.2.2 如何访问结构体成员"></a>1.2.2 如何访问结构体成员</h4><p>访问结构体变量的成员可以使用.运算符。首先写出结构体变量的名字，然后写上.，最后写上你要访问的成员的名字。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125; student1, student2;  <span class="comment">// 在定义struct Student类型的同时，声明了两个此类型的变量student1和student2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">strcpy</span>(student1.name, <span class="string">&quot;lican&quot;</span>);  <span class="comment">// 设置student1的名字为&quot;John Doe&quot;</span></span><br><span class="line">     student1.age = <span class="number">20</span>;  <span class="comment">// 设置student1的年龄为20</span></span><br><span class="line">     student1.grade = <span class="number">90.5</span>;  <span class="comment">// 设置student1的成绩为90.5</span></span><br><span class="line"></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student3</span>;</span></span><br><span class="line">     <span class="built_in">strcpy</span>(student3.name, <span class="string">&quot;lile&quot;</span>);  <span class="comment">// 设置student1的名字为&quot;John Doe&quot;</span></span><br><span class="line">     student3.age = <span class="number">20</span>;  <span class="comment">// 设置student1的年龄为20</span></span><br><span class="line">     student3.grade = <span class="number">90.5</span>;  <span class="comment">// 设置student1的成绩为90.5</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>当我们使用指向结构体的指针时，可以使用 -&gt; 运算符来访问结构体的成员。下面是一个使用 -&gt; 运算符访问结构体成员的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">     <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">     <span class="type">int</span> age;</span><br><span class="line">     <span class="type">float</span> grade;</span><br><span class="line"> &#125;student1;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">strcpy</span>(student1.name, <span class="string">&quot;lican&quot;</span>);  <span class="comment">// 设置student1的名字为&quot;John Doe&quot;</span></span><br><span class="line">     student1.age = <span class="number">20</span>;  <span class="comment">// 设置student1的年龄为20</span></span><br><span class="line">     student1.grade = <span class="number">90.5</span>;  <span class="comment">// 设置student1的成绩为90.5</span></span><br><span class="line"></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student3</span>;</span></span><br><span class="line">     <span class="built_in">strcpy</span>(student3.name, <span class="string">&quot;lile&quot;</span>);  <span class="comment">// 设置student1的名字为&quot;John Doe&quot;</span></span><br><span class="line">     student3.age = <span class="number">20</span>;  <span class="comment">// 设置student1的年龄为20</span></span><br><span class="line">     student3.grade = <span class="number">90.5</span>;  <span class="comment">// 设置student1的成绩为90.5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">p</span> =</span> &amp;student1;  <span class="comment">// p是一个指向student1的指针</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用-&gt;运算符访问student1的成员</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p-&gt;name);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;age);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, p-&gt;grade);</span><br><span class="line"></span><br><span class="line">     p = <span class="literal">NULL</span>;</span><br><span class="line">     p = &amp;student3;  <span class="comment">// p是一个指向student1的指针</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用-&gt;运算符访问student3的成员</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p-&gt;name);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;age);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, p-&gt;grade);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，p 是一个指向 student1 的指针，p-&gt;name 就是访问 p 指向的结构体的 name 成员，p-&gt;age 和 p-&gt;grade 同理。所以，-&gt; 运算符是用于通过结构体指针访问结构体成员的。</p><h4 id="1-2-3-如何初始化结构体变量"><a href="#1-2-3-如何初始化结构体变量" class="headerlink" title="1.2.3 如何初始化结构体变量"></a>1.2.3 如何初始化结构体变量</h4><p>初始化结构体变量可以在声明的同时进行。写出结构体类型和变量名，然后在等号右边用花括号包裹起来的值列表来初始化所有的成员。值的顺序应该和成员在结构体定义中的顺序一致。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student1</span> =</span> &#123;<span class="string">&quot;tan&quot;</span>, <span class="number">20</span>, <span class="number">90.5</span>&#125;;  <span class="comment">// 初始化student1的所有成员</span></span><br></pre></td></tr></table></figure><p>在这个例子中，”tan”初始化了name成员，20初始化了age成员，90.5初始化了grade成员。<br>也可以使用指定初始化器的方式来初始化结构体变量，这种方式可以不按照成员顺序进行，而是根据成员的名字来指定值。例如：<br><strong>struct Student student1 &#x3D; {.name &#x3D; “John Doe”, .age &#x3D; 20, .grade &#x3D; 90.5}; &#x2F;&#x2F; 使用指定初始化器初始化student1的所有成员</strong></p><h3 id="1-3-结构体和函数的关系"><a href="#1-3-结构体和函数的关系" class="headerlink" title="1.3 结构体和函数的关系"></a>1.3 结构体和函数的关系</h3><h4 id="1-3-1-如何将结构体作为函数参数"><a href="#1-3-1-如何将结构体作为函数参数" class="headerlink" title="1.3.1 如何将结构体作为函数参数"></a>1.3.1 如何将结构体作为函数参数</h4><p>我们可以将结构体作为函数的参数。在这种情况下，函数会接收结构体的一个<strong>副本</strong>，修改这个副本并不会影响原来的结构体。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_student</span><span class="params">(                                                )</span>    <span class="comment">//参数列表为结构体</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, s.grade);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">john</span> =</span> &#123;<span class="string">&quot;John Doe&quot;</span>, <span class="number">20</span>, <span class="number">90.5</span>&#125;;</span><br><span class="line">print_student(john);  <span class="comment">// 将john作为参数传递给print_student函数</span></span><br></pre></td></tr></table></figure><p>如果要在函数内部修改原来的结构体，需要传递一个指向结构体的指针，然后在函数内部通过这个指针来访问和修改结构体。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">birthday</span><span class="params">(<span class="keyword">struct</span> Student *s)</span> &#123;</span><br><span class="line">    s-&gt;age++;  <span class="comment">// 通过指针访问并修改结构体的成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">birthday(&amp;john);  <span class="comment">// 将指向john的指针作为参数传递给birthday函数</span></span><br></pre></td></tr></table></figure><h4 id="1-3-2-在函数中返回结构体"><a href="#1-3-2-在函数中返回结构体" class="headerlink" title="1.3.2 在函数中返回结构体"></a>1.3.2 在函数中返回结构体</h4><p>函数也可以返回一个结构体。 在这种情况下，函数会返回一个结构体的副本。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student <span class="title function_">make_student</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> age, <span class="type">float</span> grade)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s</span>;</span></span><br><span class="line">    <span class="built_in">strcpy</span>(s.name, name);</span><br><span class="line">    s.age = age;</span><br><span class="line">    s.grade = grade;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">john</span> =</span> make_student(<span class="string">&quot;peng&quot;</span>, <span class="number">20</span>, <span class="number">90.5</span>);  <span class="comment">// 使用make_student函数的返回值来初始化john</span></span><br></pre></td></tr></table></figure><p>需要注意的是，返回一个结构体会涉及到拷贝整个结构体，如果结构体很大，这可能会比较低效。在这种情况下，一种可能的解决方案是返回一个指向结构体的指针。但需要注意的是，不能返回指向局部变量的指针，因为当函数返回后，局部变量就不存在了。你可以返回一个指向动态分配的内存的指针，这个内存可以在函数返回后继续存在。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Student *make_student(char *name, int age, float grade) &#123;</span><br><span class="line">    struct Student *s = malloc(sizeof(struct Student));</span><br><span class="line">    if (s != NULL) &#123;</span><br><span class="line">        strcpy(s-&gt;name, name);</span><br><span class="line">        s-&gt;age = age;</span><br><span class="line">        s-&gt;grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Student *john = make_student(&quot;John Doe&quot;, 20, 90.5);  // john是一个指向动态分配的结构体的指针</span><br></pre></td></tr></table></figure><p>在这个例子中，make_student 函数使用 malloc 函数动态分配了一块内存，并返回了指向这块内存的指针。使用完这块内存后，你需要使用 free 函数来释放它，防止内存泄漏。</p><h2 id="二、C语言中结构体数组和指针"><a href="#二、C语言中结构体数组和指针" class="headerlink" title="二、C语言中结构体数组和指针"></a>二、C语言中结构体数组和指针</h2><h3 id="2-1-结构体数组的定义和使用"><a href="#2-1-结构体数组的定义和使用" class="headerlink" title="2.1 结构体数组的定义和使用"></a>2.1 结构体数组的定义和使用</h3><h4 id="2-1-1-如何定义和初始化结构体数组"><a href="#2-1-1-如何定义和初始化结构体数组" class="headerlink" title="2.1.1 如何定义和初始化结构体数组"></a>2.1.1 如何定义和初始化结构体数组</h4><p>定义和初始化结构体数组的语法与普通数组非常类似。我们首先定义结构体类型，然后声明该类型的数组，并在声明时初始化数组。<br>以下是一个示例，我们定义了一个名为Student的结构体，并声明了该类型的数组students：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并初始化一个结构体数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">students</span>[3] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">20</span>, <span class="number">85.6</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">22</span>, <span class="number">90.8</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">19</span>, <span class="number">88.5</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-如何访问结构体数组的元素"><a href="#2-1-2-如何访问结构体数组的元素" class="headerlink" title="2.1.2 如何访问结构体数组的元素"></a>2.1.2 如何访问结构体数组的元素</h4><p>访问结构体数组的元素非常直观，我们可以通过索引来访问数组的元素，然后使用.运算符来访问结构体的成员。<br>以下是一个示例，我们访问students数组的元素并打印相关信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印第一个学生的姓名</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, students[<span class="number">0</span>].name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印第二个学生的年龄</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Age: %d\n&quot;</span>, students[<span class="number">1</span>].age);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印第三个学生的成绩</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Grade: %.2f\n&quot;</span>, students[<span class="number">2</span>].grade);</span><br></pre></td></tr></table></figure><p>在这个示例中，students[0]、students[1]、students[2]分别表示数组students中的第一个、第二个和第三个元素，这些元素都是Student类型的结构体。我们使用.运算符来访问这些结构体的成员。</p><h3 id="2-2-的定义和使用"><a href="#2-2-的定义和使用" class="headerlink" title="2.2 &lt;结构体指针&gt;的定义和使用"></a>2.2 &lt;结构体指针&gt;的定义和使用</h3><h4 id="2-2-1-如何定义结构体指针"><a href="#2-2-1-如何定义结构体指针" class="headerlink" title="2.2.1 如何定义结构体指针"></a>2.2.1 如何定义结构体指针</h4><p>定义一个指向结构体的指针与定义普通指针类似。首先我们需要指定指针的类型，即指针指向的结构体的类型，然后指定指针的名称。例如，我们可以这样定义一个指向 struct Student 类型的指针 p：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student1</span> =</span> &#123;<span class="string">&quot;John Doe&quot;</span>, <span class="number">20</span>, <span class="number">90.5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">p</span>;</span>  <span class="comment">// 定义一个指向struct Student类型的指针p</span></span><br><span class="line"></span><br><span class="line">p = &amp;student1;  <span class="comment">// 将p指向student1</span></span><br></pre></td></tr></table></figure><p>在上述代码中，我们首先定义了一个 struct Student 类型的变量 student1，然后定义了一个指向 struct Student 类型的指针 p，最后将 p 指向 student1。</p><h4 id="2-2-2-如何访问指向结构体的指针成员"><a href="#2-2-2-如何访问指向结构体的指针成员" class="headerlink" title="2.2.2 如何访问指向结构体的指针成员"></a>2.2.2 如何访问指向结构体的指针成员</h4><p>我们可以通过结构体指针来访问结构体的成员，这时我们需要使用 <strong>-&gt;</strong> 运算符。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p-&gt;name);  <span class="comment">// 使用-&gt;运算符访问p指向的结构体的name成员</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;age);  <span class="comment">// 使用-&gt;运算符访问p指向的结构体的age成员</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, p-&gt;grade);  <span class="comment">// 使用-&gt;运算符访问p指向的结构体的grade成员</span></span><br></pre></td></tr></table></figure><p>在这个例子中，p 是一个指向 student1 的指针，p-&gt;name 就是访问 p 指向的结构体的 name 成员，p-&gt;age 和 p-&gt;grade 同理。所以，-&gt; 运算符是用于通过结构体指针访问结构体成员的。</p><h2 id="三、C语言中结构体字节对齐和位域"><a href="#三、C语言中结构体字节对齐和位域" class="headerlink" title="三、C语言中结构体字节对齐和位域"></a>三、C语言中结构体字节对齐和位域</h2><h3 id="3-1-结构体的字节对齐"><a href="#3-1-结构体的字节对齐" class="headerlink" title="3.1 结构体的字节对齐"></a>3.1 结构体的字节对齐</h3><p>字节对齐（Data Alignment）是计算机硬件为了提高内存读写效率所采取的一种措施。在C语言中，结构体的成员可能不会严格按照代码中的顺序在内存中排列，而会进行字节对齐。</p><h4 id="3-1-1-结构体的字节对齐"><a href="#3-1-1-结构体的字节对齐" class="headerlink" title="3.1.1 结构体的字节对齐"></a>3.1.1 结构体的字节对齐</h4><p>结构体的字节对齐是指编译器在分配内存时，会保证每个成员的存储地址相对于结构体起始地址的偏移量是该成员类型大小的整数倍。例如，如果一个成员的类型为 int，则其偏移量必须是 sizeof(int) 的整数倍。</p><h4 id="3-1-2-结构体的字节对齐规则"><a href="#3-1-2-结构体的字节对齐规则" class="headerlink" title="3.1.2 结构体的字节对齐规则"></a>3.1.2 结构体的字节对齐规则</h4><ul><li>结构体的每个成员根据其类型的自然对齐要求，从起始位置按该类型的整数倍位置开始存放。</li><li>结构体本身，按照所有成员中最大自然对齐值的整数倍来对齐。</li><li>在成员对齐时，如果成员大小小于对齐值，按照成员大小对齐。如果成员大小大于对齐值，按照对齐值对齐。</li></ul><h4 id="3-1-3-如何设置字节对齐"><a href="#3-1-3-如何设置字节对齐" class="headerlink" title="3.1.3 如何设置字节对齐"></a>3.1.3 如何设置字节对齐</h4><p>在C语言中，可以通过编译指令 #pragma pack(n) 来设置字节对齐的规则。n 表示最大对齐字节数，必须是2的非负整数次幂，并且小于或等于平台最大支持的对齐字节数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(2) <span class="comment">// 设定字节对齐规则为2字节对齐</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyData</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack() <span class="comment">// 恢复编译器默认的对齐规则</span></span></span><br></pre></td></tr></table></figure><p>在上面的例子中，使用 #pragma pack(2) 设定了2字节对齐，MyData 结构体的 c 成员和 i 成员之间可能就会有1个字节的填充。然后使用 #pragma pack() 恢复了编译器默认的对齐规则。</p><p>结构体对齐的规则通常包括以下几点：</p><ol><li>基本对齐原则：结构体中的每个成员按照其自身类型的大小进行对齐。例如， int 类型通常按照 4 字节对齐， double 类型通常按照 8 字节对齐。</li><li>填充字节：为了满足对齐要求，可能会在成员之间插入填充字节。例如，如果一个  char 类型（1 字节）后面紧跟着一个  int 类型（4 字节），那么可能会在  char 后面填充 3 个字节，以使  int 从 4 字节的边界开始存储。</li><li>结构体大小：结构体的总大小是其最大成员大小的整数倍。如果结构体的最后一个成员后面还需要填充字节以满足这个规则，也会进行填充。</li><li>嵌套结构体：如果结构体中包含嵌套的结构体，嵌套结构体也会按照上述规则进行对齐，并且整个结构体的对齐要考虑嵌套结构体的对齐情况。</li><li>编译器特定规则：不同的编译器可能对结构体的对齐有一些细微的差别，或者提供特定的编译选项来控制对齐方式。</li></ol><p>下面是一个示例来说明结构体对齐：</p><p>#include &lt;stdio.h&gt;</p><p>struct S1 {</p><p>​    char c;</p><p>​    int i;</p><p>};</p><p>struct S2 {</p><p>​    int i;</p><p>​    char c;</p><p>};</p><p>int main() {</p><p>​    printf(“Size of S1: %zu\n”, sizeof(struct S1));</p><p>​    printf(“Size of S2: %zu\n”, sizeof(struct S2));</p><p>​    return 0;</p><p>}</p><p>在常见的编译器中， struct S1 的大小可能是 8 字节，因为  char 后面会填充 3 个字节以满足  int 的 4 字节对齐要求。而  struct S2 的大小通常也是 8 字节，因为结构体的总大小要为 4 的整数倍，所以在最后可能会填充 3 个字节。</p><h3 id="3-2-结构体的位域"><a href="#3-2-结构体的位域" class="headerlink" title="3.2 结构体的位域"></a>3.2 结构体的位域</h3><h4 id="3-2-1-什么是位域，他的作用"><a href="#3-2-1-什么是位域，他的作用" class="headerlink" title="3.2.1 什么是位域，他的作用"></a>3.2.1 什么是位域，他的作用</h4><p>位域（Bit-field）是C语言中的一种特殊类型，它允许程序员对一个整型变量的位进行操作，从而节省内存空间。位域通常用于处理底层硬件或者协议中的数据，例如，一些硬件的寄存器可能只有几个位有实际意义，或者网络协议中的一些字段可能只有几位。</p><h4 id="3-2-2-如何定义和使用位域"><a href="#3-2-2-如何定义和使用位域" class="headerlink" title="3.2.2 如何定义和使用位域"></a>3.2.2 如何定义和使用位域</h4><p>位域的定义在语法上类似于普通的结构体成员定义，但是需要在类型名和成员名之间加上一个冒号和一个数字，表示该成员的位数。<br>例如，下面的代码定义了一个包含两个位域成员的结构体 BitField：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BitField</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a : <span class="number">3</span>;  <span class="comment">// a是一个3位的无符号整型位域</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b : <span class="number">4</span>;  <span class="comment">// b是一个4位的无符号整型位域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用位域的方式和普通的结构体成员类似，都是使用 . 运算符。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BitField</span> <span class="title">bf</span>;</span></span><br><span class="line">bf.a = <span class="number">5</span>;  <span class="comment">// 设置a为5</span></span><br><span class="line">bf.b = <span class="number">10</span>;  <span class="comment">// 设置b为10</span></span><br></pre></td></tr></table></figure><p>需要注意的是，位域的值不能超过它的位数所能表示的最大值。例如，在上面的代码中，a 最大只能表示到 2^3-1 &#x3D; 7，如果尝试设置一个更大的值，那么只有最低的3位会被保留，高位的值会被丢弃。</p><h4 id="3-2-3-位于在结构体中的内存分布"><a href="#3-2-3-位于在结构体中的内存分布" class="headerlink" title="3.2.3 位于在结构体中的内存分布"></a>3.2.3 位于在结构体中的内存分布</h4><p>位域在内存中的布局取决于具体的编译器和平台。大部分情况下，同一类型的连续位域会被打包在一起。如果一组连续的位域的总位数超过了它们的类型的大小，那么编译器可能会将它们分配到两个或更多的字（word）中。如果位域之间有一个非位域成员，或者两个位域成员的类型不同，那么它们也可能被分配到不同的字中。<br>例如，下面的代码定义了一个包含三个位域成员的结构体 BitField2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BitField2</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a : <span class="number">3</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b : <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> c : <span class="number">6</span>;  <span class="comment">// c可能无法和a、b打包在一起，因为a、b、c的总位数超过了unsigned int的大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，a、b 和 c 可能无法全部打包在一个 unsigned int 中，因为它们的总位数（3+4+6 &#x3D; 13）超过了 unsigned int 的大小（通常为8或16）。这时，c 可能会被分配到另一个 unsigned int 中。但是具体的内存布局取决于编译器和平台，可以通过编译器的文档或者实验来确定。</p><h2 id="四、C语言中共用体的概念和使用-union"><a href="#四、C语言中共用体的概念和使用-union" class="headerlink" title="四、C语言中共用体的概念和使用(union)"></a>四、C语言中共用体的概念和使用(union)</h2><h3 id="4-1-共用体的概念"><a href="#4-1-共用体的概念" class="headerlink" title="4.1 共用体的概念"></a>4.1 共用体的概念</h3><p>共用体（union）是C语言中的一种复合数据类型，类似于结构体。它允许在相同的内存位置存储不同的数据类型。也就是说，共用体的所有成员共享同一块内存空间，它的大小由最大的成员决定。因此，共用体可以被看作是一个可以存储多种数据类型的变量。<br>共用体的主要用途是节省内存，特别是当我们有一些组件会以多种方式使用的时候。但请注意，同一时间只能使用共用体的一个成员，因为所有成员都共享同一块内存。</p><h3 id="4-2-共用体的基本语法"><a href="#4-2-共用体的基本语法" class="headerlink" title="4.2 共用体的基本语法"></a>4.2 共用体的基本语法</h3><p>共用体的定义与结构体类似，使用关键字 union。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">union Data &#123;</span><br><span class="line">   int i;</span><br><span class="line">   float f;</span><br><span class="line">   char str[20];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个名为 Data 的共用体，它有三个成员：一个 int，一个 float 和一个 char 数组。共用体 Data 的大小等于其最大成员的大小，即 char str[20] 的大小。</p><h3 id="4-3-如何使用共用体"><a href="#4-3-如何使用共用体" class="headerlink" title="4.3 如何使用共用体"></a>4.3 如何使用共用体</h3><p>共用体的使用方法和结构体相似。我们可以定义一个共用体类型的变量，然后通过 . 运算符来访问它的成员。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">union Data data;</span><br><span class="line"></span><br><span class="line">data.i = 10;</span><br><span class="line">printf( &quot;%d\n&quot;, data.i);</span><br><span class="line"></span><br><span class="line">data.f = 220.5;</span><br><span class="line">printf( &quot;%f\n&quot;, data.f);</span><br><span class="line"></span><br><span class="line">strcpy( data.str, &quot;C Programming&quot;);</span><br><span class="line">printf( &quot;%s\n&quot;, data.str);</span><br></pre></td></tr></table></figure><p>在上面的代码中，首先定义了一个 Data 类型的变量 data，然后依次将其 int 成员 i，float 成员 f 和 char 数组成员 str 赋值并打印。注意在赋值新的成员之后，之前的成员的值就不再保留了。<br>总结来说，共用体在C语言中是一个非常有用的工具，它可以帮助我们在不同情况下复用内存，但使用时需要注意其成员之间的覆盖关系。</p><h2 id="五、C语言中枚举的概念和使用-enum"><a href="#五、C语言中枚举的概念和使用-enum" class="headerlink" title="五、C语言中枚举的概念和使用(enum)"></a>五、C语言中枚举的概念和使用(enum)</h2><h3 id="5-1-枚举的概念"><a href="#5-1-枚举的概念" class="headerlink" title="5.1 枚举的概念"></a>5.1 枚举的概念</h3><p>枚举（enum）是C语言中的一种数据类型，它由程序员定义一组整数常量，并给这组常量赋予一个名字。枚举类型的变量只能被赋予枚举中的某个值，这样可以使程序更加清晰和易于理解。<br>枚举类型通常被用在需要一组固定值的场景，例如一周的七天、一个月的十二个月、棋盘的颜色（黑色和白色）、交通信号灯的颜色（红、黄、绿）等等。</p><h3 id="5-2-枚举的基本语法"><a href="#5-2-枚举的基本语法" class="headerlink" title="5.2 枚举的基本语法"></a>5.2 枚举的基本语法</h3><p>枚举的定义使用关键字 enum。例如，下面的代码定义了一个名为 Day 的枚举类型，它包含一周的七天：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span> &#123;</span></span><br><span class="line">    SUNDAY,</span><br><span class="line">    MONDAY,</span><br><span class="line">    TUESDAY,</span><br><span class="line">    WEDNESDAY,</span><br><span class="line">    THURSDAY,</span><br><span class="line">    FRIDAY,</span><br><span class="line">    SATURDAY</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，SUNDAY、MONDAY 等被称为枚举常量，它们默认对应的整数值从0开始，逐个加1。也就是说，SUNDAY 对应0，MONDAY 对应1，以此类推。你也可以显式地为它们赋予其他的整数值。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span> &#123;</span></span><br><span class="line">    SUNDAY = <span class="number">1</span>,</span><br><span class="line">    MONDAY,</span><br><span class="line">    TUESDAY,</span><br><span class="line">    WEDNESDAY,</span><br><span class="line">    THURSDAY,</span><br><span class="line">    FRIDAY,</span><br><span class="line">    SATURDAY</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，SUNDAY 被显式赋值为1，那么 MONDAY 对应的值就是2，TUESDAY 对应的值就是3，以此类推。</p><h3 id="5-3-如何使用枚举"><a href="#5-3-如何使用枚举" class="headerlink" title="5.3 如何使用枚举"></a>5.3 如何使用枚举</h3><p>定义了枚举类型后，你就可以声明该类型的变量，并将枚举常量赋给它。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span> <span class="title">day</span>;</span></span><br><span class="line">day = MONDAY;</span><br></pre></td></tr></table></figure><p>你也可以直接使用枚举常量，因为它们本质上就是整数。例如，你可以在 printf 函数中打印它们：<br><strong>printf(“%d\n”, MONDAY); &#x2F;&#x2F; 打印1</strong><br>或者在 switch 语句中使用它们：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Today is Monday.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TUESDAY:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Today is Tuesday.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 其他情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结来说，枚举是一种非常有用的工具，它可以帮助我们创建一组命名的整数常量，使程序更加清晰和易于理解。</p><h2 id="六、C语言中的类型定义和typedef"><a href="#六、C语言中的类型定义和typedef" class="headerlink" title="六、C语言中的类型定义和typedef"></a>六、C语言中的类型定义和typedef</h2><h3 id="6-1-类型定义的概念"><a href="#6-1-类型定义的概念" class="headerlink" title="6.1 类型定义的概念"></a>6.1 类型定义的概念</h3><p>在 C 语言中，typedef 是一个关键字，它用于为复杂的数据类型定义新的名称，以方便在程序中使用。这通常被用来简化复杂的类型声明，或者为某种特定的类型定义更具可读性的名称。</p><h3 id="6-2-typedef-的基本语法"><a href="#6-2-typedef-的基本语法" class="headerlink" title="6.2 typedef 的基本语法"></a>6.2 typedef 的基本语法</h3><p>作用：给变量更换名字</p><p>typedef 的基本语法是这样的：<br><strong>typedef existing_type new_type_name;</strong><br>在这个语句中，existing_type 是一个已经存在的类型，可以是内置的类型（如 int, float 等），也可以是用户定义的类型（如结构体，联合体等）。new_type_name 是你想要定义的新类型的名称。<br>例如，你可以为 unsigned int 类型定义一个新的名称 uint：<br><strong>typedef unsigned int uint;</strong><br>之后，你就可以在程序中使用 uint 来代替 unsigned int 类型：<br><strong>uint a &#x3D; 10;</strong></p><h3 id="6-3-typedef-在结构体和联合体中的使用"><a href="#6-3-typedef-在结构体和联合体中的使用" class="headerlink" title="6.3 typedef 在结构体和联合体中的使用"></a>6.3 typedef 在结构体和联合体中的使用</h3><p>typedef 在结构体和联合体中的使用非常常见。例如，你可以为结构体定义一个新的类型名称，这样在声明结构体变量时就不用再写 struct 关键字了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; Point;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在你可以直接使用 Point 来声明变量</span></span><br><span class="line">Point p1, p2;</span><br></pre></td></tr></table></figure><p>这种方式在定义复杂的类型，如指向结构体的指针或者结构体数组时，会让代码更加清晰易读。<br>总结来说，typedef 是一个非常有用的工具，它可以帮助我们简化复杂的类型声明，提高代码的可读性。</p><h1 id="第七章-文件操作和预处理器"><a href="#第七章-文件操作和预处理器" class="headerlink" title="第七章 文件操作和预处理器"></a><strong>第七章 文件操作和预处理器</strong></h1><p>@[toc]<strong>目标</strong></p><ul><li>1、C语言的文件操作</li><li>2、C语言中的文件读写函数</li><li>3、C语言中的文件定位函数</li><li>4、C语言中的文件实战</li><li>5、C语言中的预处理器指令</li><li>6、C语言中的模块化编程</li><li>7、C语言中的宏函数和内联函数</li></ul><p><img src="/./../../../images/1695088035509-427cdd79-45a7-4cd9-a9ec-410a1da1c686.jpeg" alt="img"></p><h2 id="一、C语言的文件操作"><a href="#一、C语言的文件操作" class="headerlink" title="一、C语言的文件操作"></a>一、C语言的文件操作</h2><h3 id="1-1-文件操作的基本概念"><a href="#1-1-文件操作的基本概念" class="headerlink" title="1.1 文件操作的基本概念"></a>1.1 文件操作的基本概念</h3><p>在C语言中，文件是一种存储在存储设备上（如硬盘、光盘等）的数据集合。文件是数据的重要载体，是操作系统中对数据管理的一种抽象方式。文件不仅可以存储程序代码，还可以存储各种类型的数据，如文字、图片、音频、视频等。C语言提供了一系列的文件操作函数，可以帮助我们实现对文件的读取、写入、修改等操作。</p><h3 id="1-2-文件的打开和关闭"><a href="#1-2-文件的打开和关闭" class="headerlink" title="1.2 文件的打开和关闭"></a>1.2 文件的打开和关闭</h3><p>在C语言中，我们使用fopen函数来打开一个文件，fopen函数需要两个参数：一个是文件路径，另一个是文件模式。文件模式决定了我们可以进行哪些操作，例如，我们可以选择只读模式（”r”）、只写模式（”w”）、读写模式（”rw”）等。<br>在操作完文件后，我们需要使用fclose函数来关闭文件，以释放操作系统分配给该文件的资源。这是一个良好的编程习惯，可以防止资源泄漏，提高程序的稳定性和运行效率。</p><h3 id="1-3-文件模式"><a href="#1-3-文件模式" class="headerlink" title="1.3 文件模式"></a>1.3 文件模式</h3><p>文件模式用于决定如何操作文件。以下是C语言中常用的文件模式：<br><img src="https://cdn.nlark.com/yuque/0/2023/png/8368890/1695052366873-08a7b38d-ee80-40ae-b43d-7c9d514b3511.png#averageHue=%23f1f1f1&clientId=u6674c2ea-3afd-4&from=paste&height=591&id=uc15feaa9&originHeight=886&originWidth=1691&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=570163&status=done&style=none&taskId=u99c57e77-6df2-4fef-ad4c-b50a6b548e9&title=&width=1127.3333333333333" alt="img"></p><ul><li>“r”：只读模式。这种模式下，程序只能读取文件，不能写入。如果文件不存在，fopen函数会返回NULL。</li><li>“w”：只写模式。这种模式下，程序只能写入文件，不能读取。如果文件不存在，fopen函数会创建一个新文件。如果文件已存在，它的内容将被清空，即被覆盖。</li><li>“a”：追加模式。这种模式下，程序只能在文件的末尾写入数据。如果文件不存在，fopen函数会创建一个新文件。</li><li><strong>“r+”：读写模式。这种模式下，程序既能读取文件，也能写入文件。文件必须存在，否则fopen函数会返回NULL。</strong></li><li><strong>“w+”：读写模式。这种模式下，程序既能读取文件，也能写入文件。如果文件不存在，fopen函数会创建一个新文件。如果文件已存在，它的内容将被清空，即被覆盖。</strong></li><li><strong>“a+”：读写模式。这种模式下，程序既能读取文件，也能在文件的末尾写入数据。如果文件不存在，fopen函数会创建一个新文件。</strong></li></ul><p>在这些模式中，我们可以添加一个”b”来打开一个二进制文件，如”rb”、”wb”、”ab”、”r+b”、”w+b”、”a+b”。在二进制模式下，文件将按照二进制形式进行读取或写入，这对于处理图像、音频、视频等非文本文件非常有用。</p><h2 id="二、C语言中的文件读写函数"><a href="#二、C语言中的文件读写函数" class="headerlink" title="二、C语言中的文件读写函数"></a>二、C语言中的文件读写函数</h2><h3 id="2-1-读写函数的基本概念"><a href="#2-1-读写函数的基本概念" class="headerlink" title="2.1 读写函数的基本概念"></a>2.1 读写函数的基本概念</h3><p>在C语言中，我们可以使用特定的函数来从文件中读取数据或者向文件中写入数据。这些函数主要分为三类：</p><ol><li><strong>字符读写函数</strong>：这类函数用于读取或写入单个字符，例如 fgetc 和 fputc。</li><li><strong>行读写函数</strong>：这类函数用于读取或写入一行字符串，例如 fgets 和 fputs。</li><li><strong>格式化读写函数</strong>：这类函数用于读取或写入特定格式的数据，例如 fscanf 和 fprintf。</li></ol><p>所有这些函数都需要一个文件指针作为参数，这个文件指针指向要读取或写入的文件。接下来，我们将详细介绍这些函数的使用方法。</p><h4 id="2-2-使用-fgetc-和-fputc-进行字符读写"><a href="#2-2-使用-fgetc-和-fputc-进行字符读写" class="headerlink" title="2.2 使用 fgetc 和 fputc 进行字符读写"></a>2.2 使用 fgetc 和 fputc 进行字符读写</h4><p>fgetc 和 fputc 是C语言中最基本的文件读写函数，它们分别用于从文件中读取单个字符和向文件中写入单个字符。</p><h5 id="fgetc-函数"><a href="#fgetc-函数" class="headerlink" title="fgetc 函数"></a>fgetc 函数</h5><ul><li><strong>头文件</strong>：stdio.h</li><li><strong>函数原型</strong>：int fgetc(FILE *stream);</li><li><strong>函数功能</strong>：从参数stream所指的文件中读取一个字符。</li><li><strong>返回值</strong>：读取成功返回字符的ASCII值，读到文件结束或发生错误返回EOF。</li></ul><h5 id="fputc-函数"><a href="#fputc-函数" class="headerlink" title="fputc 函数"></a>fputc 函数</h5><ul><li><strong>头文件</strong>：stdio.h</li><li><strong>函数原型</strong>：int fputc(int c, FILE *stream);</li><li><strong>函数功能</strong>：将参数c指定的字符写入参数stream所指的文件中。</li><li><strong>返回值</strong>：写入成功返回写入的字符，发生错误返回EOF。</li></ul><h5 id="示例程序："><a href="#示例程序：" class="headerlink" title="示例程序："></a>示例程序：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     FILE *fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);  <span class="comment">//读写模式</span></span><br><span class="line">     <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Open file failed!\n&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用fputc向文件中写入字符</span></span><br><span class="line">     <span class="type">char</span> c;</span><br><span class="line">     <span class="keyword">for</span> (c = <span class="string">&#x27;A&#x27;</span>; c &lt;= <span class="string">&#x27;Z&#x27;</span>; c++) &#123;</span><br><span class="line">         fputc(c, fp);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 将文件指针重新定位到文件开头</span></span><br><span class="line">     rewind(fp);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用fgetc从文件中读取字符</span></span><br><span class="line">     <span class="keyword">while</span> ((c = fgetc(fp)) != EOF) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, c);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 关闭文件</span></span><br><span class="line">     fclose(fp);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>此程序首先向文件test.txt中写入了从’A’到’Z’的所有大写字母，然后将文件指针重新定位到文件开头，接着用fgetc从文件中读取并打印出所有字符。</p><ol><li><p>编写一个程序，使用fgetc和fputc复制一个文件的内容到另一个文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *sourceFile, *destinationFile;  <span class="comment">// 定义两个文件指针</span></span><br><span class="line">    <span class="type">char</span> ch;                            <span class="comment">// 用于存储读取的字符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开源文件，以只读模式（&quot;r&quot;）</span></span><br><span class="line">    sourceFile = fopen(<span class="string">&quot;source.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sourceFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开源文件。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 文件打开失败，退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建或打开目标文件，以写入模式（&quot;w&quot;）</span></span><br><span class="line">    destinationFile = fopen(<span class="string">&quot;destination.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (destinationFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法创建或打开目标文件。\n&quot;</span>);</span><br><span class="line">        fclose(sourceFile);  <span class="comment">// 关闭源文件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 文件打开失败，退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐个字符读取并写入</span></span><br><span class="line">    <span class="keyword">while</span> ((ch = fgetc(sourceFile)) != EOF) &#123;  <span class="comment">// EOF是文件结束标志</span></span><br><span class="line">        fputc(ch, destinationFile);  <span class="comment">// 将读取的字符写入目标文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(sourceFile);</span><br><span class="line">    fclose(destinationFile);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件复制完成。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写一个程序，使用fgetc读取一个文本文件，并统计其中的字符数量。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3-使用-fgets-和-fputs-进行行读写"><a href="#2-3-使用-fgets-和-fputs-进行行读写" class="headerlink" title="2.3 使用 fgets 和 fputs 进行行读写"></a>2.3 使用 fgets 和 fputs 进行行读写</h3><p>fgets 和 fputs 是C语言中用于处理字符串的文件读写函数，它们分别用于从文件中读取一行字符串和向文件中写入一行字符串。</p><h5 id="fgets-函数"><a href="#fgets-函数" class="headerlink" title="fgets 函数"></a>fgets 函数</h5><ul><li><strong>头文件</strong>：stdio.h</li><li><strong>函数原型</strong>：char <em>fgets(char</em> str, int n, FILE *stream);</li><li><strong>函数功能</strong>：从参数stream所指的文件中读取一行字符串（包括’\n’）到str所指的字符数组，最多读取n-1个字符（最后一个字符会被自动赋值为’\0’）。</li></ul><h5 id="fgets-函数参数解释"><a href="#fgets-函数参数解释" class="headerlink" title="fgets 函数参数解释"></a>fgets 函数参数解释</h5><ul><li><strong>str</strong>：这是指向一个字符数组的指针，该数组将存储从文件中读取的字符串。</li><li><strong>n</strong>：这是要读取的最大字符数，包括空字符’\0’。换句话说，str指向的字符数组的大小应至少为n。</li><li><strong>stream</strong>：这是一个指向FILE类型的指针，它指定了要从中读取字符的文件。</li><li><strong>返回值</strong>：读取成功返回str，读到文件结束或发生错误返回NULL。</li></ul><h5 id="fputs-函数"><a href="#fputs-函数" class="headerlink" title="fputs 函数"></a>fputs 函数</h5><ul><li><strong>头文件</strong>：stdio.h</li><li><strong>函数原型</strong>：int fputs(const char <em>str, FILE</em> stream);</li><li><strong>函数功能</strong>：将参数str所指的字符串写入参数stream所指的文件中。</li></ul><h5 id="fputs-函数参数解释"><a href="#fputs-函数参数解释" class="headerlink" title="fputs 函数参数解释"></a>fputs 函数参数解释</h5><ul><li><strong>str</strong>：这是一个指针，指向要写入文件的字符串。字符串应以空字符’\0’结尾。</li><li><strong>stream</strong>：这是一个指向FILE类型的指针，它指定了要写入字符串的文件。</li><li><strong>返回值</strong>：写入成功返回非负值，发生错误返回EOF。</li></ul><h5 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     FILE *fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;文件打开失败\n&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用fputs向文件中写入字符串</span></span><br><span class="line">     <span class="type">char</span> str[] = <span class="string">&quot;Hello, World!\n&quot;</span>;</span><br><span class="line">     <span class="built_in">fputs</span>(str, fp);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 将文件指针重新定位到文件开头</span></span><br><span class="line">     rewind(fp);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用fgets从文件中读取字符串</span></span><br><span class="line">     <span class="type">char</span> buffer[<span class="number">50</span>];</span><br><span class="line">     <span class="keyword">while</span> (fgets(buffer, <span class="number">50</span>, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 关闭文件</span></span><br><span class="line">     fclose(fp);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-使用-fscanf-和-fprintf-进行格式化读写"><a href="#2-4-使用-fscanf-和-fprintf-进行格式化读写" class="headerlink" title="2.4 使用 fscanf 和 fprintf 进行格式化读写"></a>2.4 使用 fscanf 和 fprintf 进行格式化读写</h4><p>fscanf 和 fprintf 是C语言中用于格式化文件读写的函数，它们可以分别从文件中读取和向文件中写入各种类型的数据，包括字符、数字和字符串。</p><h5 id="fscanf-函数"><a href="#fscanf-函数" class="headerlink" title="fscanf 函数"></a>fscanf 函数</h5><ul><li><p><strong>头文件</strong>：stdio.h</p></li><li><p><strong>函数原型</strong>：int fscanf(FILE <em>stream, const char</em> format, …);</p></li><li><p><strong>函数功能</strong>：从参数stream所指的文件中按照参数format所指定的格式读取数据。</p></li><li><p>参数解析： </p></li><li><p><strong>stream</strong>：这是一个指向FILE类型的指针，它指定了要从中读取数据的文件。</p></li><li><p><strong>format</strong>：这是一个格式字符串，它包含一个或多个用于指定要读取的数据类型的格式说明符。</p></li><li><p>**…**：这是变长参数列表，每一个参数都应该是一个指向变量的指针，这些变量将被用于存储从文件中读取的数据。</p></li><li><p><strong>返回值</strong>：成功读取的项数，或者在读取失败或读到文件末尾时返回EOF。</p></li></ul><h5 id="fprintf-函数"><a href="#fprintf-函数" class="headerlink" title="fprintf 函数"></a>fprintf 函数</h5><ul><li><p><strong>头文件</strong>：stdio.h</p></li><li><p><strong>函数原型</strong>：int fprintf(FILE <em>stream, const char</em> format, …);</p></li><li><p><strong>函数功能</strong>：将参数format所指定的格式的数据写入参数stream所指的文件。</p></li><li><p>参数解析： </p></li><li><p><strong>stream</strong>：这是一个指向FILE类型的指针，它指定了要写入数据的文件。</p></li><li><p><strong>format</strong>：这是一个格式字符串，它包含一个或多个用于指定要写入的数据类型的格式说明符。</p></li><li><p>**…**：这是变长参数列表，每一个参数都应该是一个变量，这些变量的值将被写入文件。</p></li><li><p><strong>返回值</strong>：成功写入的项数，或者在写入失败时返回负值。</p></li></ul><h5 id="示例程序-1"><a href="#示例程序-1" class="headerlink" title="示例程序"></a>示例程序</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">     FILE * fp = fopen(<span class="string">&quot;hello.txt&quot;</span> , <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;文件打开失败!!!&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用fprintf向文件写入数据</span></span><br><span class="line">     <span class="type">int</span> age = <span class="number">30</span>;</span><br><span class="line">     <span class="type">float</span> height = <span class="number">180.5</span>;</span><br><span class="line">     <span class="built_in">fprintf</span>(fp , <span class="string">&quot;年龄 :%d\n身高 :%.2f\n&quot;</span>, age , height);    <span class="comment">//格式化输入字符到文件中</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//将文件重新定义到文件开头</span></span><br><span class="line">     rewind(fp);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用fscanf 从文件中读取格式化的数据</span></span><br><span class="line">     <span class="type">int</span> read_age = <span class="number">0</span>;</span><br><span class="line">     <span class="type">float</span> read_height = <span class="number">0</span>;</span><br><span class="line">     <span class="built_in">fscanf</span>(fp , <span class="string">&quot;年龄 :%d\n身高 :%f\n&quot;</span>, &amp;read_age , &amp;read_height);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;年龄 :%d\n身高 :%.2f\n&quot;</span>, read_age , read_height);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     fclose(fp);  <span class="comment">//关闭文件</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>*<strong>fprintf和fscanf格式和文件内部格式一定要相同，不要自己写，ctrl c v*</strong></p><h2 id="三、C语言中的文件定位函数"><a href="#三、C语言中的文件定位函数" class="headerlink" title="三、C语言中的文件定位函数"></a>三、C语言中的文件定位函数</h2><h3 id="3-1-文件定位函数的基本概念"><a href="#3-1-文件定位函数的基本概念" class="headerlink" title="3.1 文件定位函数的基本概念"></a>3.1 文件定位函数的基本概念</h3><p>文件定位函数用于操作文件指针，改变文件指针的当前位置。它们使得我们可以在文件中随机地访问数据，而不仅仅是按顺序读取或写入数据。这在处理大文件或需要随机访问的应用中尤其有用。<br>C语言中的文件定位函数主要包括以下几种：</p><ol><li>fseek 函数：移动文件指针到指定位置</li><li>ftell 函数：获取当前文件指针的位置</li><li>rewind 函数：将文件指针重置到文件的开头</li></ol><p>文件指针是一个指示当前正在读取或写入的文件位置的指针。每个文件在被打开时都会有一个文件指针与之关联，这个指针最初总是指向文件的开头。当我们读取或写入数据时，文件指针会随之移动，以指示下一个将要操作的位置。</p><h3 id="3-2-使用-fseek-进行文件定位"><a href="#3-2-使用-fseek-进行文件定位" class="headerlink" title="3.2 使用 fseek 进行文件定位"></a>3.2 使用 fseek 进行文件定位</h3><ul><li><p><strong>头文件</strong>：#include &lt;stdio.h&gt;</p></li><li><p><strong>函数原型</strong>：int fseek(FILE *stream, long offset, int whence);</p></li><li><p><strong>函数名称</strong>：fseek</p></li><li><p><strong>函数参数</strong>： </p></li><li><p>FILE *stream: 需要进行定位的文件指针。</p></li><li><p>long offset: 需要移动的字节数，从 whence 指定的位置算起。</p></li><li><p>int whence: 偏移的起始位置，可以有三个值： </p></li><li><p><strong>SEEK_SET: 文件开头</strong></p></li><li><p><strong>SEEK_CUR: 当前位置</strong></p></li><li><p><strong>SEEK_END: 文件结尾</strong></p></li><li><p><strong>函数返回值</strong>：如果成功，返回0。如果发生错误，返回非0值。</p></li><li><p><strong>示例程序</strong>：</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     FILE *fp;</span><br><span class="line"></span><br><span class="line">     fp = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">     <span class="built_in">fputs</span>(<span class="string">&quot;This is a test&quot;</span>, fp);</span><br><span class="line"></span><br><span class="line">     fseek(fp, <span class="number">7</span>, SEEK_SET);</span><br><span class="line">     <span class="built_in">fputs</span>(<span class="string">&quot; Hello World!&quot;</span>, fp);</span><br><span class="line">     fclose(fp);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>以上程序会创建一个新文件 file.txt，并在其中写入 “This is a test”。然后，程序将文件指针移动到文件的第7个字节（即 ‘a’ 后面的空格），并接着写入 “ Hello World!”。所以，最后的文件内容将是 “This is Hello World!”。</p><ul><li><p>练习： </p></li><li><p>创建一个文件，并写入一些文本。</p></li><li><p>使用 fseek 函数将文件指针移动到文件中的某个位置。</p></li><li><p>在该位置写入一些文本。</p></li><li><p>关闭文件，并查看最后的文件内容。</p></li></ul><h3 id="3-3-使用-ftell-获取当前位置"><a href="#3-3-使用-ftell-获取当前位置" class="headerlink" title="3.3 使用 ftell 获取当前位置"></a>3.3 使用 ftell 获取当前位置</h3><p>ftell 是一个标准库函数，它返回参数指定的文件流的当前文件位置指示器的位置。该函数是非常有用的，尤其是当你需要在文件中进行随机访问时。<br><strong>头文件</strong>：需要包含头文件 #include &lt;stdio.h&gt;<br><strong>函数原型</strong>：long ftell(FILE *stream);<br><strong>函数名</strong>：ftell<br><strong>函数参数</strong>：FILE *stream，指向FILE对象的指针，该FILE对象指定了一个输入流。<br><strong>函数返回值</strong>：如果成功，该函数返回当前文件位置指示器的位置，否则返回-1并设置全局变量 errno。<br><strong>示例程序</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     FILE *fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Open file failed!\n&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 移动文件位置指示器到文件中间</span></span><br><span class="line">     fseek(fp, <span class="number">5</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取当前文件位置</span></span><br><span class="line">     <span class="type">long</span> pos = ftell(fp);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Current file position: %ld\n&quot;</span>, pos);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 关闭文件</span></span><br><span class="line">     fclose(fp);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先打开一个文件，并使用 fseek 函数将文件位置指示器移到文件的中间。然后，我们使用 ftell 函数获取当前的文件位置，并打印出来。最后，我们关闭文件。<br><strong>练习</strong>：尝试修改示例程序，让文件位置指示器移动到文件的不同位置，然后使用 ftell 函数获取并打印当前的文件位置。</p><h3 id="3-4-使用-回到文件首部"><a href="#3-4-使用-回到文件首部" class="headerlink" title="3.4 使用 回到文件首部"></a>3.4 使用 回到文件首部</h3><p>rewind 是一个标准库函数，它将文件位置指示器移回参数指定的文件流的开始位置，同时清除和流有关的错误和结束文件状态。<br><strong>头文件</strong>：需要包含头文件 #include &lt;stdio.h&gt;<br><strong>函数原型</strong>：void rewind(FILE *stream);<br><strong>函数名</strong>：rewind<br><strong>函数参数</strong>：FILE *stream，指向FILE对象的指针，该FILE对象指定了一个输入流。<br><strong>函数返回值</strong>：无。<br><strong>示例程序</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     FILE *fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Open file failed!\n&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 写入一些数据到文件</span></span><br><span class="line">     <span class="built_in">fputs</span>(<span class="string">&quot;Hello, world!&quot;</span>, fp);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用rewind将文件位置指示器重置到文件开始</span></span><br><span class="line">     rewind(fp);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 读取并打印文件中的数据</span></span><br><span class="line">     <span class="type">char</span> buffer[<span class="number">50</span>];</span><br><span class="line">     fgets(buffer, <span class="number">50</span>, fp);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 关闭文件</span></span><br><span class="line">     fclose(fp);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先打开一个文件并写入一些数据。然后我们使用 rewind 函数将文件位置指示器重置到文件的开始。接着，我们读取并打印出文件中的数据。最后，我们关闭文件。<br><strong>练习</strong>：尝试修改示例程序，使用 fseek 函数将文件位置指示器移动到文件的不同位置，然后使用 rewind 函数重置文件位置指示器，并使用 fgets 函数读取并打印出文件中的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Open file failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入一些数据到文件</span></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;Hello, world!\nThis is a test file.\n&quot;</span>, fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用rewind将文件位置指示器重置到文件开始</span></span><br><span class="line">    rewind(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取并打印文件中的数据</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">50</span>];</span><br><span class="line">    fgets(buffer, <span class="number">50</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First read: %s&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用fseek将文件位置指示器移动到文件的特定位置</span></span><br><span class="line">    <span class="comment">// 移动到文件开头后50个字节的位置</span></span><br><span class="line">    fseek(fp, <span class="number">50</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次读取并打印文件中的数据</span></span><br><span class="line">    fgets(buffer, <span class="number">50</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nSecond read: %s&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、C语言中的文件实战"><a href="#四、C语言中的文件实战" class="headerlink" title="四、C语言中的文件实战"></a>四、C语言中的文件实战</h2><h3 id="4-1-实战项目介绍"><a href="#4-1-实战项目介绍" class="headerlink" title="4.1 实战项目介绍"></a>4.1 实战项目介绍</h3><h3 id="4-2-代码实现"><a href="#4-2-代码实现" class="headerlink" title="4.2 代码实现"></a>4.2 代码实现</h3><h3 id="4-3-代码测试和问题解决"><a href="#4-3-代码测试和问题解决" class="headerlink" title="4.3 代码测试和问题解决"></a>4.3 代码测试和问题解决</h3><h2 id="五、C语言中的预处理器指令"><a href="#五、C语言中的预处理器指令" class="headerlink" title="五、C语言中的预处理器指令"></a>五、C语言中的预处理器指令</h2><p>C 语言的预处理器指令是在编译器开始编译程序代码之前由预处理器执行的一些指令。以下是一些常见的预处理器指令：</p><ol><li>#include - 用于包含头文件。例如： #include &lt;stdio.h&gt;</li></ol><p><strong>include</strong><br>include &lt;&gt; : 调用系统库内的.h文件<br>include “” : 调用本地文件的.h文件， 如果没有则查找系统库内的文件</p><ol><li>#define - 用于定义宏。例如： #define PI 3.14159</li></ol><p>define 宏定义 ： 无脑替换<br>定义常量<br>定义函数</p><ol><li>#undef - 用于取消已定义的宏。例如： #undef PI</li><li>#if, #elif, #else, #endif - 用于条件编译。例如：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(WIN32)</span></span><br><span class="line"><span class="comment">// Windows 平台的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(LINUX)</span></span><br><span class="line"><span class="comment">// Linux 平台的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// 其他平台的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><ol><li>#ifdef 和 #ifndef - 用于检查宏是否已定义或未定义。例如：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="comment">// 调试模式下的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>注意，预处理器指令不是C语言的一部分，它们是由C预处理器处理的，而不是C编译器。预处理器指令通常不遵循C语言的语法规则，而是遵循自己的规则集。</p><h2 id="六、C语言中的模块化编程"><a href="#六、C语言中的模块化编程" class="headerlink" title="六、C语言中的模块化编程"></a>六、C语言中的模块化编程</h2><h2 id="七、C语言中的宏函数和内联函数"><a href="#七、C语言中的宏函数和内联函数" class="headerlink" title="七、C语言中的宏函数和内联函数"></a>七、C语言中的宏函数和内联函数</h2><p>在C语言中，宏是由预处理器（preprocessor）处理的一种机制，可以用来为代码创建别名或者执行简单的代码生成任务。宏可以分为对象宏和函数宏两种。</p><h3 id="1-对象宏（Object-Macros）"><a href="#1-对象宏（Object-Macros）" class="headerlink" title="1. 对象宏（Object Macros）"></a>1. 对象宏（Object Macros）</h3><p>对象宏用于为某个值或表达式定义一个名字。它们通常是这样定义的：<br>#define PI 3.14159<br>在这里，PI 是一个宏，它被定义为3.14159。</p><h3 id="2-函数宏（Function-Macros）"><a href="#2-函数宏（Function-Macros）" class="headerlink" title="2. 函数宏（Function Macros）"></a>2. 函数宏（Function Macros）</h3><p>函数宏类似于函数，但它们是在预处理阶段展开的，而不是在运行时被调用。函数宏是这样定义的：<br>#define SQUARE(x) ((x) * (x))<br>在这里，SQUARE是一个宏，它接受一个参数x，并返回x的平方。注意，参数被括在括号里，以避免由于运算符优先级引起的问题。</p><h3 id="3-宏函数的使用注意事项："><a href="#3-宏函数的使用注意事项：" class="headerlink" title="3. 宏函数的使用注意事项："></a>3. 宏函数的使用注意事项：</h3><ol><li><strong>括号的使用</strong>：为了避免优先级的问题，参数和整个宏都应该用括号括起来。</li><li><strong>副作用</strong>：由于宏是在预处理阶段展开的，所以如果宏的参数有副作用（例如，它是一个具有副作用的表达式），那么这个副作用可能会发生多次。</li><li><strong>代码膨胀</strong>：使用宏可以导致代码膨胀，因为宏每次被调用时都会被其定义所替换。</li><li><strong>调试困难</strong>：使用宏可以使代码更难调试，因为编译器在编译代码之前会先展开宏，这使得源代码和编译器看到的代码之间存在差异。</li></ol><h3 id="4-一个例子："><a href="#4-一个例子：" class="headerlink" title="4. 一个例子："></a>4. 一个例子：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">double</span> radius = <span class="number">2.0</span>;</span><br><span class="line">     <span class="type">double</span> area = PI * SQUARE(radius);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Area: %f\n&quot;</span>, area);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了两个宏：PI 和 SQUARE，并使用它们来计算一个圆的面积。</p><p>内联函数是一种特殊类型的函数，它的目的是为了减少函数调用的开销。当你将一个函数声明为内联时，编译器会尝试将该函数的代码嵌入到每一个调用点，就像宏一样。但是与宏不同，内联函数仍然是一个真正的函数，这意味着它遵循常规的类型检查和作用域规则。</p><h3 id="声明内联函数"><a href="#声明内联函数" class="headerlink" title="声明内联函数"></a>声明内联函数</h3><p>要声明一个内联函数，你可以使用 inline 关键字，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特点和注意事项"><a href="#特点和注意事项" class="headerlink" title="特点和注意事项"></a>特点和注意事项</h3><ol><li><strong>类型检查</strong>：内联函数与普通函数一样，进行类型检查，而宏不进行类型检查。</li><li><strong>编译器决定</strong>：即使你将一个函数声明为内联，编译器也可能决定不内联它，特别是如果函数体很大或者很复杂。</li><li><strong>代码膨胀</strong>：与宏一样，内联函数也可能导致代码膨胀，因为它们的代码可以被插入到多个调用点。</li><li><strong>调用开销减少</strong>：通过内联一个函数，你可以减少函数调用的开销，这可能会使你的程序运行得更快，但是这也可能增加你的程序的大小。</li><li><strong>多重定义</strong>：在多个源文件中包含相同的内联函数定义是允许的，但所有的定义必须是完全相同的。</li></ol><h3 id="内联函数的例子："><a href="#内联函数的例子：" class="headerlink" title="内联函数的例子："></a>内联函数的例子：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> x * x;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Square of %d is %d\n&quot;</span>, a, square(a));</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个内联函数 square，用于计算一个数的平方，并在 main 函数中调用它。注意，我们使用 inline 关键字来指示编译器我们想要将这个函数作为内联函数。</p><h1 id="第八章-高级C语言特性"><a href="#第八章-高级C语言特性" class="headerlink" title="第八章 高级C语言特性"></a><strong>第八章 高级C语言特性</strong></h1><p>@[toc]<strong>目标</strong></p><ul><li>1、C语言中的动态内存分配</li><li>2、C语言中的可变参数函数</li><li>3、C语言中的递归函数</li></ul><h2 id="一、C语言中的动态内存分配"><a href="#一、C语言中的动态内存分配" class="headerlink" title="一、C语言中的动态内存分配"></a>一、C语言中的动态内存分配</h2><h3 id="1-内存管理"><a href="#1-内存管理" class="headerlink" title="1. 内存管理"></a>1. 内存管理</h3><p>内存的使用是程序设计中需要考虑的重要因素，尤其是在嵌入式系统中，对于内存资源是有限的。<br>在C语言中，内存通常分为以下几个区域：</p><ul><li><p><strong>代码区（Text Segment）</strong>：该区域存放程序的代码（可执行指令），它是只读的，以防止程序在运行时自我修改。</p></li><li><p><strong>数据区</strong>：又可以细分为以下几部分： </p></li><li><p><strong>全局变量与静态变量区</strong>：此区域用于存放全局变量和静态变量。这些变量的内存是在程序启动时分配的，并在程序结束时释放。</p></li><li><p><strong>常量区</strong>：存放如字符串常量的区域。</p></li><li><p><strong>堆区（Heap）</strong>：堆是用于动态内存分配的区域，使用malloc，calloc或realloc函数分配内存，并使用free函数释放内存。动态内存分配提供了灵活性，但也增加了内存泄漏和其他问题的可能性。</p></li><li><p><strong>栈区（Stack）</strong>：栈用于存放局部变量和函数调用的信息。它是系统自管理的，每当进入一个函数时，就会为该函数分配一块新的栈空间，函数返回时，该块栈空间被释放。虽然栈的使用很高效，但空间有限 ，在Linux中只有8m 8192。</p></li></ul><p><img src="/./../../../images/1695190187057-9ac6f647-031b-4c12-98ce-852571ada6cf.jpeg" alt="img"><br><strong>示例与解释</strong><br>例如，当我们定义如下结构体时：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果学生的姓名超过我们所定义的空间，可能会发生内存溢出的问题。因此，在这种情况下使用动态内存分配更合理，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以动态分配内存来存储姓名，这样可以避免内存溢出的问题。在分配内存时，我们可以根据实际需要来分配内存空间，而不是预先分配固定大小的空间。<br>下面这段程序示例了不同类型的内存分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//  申请空间</span></span><br><span class="line"><span class="comment">//  void * 类型   泛指针   -&gt;  可以转换成其他类型的</span></span><br><span class="line"><span class="comment">// extern void *malloc (size_t __size)</span></span><br><span class="line"><span class="comment">//  size_t __size   要申请空间的大小</span></span><br><span class="line"><span class="comment">//  malloc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放空间</span></span><br><span class="line"><span class="comment">//  extern void free (void *__ptr) </span></span><br><span class="line"><span class="comment">//  free(__ptr)</span></span><br><span class="line"><span class="comment">//  __ptr   要释放的空间</span></span><br><span class="line"><span class="comment">// 强制类型转换 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zzh</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> * name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;zzh;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//申请空间</span></span><br><span class="line">    zzh * zzh1 = (zzh *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(zzh));</span><br><span class="line">    <span class="comment">//  zzh * zzh1   创建结构体指针</span></span><br><span class="line">    <span class="comment">//  (zzh *)malloc(sizeof(zzh));</span></span><br><span class="line">    <span class="comment">//      (zzh *)         类型转换</span></span><br><span class="line">    <span class="comment">//      malloc          申请空间的函数</span></span><br><span class="line">    <span class="comment">//      sizeof(zzh)     申请空间的大小</span></span><br><span class="line">    <span class="comment">//判断空间创建是否成功</span></span><br><span class="line">    <span class="comment">//      指针指向问题  :  指针只能指向同类型的变量地址</span></span><br><span class="line">    <span class="keyword">if</span> (zzh1 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zzh1-&gt;id = <span class="number">666</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , zzh1-&gt;id);</span><br><span class="line">    zzh1-&gt;name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span> , zzh1-&gt;name);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放空间</span></span><br><span class="line">    <span class="built_in">free</span>(zzh1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个名为stu的结构体，包含一个字符指针和一个整数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> *name;</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配内存以存储一个stu结构体实例</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">s</span> =</span> (<span class="keyword">struct</span> stu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> stu));</span><br><span class="line">    <span class="comment">// 检查内存分配是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为结构体中的name字段动态分配内存，可以容纳50个字符</span></span><br><span class="line">    s-&gt;name = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">50</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="comment">// 检查内存分配是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;name == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(s); <span class="comment">// 在退出前释放之前分配的内存</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置结构体中的id和name字段</span></span><br><span class="line">    s-&gt;id = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">snprintf</span>(s-&gt;name, <span class="number">50</span>, <span class="string">&quot;Student Name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印结构体中的id和name字段</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ID: %d, Name: %s\n&quot;</span>, s-&gt;id, s-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="built_in">free</span>(s-&gt;name);</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 程序成功结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在此程序中，我们创建了一个stu结构体并动态分配了内存来存储结构体及其name字段。在程序结束时，我们释放了分配的内存，避免了内存泄漏。</p><h3 id="2、动态内存的申请和释放"><a href="#2、动态内存的申请和释放" class="headerlink" title="2、动态内存的申请和释放"></a>2、动态内存的申请和释放</h3><p>malloc 和 free 是 C 语言中用于动态内存分配和释放的两个主要函数。下面我们将详细介绍这两个函数的用法和一些相关注意事项：</p><h4 id="1-malloc"><a href="#1-malloc" class="headerlink" title="1. malloc"></a>1. malloc</h4><p><strong>功能</strong>：malloc ，用于在堆上分配一块指定大小的内存。<br><strong>原型</strong>：<br>void* malloc(size_t size);<br><strong>参数</strong>：</p><ul><li>size：要分配的内存大小，以字节为单位。</li></ul><p><strong>返回值</strong>：</p><ul><li>如果分配成功，则返回指向分配的内存块的指针。</li><li>如果分配失败，则返回 NULL。</li></ul><p><strong>例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配一块足够存放一个整数的内存</span></span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed\n&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">*ptr = <span class="number">42</span>; <span class="comment">// 初始化分配的内存</span></span><br></pre></td></tr></table></figure><h4 id="2-free"><a href="#2-free" class="headerlink" title="2. free"></a>2. free</h4><p><strong>功能</strong>：释放由 malloc（或 calloc, realloc）分配的内存块。<br><strong>原型</strong>：<br>void free(void* ptr);<br><strong>参数</strong>：</p><ul><li>ptr：指向要释放的内存块的指针。</li></ul><p><strong>返回值</strong>：无<br><strong>例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed\n&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">*ptr = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(ptr); <span class="comment">// 释放分配的内存</span></span><br><span class="line">ptr = <span class="literal">NULL</span>; <span class="comment">// 为了避免悬挂指针，将 ptr 设置为 NULL</span></span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li><strong>内存泄漏</strong>：如果你分配了内存但未释放它，就会发生内存泄漏。为了避免内存泄漏，你应该确保每次调用 malloc 后，最终都调用 free 来释放内存。</li><li><strong>悬挂指针</strong>：在释放内存后，应将指针设置为 NULL 以避免产生悬挂指针（指针仍然指向已释放的内存区域）。</li><li><strong>双重释放</strong>：避免对同一内存块进行多次释放，因为这将导致未定义的行为。</li><li><strong>内存初始化</strong>：malloc 分配的内存块不会被初始化，它可能包含垃圾数据。在使用前，你应该自己初始化这块内存。</li></ol><p>通过适当使用 malloc 和 free，你可以更灵活地管理程序中的内存，但也要注意避免相关的内存管理问题。</p><h3 id="3、堆和栈的区别"><a href="#3、堆和栈的区别" class="headerlink" title="3、堆和栈的区别"></a>3、堆和栈的区别</h3><p>堆（Heap）和栈（Stack）是两种不同的内存分配机制，它们在程序中扮演不同的角色。以下是它们之间的一些主要区别：<br><strong>堆 ：</strong> 程序员手动申请 ， 手动释放<br><strong>栈 ：</strong> 系统自动申请，自动释放 (局部变量）</p><h4 id="1-内存管理-1"><a href="#1-内存管理-1" class="headerlink" title="1. 内存管理"></a>1. <strong>内存管理</strong></h4><ul><li><p><strong>堆（Heap）</strong></p></li><li><p>堆是一个由操作系统管理的内存区域，主要用于<strong>动态内存分配</strong>。在C语言中，你可以使用malloc(), calloc(), realloc()等函数来在堆上分配内存，<strong>并使用free()来释放内存。</strong></p></li><li><p>堆内存的分配和释放由程序员控制，容易产生内存泄漏（memory leaks）和悬挂指针（dangling pointers）等问题，如果不妥善管理。</p></li><li><p><strong>栈（Stack）</strong></p></li><li><p>栈是一个由编译器自动管理的内存区域，用于存储局部变量、函数参数和返回地址等。</p></li><li><p>栈内存的分配和释放是自动的，由编译器在函数调用和返回时进行。</p></li></ul><h4 id="2-内存分配速度"><a href="#2-内存分配速度" class="headerlink" title="2. 内存分配速度"></a>2. <strong>内存分配速度</strong></h4><ul><li><p><strong>堆（Heap）</strong></p></li><li><p>动态内存分配和释放通常比栈上的分配和释放要慢，因为它涉及到更复杂的内存管理算法和可能的系统调用。</p></li><li><p><strong>栈（Stack）</strong></p></li><li><p>栈上的内存分配和释放速度非常快，因为它仅涉及到栈指针的移动。</p></li></ul><h4 id="3-内存大小"><a href="#3-内存大小" class="headerlink" title="3. 内存大小"></a>3. <strong>内存大小</strong></h4><ul><li><p><strong>堆（Heap）</strong></p></li><li><p>堆通常有很大的空间，可以用于存储大量数据。</p></li><li><p>在堆上分配大量内存可能会导致内存碎片化（memory fragmentation）。</p></li><li><p><strong>栈（Stack）</strong></p></li><li><p>栈的大小通常比堆小，因此适合存储小量的数据。</p></li><li><p>超出栈的大小限制（例如递归调用深度太深）可能会导致栈溢出（stack overflow）。</p></li></ul><h4 id="4-生命周期"><a href="#4-生命周期" class="headerlink" title="4. 生命周期"></a>4. <strong>生命周期</strong></h4><ul><li><p><strong>堆（Heap）</strong></p></li><li><p>分配在堆上的内存的生命周期由程序员控制，可以跨越多个函数调用。</p></li><li><p><strong>栈（Stack）</strong></p></li><li><p>栈上的内存有限制的生命周期，通常与它们所在的函数调用的生命周期相同。</p></li></ul><h4 id="5-可见性"><a href="#5-可见性" class="headerlink" title="5. 可见性"></a>5. <strong>可见性</strong></h4><ul><li><p><strong>堆（Heap）</strong></p></li><li><p>堆上分配的内存可以被程序中的任何函数访问，只要你有指向该内存的有效指针。</p></li><li><p><strong>栈（Stack）</strong></p></li><li><p>栈上的内存（如局部变量）仅在其声明的函数内部可见。</p></li></ul><p>希望这有助于你理解堆和栈的区别！如果你有任何其他问题或需要更多的解释，请随时问。</p><h2 id="二、C语言中的可变参数函数"><a href="#二、C语言中的可变参数函数" class="headerlink" title="二、C语言中的可变参数函数"></a>二、C语言中的可变参数函数</h2><p>在C语言中，可变参数函数是一种可以接受可变数量的参数的函数。要创建可变参数函数，您需要包含头文件 &lt;stdarg.h&gt;，然后使用一组宏来访问这些参数。下面是一个简单的步骤和示例说明如何创建和使用可变参数函数：</p><h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol><li><strong>包含头文件</strong>：&lt;stdarg.h&gt;是包含可变参数宏的头文件，您需要在程序中包含它。 #include &lt;stdarg.h&gt;</li><li><strong>定义函数</strong>：在函数定义中，至少应有一个已命名的参数，后跟省略号（…），表示函数可以接收可变数量的参数。 void my_function(int num, …);</li><li><strong>声明va_list</strong>：在函数内部，使用va_list类型的变量来存储可变参数的列表。</li><li><strong>初始化va_list</strong>：使用va_start宏初始化va_list变量。</li><li><strong>访问可变参数</strong>：使用va_arg宏来访问可变参数列表中的每个参数。</li><li><strong>清理va_list</strong>：使用va_end宏来清理va_list变量。</li></ol><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_function</span><span class="params">(<span class="type">int</span> num, ...)</span> &#123;</span><br><span class="line">     va_list args;</span><br><span class="line">     va_start(args, num);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">         <span class="type">int</span> value = va_arg(args, <span class="type">int</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Argument %d: %d\n&quot;</span>, i+<span class="number">1</span>, value);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     va_end(args);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     my_function(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，my_function是一个可变参数函数，它接受一个整数参数num，表示将传递多少个可变参数，然后是实际的可变参数。它使用va_list和相关的宏来访问和处理这些参数。</p><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Argument 1: 1</span><br><span class="line">Argument 2: 2</span><br><span class="line">Argument 3: 3</span><br></pre></td></tr></table></figure><p>这是创建和使用可变参数函数的基本方式。您可以根据需要修改和扩展这个示例，以适应更复杂的情况和不同类型的参数。</p><h2 id="三、C语言中的递归函数"><a href="#三、C语言中的递归函数" class="headerlink" title="三、C语言中的递归函数"></a>三、C语言中的递归函数</h2><p>在C语言中，递归是一个函数直接或间接地调用自身的过程。递归函数是解决分治问题的有力工具，但是必须有一个明确的基本情况或停止条件，以避免无限递归。下面是一个递归函数的基本结构和一个简单的示例（计算阶乘）：</p><h3 id="递归函数的基本结构："><a href="#递归函数的基本结构：" class="headerlink" title="递归函数的基本结构："></a>递归函数的基本结构：</h3><ol><li><strong>基本情况</strong>：这是递归结束的条件，避免无限递归。</li><li><strong>递归步骤</strong>：这是一个或多个递归调用，通过逐步减小问题的规模来解决原始问题。</li></ol><h3 id="示例：计算阶乘"><a href="#示例：计算阶乘" class="headerlink" title="示例：计算阶乘"></a>示例：计算阶乘</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">     <span class="comment">// 基本情况</span></span><br><span class="line">     <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 递归步骤</span></span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> number = <span class="number">5</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;The factorial of %d is: %d\n&quot;</span>, number, factorial(number));</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ● 基本情况：当n等于0时，函数返回1，因为0的阶乘定义为1。</span></span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ● 递归步骤：否则，函数调用自身，参数为n-1，并将返回值与n相乘。</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> num * fun(num - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  压栈</span></span><br><span class="line"><span class="comment">//  fun -&gt;   num = 5</span></span><br><span class="line"><span class="comment">//      fun -&gt; num = 4</span></span><br><span class="line"><span class="comment">//          fun -&gt; num = 3</span></span><br><span class="line"><span class="comment">//              fun -&gt; num = 2</span></span><br><span class="line"><span class="comment">//                  fun -&gt; num = 1</span></span><br><span class="line"><span class="comment">//                      fun -&gt; num = 0  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  出栈</span></span><br><span class="line"><span class="comment">//                      fun -&gt; num = 1  fun(num - 1) -&gt;1    num * 1;    1</span></span><br><span class="line"><span class="comment">//                  fun -&gt; num = 2  fun(num - 1) -&gt;1    num * 1;        2</span></span><br><span class="line"><span class="comment">//               fun -&gt; num = 3  fun(num - 1) -&gt;1    num * 1;           6</span></span><br><span class="line"><span class="comment">//            fun -&gt; num = 4  fun(num - 1) -&gt;1    num * 1;              24</span></span><br><span class="line"><span class="comment">//          fun -&gt; num = 5  fun(num - 1) -&gt;1    num * 1;                120</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d 的阶乘是%d\n&quot;</span> , num , fun(num));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//   压栈</span></span><br></pre></td></tr></table></figure><p>在这个示例中：</p><ul><li><strong>基本情况</strong>：当n等于0时，函数返回1，因为0的阶乘定义为1。</li><li><strong>递归步骤</strong>：否则，函数调用自身，参数为n-1，并将返回值与n相乘。</li></ul><p>递归函数的调用栈会增长到它达到基本情况并开始返回。在上述示例中，调用栈将如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">factorial(<span class="number">5</span>)</span><br><span class="line">   → factorial(<span class="number">4</span>)</span><br><span class="line">     → factorial(<span class="number">3</span>)</span><br><span class="line">       → factorial(<span class="number">2</span>)</span><br><span class="line">         → factorial(<span class="number">1</span>)</span><br><span class="line">           → factorial(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>然后它开始返回并计算结果。<br>注意，<strong>递归函数要小心设计，以避免无限递归和栈溢出，还应注意可能的高时间和空间复杂度。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 函数 </tag>
            
            <tag> 指针 </tag>
            
            <tag> 结构体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2023/08/06/test/%E5%8D%9A%E5%AE%A2/2024-08-06-%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/08/06/test/%E5%8D%9A%E5%AE%A2/2024-08-06-%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="测试测试"><a href="#测试测试" class="headerlink" title="测试测试"></a>测试测试</h2>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派配置使用教程</title>
      <link href="/2022/05/05/test/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2022/05/05/test/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="树莓派配置使用教程-HQ"><a href="#树莓派配置使用教程-HQ" class="headerlink" title="树莓派配置使用教程 - HQ"></a>树莓派配置使用教程 - HQ</h1><p>[TOC]</p><hr><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><a href="http://mp.weixin.qq.com/mp/homepage?__biz=MzkzMDE4MDM2NQ==&hid=2&sn=9f206e6f23e14e08383bab0cdd812062&scene=18#wechat_redirect">树莓派使用文章汇总 - 编程那些年 - 已摘录</a></li><li><a href="http://mp.weixin.qq.com/mp/homepage?__biz=MzkzMDE4MDM2NQ==&hid=3&sn=a29994435d8945a531f14c5be3b4f801&scene=18#wechat_redirect">Linux基础文章汇总 - 编程那些年 - 已摘录</a></li><li><a href="https://blog.csdn.net/weixin_45911959/article/details/122709090">超简单教你在树莓派上安装opencv(一) - 未摘录</a></li><li><a href="https://blog.csdn.net/weixin_45911959/article/details/124157416">超简单教你在树莓派上安装opencv(一) - 未摘录</a></li></ul><hr><h2 id="【树莓派】基本使用-基本操作"><a href="#【树莓派】基本使用-基本操作" class="headerlink" title="【树莓派】基本使用 &amp; 基本操作"></a>【树莓派】基本使用 &amp; 基本操作</h2><p>打开树莓派Linux系统可视化配置界面  <code>sudo raspi-config</code></p><blockquote><img src="./../../../images/image-20220505212046292-1748585431990-15.png" alt="image-20220505212046292" style="zoom:50%;"></blockquote><h2 id="【树莓派】静态IP的正确配置方式-wifi"><a href="#【树莓派】静态IP的正确配置方式-wifi" class="headerlink" title="【树莓派】静态IP的正确配置方式(wifi)"></a>【树莓派】静态IP的正确配置方式(wifi)</h2><p>WiFi模式下使用以下几种方法，可以快速配置静态IP， 不用担心因为路由器DHCP的租约到期导致IP被重新分配的问题，并且会保留配置好的网络环境对应的静态IP，不用每次都来修改配置，非常方便。接下来就讲下几种配置方法。</p><h3 id="方法一：直接修改配置文件"><a href="#方法一：直接修改配置文件" class="headerlink" title="方法一：直接修改配置文件"></a>方法一：直接修改配置文件</h3><p>1、刷完机后首先根据需要，参考公众号文章《<strong>【树莓派】配置串口登录</strong>》<strong>、《【树莓派】系统启用SSH服务》</strong>选择性的做相应的配置<br>2、根据《<strong>【树莓派】配置无线网络(wifi)<strong>》文章连接WIFI，并确认动态获取的IP，通过</strong>ifconfig</strong>命令查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ ifconfig wlan0</span><br><span class="line">wlan0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.120  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        inet6 fe80::23ec:e056:3e62:59f1  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether b8:27:eb:5d:03:fe  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 303  bytes 39869 (38.9 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 26  bytes 3706 (3.6 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>3、并通过<strong>route</strong>命令查看默认路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.1.1     0.0.0.0         UG    303    0        0 wlan0</span><br><span class="line">192.168.1.0     0.0.0.0         255.255.255.0   U     303    0        0 wlan0</span><br><span class="line">pi@raspberrypi:~ $ </span><br></pre></td></tr></table></figure><p>4、通过<strong>vim.tiny</strong>或者nano命令修改**&#x2F;etc&#x2F;dhcpcd.conf**文件，将动态获取的IP以静态配置的方式追加到该文件末尾：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ vim.tiny  /etc/dhcpcd.conf# fallback to static profile on eth0</span><br><span class="line">#interface eth0</span><br><span class="line">#fallback static_eth0</span><br><span class="line">interface wlan0</span><br><span class="line">static ip_address=192.168.1.120/24</span><br><span class="line">static routers=192.168.1.1</span><br><span class="line">static domain_name_servers=192.168.1.1</span><br></pre></td></tr></table></figure><p>这其中 “interface wlan0”表示无线网卡，如果要配置有线网卡为静态IP，则改为”interface eth0”即可<br>“static ip_address&#x3D;192.168.1.120&#x2F;24”表示静态IP设置为上面获取的”192.168.1.120”， 24表示子网掩码为”255.255.255.0 “</p><p>“static routers&#x3D;192.168.1.1”表示默认路由为上面的”192.168.1.1”</p><p>“static domain_name_servers&#x3D;192.168.1.1”表示DNS为”192.168.1.1”,当然不同的网络这里会有差异，可在电脑上通过ipconfig命令查看确认的DNS</p><p>最后重启树莓派即可。</p><h3 id="方法二：通过网络设置界面"><a href="#方法二：通过网络设置界面" class="headerlink" title="方法二：通过网络设置界面"></a>方法二：通过网络设置界面</h3><p>1、刷完机后首先根据需要，参考公众号文章《<strong>【树莓派】配置串口登录</strong>》、《<strong>【树莓派】系统启用SSH服务</strong>》选择性的做相应的配置<br>2、根据《<strong>【树莓派】配置无线网络(wifi)<strong>》文章连接WIFI，并确认动态获取的IP，通过</strong>ifconfig</strong>命令查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ ifconfig wlan0</span><br><span class="line">wlan0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.120  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        inet6 fe80::23ec:e056:3e62:59f1  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether b8:27:eb:5d:03:fe  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 303  bytes 39869 (38.9 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 26  bytes 3706 (3.6 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>3、并通过<strong>route</strong>命令查看默认路由：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.1.1     0.0.0.0         UG    303    0        0 wlan0</span><br><span class="line">192.168.1.0     0.0.0.0         255.255.255.0   U     303    0        0 wlan0</span><br><span class="line">pi@raspberrypi:~ $ </span><br></pre></td></tr></table></figure><p>4、树莓派接上HDM显示器I重新开机或者通过VNC、RDP（<em>PS:远程登录要预先配置好响应服务</em>）等方式远程登录进树莓派，右键右上角的网络图标，选择**”Wireless &amp; Wired Network Settings”：**</p><blockquote><img src="./../../../images/64022-1748585431990-14.jpeg" alt="图片" style="zoom:67%;"></blockquote><p>5、弹出的**”Network Preferences”<strong>窗口，选择”<strong>Configure-&gt;Interface-&gt;wlan0”</strong>, 勾选</strong>“Automatically configure empty options”<strong>, 勾选</strong>“Disable IPv6”<strong>, 并根据上面动态获取到的IP和默认路由输入到对应的</strong>“IPV4 Address**”和**”Router”**栏中。并点击一次”Apply”，然后点击”Close”如下：</p><blockquote><img src="./../../../images/640-16516755057291-1748585431990-16.jpeg" alt="图片" style="zoom:67%;"></blockquote><p>如果保存成功的话，通过<strong>cat &#x2F;etc&#x2F;dhcpcd.conf</strong>可看到如下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># fallback to static profile on eth0</span><br><span class="line">#interface eth0</span><br><span class="line">#fallback static_eth0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface wlan0</span><br><span class="line">inform 192.168.1.120</span><br><span class="line">static routers=192.168.1.1</span><br><span class="line">noipv6 </span><br></pre></td></tr></table></figure><p>可以看到本质也是配置的dhcpcd.conf文件。</p><h3 id="方法三、骚操作-修改路由器"><a href="#方法三、骚操作-修改路由器" class="headerlink" title="方法三、骚操作 修改路由器"></a>方法三、骚操作 修改路由器</h3><p>1、刷完机后首先根据需要，参考公众号文章《<strong>【树莓派】配置串口登录</strong>》、《<strong>【树莓派】系统启用SSH服务</strong>》选择性的做相应的配置<br>2、根据《<strong>【树莓派】配置无线网络(wifi)<strong>》文章连接WIFI，并确认动态获取的IP<br>3、通过浏览器直接进入路由器web管理界面,找到IP和MAC绑定选项，查找到树莓派的IP，直接将其</strong>IP和MAC绑定</strong>即可*(不同的路由器配置的位置不太一样)*：</p><blockquote><img src="./../../../images/640-16516755057292-1748585431990-17.jpeg" alt="图片" style="zoom:67%;"></blockquote><h2 id="【树莓派】系统刷机教程"><a href="#【树莓派】系统刷机教程" class="headerlink" title="【树莓派】系统刷机教程"></a>【树莓派】系统刷机教程</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>树莓派（Raspberry Pi）是一款小型的专门为学习而设计的ARM开发板，支持Raspbian，Ubuntu Mate， Ubuntu Server等多种Linux操作系统。接下来就简单的讲解下如何烧录树莓派系统。</p><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><h5 id="准备一张8G以上存储大小的SD卡"><a href="#准备一张8G以上存储大小的SD卡" class="headerlink" title="准备一张8G以上存储大小的SD卡"></a>准备一张8G以上存储大小的SD卡</h5><h3 id="下载镜像及工具"><a href="#下载镜像及工具" class="headerlink" title="下载镜像及工具"></a>下载镜像及工具</h3><p>1、 进入Raspberry Pi官网(<a href="https://www.raspberrypi.org/)%EF%BC%8C%E4%B8%8B%E8%BD%BD%E6%89%80%E9%9C%80%E7%9A%84%E9%95%9C%E5%83%8F%EF%BC%8C%E6%9C%89%E4%B8%89%E4%B8%AA%E9%80%89%E9%A1%B9%E5%8F%AF%E9%80%89%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AF%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83+%E6%8E%A8%E8%8D%90%E8%BD%AF%E4%BB%B6%E3%80%81%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83%E3%80%81%E6%9C%80%E5%B0%8F%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%EF%BC%9A">https://www.raspberrypi.org/)，下载所需的镜像，有三个选项可选，分别是桌面环境+推荐软件、桌面环境、最小运行环境：</a></p><blockquote><img src="./../../../images/640-16516755401936-1748585431990-18.jpeg" alt="图片" style="zoom:67%;"></blockquote><p>或者下载NOOBS压缩包（方法三使用）</p><blockquote><img src="./../../../images/640-16516755401947-1748585431990-19.png" alt="图片" style="zoom:67%;"></blockquote><p><em>（PS：可在公众号回复”树莓派”获取”桌面环境版本”和NOOBS压缩包）</em></p><p>2、下载刻录镜像所需的工具，这里可选择”Win32DiskImager” 或者树莓派官方提供的”Raspberry Pi Imager”</p><p>Win32DiskImager下载地址如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1https://win32diskimager.download/</span><br></pre></td></tr></table></figure><p>Raspberry Pi Imager下载地址如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1https://www.raspberrypi.org/software/</span><br></pre></td></tr></table></figure><p>（注：也可直接在公众号回复”树莓派”获取刻录工具）</p><h3 id="烧录镜像"><a href="#烧录镜像" class="headerlink" title="烧录镜像"></a>烧录镜像</h3><p>  首先在电脑上插入TF卡，并采用以上几种刻录工具中的一种对下载好的img镜像进行刻录。</p><h4 id="1、采用Win32DiskImager刻录："><a href="#1、采用Win32DiskImager刻录：" class="headerlink" title="1、采用Win32DiskImager刻录："></a>1、采用Win32DiskImager刻录：</h4><p>  打开Win32DiskImager软件， 点击”文件”图标，选择要刻录的img系统镜像，并在”设备”处确认TF卡的正常分区号。然后点击写入即可开始刻录系统。</p><blockquote><img src="./../../../images/640-16516755401958-1748585431991-22.jpeg" alt="图片" style="zoom:67%;"></blockquote><p>等待烧录</p><blockquote><img src="./../../../images/640-16516755401959-1748585431990-20.png" alt="图片" style="zoom:67%;"></blockquote><p>当提示”写入成功”后，根据需要配置下<a href="http://mp.weixin.qq.com/s?__biz=MzkzMDE4MDM2NQ==&mid=2247483746&idx=1&sn=9c09f6a167f989eb3ad136c47c1f6149&chksm=c27f7d00f508f416ecc48f7e1f067200cd22fd5c498afb99e57e27ea24640d21f79dedd8c75f&scene=21#wechat_redirect">树莓派的串口</a>和<a href="http://mp.weixin.qq.com/s?__biz=MzkzMDE4MDM2NQ==&mid=2247483728&idx=1&sn=dc585685feab7f1b6b7f1c64961906ba&chksm=c27f7d32f508f42454bf01b04fdcaadacbc7fbeab58909664b2f1fd25f93914cc7b81df9d401&scene=21#wechat_redirect">SSH服务</a>后， 把TF拔下来插到树莓派上即可。</p><blockquote><img src="./../../../images/640-165167554019510-1748585431991-21.png" alt="图片" style="zoom:67%;"></blockquote><h4 id="2、采用Raspberry-Pi-Imager工具烧录"><a href="#2、采用Raspberry-Pi-Imager工具烧录" class="headerlink" title="2、采用Raspberry Pi Imager工具烧录"></a>2、采用Raspberry Pi Imager工具烧录</h4><p>打开Raspberry Pi Imager工具</p><blockquote><img src="./../../../images/640-165167554019511-1748585431991-23.png" alt="图片" style="zoom:67%;"></blockquote><p>点击”CHOOSE OS”按钮， 选择要在线安装的操作系统（受限于网络）或已经提前下载好的系统，</p><blockquote><img src="./../../../images/640-165167554019512-1748585431991-24.jpeg" alt="图片" style="zoom:67%;"></blockquote><blockquote><img src="./../../../images/640-165167554019513-1748585431991-25.png" alt="图片" style="zoom:67%;"></blockquote><p>点击”CHOOSE SD CARD READ”按钮 ,选择要写入的TF卡后</p><blockquote><img src="./../../../images/640-165167554019614-1748585431991-26.png" alt="图片" style="zoom:67%;"></blockquote><blockquote><img src="./../../../images/640-165167554019615-1748585431991-27.jpeg" alt="图片" style="zoom: 67%;"></blockquote><p>点击”WRITE”按钮，开始烧录</p><blockquote><img src="./../../../images/640-165167554019616-1748585431991-28.png" alt="图片" style="zoom: 67%;"></blockquote><blockquote><img src="./../../../images/640-165167554019617-1748585431991-30.jpeg" alt="图片" style="zoom:67%;"></blockquote><p>等待烧录完成后，根据需要配置下<a href="http://mp.weixin.qq.com/s?__biz=MzkzMDE4MDM2NQ==&mid=2247483746&idx=1&sn=9c09f6a167f989eb3ad136c47c1f6149&chksm=c27f7d00f508f416ecc48f7e1f067200cd22fd5c498afb99e57e27ea24640d21f79dedd8c75f&scene=21#wechat_redirect">树莓派的串口</a>和<a href="http://mp.weixin.qq.com/s?__biz=MzkzMDE4MDM2NQ==&mid=2247483728&idx=1&sn=dc585685feab7f1b6b7f1c64961906ba&chksm=c27f7d32f508f42454bf01b04fdcaadacbc7fbeab58909664b2f1fd25f93914cc7b81df9d401&scene=21#wechat_redirect">树莓派的SSH服务</a>等配置后， 把TF拔下来插到树莓派上即可。</p><h4 id="3、利用NOOBS文件刷机"><a href="#3、利用NOOBS文件刷机" class="headerlink" title="3、利用NOOBS文件刷机"></a>3、利用NOOBS文件刷机</h4><p>去Raspberry Pi官网下载NOOBS压缩包（PS：也可直接在公众号回复”树莓派”获取）<br>将SD卡格式化为FAT32格式<br>将下载好的NOOBS文件解压，并将NOOBS文件夹的全部内容拷贝到SD卡的根目录中</p><blockquote><img src="./../../../images/640-165167554019818-1748585431991-29.png" alt="图片" style="zoom:67%;"></blockquote><p> 将SD卡插入树莓派，并接上HDMI显示和键盘，上电开机机， NOOBS会自动将你的SD卡进行分区。<br> 然后会弹出系统安装窗口，你可以根据自己的喜好选择其一安装（不需要网络），这里我选择了Raspbian，并选择好所需的语言和键盘语言</p><blockquote><img src="./../../../images/640-165167554019819-1748585431991-31.jpeg" alt="图片" style="zoom:67%;"></blockquote><p>然后等待安装完成即可</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>如果在刷机过程中出现刷机失败，可利用”SD Card Formatter”软件对SD卡进行格式化后，再重新刷机。</p><p>以上工具均可在公众号回复“树莓派”获取网盘下载链接</p><h2 id="【树莓派】让你的SD卡快速扩容"><a href="#【树莓派】让你的SD卡快速扩容" class="headerlink" title="【树莓派】让你的SD卡快速扩容"></a>【树莓派】让你的SD卡快速扩容</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>在树莓派实际使用当中，我们会发现SD卡的存储并没有得到充分的利用，是否有办法让可用空间变的更大，毫无疑问肯定是有的，不然我就不在这里废话了。</p><h3 id="准备环境-1"><a href="#准备环境-1" class="headerlink" title="准备环境"></a>准备环境</h3><p>  <strong>设备：</strong>树莓派 3B<em>（其他型号也可以）</em><br>  <strong>SD卡容量：</strong>16G</p><h3 id="方案一：使用raspi-config扩容（推荐）"><a href="#方案一：使用raspi-config扩容（推荐）" class="headerlink" title="方案一：使用raspi-config扩容（推荐）"></a>方案一：使用raspi-config扩容（推荐）</h3><p>  首先输入**”df -h”**命令可以看到，当前root分区总共只用了3.1G，而可用空间仅剩288M，但实际我们的存储是16G的，所以可用空间理论上不应该这么小，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~$ df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/root       3.1G  2.7G  288M  91% /</span><br><span class="line">devtmpfs        310M     0  310M   0% /dev</span><br><span class="line">tmpfs           438M     0  438M   0% /dev/shm</span><br><span class="line">tmpfs           438M   17M  421M   4% /run</span><br><span class="line">tmpfs           5.0M  4.0K  5.0M   1% /run/lock</span><br><span class="line">tmpfs           438M     0  438M   0% /sys/fs/cgroup</span><br><span class="line">/dev/mmcblk0p1   43M   22M   21M  51% /boot</span><br><span class="line">tmpfs            88M     0   88M   0% /run/user/1000</span><br><span class="line">pi@raspberrypi:~$</span><br></pre></td></tr></table></figure><p>此时可以利用**”raspi-config”**对root分区进行扩容，输入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo raspi-config</span><br></pre></td></tr></table></figure><p>选择**”7 Advanced Options”**回车：</p><blockquote><img src="./../../../images/640-165167557649734-1748585431991-32.png" alt="图片" style="zoom:67%;"></blockquote><p>然后选择**”A1 Expand Filesystem Ensures that all of ….”**,回车：</p><blockquote><img src="./../../../images/640-165167557649835-1748585431991-33.png" alt="图片" style="zoom:67%;"></blockquote><p>询问是否修改root分区，直接回车：</p><blockquote><img src="./../../../images/640-165167557649836-1748585431991-35.png" alt="图片" style="zoom:67%;"></blockquote><p>到首页面，按**”Tab”<strong>键，选择</strong>“Finish”**，回车：</p><blockquote><img src="./../../../images/640-165167557649837-1748585431991-34.png" alt="图片" style="zoom:67%;"></blockquote><p>询问是否重启，选择重启：</p><blockquote><img src="./../../../images/640-165167557649838-1748585431991-36.png" alt="图片" style="zoom:67%;"></blockquote><p>重启完后，输入**”df -h”**,会发现root分区已经扩容成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/root        15G  2.9G   11G  22% /</span><br><span class="line">devtmpfs        433M     0  433M   0% /dev</span><br><span class="line">tmpfs           438M     0  438M   0% /dev/shm</span><br><span class="line">tmpfs           438M   12M  426M   3% /run</span><br><span class="line">tmpfs           5.0M  4.0K  5.0M   1% /run/lock</span><br><span class="line">tmpfs           438M     0  438M   0% /sys/fs/cgroup</span><br><span class="line">/dev/mmcblk0p1  253M   53M  200M  21% /boot</span><br><span class="line">tmpfs            88M     0   88M   0% /run/user/1000</span><br></pre></td></tr></table></figure><p>又可以愉快的玩耍了。</p><h3 id="方案二：利用fdisk和resize2fs扩容"><a href="#方案二：利用fdisk和resize2fs扩容" class="headerlink" title="方案二：利用fdisk和resize2fs扩容"></a>方案二：利用fdisk和resize2fs扩容</h3><p>  利用**”fdisk”<strong>和</strong>“resize2fs”<strong>命令确认mmcblk0p2节点的其实地址为：</strong>“532480”**（注：根据实际情况确认该地址，要输错了会导致分区出错，很重要！！！）,并对该分区重新创建：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ sudo  fdisk  /dev/mmcblk0</span><br><span class="line"></span><br><span class="line">Welcome to fdisk (util-linux 2.33.1).</span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line"></span><br><span class="line">Command (m for help): p #查看分区信息， /dev/mmcblk0p2 start地址很重要</span><br><span class="line">Disk /dev/mmcblk0: 14.6 GiB, 15681454080 bytes, 30627840 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0xea7d04d6</span><br><span class="line"></span><br><span class="line">Device         Boot  Start     End Sectors  Size Id Type</span><br><span class="line">/dev/mmcblk0p1        8192  532479  524288  256M  c W95 FAT32 (LBA)</span><br><span class="line">/dev/mmcblk0p2      532480 7397375 6864896  3.3G 83 Linux</span><br><span class="line"></span><br><span class="line">Command (m for help): d #删除mmcblk0p2分区</span><br><span class="line">Partition number (1,2, default 2): 2</span><br><span class="line"></span><br><span class="line">Partition 2 has been deleted.</span><br><span class="line"></span><br><span class="line">Command (m for help): n #新建分区</span><br><span class="line">Partition type</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended (container for logical partitions)</span><br><span class="line">Select (default p):</span><br><span class="line"></span><br><span class="line">Using default response p.</span><br><span class="line">Partition number (2-4, default 2): 2 #分区号选择2 即mmcblk0p2分区</span><br><span class="line">First sector (2048-30627839, default 2048): 532480  #刚才查看的mmcblk0p2起始地址</span><br><span class="line">Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (532480-30627839, default 30627839): #默认直接回车</span><br><span class="line"></span><br><span class="line">Created a new partition 2 of type &#x27;Linux&#x27; and of size 14.4 GiB.</span><br><span class="line">Partition #2 contains a ext4 signature.</span><br><span class="line"></span><br><span class="line">Do you want to remove the signature? [Y]es/[N]o: y</span><br><span class="line"></span><br><span class="line">The signature will be removed by a write command.</span><br><span class="line"></span><br><span class="line">Command (m for help): p #这里重新查看发现mmcblk0p2分区变大了</span><br><span class="line">Disk /dev/mmcblk0: 14.6 GiB, 15681454080 bytes, 30627840 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0xea7d04d6</span><br><span class="line"></span><br><span class="line">Device         Boot  Start      End  Sectors  Size Id Type</span><br><span class="line">/dev/mmcblk0p1        8192   532479   524288  256M  c W95 FAT32 (LBA)</span><br><span class="line">/dev/mmcblk0p2      532480 30627839 30095360 14.4G 83 Linux</span><br><span class="line"></span><br><span class="line">Filesystem/RAID signature on partition 2 will be wiped.</span><br><span class="line"></span><br><span class="line">Command (m for help): w #保存，如果输错了，按q不保存重新来</span><br><span class="line">The partition table has been altered.</span><br><span class="line">Syncing disks.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pi@raspberrypi:~ $ sudo resize2fs /dev/mmcblk0p2 #利用resize2fs调整文件系统实际大小</span><br><span class="line">resize2fs 1.44.5 (15-Dec-2018) </span><br><span class="line">Filesystem at /dev/mmcblk0p2 is mounted on /; on-line resizing required</span><br><span class="line">old_desc_blocks = 1, new_desc_blocks = 1</span><br><span class="line">The filesystem on /dev/mmcblk0p2 is now 3761920 (4k) blocks long.</span><br></pre></td></tr></table></figure><p>然后重启，也是可以愉快的玩耍的。</p><h3 id="交换分区大小"><a href="#交换分区大小" class="headerlink" title="交换分区大小"></a>交换分区大小</h3><p>虽然可用空间变大了，但我们在使用的实际当中会发现有些卡顿，这是因为树莓派默认的给的swap分区只要100M。</p><p><strong>关于交换分区的解释大致如下：</strong></p><p>  Swap分区是存储上一个特殊用途的分区或文件，是当系统内存不够用的时候，把物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放或交换出来的内容就会被临时保存到Swap分区中，等到程序需要时，再从Swap分区中恢复数据到内存中。</p><p><strong>修改方法如下：</strong></p><p>  通过修改**”&#x2F;etc&#x2F;dphys-swapfile”<strong>文件的</strong>“CONF_SWAPSIZE”*<em>字段达到扩大交换分区的目的（</em>以M为单位*）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ sudo vi /etc/dphys-swapfile #输入如下命令</span><br><span class="line"></span><br><span class="line"># /etc/dphys-swapfile - user settings for dphys-swapfile package</span><br><span class="line"># author Neil Franklin, last modification 2010.05.05</span><br><span class="line"># copyright ETH Zuerich Physics Departement</span><br><span class="line">#   use under either modified/non-advertising BSD or GPL license</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># this file is sourced with . so full normal sh syntax applies</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># the default settings are added as commented out CONF_*=* lines</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># where we want the swapfile to be, this is the default</span><br><span class="line">#CONF_SWAPFILE=/var/swap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># set size to absolute value, leaving empty (default) then uses computed value</span><br><span class="line">#   you most likely don&#x27;t want this, unless you have an special disk situation</span><br><span class="line">CONF_SWAPSIZE=2048 #将该字段的100改为2048</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># set size to computed value, this times RAM size, dynamically adapts,</span><br><span class="line">#   guarantees that there is enough swap without wasting disk space on excess</span><br><span class="line">#CONF_SWAPFACTOR=2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># restrict size (computed and absolute!) to maximally this limit</span><br><span class="line">#   can be set to empty for no limit, but beware of filled partitions!</span><br><span class="line">#   this is/was a (outdated?) 32bit kernel limit (in MBytes), do not overrun it</span><br><span class="line">#   but is also sensible on 64bit to prevent filling /var or even / partition</span><br><span class="line">#CONF_MAXSWAP=2048</span><br></pre></td></tr></table></figure><p>然后重启下服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ sudo /etc/init.d/dphys-swapfile restart</span><br><span class="line">[ ok ] Restarting dphys-swapfile (via systemctl): dphys-swapfile.service.</span><br><span class="line">pi@raspberrypi:~</span><br></pre></td></tr></table></figure><p>酱紫，我们就把Swap分区从100M调整到了2G，可通过**”free -m”**命令查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:            875         101         613          11         159         712</span><br><span class="line">Swap:          2047           0        2047  #这里就是交换的内容</span><br><span class="line">pi@raspberrypi:~ $</span><br></pre></td></tr></table></figure><h2 id="【树莓派】系统备份与还原"><a href="#【树莓派】系统备份与还原" class="headerlink" title="【树莓派】系统备份与还原"></a>【树莓派】系统备份与还原</h2><p>很多同学在开发树莓派的过程中会遇到因为操作失误导致系统无法正常启动或者偶然出现宕机的情况，此时如果没有备份，需要重刷系统是一件很崩溃的事情， 本文就讲解下如何简单的对Pi上的系统进行备份。</p><p><strong>方法一、利用Win32DiskImager工具备份</strong></p><p>​    首先下载Win32DiskImager， 下载地址如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://sourceforge.net/projects/win32diskimager/</span><br></pre></td></tr></table></figure><p>​     将SD卡接到windows主机上，打开Win32DiskImager工具，点击<strong>文件图标</strong>，输入选择要保存的路径，同时输入文件名称，然后选择<strong>“打开”</strong>，如下：</p><blockquote><img src="./../../../images/640-165167560614344-1748585431991-38.png" alt="图片" style="zoom:67%;"></blockquote><p>​      点击<strong>“读取”</strong>开始备份，耐心等待备份完成即可， 如下：</p><blockquote><img src="./../../../images/640-165167560614345-1748585431991-37.png" alt="图片" style="zoom:67%;"></blockquote><p>  正常整个img备份下来的大小和实际TF的大小一样（如TF卡实际可读写大小为14.6G，那么备份出来的大小就是14.6G）。下次如果TF卡无法正常启动，可利用Win32DiskImager将备份好的img再次写入即可。</p><p><strong>方法二、利用Linux dd命令主机备份</strong></p><p>  该方法要求：Linux主机可利用空间要大于SD卡的实际大小。 将SD卡接到Linux主机或者连接到Linux虚拟机后，用如下命令备份<em>（SD卡的实际设备节点可通过lsblk确认）</em>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:/$ lsblk</span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0   20G  0 disk </span><br><span class="line">└─sda1   8:1    0   20G  0 part /</span><br><span class="line">sdb      8:16   1 14.6G  0 disk </span><br><span class="line">├─sdb1   8:17   1  256M  0 part /media/linux/boot</span><br><span class="line">└─sdb2   8:18   1  3.3G  0 part /media/linux/rootfs</span><br><span class="line">:/$ sudo dd bs=4M if=/dev/sdb of=/mnt/hgfs/F/2021-01-02.img</span><br></pre></td></tr></table></figure><p>​    如果需要还原，则直接通过dd命令还原，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:/$ sudo dd bs=4M if=/mnt/hgfs/F/2021-01-02.img of=/dev/sdb</span><br></pre></td></tr></table></figure><p>  当然，由于dd出来的img会比较大，可以利用gzip等压缩工具对img进行压缩，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:/$ sudo dd bs=4M if=/dev/sdb | gzip &gt;/mnt/hgfs/F/2021-01-02.img.gz</span><br></pre></td></tr></table></figure><p>​    此后，如果需要进行还原，可利用如下命令实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:/$  gunzip --stdout /mnt/hgfs/F/2021-01-02.img.gz | sudo dd bs=4M of=/dev/sdb</span><br></pre></td></tr></table></figure><p><strong>方法三、利用dump 和 restore 备份工具</strong></p><p>   偷懒直接参考别人写好的脚步，首先从在Pi上下载相关脚步， github地址如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/nanhantianyi/rpi-backup</span><br></pre></td></tr></table></figure><p>​     然后在Pi上接入u盘，将其挂载在&#x2F;media目录， 并利用backup.sh脚本备份系统，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /media/linux</span><br><span class="line">sudo mount /dev/sdb1 /media/linux</span><br><span class="line">cd rpi-backup/</span><br><span class="line">pi@pi:~/rpi-backup$ sudo ./back.sh /media/linux/2021-01-02.img</span><br></pre></td></tr></table></figure><p>​    如果要还原，可直接使用Win32DiskImager或者Linux dd命令均可，还原后，再利用resize.sh脚本在Pi上进行root分区扩容，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash resize.sh </span><br></pre></td></tr></table></figure><h2 id="【树莓派】配置串口登录"><a href="#【树莓派】配置串口登录" class="headerlink" title="【树莓派】配置串口登录"></a>【树莓派】配置串口登录</h2><p>当树莓派刚刷完机之后，它的硬件串口（&#x2F;dev&#x2F;ttyAMA0）默认是分配给板载蓝牙使用的，因此无法通过串口进行登录。这个时候就需要对串口进行配置， 才能够通过MobaXterm等软件以Serial的方式登录到树莓派的终端上。</p><p><strong>方式一、直接修改配置文件</strong></p><p>  1、树莓派下电， 把TF卡从Pi上拔下来，插到电脑上，直接进入根目录，用Nopad++软件打开<strong>config.txt</strong>，在文件末尾添加如下内容：</p><blockquote><p><img src="/./../../../images/640-165167595867548-1748585431991-39.png" alt="图片"></p></blockquote><p>保存后退出。 </p><p>   2、修改cmdline.txt文件， 确保里面包含”<strong>console&#x3D;serial0,115200”,<strong>同时删除“</strong>rootwait”</strong>之后的内容。最后保存下来的内容如下:</p><blockquote><p><img src="/./../../../images/640-165167595867649-1748585431991-40.png" alt="图片"></p></blockquote><p> 如果配置正常，在树莓派上通过**”cat &#x2F;proc&#x2F;cmdline”**，可以看到 **”consle&#x3D;ttyAMA0,115200”**字样，如下所示：</p><blockquote><p><img src="/./../../../images/640-165167595867650-1748585431991-41.png" alt="图片"></p></blockquote><p><strong>方式二、接HDMI显示或者远程登陆，通过命令行配置</strong></p><p>   如果有接着HDMI显示器或者直接之前开启过SSH，则可以通过开启终端，在终端上输入<strong>“sudo raspi-config”</strong>命令，然后按方向键**”↓”**键选择 <strong>“5 Interfacing Options”</strong>，回车，如下所示：</p><blockquote><img src="./../../../images/640-165167595867651-1748585431991-43.png" alt="图片" style="zoom:67%;"></blockquote><p>  用方向键**”↓”<strong>键，选择</strong>“P6 Serial “，** 回车：</p><blockquote><img src="./../../../images/640-165167595867652-1748585431991-42.png" alt="图片" style="zoom:67%;"></blockquote><p>然后选择**”YES”<strong>即可</strong>*（备注：如果想关闭串口登录，去编程读写串口，则选择”NO”）***，回车即可，如下：</p><blockquote><img src="./../../../images/640-165167595867653-1748585431991-44.png" alt="图片" style="zoom:67%;"></blockquote><p>选择**”OK”,**回车：</p><blockquote><img src="./../../../images/image-20220505091552848-1748585431991-46.png" alt="image-20220505091552848" style="zoom:67%;"></blockquote><p>然后在配置首页按**”Tab”<strong>键，选择</strong>“Finish”，重启树莓派，**正常就能通过串口登录。</p><p> 另外需要注意的是： 通常采用USB转TTL去接树莓派时，通常需要接三个线，即：</p><ul><li><p>树莓派的<strong>GND接</strong>USB转TTL的<strong>GND</strong></p></li><li><p>树莓派的<strong>TX接</strong>USB转TTL的<strong>RX</strong></p></li><li><p>树莓派的<strong>RX接</strong>USB转TTL的<strong>TX</strong></p></li></ul><p>树莓派的<strong>引脚视图</strong>如下：</p><blockquote><img src="./../../../images/640-165167595867754-1748585431991-45.png" alt="图片" style="zoom:67%;"></blockquote><h2 id="【树莓派】系统启用SSH服务"><a href="#【树莓派】系统启用SSH服务" class="headerlink" title="【树莓派】系统启用SSH服务"></a>【树莓派】系统启用SSH服务</h2><p>树莓派官方发布的 Raspbian 系统镜像，默认禁用了SSH 服务，因此默认是无法通过SecurityCRT、MobaXterm 或者Putty等软件远程登录到Pi上的。想要通过SSH登录到树莓派控制台，可通过以下四种方式进行配置：</p><p><strong>一、SSH服务配置方法</strong></p><p><strong>方式一、直接添加配置文件</strong></p><p>树莓派下电， 把TF卡从Pi上拔下来，插到电脑上，直接进入<strong>根目录</strong>，新建一个<strong>名为ssh的空白文件</strong>就行了，如下：</p><blockquote><img src="./../../../images/640-165167604961780-1748585431991-47.png" alt="图片" style="zoom: 67%;"></blockquote><p>然后再把卡插回树莓派，重新上电，就可以使用SSH了（前提是已经配置了网络，网络详细配置见《<a href="http://mp.weixin.qq.com/s?__biz=MzkzMDE4MDM2NQ==&mid=2247483683&idx=1&sn=b5e62b916bbc42df384d708d9e6a00c9&chksm=c27f7d41f508f4570b5543e7ebb8bcee4d535d71ca090f9f7a6cbeb6a512ecc33c2bd7e32ac4&scene=21#wechat_redirect">【树莓派】配置无线网络(wifi)</a>》）。</p><p><strong>方式二、通过命令行配置（sudo raspi-config）</strong></p><p>  在命令行输入”**sudo raspi-config”**，然后回车:</p><blockquote><img src="./../../../images/640-165167604961781-1748585431991-48.png" alt="图片" style="zoom:67%;"></blockquote><p>选择**”Interfacing Options”,**回车：</p><blockquote><img src="./../../../images/640-165167604961882-1748585431991-49.png" alt="图片" style="zoom:67%;"></blockquote><p>选择**”P2 SSH”**,回车：</p><blockquote><img src="./../../../images/640-165167604961883-1748585431991-50.png" alt="图片" style="zoom:67%;"></blockquote><p> 按方向键**”←”键<strong>选择</strong>“YES”**，回车：</p><blockquote><img src="./../../../images/640-165167604961884-1748585431991-51.png" alt="图片" style="zoom: 80%;"></blockquote><p>  <strong>再次回车,<strong>然后按</strong>Tab键</strong>选择**”Finish”**退出。  </p><blockquote><img src="./../../../images/image-20220505091730292-1748585431991-52.png" alt="image-20220505091730292" style="zoom:67%;"></blockquote><p>可以通过**”ps ax | grep sshd”**，查看是否有sshd进程：</p><blockquote><p><img src="/2022/05/05/test/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/../../../../%25E7%25AC%2594%25E8%25AE%25B0/0%2520-%2520%25E6%25A0%2591%25E8%258E%2593%25E6%25B4%25BE%25E9%25A1%25B9%25E7%259B%25AE/%25E3%2580%25900%25E3%2580%2591%25E6%25A0%2591%25E8%258E%2593%25E6%25B4%25BE%25E5%259F%25BA%25E7%25A1%2580%25E4%25BD%25BF%25E7%2594%25A8/undefined" alt="图片" style="zoom:67%;"> <img src="/./../../../images/image-20220505091744039-1748585431991-53.png" alt="image-20220505091744039"></p></blockquote><p>如果有，就说明服务已经起来，就可以连接了。</p><p><strong>方式三、高效命令行方式开启：</strong></p><p>​    首先运行**”sudo systemctl enable ssh.service”**，回车，使能开机启动SSH服务。</p><p>​    然后运行**”sudo systemctl start ssh.service”**，回车，启动SSH服务,如下所示：    </p><blockquote><p><img src="/./../../../images/640-165167604961885-1748585431991-55.png" alt="图片"></p></blockquote><p><strong>方式四、接HDMI显示器，通过界面配置：</strong></p><p>选择“<strong>Start Menu-&gt;Preferences-&gt;Raspberry Pi Configuration</strong>”,</p><blockquote><img src="./../../../images/640-165167604961886-1748585431991-54.png" alt="图片" style="zoom:67%;"></blockquote><p>选中**”Interfaces”<strong>后，将SSH选项</strong>“Enable”**，然后点击”OK”即可，如下：</p><blockquote><img src="./../../../images/640-165167604961887-1748585431991-56.png" alt="图片" style="zoom:67%;"></blockquote><p><strong>二、SSH远程连接设置流程</strong></p><p><strong>以MobaXterm软件为例：</strong></p><p>  首先，打开MobaXterm软件,点击<strong>“Session”</strong>:</p><blockquote><img src="./../../../images/image-20220505091833151-1748585431991-57.png" alt="image-20220505091833151" style="zoom:67%;"></blockquote><p>  单击**”SSH”**按钮，新建SSH会话，输入树莓派的实际IP和登录用户名：</p><blockquote><p><img src="/./../../../images/640-165167604961988-1748585431991-58.png" alt="图片"></p></blockquote><p>然后点击确认，<strong>输入密码，回车</strong>即可连接<em>（<strong>pi</strong>的默认密码为<strong>raspberry</strong>，输入的密码默认不可见**）</em>，如下：</p><blockquote><p><img src="/./../../../images/640-165167604961989-1748585431991-59.png" alt="图片"></p></blockquote><blockquote><img src="./../../../images/640-165167604961990-1748585431991-60.png" alt="图片" style="zoom:67%;"></blockquote><h2 id="【树莓派】配置无线网络-wifi"><a href="#【树莓派】配置无线网络-wifi" class="headerlink" title="【树莓派】配置无线网络(wifi)"></a>【树莓派】配置无线网络(wifi)</h2><p> 树莓派网络分为有线网络和无线网络两种连接方式，有线网络只需要一根网线接入，让设备动态获取IP即可， 基本不需要进行设置。但在使用无线网络连接时，经常会出现一些问题，如输入<strong>ifconfig</strong>命令时<strong>找不到设备节点wlan0</strong>：</p><blockquote><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/y4y47RhOQZxPINKdVGn4k7Tz4FTlF5Te3fepWvB10RcPyRWA8YY9Lm4ftIGlmfE9dqGgUgUyWTKXWiayra4ibRJQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;"></blockquote><p>或者<strong>找到了wlan0设备节点，但是没有获取到IP</strong>：</p><blockquote><img src="./../../../images/640-1651676068912103-1748585431991-61.png" alt="图片" style="zoom:67%;"></blockquote><p>此时我们可以通过<strong>“ls &#x2F;sys&#x2F;class&#x2F;net”</strong>命令确认设备节点是否存在来排除是否为硬件故障或者没有加载驱动：</p><blockquote><p><img src="/./../../../images/640-1651676068912104-1748585431991-62.png" alt="图片"></p></blockquote><p>然后通过<strong>“sudo iw dev wlan0 scan |grep SSID”</strong>命令确认能否搜索到你想要的wifi,如下：</p><blockquote><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/y4y47RhOQZwP6Mpmiaqdh2yehCR7TTvZn8NOAPjMroqCEwzK7wF0qpbcSq6iaaPQReYhkV7IurZTakUQzftA9DOA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p></blockquote><p><strong>可以通过以下几种方式配置wifi网络：</strong></p><p><strong>方式一、通过命令行方式配置（sudo raspi-config）：</strong></p><p>   输入<strong>“sudo raspi-config“，</strong>会出现以下配置界面：</p><blockquote><img src="./../../../images/640-1651676068912106-1748585431991-63.png" alt="图片" style="zoom:67%;"></blockquote><p>用键盘”↓“键选择第二项（<strong>2 Network Options</strong>），然后回车，出现以下界面：</p><blockquote><img src="./../../../images/640-1651676068912107-1748585431991-64.png" alt="图片" style="zoom:67%;"></blockquote><p>选择**N2 Wi-fi,**然后回车:</p><blockquote><img src="./../../../images/image-20220505091952802-1748585431991-65.png" alt="image-20220505091952802" style="zoom:67%;"></blockquote><p>用键盘”↓“键一直下翻，选择<strong>CN China</strong>,然后回车，到输入SSID界面：</p><blockquote><img src="./../../../images/image-20220505092005777-1748585431991-66.png" alt="image-20220505092005777" style="zoom:67%;"></blockquote><p>这是输入<strong>WiFi的名字</strong>（注意有些型号如树莓派3&#x2F;3B是不支持5G和中文的）<strong>，</strong>回车出现下列输入密码界面：</p><blockquote><img src="./../../../images/640-1651676068912108-1748585431991-67.png" alt="图片" style="zoom:67%;"></blockquote><p><strong>输入密码</strong>然后回车，回到raspi-config的首页，用<strong>Tab键</strong>选择<strong>Finish，</strong>然后<strong>重启</strong>，此时在终端上输入<strong>ifconfig</strong>,正常能看到wlan0动态获取到的IP，如下：</p><blockquote><img src="./../../../images/640-1651676068913109-1748585431991-68.png" alt="图片" style="zoom:80%;"></blockquote><p>如果这种方法不生效，可使用其他方法设置。</p><p><strong>方式二、直接修改配置文件</strong></p><p>在终端上输入 sudo nano &#x2F;etc&#x2F;wpa_supplicant.conf</p><p>输入如下内容：（编辑完后先Ctrl+x退出，然后按Y保存退出、按N则不保存退出）</p><blockquote><img src="./../../../images/image-20220505092101048-1748585431991-69.png" alt="image-20220505092101048" style="zoom: 67%;"></blockquote><p>   然后运行<strong>“sudo reboot”</strong>重启树莓派，再次通过<strong>ifconfig</strong>判断是否正确获取到IP:</p><blockquote><p><img src="/./../../../images/640-1651676068913109-1748585431991-68.png" alt="图片"></p></blockquote><p><strong>方式三、接HDMI显示，通过界面配置WIFI</strong></p><p>如果手上有HDMI显示器或者带HDMI接口的电视机，则可直接通过可视化界面配置WIFI，这种方法最为直接简单，如下：</p><blockquote><img src="./../../../images/640-1651676068913110-1748585431991-71.png" alt="图片" style="zoom:67%;"></blockquote><p>注：另外，配置问题如果出现”**Wi-FI is currently blocked by rkfill”**，</p><p>则可以通过**”sudo rfkill unblock all”**解锁，然后按上面的三种配置方式中的其中一种配置即可。</p><h2 id="【树莓派】简单配置CSI摄像头"><a href="#【树莓派】简单配置CSI摄像头" class="headerlink" title="【树莓派】简单配置CSI摄像头"></a>【树莓派】简单配置CSI摄像头</h2><p>本文讲讲树莓派如何正常安装CSI摄像头以及一些基础的配置和简单的使用</p><h3 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h3><p><strong>硬件：</strong>树莓派3B&#x2F;3B+<br><strong>系统：</strong>Raspberry Debian 9 &#x2F; Debian 10</p><h3 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h3><p>1、找到 <strong>CSI 接口</strong>(<em>树莓派3B的CSI接口在HDMI接口和音频口中间</em>)，**需要拉起 CSI 接口挡板,**如下：</p><blockquote><img src="./../../../images/image-20220505092158916-1748585431991-70.png" alt="image-20220505092158916" style="zoom:67%;"></blockquote><p>2、将摄像头排线插入CSI接口。<strong>记住，有蓝色胶带的一面应该面向音频口或者网卡方向， 确认方向并插紧排线，将挡板压下去</strong>，如下所示：</p><blockquote><img src="./../../../images/image-20220505092223652-1748585431991-72.png" alt="image-20220505092223652" style="zoom:67%;"></blockquote><p>安装好的效果图大致如下：</p><blockquote><img src="./../../../images/640-16516753824911-1748585431991-73.jpeg" alt="图片" style="zoom:67%;"></blockquote><h3 id="使能摄像头"><a href="#使能摄像头" class="headerlink" title="使能摄像头"></a>使能摄像头</h3><h4 id="1、首先使用”ls”指令来查看是否存在vchiq设备节点："><a href="#1、首先使用”ls”指令来查看是否存在vchiq设备节点：" class="headerlink" title="1、首先使用”ls”指令来查看是否存在vchiq设备节点："></a>1、首先使用”ls”指令来查看是否存在vchiq设备节点：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">linux@ubuntu:~$ ls /dev</span><br><span class="line">pi@raspberrypi:~ $ ls  /dev/</span><br><span class="line">autofs           disk       gpiomem  loop3             mmcblk0             ptmx   ram15  random   stdout  tty15  tty23  tty31  tty4   tty48  tty56  tty7       vchiq   vcs6   vcsa7</span><br><span class="line">block            dri        hwrng    loop4             mmcblk0p1           pts    ram2   raw      tty     tty16  tty24  tty32  tty40  tty49  tty57  tty8       vcio    vcs7   vcsm</span><br><span class="line">btrfs-control    fb0        initctl  loop5             mmcblk0p2           ram0   ram3   rfkill   tty0    tty17  tty25  tty33  tty41  tty5   tty58  tty9       vc-mem  vcsa   vhci</span><br><span class="line">bus              fd         input    loop6             mqueue              ram1   ram4   serial0  tty1    tty18  tty26  tty34  tty42  tty50  tty59  ttyAMA0    vcs     vcsa1  watchdog</span><br><span class="line">cachefiles       full       kmsg     loop7             net                 ram10  ram5   serial1  tty10   tty19  tty27  tty35  tty43  tty51  tty6   ttyprintk  vcs1    vcsa2  watchdog0</span><br><span class="line">char             fuse       log      loop-control      network_latency     ram11  ram6   shm      tty11   tty2   tty28  tty36  tty44  tty52  tty60  ttyS0      vcs2    vcsa3  zero</span><br><span class="line">console          gpiochip0  loop0    mapper            network_throughput  ram12  ram7   snd      tty12   tty20  tty29  tty37  tty45  tty53  tty61  uhid       vcs3    vcsa4</span><br><span class="line">cpu_dma_latency  gpiochip1  loop1    mem               null                ram13  ram8   stderr   tty13   tty21  tty3   tty38  tty46  tty54  tty62  uinput     vcs4    vcsa5</span><br><span class="line">cuse             gpiochip2  loop2    memory_bandwidth  ppp                 ram14  ram9   stdin    tty14   tty22  tty30  tty39  tty47  tty55  tty63  urandom    vcs5    vcsa6</span><br><span class="line">pi@raspberrypi:~ $  </span><br></pre></td></tr></table></figure><p>如果没有，则可能是内核或者设备硬件存在问题，可尝试重刷系统或更换硬件。</p><h4 id="2、运行”vcgencmd-get-camera”查看当前摄像头是否可用："><a href="#2、运行”vcgencmd-get-camera”查看当前摄像头是否可用：" class="headerlink" title="2、运行”vcgencmd get_camera”查看当前摄像头是否可用："></a>2、运行”vcgencmd get_camera”查看当前摄像头是否可用：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~$ vcgencmd get_camera</span><br><span class="line">supported=1 detected=1&quot;</span><br></pre></td></tr></table></figure><p>如果detected&#x3D;0，说明摄像头模块没接好，重新排查下硬件。detected&#x3D;1则说明CSI摄像头接入正常。supported&#x3D;1说明摄像头已经使能，摄像头已经可以使用。supported&#x3D;1则说明CSI摄像头没有使能。需要使能下摄像头模块。</p><h4 id="3、运行”sudo-raspi-config”命令使能树莓派CSI摄像头"><a href="#3、运行”sudo-raspi-config”命令使能树莓派CSI摄像头" class="headerlink" title="3、运行”sudo raspi-config”命令使能树莓派CSI摄像头"></a>3、运行”sudo raspi-config”命令使能树莓派CSI摄像头</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ sudo raspi-config </span><br></pre></td></tr></table></figure><blockquote><img src="./../../../images/640-16516753824922-1748585431991-74.png" alt="图片" style="zoom:67%;"></blockquote><blockquote><img src="./../../../images/640-16516753824923-1748585431992-75.png" alt="图片" style="zoom:67%;"></blockquote><blockquote><img src="./../../../images/640-16516753824934-1748585431992-76.png" alt="图片" style="zoom:67%;"></blockquote><blockquote><img src="./../../../images/640-16516753824935-1748585431992-77.png" alt="图片" style="zoom:67%;"></blockquote><p>然后重启下树莓派</p><h3 id="添加UVC驱动"><a href="#添加UVC驱动" class="headerlink" title="添加UVC驱动"></a>添加UVC驱动</h3><p>有些程序采用V4L2编程，会访问到&#x2F;dev&#x2F;videoX设备，因此需要添加UVC驱动，针对树莓派3B&#x2F;3B+可以采用如下的方法添加bcm2835-v4l2驱动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~$ vim.tiny /etc/modules</span><br><span class="line"># /etc/modules: kernel modules to load at boot time.</span><br><span class="line">#</span><br><span class="line"># This file contains the names of kernel modules that should be loaded</span><br><span class="line"># at boot time, one per line. Lines beginning with &quot;#&quot; are ignored.</span><br><span class="line"></span><br><span class="line">i2c-dev</span><br><span class="line">bcm2835-v4l2</span><br></pre></td></tr></table></figure><p>然后重启即可在&#x2F;dev&#x2F;目录下看到videoX（X为数字编号,如0）的驱动</p><h3 id="使用rapistill命令拍照"><a href="#使用rapistill命令拍照" class="headerlink" title="使用rapistill命令拍照"></a>使用rapistill命令拍照</h3><p>运行**”raspistill -o image.jpg”**即可成功拍照并保存，更多参数使用raspistill –help</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ raspistill -o image.jpg</span><br></pre></td></tr></table></figure><p>将image.jpg图片传输到windows桌面打开， 即可看到拍照出来的效果，如</p><h2 id="【树莓派】扩展root分区"><a href="#【树莓派】扩展root分区" class="headerlink" title="【树莓派】扩展root分区"></a>【树莓派】扩展root分区</h2><p>最近用安装魔镜，老是提醒我root分区已满，我还总是不信，因为自己用的是16G的内存卡，结果一查看确实不足了。</p><p>输入 df -h</p><blockquote><p><img src="/./../../../images/cb9ba1b5c1a8b9e65f383e1ae50ed585-11831-1748585431992-78" alt="img"></p></blockquote><p>原来我的root只被分到4.5个G啊，这还是我重新烧录系统后的结果。</p><p>更改分区有风险，我就因为更改一次而系统崩溃启动不了，所以请大家跟我一步一步操作。</p><h3 id="1、进入分区管理"><a href="#1、进入分区管理" class="headerlink" title="1、进入分区管理"></a>1、进入分区管理</h3><p>输入 sudo fdisk &#x2F;dev&#x2F;mmcblk0 </p><p>输入p，看到两个分区，第一个分区不要动，我们改动第二个分区。</p><p>注意，记住&#x2F;dev&#x2F;mmcblk0p2的start起始块数，我的为98304。</p><blockquote><p><img src="/./../../../images/2a0e6b3a9e49a81f6063231382d521e8-18310-1748585431992-79" alt="img"></p></blockquote><h3 id="2、删除分区"><a href="#2、删除分区" class="headerlink" title="2、删除分区"></a>2、删除分区</h3><p>输入d ， 再输入2，删除第二分区</p><p>接着输入p，确认只剩下一个分区</p><blockquote><p><img src="/./../../../images/3f0e9b5cd5dd5fa469ad45d8f1984e03-13926-1748585431992-80" alt="img"></p></blockquote><h3 id="3、创建分区"><a href="#3、创建分区" class="headerlink" title="3、创建分区"></a>3、创建分区</h3><p>输入n，创建一个分区</p><blockquote><p><img src="/./../../../images/6c44757c91a5595c3519b9785cdabf5c-3853-1748585431992-81" alt="img"></p></blockquote><p>输入p，建立主分区</p><p>输入2，输入起始块数98304</p><p>接着回车，默认能够分配到最大</p><p>最后输入y，确认</p><blockquote><p><img src="/./../../../images/54f7c3bf7131d66ea4c1b92085059dc2-9604-1748585431992-82" alt="img"></p></blockquote><h3 id="4、保存并重启"><a href="#4、保存并重启" class="headerlink" title="4、保存并重启"></a>4、保存并重启</h3><p>输入w，保存更改</p><p>输入sudo reboot，重启</p><blockquote><p><img src="/./../../../images/abc497433aeef314ce2212af96a4bff7-7345-1748585431992-83" alt="img"></p></blockquote><h3 id="5、修护分区"><a href="#5、修护分区" class="headerlink" title="5、修护分区"></a>5、修护分区</h3><p>输入sudo resize2fs &#x2F;dev&#x2F;mmcblk0p2</p><blockquote><p><img src="/./../../../images/77b309ec33b9186bedc253ae2b6c0f95-8173-1748585431992-84" alt="img"></p></blockquote><p>最后再查看一下</p><p>输入df -h</p><blockquote><p><img src="/./../../../images/f0113c097eaadd09f7e7fc517e277ee3-11624-1748585431992-85" alt="img"></p></blockquote><p>看到我们的root分区已经被扩展到15G了。</p><p>如果以后出现安装不了文件的情况，请尝试输入sudo apt-get update 和 sudo apt-get upgrade。</p><h2 id="【树莓派】apt更改镜像源"><a href="#【树莓派】apt更改镜像源" class="headerlink" title="【树莓派】apt更改镜像源"></a>【树莓派】apt更改镜像源</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>原理就是使用国内的镜像源，代替国外的镜像源。</p><p>有两个推荐的源：</p><ul><li>清华大学镜像：<a href="https://links.jianshu.com/go?to=https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/">https://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/</a></li><li>阿里云镜像：<a href="https://links.jianshu.com/go?to=https://mirrors.aliyun.com/raspbian/raspbian/">https://mirrors.aliyun.com/raspbian/raspbian/</a></li></ul><p><strong>1.备份原系统的apt的源镜像列表</strong></p><p>sudo cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.bak</p><p><strong>2.编辑sources.list 文件</strong></p><p>sudo vim &#x2F;etc&#x2F;apt&#x2F;sources.list</p><p><strong>3.注释掉原来的内容，添加以下内容：</strong></p><p>deb <a href="http://mirrors.aliyun.com/raspbian/raspbian/">http://mirrors.aliyun.com/raspbian/raspbian/</a> buster main contrib non-free rpi</p><p>deb-src <a href="http://mirrors.aliyun.com/raspbian/raspbian/">http://mirrors.aliyun.com/raspbian/raspbian/</a> buster main contrib non-free rpi</p><p><strong>注意：这里编辑的时候需要注意版本（只需要更换链接部分的内容就可以）</strong></p><p><strong>sudo apt-get install screenfetch</strong></p><p><strong>screenfetch &#x2F;&#x2F;查看当前版本信息</strong></p><table><thead><tr><th>Debian版本</th><th>对应名称</th></tr></thead><tbody><tr><td>Debian7</td><td>wheezy</td></tr><tr><td>Debian8</td><td>jessie</td></tr><tr><td>Debian9</td><td>stretch</td></tr><tr><td>Debian10</td><td>buster</td></tr></tbody></table><p>保存退出。</p><p>再执行 sudo apt-get update 和 sudo apt-get upgrade，就能看到加速效果了</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">\#将原有内容用#注释掉</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/raspbian/raspbian/ buster main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/raspbian/raspbian/ buster main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">sudo nano /etc/apt/sources.list.d/raspi.list</span><br><span class="line"></span><br><span class="line">\#将原有内容用#注释掉</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/raspbian/raspbian/ buster main</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/raspbian/raspbian/ buster main</span><br></pre></td></tr></table></figure><p>更新</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-mark hold raspberrypi-bootloader //锁住内核和驱动</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get upgrade -y</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">1.编辑sources.list</span><br><span class="line"></span><br><span class="line">打开终端 输入</span><br><span class="line"></span><br><span class="line">sudo nano /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">用#注释或直接删除原有的内容，新增两条：</span><br><span class="line"></span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">\#deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">ctrl+x 保存并退出。</span><br><span class="line"></span><br><span class="line">编辑raspi.list</span><br><span class="line"></span><br><span class="line">sudo nano /etc/apt/sources.list.d/raspi.list</span><br><span class="line"></span><br><span class="line">用#注释或直接删除原有的内容，新增两条：</span><br><span class="line"></span><br><span class="line">deb http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ stretch main ui</span><br><span class="line"></span><br><span class="line">\#deb-src http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ stretch main ui</span><br><span class="line"></span><br><span class="line">ctrl+x 保存并退出。</span><br><span class="line"></span><br><span class="line">更新软件源列表：</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">我的设置：</span><br><span class="line"></span><br><span class="line">\#deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">\#deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">\#deb http://mirrors.zju.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">\#deb-src http://mirrors.zju.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/raspbian/raspbian/ stretch main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">\#deb http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">\# Uncomment line below then &#x27;apt-get update&#x27; to enable &#x27;apt-get source&#x27;</span><br><span class="line"></span><br><span class="line">\#deb-src http://raspbian.raspberrypi.org/raspbian/ buster main contrib non-free rpi</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">\#deb http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ stretch main ui</span><br><span class="line"></span><br><span class="line">\#deb-src http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ stretch main ui</span><br><span class="line"></span><br><span class="line">\#deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/ stretch main ui</span><br><span class="line"></span><br><span class="line">\#deb-src http://mirrors.ustc.edu.cn/archive.raspberrypi.org/ stretch main ui</span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/raspbian/raspbian/ stretch main</span><br><span class="line"></span><br><span class="line">deb-src http://mirrors.aliyun.com/raspbian/raspbian/ stretch main</span><br><span class="line"></span><br><span class="line">\#deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/ stretch main ui</span><br><span class="line"></span><br><span class="line">\#deb http://archive.raspberrypi.org/debian/ buster main</span><br><span class="line"></span><br><span class="line">\# Uncomment line below then &#x27;apt-get update&#x27; to enable &#x27;apt-get source&#x27;</span><br><span class="line"></span><br><span class="line">\#deb-src http://archive.raspberrypi.org/debian/ buster main</span><br></pre></td></tr></table></figure><h2 id="【树莓派】登录与连接方法"><a href="#【树莓派】登录与连接方法" class="headerlink" title="【树莓派】登录与连接方法"></a>【树莓派】登录与连接方法</h2><p>默认情况，树莓派的串口和蓝牙连接。</p><p>想办法断开蓝牙连接，把串口用来数据通信</p><p><a href="https://blog.csdn.net/syjsxxjy/article/details/80774262">https://blog.csdn.net/syjsxxjy/article/details/80774262</a></p><ol><li><strong>观看树莓派的启动过程，字符</strong></li><li><strong>串口登录树莓派</strong></li></ol><blockquote><img src="./../../../images/8db6125e6ce01661317a9c9b848913be-37781-1748585431992-86" alt="img" style="zoom:67%;"></blockquote><blockquote><p>默认账号：pi</p><p>默认密码：raspberry</p></blockquote><h3 id="配置方法-1"><a href="#配置方法-1" class="headerlink" title="配置方法 1"></a>配置方法 1</h3><p>首先查看wlan0是否连接，连接的情况下会展示连接的无线网名称和状态，没有连接会输出”Not connected”</p><p>iw wlan0 link</p><p>检索附近的无线网络名称</p><p>sudo iwlist wlan0 scan | grep ESSID</p><p>在选择某个无线网名称时会在配置文件中进行修改，如果是只读文件的话需要先赋予读写权限sudo chmod 666 &#x2F;etc&#x2F;wpa_supplicant&#x2F;wpa_supplicant.conf 再修改</p><p>vi &#x2F;etc&#x2F;wpa_supplicant&#x2F;wpa_supplicant.conf</p><p>如果需要更换网络，将原先的network这组数据注释，添加新的网络</p><p>修改完网络之后需要先停用后启用</p><p>sudo ifdown wlan0 关闭（down）wlan0端口</p><p>sudo ifup wlan0 启用（up）wlan0端口</p><p>如果密码不对，就会连接不上。请确认密码是否正确</p><p>查看网络是否连接成功，IP地址是否分配</p><p>ifconfig wlan0</p><p>这样算是重新连接成功</p><p>ifconfig不到wlan0相关信息</p><p>我们所使用的 Raspberry-pi-os是2020最新版本，无论哪个版本的树莓派装了这个后，用ifconfig指令都看不到wlan无线网络的信息，但是用sudo ifconfig -a可以看到有wlan0，</p><p>那就证明我们的网卡驱动没问题，只是无线射频被锁起来了，使用rfkill list查看是否关闭射频：</p><p>我这有一个被锁住了，需要打开它：rfkill unblock all，全部打开，再ifconfig 看看</p><h3 id="配置方法-2"><a href="#配置方法-2" class="headerlink" title="配置方法 2"></a>配置方法 2</h3><p><strong>打开ssh功能</strong></p><p>sudo raspi-config</p><p>修改  <a href="https://blog.csdn.net/qq_36760780/article/details/82016711">https://blog.csdn.net/qq_36760780/article/details/82016711</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/wpa_supplicant/wpa_supplicant.conf</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line"></span><br><span class="line">    ssid=&quot;wifipig&quot;</span><br><span class="line"></span><br><span class="line">    psk=&quot;123456789&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><img src="./../../../images/d3b10475d315a458ee302b2ba0529517-11243-1748585431992-87" alt="img" style="zoom:67%;"></blockquote><p>Nano是文档编辑器，已进入便可以编写。</p><p>Ctrl+o 保存<strong>，</strong>会有提示是否写入。我们按回车。Ctrl+x退出</p><p>固定树莓派的ip地址&#x3D;&#x3D;（错误方式，只是障眼法，并未改变实际ip地址）&#x3D;&#x3D;</p><p>sudo nano   &#x2F;etc&#x2F;rc.local</p><blockquote><img src="./../../../images/3a77cdc11fc86e07ef3970e847cdb8d8-7242-1748585431992-88" alt="img" style="zoom:67%;"></blockquote><h3 id="Xrdp界面登录"><a href="#Xrdp界面登录" class="headerlink" title="Xrdp界面登录"></a>Xrdp界面登录</h3><p>sudo apt-get install xrdp</p><p>安装好之后通过win10的远程电脑登录即可。</p><blockquote><p><img src="/./../../../images/cbf2211488fd1b66315ae091fe1d7ada-2352-1748585431992-89" alt="img"></p></blockquote><h3 id="传输文件"><a href="#传输文件" class="headerlink" title="传输文件"></a>传输文件</h3><p>使用filezilla软件</p><p>连接主机的IP地址前加上sftp:&#x2F;&#x2F;即可稳定连接<a href="sftp://192.168.3.104/">sftp://192.168.3.104</a></p><h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><p>cmdline.txt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console=serial0,115200 console=tty1 root=PARTUUID=f4481065-02 rootfstype=ext4 elevator=deadline fsck.repair=yes rootwait quiet init=/usr/lib/raspi-config/init_resize.sh splash plymouth.ignore-serial-consoles</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>config.txt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">For more options and information see</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">http://rpf.io/configtxt</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Some settings may impact device functionality. See <span class="built_in">link</span> above <span class="keyword">for</span> details</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uncomment <span class="keyword">if</span> you get no picture on HDMI <span class="keyword">for</span> a default <span class="string">&quot;safe&quot;</span> mode</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hdmi_safe=1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uncomment this <span class="keyword">if</span> your display has a black border of unused pixels visible</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and your display can output without overscan</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">disable_overscan=1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uncomment the following to adjust overscan. Use positive numbers <span class="keyword">if</span> console</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">goes off screen, and negative <span class="keyword">if</span> there is too much border</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">overscan_left=16</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">overscan_right=16</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">overscan_top=16</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">overscan_bottom=16</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">uncomment to force a console size. By default it will be display<span class="string">&#x27;s size minus</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">overscan.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">framebuffer_width=1280</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">framebuffer_height=720</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">uncomment if hdmi display is not detected and composite is being output</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">hdmi_force_hotplug=1</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">uncomment to force a specific HDMI mode (this will force VGA)</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">hdmi_group=1</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">hdmi_mode=1</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">uncomment to force a HDMI mode rather than DVI. This can make audio work in</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">DMT (computer monitor) modes</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">hdmi_drive=2</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">uncomment to increase signal to HDMI, if you have interference, blanking, or</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">no display</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">config_hdmi_boost=4</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">uncomment for composite PAL</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">sdtv_mode=2</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">uncomment to overclock the arm. 700 MHz is the default.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">arm_freq=800</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Uncomment some or all of these to enable the optional hardware interfaces</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">dtparam=i2c_arm=on</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">dtparam=i2s=on</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">dtparam=spi=on</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Uncomment this to enable infrared communication.</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">dtoverlay=gpio-ir,gpio_pin=17</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">dtoverlay=gpio-ir-tx,gpio_pin=18</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Additional overlays and parameters are documented /boot/overlays/README</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Enable audio (loads snd_bcm2835)</span></span></span><br><span class="line">dtparam=audio=on</span><br><span class="line"></span><br><span class="line">[pi4]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">Enable DRM VC4 V3D driver on top of the dispmanx display stack</span></span></span><br><span class="line">dtoverlay=vc4-fkms-v3d</span><br><span class="line">max_framebuffers=2</span><br><span class="line"></span><br><span class="line">[all]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="string">dtoverlay=vc4-fkms-v3d</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树莓派 </tag>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树莓派交叉编译与内核编译完全指南</title>
      <link href="/2022/01/01/test/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2022/01/01/test/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="树莓派交叉编译-内核编译-HQ"><a href="#树莓派交叉编译-内核编译-HQ" class="headerlink" title="树莓派交叉编译 &amp; 内核编译 - HQ"></a>树莓派交叉编译 &amp; 内核编译 - HQ</h1><p>[TOC]</p><hr><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>- </p><hr><h1 id="树莓派交叉编译"><a href="#树莓派交叉编译" class="headerlink" title="树莓派交叉编译"></a>树莓派交叉编译</h1><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p><strong>为什么要交叉编译</strong></p><ol><li><p>因为目的平台上的资源贫乏，无法运行我们所需要编译器，平台上不允许或不能够安装我们所需要的编译器比如C51。</p></li><li><p>树莓派有时又是因为目的平台还没有建立，连操作系统都没有，根本谈不上运行什么编译器。操作系统也是代码，也要编译。</p></li></ol><blockquote><p>平台运行需要两样至少东西：bootloader（启动引导代码）以及操作系统核心</p><p>宿主机（host） ：编辑和编译程序的平台，一般是基于X86的PC机，通常也被称为主机。</p><p>目标机（target）：用户开发的系统，通常都是非X86平台。host编译得到的可执行代码在target上运行。</p></blockquote><p><strong>交叉编译需要用到什么工具</strong></p><p>交叉编译器、交叉编译工具链</p><h3 id="交叉编译工具链的安装"><a href="#交叉编译工具链的安装" class="headerlink" title="交叉编译工具链的安装"></a>交叉编译工具链的安装</h3><p><a href="https://github.com/raspberrypi/">https://github.com/raspberrypi/</a></p><ol><li>从共享文件夹拷贝到工作目录  <code>cp /mnt/hgfs/share/tools-master.zip .</code></li><li>解压  <code>unzip tools-master.zip</code></li><li>&#96;&#96;cd &#x2F;home&#x2F;CLC&#x2F;lessonPI&#x2F;tools-master&#x2F;arm-bcm2708&#x2F;gcc-linaro-arm-linux-gnueabihf-raspbian-x64&#x2F;bin&#96;</li><li><code>pwd</code>获得路径</li><li><code>echo $PATH</code> 获得当前环境变量的值</li></ol><p><strong>临时有效，配置环境变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PATH 环境变量</span><br><span class="line"></span><br><span class="line">export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/home/CLC/lessonPI/tools-master/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin</span><br></pre></td></tr></table></figure><p><strong>永久有效，配置环境变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修改工作目录下的.bashrc 隐藏文件，配置命令终端的  vi /home/CLC/.bashrc</span><br><span class="line"></span><br><span class="line">在文件最后一行加入：</span><br><span class="line"></span><br><span class="line">export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/home/CLC/lessonPI/tools-master/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin</span><br><span class="line"></span><br><span class="line">source /home/CLC/.bashrc 加载配置文件，马上生效配置。</span><br></pre></td></tr></table></figure><blockquote><p><img src="/./../../../images/bf23abb9335c7529fe25d8eb3ffa5024-42710-1748585374057-1" alt="img"></p></blockquote><p>将安装路径添加到PATH中，添加到.bashrc的结尾即可</p><blockquote><p><img src="/./../../../images/a3538b7515fa89f7810eff02416638ae-62196-1748585374057-2" alt="img"></p></blockquote><blockquote><p><img src="/./../../../images/6c7d0cf21d41865a112762b2a5de831e-9882-1748585374057-3" alt="img"></p></blockquote><h3 id="交叉编译使用举例"><a href="#交叉编译使用举例" class="headerlink" title="交叉编译使用举例"></a>交叉编译使用举例</h3><p>交叉编译：检查下交叉编译工具对不对 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc -v    4.8.3  </span><br><span class="line">arm-linux-gnueabihf-gcc xxx.c -o xxx</span><br></pre></td></tr></table></figure><p>如何把编译生成的可执行文件下载到开发板  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 指令 文件名 开发板用户名@开发板地址：开发板的绝对路径</span><br><span class="line">scp clientInPi pi@192.168.43.30:/home/pi</span><br></pre></td></tr></table></figure><h1 id="树莓派源码分析-内核编译-简略"><a href="#树莓派源码分析-内核编译-简略" class="headerlink" title="树莓派源码分析 &amp; 内核编译 - 简略"></a>树莓派源码分析 &amp; 内核编译 - 简略</h1><h3 id="Linux内核源代码目录树结构"><a href="#Linux内核源代码目录树结构" class="headerlink" title="Linux内核源代码目录树结构"></a>Linux内核源代码目录树结构</h3><p><strong>arch：</strong>包含和硬件体系结构相关的代码，每种平台占一个相应的目录。和32位PC相关的代码存放在i386目录下，其中比较重要的包括kernel（内核核心部分）、mm（内存管理）、math-emu（浮点单元仿真）、lib（硬件相关工具函数）、boot（引导程序）、pci（PCI总线）和power（CPU相关状态）。</p><p><strong>block：</strong>部分块设备驱动程序。</p><p><strong>crypto：</strong>常用加密和散列算法（如AES、SHA等），还有一些压缩和CRC校验算法。</p><p><strong>Documentation：</strong>关于内核各部分的通用解释和注释。</p><p><strong>drivers：</strong>设备驱动程序，每个不同的驱动占用一个子目录。</p><p><strong>fs：</strong>各种支持的文件系统，如ext、fat、ntfs等。</p><p><strong>include：</strong>头文件。其中，和系统相关的头文件被放置在linux子目录下。</p><p><strong>init：</strong>内核初始化代码（注意不是系统引导代码）。</p><p><strong>ipc：</strong>进程间通信的代码。</p><p><strong>kernel：</strong>内核的最核心部分，包括进程调度、定时器等，和平台相关的一部分代码放在arch&#x2F;*&#x2F;kernel目录下。</p><p><strong>lib：</strong>库文件代码。</p><p><strong>mm：</strong>内存管理代码，和平台相关的一部分代码放在arch&#x2F;*&#x2F;mm目录下。</p><p><strong>net：</strong>网络相关代码，实现了各种常见的网络协议。</p><p><strong>scripts：</strong>用于配置内核文件的脚本文件。</p><p><strong>security：</strong>主要是一个SELinux的模块。</p><p><strong>sound：</strong>常用音频设备的驱动程序等。</p><p><strong>usr：</strong>实现了一个cpio。</p><p>在i386体系下，系统引导将从<code>arch/i386/kernel/head.s</code>开始执行，并进而转移到<code>init/main.c</code>中的<code>main()函数</code>初始化内核。</p><h3 id="树莓派Linux源码配置"><a href="#树莓派Linux源码配置" class="headerlink" title="树莓派Linux源码配置"></a>树莓派Linux源码配置</h3><p><strong><code>.config</code>文件是linux内核配置文件，当执行#make uImage编译生成内核时，顶层的Makefile会读取<code>.config</code>文件的内容，根据这个配置文件来编译所定制的内核。</strong></p><p>内核源码配置的三种方式</p><ol><li>根据厂家提供的Linux内核源码，进行修改，<code>厂家.config</code>-&gt;<code>自己.config</code></li><li><code>make menuconfig</code> 进行配置，通常是基于厂家的config来配置。</li><li>完全自己开发</li></ol><h3 id="内核编译-详细过程参考下一章"><a href="#内核编译-详细过程参考下一章" class="headerlink" title="内核编译 - 详细过程参考下一章"></a>内核编译 - 详细过程参考下一章</h3><p><strong>1.编译内核</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make -j4 zImage modules dtbs</span><br></pre></td></tr></table></figure><blockquote><p><code>-j4</code> 指定用多少电脑资源进行编译</p><p><code>zImage</code> 生成内核镜像</p><p><code>modules</code> 要生成驱动模块</p><p><code>dtbs</code> 生成配置文件（设备树）</p></blockquote><p><strong>2.编译成功后</strong></p><p>看到源码树目录多了vmlinux，失败则无此文件，成功后，目标zImage镜像arch&#x2F;arm&#x2F;boot底下。</p><p><strong>3.打包zImage成树莓派可用的xxx.img</strong></p><p>直接用linux源码包里的工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./scripts/mkknlimg arch/arm/boot/zImage ./kernel_new.img</span><br></pre></td></tr></table></figure><p><strong>4.数据拷贝</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir data1 data2</span><br></pre></td></tr></table></figure><p>挂载U盘</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mount /dev/sdb1 data1  一个fat分区，是boot相关的内容，kernel的img</span><br><span class="line">sudo mount /dev/sdb2 data2  一个是ext4分区，也就是系统的根目录分区。</span><br></pre></td></tr></table></figure><p>安装modules, 设备驱动文件，如 hdmi usb wifi io …</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make INSTALL_MOD_PATH=/home/chenlc/data2 modules_install</span><br></pre></td></tr></table></figure><p>安装更新 kernel.img 文件，注意镜像名字是kernel7.img</p><p>再把编译新生成的拷贝到data1，起名kernel7.img</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp kernel_new.img /home/chenlc/data1/kernel7.img</span><br></pre></td></tr></table></figure><p>拷贝配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp arch/arm/boot/dts/.*dtb* /home/chenlc/data1</span><br></pre></td></tr></table></figure><p>后面步骤参考下一章</p><blockquote><p><img src="/./../../../images/6a13d650389171ea0e9f2e726c339f0f-5095752-1748585374057-4" alt="img"></p></blockquote><h1 id="树莓派交叉编译-本地编译-详细"><a href="#树莓派交叉编译-本地编译-详细" class="headerlink" title="树莓派交叉编译 &amp; 本地编译 - 详细"></a>树莓派交叉编译 &amp; 本地编译 - 详细</h1><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>树莓派的github主页：<a href="https://github.com/raspberrypi%EF%BC%8C%E9%87%8C%E9%9D%A2%E5%8C%85%E5%90%AB%E4%BA%86linux%E6%BA%90%E7%A0%81%E3%80%81%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%93%BE%E7%AD%89%E5%86%85%E5%AE%B9%E3%80%82">https://github.com/raspberrypi，里面包含了linux源码、交叉编译工具链等内容。</a></p><p>对于我们要用到的有两个仓库：</p><p><a href="https://github.com/raspberrypi/linux">https://github.com/raspberrypi/linux</a> 内核源码</p><p><a href="https://github.com/raspberrypi/tools">https://github.com/raspberrypi/tools</a> 交叉编译工具链（仅在交叉编译时用到）</p><p>注：<br>1、树莓派里安装的系统镜像版本要和kernel代码对应。因为树莓派系统是在不断开发和升级的，如果你的树莓派使用的是某个时间的系统镜像，那么最好也使用当时的kernel代码。<br>2、关于内核编译方法，官网有很详细的介绍：<a href="https://www.raspberrypi.org/documentation/linux/kernel/building.md%EF%BC%8C%E8%BF%99%E9%87%8C%E7%AE%97%E6%98%AF%E7%BF%BB%E8%AF%91%E5%92%8C%E8%A1%A5%E5%85%85%E3%80%82">https://www.raspberrypi.org/documentation/linux/kernel/building.md，这里算是翻译和补充。</a><br>3、以下编译过程在树莓派1和树莓派3B上测试ok。</p><h3 id="二、ubuntu里交叉编译"><a href="#二、ubuntu里交叉编译" class="headerlink" title="二、ubuntu里交叉编译"></a>二、ubuntu里交叉编译</h3><h4 id="1、获取交叉编译工具和源码"><a href="#1、获取交叉编译工具和源码" class="headerlink" title="1、获取交叉编译工具和源码"></a>1、获取交叉编译工具和源码</h4><p>源码：<strong>git clone <a href="mailto:&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#x68;&#117;&#x62;&#46;&#99;&#x6f;&#109;">&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#x68;&#117;&#x62;&#46;&#99;&#x6f;&#109;</a>:raspberrypi&#x2F;linux</strong></p><p>交叉编译工具：<strong>git clone <a href="mailto:&#103;&#x69;&#x74;&#64;&#x67;&#105;&#116;&#104;&#x75;&#x62;&#46;&#99;&#111;&#109;">&#103;&#x69;&#x74;&#64;&#x67;&#105;&#116;&#104;&#x75;&#x62;&#46;&#99;&#111;&#109;</a>:raspberrypi&#x2F;tools</strong></p><h4 id="2、配置编译环境变量"><a href="#2、配置编译环境变量" class="headerlink" title="2、配置编译环境变量"></a>2、配置编译环境变量</h4><h5 id="2-1-手动配置环境变量"><a href="#2-1-手动配置环境变量" class="headerlink" title="2.1 手动配置环境变量"></a>2.1 手动配置环境变量</h5><p>编译工具下载后，在64位ubuntu上编译我们需要的编译工具bin文件在：<code>tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin</code> 目录下，将此目录添加到环境变量PATH中，添加方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=$PATH:/home/nicek/githubProjects/raspberrypi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin</span><br></pre></td></tr></table></figure><p>如果是在32位系统中编译则要选择32位的交叉编译工具。</p><p>配置完成之后可以用编译工具命令查看到版本号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc -v</span><br></pre></td></tr></table></figure><p>之后，所有的make命令都要指明一些环境变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7</span><br></pre></td></tr></table></figure><table><thead><tr><th>ARCH&#x3D;arm</th><th>指明当前要编译arm，虽然树莓派是64位的，这里仍然选择arm，而不是arm64。</th></tr></thead><tbody><tr><td>CROSS_COMPILE</td><td>指明交叉工具链名称。</td></tr><tr><td>KERNEL</td><td>指明kernel类型，<strong>树莓派1设置为kernel，树莓派2、3设置为kernel7。</strong></td></tr></tbody></table><p>每次make都需要指明这些环境变量，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make menuconfig</span><br><span class="line">ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make -j4 zImage</span><br></pre></td></tr></table></figure><h5 id="2-2-自动配置环境变量"><a href="#2-2-自动配置环境变量" class="headerlink" title="2.2 自动配置环境变量"></a>2.2 自动配置环境变量</h5><p>上面这些环境变量每次命令都要写很麻烦，可以通过export一次设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:/home/nicek/githubProjects/raspberrypi/tools/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7</span><br></pre></td></tr></table></figure><p>之后在本终端里执行的所有命令都带有这些环境变量信息。</p><p>此 export 命令可以写成一个脚本，然后在编译前在终端里source一下这个脚本即可设置好所有的环境变量。就像android编译前也要先source一下envsetup.sh一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash DIR=&quot;$( cd &quot;$( dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot; )&quot; &amp;&amp; pwd )&quot; export PATH=&quot;$PATH:$DIR/arm-bcm2708/gcc-linaro-arm-linux-gnueabihf-raspbian-x64/bin/&quot; export ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 </span><br></pre></td></tr></table></figure><p>上述命令中的路径可能和你实际不同，注意修改。</p><p>export环境变量后，在本终端里的后续命令都可以不用再指明这些环境变量，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">配置之前的命令：</span><br><span class="line">ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make menuconfig</span><br><span class="line">配置之后的命令：</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure><h4 id="3、配置config"><a href="#3、配置config" class="headerlink" title="3、配置config"></a>3、配置config</h4><p>linux源码中有很多工程：<br>树莓派1的工程是<strong>bcmrpi_defconfig</strong><br>树莓派2、3的工程是<strong>bcm2709_defconfig</strong></p><h5 id="3-1-使用源码里自带的config"><a href="#3-1-使用源码里自带的config" class="headerlink" title="3.1 使用源码里自带的config"></a>3.1 使用源码里自带的config</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make bcm2709_defconfig</span><br></pre></td></tr></table></figure><blockquote><p><code>ARCH=ARM</code> 指定ARM架构</p><p><code>CROSS_COMPILE=arm-linux-gnueabihf-</code> 指定编译器</p><p><code>KERNEL=kernel7</code> 树莓派</p><p><code>make bcm2709_defconfig</code> 主要核心指令</p></blockquote><p>此命令功能是获取bcm2709_defconfig的配置到 .config里。<br>我们可以直接用工程里的配置，但这样的话可能会丢失原来使用的树莓派的配置，这里提供一个方法可以获取当前正在使用的树莓派的config。</p><h5 id="3-2-获取当前树莓派的config"><a href="#3-2-获取当前树莓派的config" class="headerlink" title="3.2 获取当前树莓派的config"></a>3.2 获取当前树莓派的config</h5><p>已经开机的树莓派上会有这个节点：**&#x2F;proc&#x2F;config.gz<strong>，从这个节点可以获取本树莓派的config。<br>如果没有这个节点的话则需要先加载模块：</strong>sudo modprobe configs**</p><p>把 config.gz 内容复制到要编译的电脑上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp pi@[ip]:/proc/config.gz .</span><br></pre></td></tr></table></figure><p>解压，保存为.confg文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcat config.gz &gt; .config</span><br></pre></td></tr></table></figure><p>注：必须在linux环境下解压，在mac下会乱码。</p><p>把此config文件复制到linux源码的根目录。</p><h4 id="4、编译"><a href="#4、编译" class="headerlink" title="4、编译"></a>4、编译</h4><p>安装必要的库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install bc</span><br><span class="line">sudo apt-get install libncurses5-dev libncursesw5-dev</span><br><span class="line">sudo apt-get install zlib1g:i386</span><br><span class="line">sudo apt-get install libc6-i386 lib32stdc++6 lib32gcc1 lib32ncurses5</span><br></pre></td></tr></table></figure><p><strong>4.1 执行menuconfig</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make menuconfig</span><br></pre></td></tr></table></figure><p>如果没什么改的就不用执行这一步。</p><p><strong>4.2 编译</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make -j4 zImage modules dtbs 2&gt;&amp;1 | tee build.log</span><br></pre></td></tr></table></figure><p>以n进程编译。不指明几进程的话则默认以单进程编译。</p><p><strong>4.3 打包zImage文件</strong></p><p>直接用linux源码包里的工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./scripts/mkknlimg arch/arm/boot/zImage ./kernel_new.img</span><br></pre></td></tr></table></figure><p>在本目录生成一个kernel_new.img文件，这个文件就是要放到sd卡中的文件。<br>注：网上很多地方说的用 tools&#x2F;mkimage&#x2F;imagetool-uncompressd.py 的方法不行！！</p><h4 id="5、挂载树莓派sd卡，并安装编译出的DIRECTLY-到sd卡"><a href="#5、挂载树莓派sd卡，并安装编译出的DIRECTLY-到sd卡" class="headerlink" title="5、挂载树莓派sd卡，并安装编译出的DIRECTLY 到sd卡"></a>5、挂载树莓派sd卡，并安装编译出的DIRECTLY 到sd卡</h4><p>把树莓派的sd卡插入ubuntu系统电脑，树莓派的sd卡有两个分区：<br>一个fat分区，是boot相关的内容，kernel的img文件就放在这个分区里；<br>一个是ext4分区，也就是系统的根目录分区。</p><p>我们生成的文件涉及到这两个分区的内容，一般插入ubuntu后会自动挂载，fat分区可以不用root权限操作，ext4分区需要root权限操作。<br>两个分区具体挂载在什么地方可以自己决定，以下用[fat]表示boot挂载的路径，[ext4]表示ext4挂载的路径。</p><p><strong>5.1 安装modules</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- KERNEL=kernel7 make INSTALL_MOD_PATH=[ext4] modules_install</span><br></pre></td></tr></table></figure><p>操作ext4分区，需要root权限。</p><p><strong>5.2 更新 kernel.img 文件</strong><br>前面已经用 mkknlimg 工具打包了kernel_new.img文件了，把它复制到boot分区并配置使用即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp kernel_new.img [fat]/</span><br></pre></td></tr></table></figure><p>编辑 [fat]&#x2F;config.txt 文件，在最后加入一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel=kernel_new.img</span><br></pre></td></tr></table></figure><p><strong>5.3 复制其他相关文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp arch/arm/boot/dts/*.dtb [fat]/</span><br><span class="line">cp arch/arm/boot/dts/overlays/*.dtb* [fat]/overlays/</span><br><span class="line">cp arch/arm/boot/dts/overlays/README [fat]/overlays/</span><br></pre></td></tr></table></figure><p>更新完成后插回树莓派即可开机，开机后可以用 uname -a 命令查看kernel信息已经改变。</p><h3 id="三、树莓派本地编译"><a href="#三、树莓派本地编译" class="headerlink" title="三、树莓派本地编译"></a>三、树莓派本地编译</h3><p>树莓派上本地编译和上面交叉编译原理基本相同，由于是本地编译，在编译工具和环境变量配置方面还简单一些。<br>树莓派上编一次内核花了将近2小时。</p><h4 id="1、获取源码"><a href="#1、获取源码" class="headerlink" title="1、获取源码"></a>1、获取源码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:raspberrypi/linux</span><br></pre></td></tr></table></figure><h4 id="2、配置编译环境"><a href="#2、配置编译环境" class="headerlink" title="2、配置编译环境"></a>2、配置编译环境</h4><p>在ubuntu里交叉编译时需要配置的环境变量有：</p><ul><li>PATH: 添加交叉工具链的目录</li><li>ARCH: 配置成arm</li><li>CROSS_COMPILE: 配置成ubuntu上使用的交叉工具链arm-linux-gnueabihf- KERNEL&#x3D;kernel7</li><li>KERNEL: 配置成kernel7</li></ul><p>而在树莓派本地编译：<br>关于交叉工具链，本身的编译工具就可以编译给自己使用，所以不用配置；<br>只需要配置 KERNEL&#x3D;kernel7 即可。</p><p>和上面相同，可以用 export KERNEL&#x3D;kernel7，一次设置之后此终端里所有命令都带有此环境变量。<br>也可以更进一步写成脚本，不过这里这一行命令很简单，不写脚本也可以。</p><h4 id="3、配置config-1"><a href="#3、配置config-1" class="headerlink" title="3、配置config"></a>3、配置config</h4><p>和上面一样，<br>树莓派1使用的是 <strong>bcmrpi_defconfig</strong>，<br>树莓派2、3使用的是 <strong>bcm2709_defconfig</strong>。<br>例：KERNEL&#x3D;kernel7 make bcm2709_defconfig</p><p>如果要使用树莓派自带的config的话：<br><strong>sudo modprobe configs</strong> # 加载模块<br><strong>zcat config.gz &gt; .config</strong> # 获取配置</p><h4 id="4、编译-1"><a href="#4、编译-1" class="headerlink" title="4、编译"></a>4、编译</h4><p>安装必要的库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install bc</span><br><span class="line">sudo apt-get install libncurses5-dev libncursesw5-dev</span><br><span class="line">sudo apt-get install zlib1g</span><br><span class="line">sudo apt-get install libc6</span><br></pre></td></tr></table></figure><p>1、执行menuconfig<br><strong>KERNEL&#x3D;kernel7 make menuconfig</strong><br>没什么要改的话就不用执行这一步。</p><p>2、编译<br><strong>KERNEL&#x3D;kernel7 make -j4 zImage modules dtbs 2&gt;&amp;1 | tee build.log</strong><br>以n进程编译。不指明几进程的话则默认以单进程编译。</p><p>3、打包zImage文件<br>直接用linux源码包里的工具：<br><strong>.&#x2F;scripts&#x2F;mkknlimg arch&#x2F;arm&#x2F;boot&#x2F;zImage .&#x2F;kernel_new.img</strong><br>在本目录生成一个kernel_new.img文件，这个文件就是要放到sd卡中的文件。</p><h4 id="5、更新系统"><a href="#5、更新系统" class="headerlink" title="5、更新系统"></a>5、更新系统</h4><p>1、安装模块<br><strong>sudo make modules_install</strong></p><p>2、复制dtb文件<br><strong>sudo cp arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;*.dtb &#x2F;boot&#x2F; sudo cp arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;overlays&#x2F;*.dtb* &#x2F;boot&#x2F;overlays&#x2F; sudo cp arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;overlays&#x2F;README &#x2F;boot&#x2F;overlays&#x2F;</strong></p><p>3、更新kernel.img文件<br><strong>sudo cp arch&#x2F;arm&#x2F;boot&#x2F;zImage &#x2F;boot&#x2F;$KERNEL.img</strong></p><h1 id="树莓派Linux内核编译-编程那些年"><a href="#树莓派Linux内核编译-编程那些年" class="headerlink" title="树莓派Linux内核编译 - 编程那些年"></a>树莓派Linux内核编译 - 编程那些年</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzkzMDE4MDM2NQ==&mid=2247483946&idx=1&sn=c896dceca1b41e69705d0f5d1e439838&scene=19#wechat_redirect">编程那些年 - 文章</a></p><p>树莓派的Linux内核编译有两种方法: 一种是在树莓派上直接编译，另一种是利用交叉编译的方法。一般我们都推荐采用交叉编译的方式进行编译，这是因为通常交叉编译Pi内核的速度比Pi本身编译快得多（性能因素）。下面就讲下如下利用这两种方式来编译Pi内核。 </p><h3 id="第一种方法：Pi本地编译"><a href="#第一种方法：Pi本地编译" class="headerlink" title="第一种方法：Pi本地编译"></a>第一种方法：Pi本地编译</h3><p><strong>前提条件</strong></p><p>准备一张16G以上TF卡。</p><p>如果上述没有该条件，可以利用NFS挂载方式，将源码目录挂载到主机上，利用主机的空间来存储代码，但会影响到编译速度。 比如我将虚拟机的nfs目录挂载到Pi的&#x2F;mnt目录下，并在该目录下存储代码，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:~ $ mount | grep mnt</span><br><span class="line">192.168.1.133:/nfs/ on /mnt type nfs (rw,relatime,vers=3,rsize=524288,wsize=524288,namlen=255,hard,nolock,proto=tcp,port=2049,timeo=70,retrans=3,sec=sys,local_lock=all,addr=192.168.1.133)</span><br><span class="line">pi@raspberrypi:~ $ ls /mnt/</span><br><span class="line">linux</span><br><span class="line">pi@raspberrypi:~ $</span><br></pre></td></tr></table></figure><p><strong>编译前准备</strong></p><p>​    首先，配置好树莓派的网络<em>（用推荐用有线网络，否则下载会非常慢）</em>和树莓派的源（推荐使用阿里源，将<strong>“raspbian.raspberrypi.org”</strong>替换为<strong>“mirrors.aliyun.com&#x2F;raspbian”</strong>字段），正常souces.list前后替换后差异内容大致如下：</p><p><img src="/./../../../images/640-1748585374057-5.png" alt="图片"></p><p>  安装git和树莓派内核编译所需的依赖库，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install git bc bison flex libssl-dev make</span><br></pre></td></tr></table></figure><p><strong>下载内核源码</strong></p><p>   利用git获取当前git仓库默认Pi的内核源码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --depth=1 https://github.com/raspberrypi/linux</span><br></pre></td></tr></table></figure><p>  当然，你也可以选择下载自己所需的内核源码版本，如需要下载4.14.y，可利用branch参数下载，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --depth=1 https://github.com/raspberrypi/linux --branch rpi-4.14.y</span><br></pre></td></tr></table></figure><p><strong>配置内核</strong></p><p>根据当前你使用的Raspberry Pi的实际型号，通过运行以下具体命令进行准备默认配置：</p><p>​    如果是Raspberry Pi 2, Pi 3, Pi 3+系列，默认配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:/mnt $ cd linux</span><br><span class="line">pi@raspberrypi:/mnt/linux $ KERNEL=kernel7</span><br><span class="line">pi@raspberrypi:/mnt/linux $ make bcm2709_defconfig</span><br></pre></td></tr></table></figure><p>Raspberry Pi 4的默认配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:/mnt $ cd linux</span><br><span class="line">pi@raspberrypi:/mnt/linux $ KERNEL=kernel7l</span><br><span class="line">pi@raspberrypi:/mnt/linux $ make bcm2711_defconfig</span><br></pre></td></tr></table></figure><p>Raspberry Pi 1、Pi Zero、Pi Zero W系列的默认采用配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:/mnt $ cd linux</span><br><span class="line">pi@raspberrypi:/mnt/linux $ KERNEL=kernel</span><br><span class="line">pi@raspberrypi:/mnt/linux $ make bcmrpi_defconfig</span><br></pre></td></tr></table></figure><p>​    如果需要额外对内核进行配置，则可以利用如下命令实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:/mnt/linux $ make menuconfig</span><br></pre></td></tr></table></figure><p> <strong>编译和安装</strong></p><p>​    最后进行编译安装内核、驱动模块、设备树配置操作，这个过程会比较漫长，需要耐心等待，命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pi@raspberrypi:/mnt/linux $ make -j4 zImage modules dtbs</span><br><span class="line">pi@raspberrypi:/mnt/linux $ sudo make modules_install</span><br><span class="line">pi@raspberrypi:/mnt/linux $ sudo cp arch/arm/boot/dts/*.dtb /boot/</span><br><span class="line">pi@raspberrypi:/mnt/linux $ sudo cp arch/arm/boot/dts/overlays/*.dtb* /boot/overlays/</span><br><span class="line">pi@raspberrypi:/mnt/linux $ sudo cp arch/arm/boot/dts/overlays/README /boot/overlays/</span><br><span class="line">pi@raspberrypi:/mnt/linux $ sudo cp arch/arm/boot/zImage /boot/$KERNEL.img</span><br><span class="line">pi@raspberrypi:/mnt/linux $  sudo reboot -f</span><br></pre></td></tr></table></figure><h3 id="第二种方法：交叉编译内核"><a href="#第二种方法：交叉编译内核" class="headerlink" title="第二种方法：交叉编译内核"></a>第二种方法：交叉编译内核</h3><p>首先，需要准备一台Linux交叉编译主机，比如Ubuntu 18.04（可以安装实体机或者VMware或VirtualBox里）。</p><p><strong>编译前准备</strong><br>首先在交叉编译Linux主机上安装所需的依赖和交叉编译工具，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install git bc bison flex libssl-dev make libc6-dev libncurses5-dev</span><br></pre></td></tr></table></figure><p>如果Pi安装的是32的内核，则安装32位的交叉编译工具链：</p><p>（注：通过在Pi里运行<strong>“file &#x2F;sbin&#x2F;busybox”</strong> 或其他可执行程序可查看当前内核是32位还是64位的。如果是32位的，会显示如下32-bit 字段，否则为64位的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install crossbuild-essential-armhf</span><br></pre></td></tr></table></figure><p>否则，如果Pi使用的是64的内核，则安装64位的交叉编译工具链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install crossbuild-essential-arm64</span><br></pre></td></tr></table></figure><p><strong>获取源码</strong></p><p> 利用git获取当前git仓库默认Pi的内核源码，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --depth=1 https://github.com/raspberrypi/linux</span><br></pre></td></tr></table></figure><p>  当然，你也可以选择下载自己所需的内核源码版本，如需要下载4.14.y，可利用branch参数下载，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone --depth=1 https://github.com/raspberrypi/linux --branch rpi-4.14.y</span><br></pre></td></tr></table></figure><p><strong>配置内核</strong></p><p><strong>针对32位系统:</strong></p><p>如果是Pi 2, Pi 3, Pi 3+, 和3系列树莓派，运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux@ubuntu:~$ cd linux</span><br><span class="line">linux@ubuntu:~/linux$ KERNEL=kernel7</span><br><span class="line">linux@ubuntu:~/linux$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcm2709_defconfig</span><br></pre></td></tr></table></figure><p>如果是Raspberry Pi 4，运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux@ubuntu:~$ cd linux</span><br><span class="line">linux@ubuntu:~/linux$ KERNEL=kernel7l</span><br><span class="line">linux@ubuntu:~/linux$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcm2711_defconfig</span><br></pre></td></tr></table></figure><p>如果是Pi 1, Pi Zero, Pi Zero W，运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux@ubuntu:~$ cd linux</span><br><span class="line">linux@ubuntu:~/linux$ KERNEL=kernel</span><br><span class="line">linux@ubuntu:~/linux$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcmrpi_defconfig</span><br></pre></td></tr></table></figure><p><strong>针对64位系统：</strong></p><p>  如果是Pi 2, Pi 3, Pi 3+, 和3系列树莓派，运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux@ubuntu:~$ cd linux</span><br><span class="line">linux@ubuntu:~/linux$ KERNEL=kernel8</span><br><span class="line">linux@ubuntu:~/linux$ make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- bcmrpi3_defconfig</span><br></pre></td></tr></table></figure><p>如果是Raspberry Pi 4，运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">linux@ubuntu:~$ cd linux</span><br><span class="line">linux@ubuntu:~/linux$ KERNEL=kernel8</span><br><span class="line">linux@ubuntu:~/linux$ make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- bcm2711_defconfig</span><br></pre></td></tr></table></figure><p><strong>编译内核</strong></p><p>如果是32位内核，运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j4  ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage modules dtbs</span><br></pre></td></tr></table></figure><p>如果是64位内核，运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j4  ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- Image modules dtbs</span><br></pre></td></tr></table></figure><p><strong>内核安装到TF卡</strong></p><p>将TF卡接到Linux交叉编译主机上（如果是VMwar虚拟机，则需要将”设置-&gt;硬件-&gt;USB控制机-&gt;USB兼容性(C)”调成“USB 1.1”）</p><p>运行<strong>lsblk</strong>命令查看识别到的TF卡设备节点，如下：*</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">linux@ubuntu:~/linux$ lsblk</span><br><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0   20G  0 disk </span><br><span class="line">└─sda1   8:1    0   20G  0 part /</span><br><span class="line">sdb      8:16   1 14.6G  0 disk </span><br><span class="line">├─sdb1   8:17   1  256M  0 part /media/linux/boot</span><br><span class="line">└─sdb2   8:18   1  3.3G  0 part /media/linux/rootfs</span><br></pre></td></tr></table></figure><p>正常TF卡设备会自动挂载到&#x2F;media&#x2F;${当前用户目录}&#x2F;下的boot和rootfs目录下，如果没有自动挂载，则根据识别到实际TF卡的设备节点，将设备挂载到主机上，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /media/linux/rootfs -p</span><br><span class="line">sudo mkdir /media/linux/boot -p</span><br><span class="line">sudo mount /dev/sdb1 /media/linux/boot</span><br><span class="line">sudo mount /dev/sdb2 /media/linux/rootfs</span><br></pre></td></tr></table></figure><p>​    然后将内核模块安装到SD中：</p><p>  如果是32位内核，运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo env PATH=$PATH make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- INSTALL_MOD_PATH=/media/linux/rootfs modules_install</span><br></pre></td></tr></table></figure><p>如果是64位内核，运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo env PATH=$PATH make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- INSTALL_MOD_PATH=/media/linux/rootfs modules_install</span><br></pre></td></tr></table></figure><p>最后备份原理SD卡中的旧内核， 并将新内核和设备树配置文件到SD卡中:</p><p>如果是32位内核，运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /media/linux/boot/$KERNEL.img /media/linux/boot/$KERNEL-backup.img</span><br><span class="line">sudo cp arch/arm/boot/zImage /media/linux/boot/$KERNEL.img</span><br><span class="line">sudo cp arch/arm/boot/dts/*.dtb /media/linux/boot</span><br><span class="line">sudo cp arch/arm/boot/dts/overlays/*.dtb* /media/linux/boot/overlays/</span><br><span class="line">sudo cp arch/arm/boot/dts/overlays/README /media/linux/boot/overlays/</span><br><span class="line">sudo umount /media/linux/boot</span><br><span class="line">sudo umount /media/linux/rootfs</span><br></pre></td></tr></table></figure><p>如果是64位内核，运行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo</span><br><span class="line">cp /media/linux/boot/$KERNEL.img /media/linux/boot/$KERNEL-backup.img</span><br><span class="line">sudo cp arch/arm64/boot/Image /media/linux/boot/$KERNEL.img</span><br><span class="line">sudo cp arch/arm64/boot/dts/broadcom/*.dtb /media/linux/boot/</span><br><span class="line">sudo cp arch/arm64/boot/dts/overlays/*.dtb* /media/linux/boot/overlays/</span><br><span class="line">sudo cp arch/arm64/boot/dts/overlays/README /media/linux/boot/overlays/</span><br><span class="line">sudo umount /media/linux/boot/</span><br><span class="line">sudo umount /media/linux/rootfs</span><br></pre></td></tr></table></figure><p>当然，你也可以不备份旧的内核，而是通过重命令编译出来的内核名称，如将编译出来的img改为kernel-new.img，然后修改config.txt的配置文件种的kernel字段,如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel=kernel-new.img</span><br></pre></td></tr></table></figure><p>这么做的好处是保证原有的内核不被破坏，如果新的内核无法启动，只需要将config.txt的kernel字段改回来即可。</p><p>最后，将TF卡插回Pi上，然后启动Pi即可。</p>]]></content>
      
      
      <categories>
          
          <category> 树莓派 </category>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> Linux开发 </tag>
            
            <tag> 树莓派 </tag>
            
            <tag> 交叉编译 </tag>
            
            <tag> 内核编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态库与动态库详解</title>
      <link href="/2022/01/01/test/%E6%A0%91%E8%8E%93%E6%B4%BE/%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/"/>
      <url>/2022/01/01/test/%E6%A0%91%E8%8E%93%E6%B4%BE/%E9%9D%99%E6%80%81%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="静态库与动态库-HQ"><a href="#静态库与动态库-HQ" class="headerlink" title="静态库与动态库 - HQ"></a>静态库与动态库 - HQ</h1><p>[TOC]</p><hr><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><a href="https://www.cnblogs.com/sunsky303/p/7731911.html">参考文章1 - 未摘录</a></li><li><a href="https://blog.csdn.net/wk_bjut_edu_cn/article/details/81735956">参考文章2 - 未摘录</a></li></ul><hr><h3 id="库的制作"><a href="#库的制作" class="headerlink" title="库的制作"></a>库的制作</h3><h4 id="静态库的制作"><a href="#静态库的制作" class="headerlink" title="静态库的制作"></a>静态库的制作</h4><p>格式  xxxx.a</p><ol><li><code>gcc calcufuncs.c -c</code> 生成xxx.o文件</li><li><code>ar rcs libcalcufunc.a calcufuncs.o</code> xxx.o文件生成xxx.a静态库文件</li></ol><h4 id="动态库的制作"><a href="#动态库的制作" class="headerlink" title="动态库的制作"></a>动态库的制作</h4><p>格式  xxxx.so</p><p><code>gcc -shared -fpic calcufuncs.c -o libcalc.so</code></p><blockquote><p>-shared 指定生成动态库</p><p>-fpic 标准，fPIC 选项作用于编译阶段,在生成目标文件时就得使用该选项,以生成位置无关的代码。</p></blockquote><h3 id="库的使用"><a href="#库的使用" class="headerlink" title="库的使用"></a>库的使用</h3><h4 id="静态库使用"><a href="#静态库使用" class="headerlink" title="静态库使用"></a>静态库使用</h4><p><code>gcc calculatorT.c -lcalcufunc -L ./ -o mainProStatic</code> </p><blockquote><p>-lcalcufunc -l（小写l）是指定要用的动态库，库名砍头去尾，只要用中间的名字</p><p>-L告诉gcc编译器从-L指定的路径去找静态库，默认是从&#x2F;usr&#x2F;lib &#x2F;usr&#x2F;local&#x2F;lib去找</p></blockquote><h4 id="动态库使用"><a href="#动态库使用" class="headerlink" title="动态库使用"></a>动态库使用</h4><p><code>gcc calculatorT.c -lcalc -L ./ -o mainProDy</code> </p><p>带动态库的程序，可以指定该程序运行时候，在LD_LIBRARY_PATH 所指定的路径去找库文件</p><p><code>export LD_LIBRARY_PATH=&quot;/home/pi/back/test&quot;</code></p><h3 id="linux动态库-so-搜索路径-目录-设置方法"><a href="#linux动态库-so-搜索路径-目录-设置方法" class="headerlink" title="linux动态库(.so)搜索路径(目录)设置方法"></a>linux动态库(.so)搜索路径(目录)设置方法</h3><p><strong>在Linux 中，动态库的搜索路径除了默认的搜索路径外，还可通过三种方法来指定：</strong></p><p>方法一：在配置文件&#x2F;etc&#x2F;ld.so.conf中指定动态库搜索路径；</p><p>方法二：通过环境变量LD_LIBRARY_PATH指定动态库搜索路径；</p><p>方法三：在编译目标代码时指定该程序的动态库搜索路径。</p><p>众所周知，&#x3D;&#x3D;Linux动态库的默认搜索路径是&#x2F;lib和&#x2F;usr&#x2F;lib&#x3D;&#x3D;。动态库被创建后，一般都复制到这两个目录中。</p><p>当程序执行时需要某动态库，并且该动 态库还未加载到内存中，则系统会自动到这两个默认搜索路径中去查找相应的动态库文件，然后加载该文件到内存中，这样程序就可以使用该动态库中的函数，以及该动态库的其它资源了。</p><p><strong>在Linux 中，动态库的搜索路径除了默认的搜索路径外，还可以通过以下三种方法来指定。</strong> </p><h4 id="方法一：在配置文件-etc-ld-so-conf中指定动态库搜索路径。"><a href="#方法一：在配置文件-etc-ld-so-conf中指定动态库搜索路径。" class="headerlink" title="方法一：在配置文件&#x2F;etc&#x2F;ld.so.conf中指定动态库搜索路径。"></a>方法一：在配置文件&#x2F;etc&#x2F;ld.so.conf中指定动态库搜索路径。</h4><p><code>vi /etc/ld.so.conf</code></p><p>添加 lib目录 ldconfig</p><h4 id="方法二：通过环境变量LD-LIBRARY-PATH指定动态库搜索路径。"><a href="#方法二：通过环境变量LD-LIBRARY-PATH指定动态库搜索路径。" class="headerlink" title="方法二：通过环境变量LD_LIBRARY_PATH指定动态库搜索路径。"></a>方法二：通过环境变量LD_LIBRARY_PATH指定动态库搜索路径。</h4><p><code>export LD_LIBRARY_PATH=”LD_LIBRARY_PATH:/opt/”</code></p><h4 id="方法三：在编译目标代码时指定该程序的动态库搜索路径。"><a href="#方法三：在编译目标代码时指定该程序的动态库搜索路径。" class="headerlink" title="方法三：在编译目标代码时指定该程序的动态库搜索路径。"></a>方法三：在编译目标代码时指定该程序的动态库搜索路径。</h4><p>还可以在编译目标代码时指定程序的动态库搜索路径。</p><p>通过gcc 的参数 ”-Wl,-rpath,” 指定</p><p>&#x3D;&#x3D;其中方法三可以避免安装部署的麻烦&#x3D;&#x3D;</p><p><strong>方法三示例</strong></p><p>假设main.cpp,hello.h,hello.cpp,其中main.cpp调用了hello类中的方法</p><p>1、生成hello.so</p><p> <code>g++ -shared hello.cpp -o libhello.so</code></p><p>2、编译main.cpp,并链接,并指定运行时libhello.so的位置</p><p> <code>g++ main.cpp -lhello -L./ -Wl,-rpath=./ -o main</code> </p><blockquote><p>值得一提的是,如果采用带版本号的库,例如libhello.so.2</p><p>链接命令可使用<code>g++ main.cpp libhello.so.2 -L./ -Wl,-rpath=./ -o main</code> </p></blockquote><p>3、加入第二个so库</p><p><code>g++ main.cpp -L./second/ -Wl,-rpath=./second/ -lsecond -L./hello/ -Wl,-rpath=./hello/ -lhello -o main</code></p><blockquote><p>ps,遇到过一个奇怪的问题,就是假设libhello.so还用到了libother.so,由于在&#x2F;etc&#x2F;ld.so.conf里配置错误了libother.so的目录路径,导致一直产生undefined reference to错误,但是在工程里对libother目录路径配置是正确的,有可能于查找路径顺序有关。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程技术 </category>
          
          <category> Linux开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态库 </tag>
            
            <tag> 动态库 </tag>
            
            <tag> Linux编程 </tag>
            
            <tag> 编译链接 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
