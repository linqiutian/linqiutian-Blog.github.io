<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>面试知识 | 林秋天的博客</title><meta name="author" content="LinQiuTian"><meta name="copyright" content="LinQiuTian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#F8F5F0"><meta name="description" content="C&#x2F;C++ 题目一个保险柜，密码是由 NOMONEY 组成的 7 位数字。每个字母对应的数字隐藏在下面的 10 进制加法算式中，相同的字母对应相同的数字，不同的字母对应不同的数字，数字范围 0-9，并且已知密码中没有 4。请解码密码。 1234	G I V E+ 	M O R E	  M O N E Y   M &#x3D; 1（因两四位数相加得五位数，最高位必为1）  G &#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="面试知识">
<meta property="og:url" content="https://www.linqiutianovo.xyz/2025/05/05/test/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="林秋天的博客">
<meta property="og:description" content="C&#x2F;C++ 题目一个保险柜，密码是由 NOMONEY 组成的 7 位数字。每个字母对应的数字隐藏在下面的 10 进制加法算式中，相同的字母对应相同的数字，不同的字母对应不同的数字，数字范围 0-9，并且已知密码中没有 4。请解码密码。 1234	G I V E+ 	M O R E	  M O N E Y   M &#x3D; 1（因两四位数相加得五位数，最高位必为1）  G &#x3D;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.linqiutianovo.xyz/img/data-structure-cover.jpg">
<meta property="article:published_time" content="2025-05-05T11:50:16.000Z">
<meta property="article:modified_time" content="2025-06-26T07:46:52.564Z">
<meta property="article:author" content="LinQiuTian">
<meta property="article:tag" content="面试知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.linqiutianovo.xyz/img/data-structure-cover.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "面试知识",
  "url": "https://www.linqiutianovo.xyz/2025/05/05/test/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/",
  "image": "https://www.linqiutianovo.xyz/img/data-structure-cover.jpg",
  "datePublished": "2025-05-05T11:50:16.000Z",
  "dateModified": "2025-06-26T07:46:52.564Z",
  "author": [
    {
      "@type": "Person",
      "name": "LinQiuTian",
      "url": "https://www.linqiutianovo.xyz/"
    }
  ]
}</script><link rel="shortcut icon" href="https://www.fomal.cc/favicon.ico"><link rel="canonical" href="https://www.linqiutianovo.xyz/2025/05/05/test/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.4.0-b1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#F8F5F0')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 18
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试知识',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/article-covers.css"><meta name="theme-color" content="#6C7A89"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><link rel="preload" href="/css/custom.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><link rel="preload" href="/css/universe.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><meta name="theme-color" content="#6C7A89"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><link rel="preconnect" href="https://s2.loli.net"><link rel="preconnect" href="https://i.loli.net"><link rel="preconnect" href="https://www.fomal.cc"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/url(https:/s2.loli.net/2024/08/07/EBzp91lhZCgXDI6.png));"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/08/07/KfPnTIM8WvotugL.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">62</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa-heart"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/data-structure-cover.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">林秋天的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">面试知识</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa-heart"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">面试知识</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-05T11:50:16.000Z" title="发表于 2025-05-05 19:50:16">2025-05-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-26T07:46:52.564Z" title="更新于 2025-06-26 15:46:52">2025-06-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/">面试知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">21.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>65分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-06-26 15:46:52&quot;}" hidden></div><h1 id="C-C-题目"><a href="#C-C-题目" class="headerlink" title="C&#x2F;C++ 题目"></a>C&#x2F;C++ 题目</h1><p>一个保险柜，密码是由 <code>NOMONEY</code> 组成的 7 位数字。每个字母对应的数字隐藏在下面的 10 进制加法算式中，相同的字母对应相同的数字，不同的字母对应不同的数字，数字范围 0-9，并且已知密码中没有 4。请解码密码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	G I V E</span><br><span class="line">+ 	M O R E</span><br><span class="line">	</span><br><span class="line">  M O N E Y</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>M &#x3D; 1</strong>（因两四位数相加得五位数，最高位必为1）</p>
</li>
<li><p><strong>G &#x3D; 9</strong>（9 + 1 &#x3D; 10，产生进位，满足五位数）</p>
</li>
<li><p><strong>O &#x3D; 0</strong>（千位相加：9 + 1 + 0 &#x3D; 10，进位后万位为1）</p>
</li>
<li><p><strong>E &#x3D; 8</strong>（个位：6 + 6 &#x3D; 12 → Y &#x3D; 2，进位1）</p>
</li>
<li><p><strong>Y &#x3D; 6</strong>（由E &#x3D; 8推导）</p>
</li>
<li><p><strong>V &#x3D; 5，R &#x3D; 2</strong>（十位：7 + 5 + 进位1 &#x3D; 13 → 进位1，E &#x3D; 6）  </p>
</li>
<li><p><strong>I &#x3D; 3</strong>（百位：8 + 进位1 &#x3D; 9 → N &#x3D; 9，但需调整后最终得出N &#x3D; 2）</p>
</li>
<li><p><strong>N &#x3D; 7</strong>（实际验证后调整）</p>
<p>答案不对 题目错了</p>
</li>
</ul>
<h4 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h4><p><strong>题目描述：</strong> 请用 C 语言写一个函数，实现如下功能：输入年、月、日，返回这一天是这一年的第几天？请注意算法的效率（空间时间）。</p>
<p><strong>答案：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dayOfYear</span><span class="params">(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">    <span class="type">int</span> daysInMonth[] = &#123;<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (m &gt; <span class="number">2</span> &amp;&amp; (y % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; y % <span class="number">100</span> != <span class="number">0</span> || y % <span class="number">400</span> == <span class="number">0</span>)) &#123;</span><br><span class="line">        daysInMonth[<span class="number">1</span>] = <span class="number">29</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> day = d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        day += daysInMonth[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> day;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h4><p><strong>题目描述：</strong> 什么样的代码是优美的？哪些好的习惯有助于提高代码质量？</p>
<p><strong>答案：</strong> 优美的代码通常具有以下特点：</p>
<ol>
<li><strong>可读性</strong>：代码结构清晰，命名规范，注释充分。</li>
<li><strong>简洁性</strong>：代码简洁，避免冗余，使用合适的数据结构和算法。</li>
<li><strong>可维护性</strong>：模块化设计，易于理解和修改。</li>
<li><strong>健壮性</strong>：代码能够处理异常情况，进行错误检查和处理。</li>
</ol>
<p>提高代码质量的好习惯包括：</p>
<ol>
<li><strong>代码审查</strong>：定期进行代码审查，发现并修复潜在问题。</li>
<li><strong>单元测试</strong>：编写单元测试，确保代码的正确性和稳定性。</li>
<li><strong>持续重构</strong>：定期重构代码，保持代码的简洁和可维护性。</li>
<li><strong>遵循编码规范</strong>：遵循团队或项目的编码规范，保持代码风格的一致性。</li>
</ol>
<h4 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h4><p><strong>题目描述：</strong> C 和 C++ 有哪些主要区别？</p>
<p><strong>答案：</strong> C 和 C++ 的主要区别包括：</p>
<ol>
<li><strong>面向过程 vs 面向对象</strong>：C 是面向过程的语言，而 C++ 支持面向对象编程。</li>
<li><strong>类和对象</strong>：C++ 支持类和对象，可以进行封装、继承和多态。</li>
<li><strong>标准模板库（STL）</strong>：C++ 提供了标准模板库，支持容器、算法和迭代器。</li>
<li><strong>异常处理</strong>：C++ 支持异常处理机制，而 C 使用错误码。</li>
<li><strong>命名空间</strong>：C++ 支持命名空间，避免命名冲突。</li>
<li><strong>构造函数和析构函数</strong>：C++ 支持构造函数和析构函数，进行资源管理。</li>
</ol>
<h4 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h4><p><strong>题目描述：</strong> 请从下面三个问题任选一个（15 分） a) 请描述 C++ 中各种智能指针（shared_ptr、auto_ptr、unique_ptr、weak_ptr）的适用场景及注意事项。 b) 请简述一下 Linux 中几种多路复用机制（select&#x2F;poll&#x2F;epoll）的优缺点对比。</p>
<p><strong>答案：</strong> a) C++ 中各种智能指针的适用场景及注意事项：</p>
<ul>
<li><strong>shared_ptr</strong>：适用于多个指针需要共享所有权的场景。注意事项：循环引用可能导致内存泄漏。</li>
<li><strong>auto_ptr</strong>：已在 C++11 中被弃用，不推荐使用。</li>
<li><strong>unique_ptr</strong>：适用于独占所有权的场景。注意事项：不能被复制，只能被移动。</li>
<li><strong>weak_ptr</strong>：用于解决 shared_ptr 的循环引用问题。注意事项：需要与 shared_ptr 配合使用。</li>
</ul>
<p>b) Linux 中几种多路复用机制的优缺点对比：</p>
<ul>
<li><strong>select</strong>：优点：简单易用。缺点：文件描述符数量有限，性能较差。</li>
<li><strong>poll</strong>：优点：没有文件描述符数量限制。缺点：性能仍然较差，尤其是在大量文件描述符的情况下。</li>
<li><strong>epoll</strong>：优点：性能优异，支持大量文件描述符。缺点：实现复杂，需要内核支持。</li>
</ul>
<h4 id="题目5"><a href="#题目5" class="headerlink" title="题目5"></a>题目5</h4><p><strong>题目描述：</strong> 翻译：When developing embedded software, you must consider the following:</p>
<ul>
<li>Understand the default compilation tool behavior and the target environment so that you appreciate the steps necessary to move from a debug or development build to a fully standalone production version of the application.</li>
<li>Some C library functionality executes by using debug environment resources. If used, you must implement this functionality to make use of target hardware.</li>
<li>The toolchain has no inherent knowledge of the memory map of any given target. You must tailor the image this functionality has no inherent knowledge of the memory map of the target hardware.</li>
<li>An embedded application must perform some initialization, such as stack and heap initialization, before the application can be run. A complete initialization sequence requires code that you implement in addition to the Arm Compiler C library initialization routines.</li>
</ul>
<p><strong>答案：</strong> 在开发嵌入式软件时，必须考虑以下几点：</p>
<ul>
<li>了解默认编译工具的行为和目标环境，以便理解从调试或开发版本迁移到完全独立的生产版本应用程序所需的步骤。</li>
<li>一些 C 库功能通过使用调试环境资源来执行。如果使用这些功能，您必须实现这些功能以利用目标硬件。</li>
<li>工具链对任何给定目标的内存映射没有固有的知识。您必须调整该功能对目标硬件内存映射的了解。</li>
<li>嵌入式应用程序必须执行一些初始化，例如堆栈和堆初始化，然后才能运行应用程序。完整的初始化序列需要您实现的代码，以补充 Arm 编译器 C 库初始化例程。</li>
</ul>
<h4 id="题目6"><a href="#题目6" class="headerlink" title="题目6"></a>题目6</h4><p><strong>题目描述：</strong> 找出下面代码中所有的错误以及不合理的地方，并请说明原因。（20 分）</p>
<ol>
<li><p>找出下面代码中所有的错误以及不合理的地方，并请说明原因。（20 分）</p>
<p>c</p>
<p>复制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    A() &#123; m_jCount = <span class="number">0</span>; &#125;</span><br><span class="line">    ~A() &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> m_jCount;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    B() : A() &#123; m_jCount = <span class="number">1</span>; &#125;</span><br><span class="line">    ~B()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    A* a = new B();</span><br><span class="line">    FILE* f;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>)</span><br><span class="line">        n = argv[<span class="number">0</span>];</span><br><span class="line">    <span class="type">char</span>* stuff = new <span class="type">char</span>[n];</span><br><span class="line">    f = fopen(<span class="string">&quot;c:\\abc\\aa.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    fread(f, n, stuff);</span><br><span class="line">    n = <span class="built_in">strlen</span>(stuff);</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(stuff, <span class="number">0</span>, <span class="number">20</span>, <span class="number">10</span>);</span><br><span class="line">    fwrite(f, <span class="number">1</span>, n, stuff);</span><br><span class="line">    delete stuff;</span><br><span class="line">    delete a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; stuff;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>答案：</strong> 代码中的错误和不合理之处包括：</p>
<ol>
<li><code>A* a = new B();</code>：<code>new B()</code> 应该使用 <code>new B</code>，而不是 <code>new B()</code>。</li>
<li><code>int m;</code>：变量 <code>m</code> 未初始化，可能导致未定义行为。</li>
<li><code>if (argc &gt; 1)</code>：如果 <code>argc</code> 小于等于 1，程序会直接返回 -1，没有进行任何处理。</li>
<li><code>char* stuff = new char[n];</code>：<code>new char[n]</code> 应该使用 <code>new char[n+1]</code>，并在最后添加一个空字符 <code>\0</code>。</li>
<li><code>memset(stuff, 0, 20, 10);</code>：<code>memset</code> 的第三个参数应该是要设置的字节数，而不是重复次数。</li>
<li><code>delete stuff;</code>：<code>delete</code> 应该使用 <code>delete[] stuff;</code>，因为 <code>stuff</code> 是一个数组。</li>
<li><code>cout &lt;&lt; stuff;</code>：<code>stuff</code> 可能包含未初始化的内存，直接输出可能导致未定义行为。</li>
</ol>
<p>这些错误和不合理之处需要修正以确保程序的正确性和稳定性。</p>
<h1 id="Uboot-引导嵌入式Linux操作系统启动的大概顺序是？"><a href="#Uboot-引导嵌入式Linux操作系统启动的大概顺序是？" class="headerlink" title="Uboot 引导嵌入式Linux操作系统启动的大概顺序是？"></a>Uboot 引导嵌入式Linux操作系统启动的大概顺序是？</h1><p>第一阶段：ROM code（芯片厂商内置的代码）初始化一些基本的时钟，从选定的设备中去加载FSBL的代码，并启动FSBL代码</p>
<p>第二阶段：FSBL first stage boot loader 完成时钟的初始化，初始化DDR，从选定的设备中去加载SSBL的代码，并启动SSBL代码</p>
<p>第三阶段：从外部储存或者网络中加载linux系统，通过启动动画向用户反馈启动过程，启动linux内核</p>
<p>第四阶段：linux内核初始化，挂载根文件系统，启动用户空间的init程序</p>
<p>最后进入到linux用户空间</p>
<h3 id="第一阶段：ROM-Code（芯片厂商内置的代码）"><a href="#第一阶段：ROM-Code（芯片厂商内置的代码）" class="headerlink" title="第一阶段：ROM Code（芯片厂商内置的代码）"></a>第一阶段：ROM Code（芯片厂商内置的代码）</h3><ul>
<li><strong>比喻</strong>：就像你刚睁开眼睛，身体还在床上，但你已经开始动脑子思考下一步要做什么。</li>
<li><strong>实际操作</strong>：计算机刚开机时，芯片里有一些预先写好的代码（ROM Code），这些代码会做一些最基本的事情，比如检查硬件是否正常，设置一些基本的时钟（就像你调整闹钟一样），然后从某个地方（比如硬盘或者USB）找到一个叫做FSBL（First Stage Boot Loader）的程序，并把它加载到内存里，然后开始运行这个程序。</li>
</ul>
<h3 id="第二阶段：FSBL（First-Stage-Boot-Loader）"><a href="#第二阶段：FSBL（First-Stage-Boot-Loader）" class="headerlink" title="第二阶段：FSBL（First Stage Boot Loader）"></a>第二阶段：FSBL（First Stage Boot Loader）</h3><ul>
<li><strong>比喻</strong>：你从床上爬起来，开始穿衣服，准备出门。</li>
<li><strong>实际操作</strong>：FSBL程序接手后，会做一些更具体的事情，比如初始化DDR（一种内存，就像你整理书包一样），设置更精确的时钟（就像你调整手表时间），然后从某个地方找到SSBL（Second Stage Boot Loader）的代码，加载到内存里，并开始运行SSBL。</li>
</ul>
<h3 id="第三阶段：加载Linux系统"><a href="#第三阶段：加载Linux系统" class="headerlink" title="第三阶段：加载Linux系统"></a>第三阶段：加载Linux系统</h3><ul>
<li><strong>比喻</strong>：你出门去学校，路上可能会看看风景，听听音乐，这些都是你在路上的“启动动画”。</li>
<li><strong>实际操作</strong>：SSBL程序会从外部存储设备（比如硬盘）或者网络中找到Linux系统的代码，加载到内存里。在这个过程中，可能会有一些启动动画显示给用户，让用户知道计算机正在启动，就像你在路上看到的风景一样。最后，Linux内核（计算机的大脑）开始运行。</li>
</ul>
<h3 id="第四阶段：Linux内核初始化"><a href="#第四阶段：Linux内核初始化" class="headerlink" title="第四阶段：Linux内核初始化"></a>第四阶段：Linux内核初始化</h3><ul>
<li><strong>比喻</strong>：你到了学校，开始上课，老师开始讲解课程内容。</li>
<li><strong>实际操作</strong>：Linux内核开始运行后，会初始化各种系统功能，比如挂载根文件系统（就像老师准备好教材一样），然后启动用户空间的init程序（就像老师开始讲解课程内容）。这个init程序就像是计算机的“老师”，它会启动其他各种程序和服务，让计算机能够正常工作。</li>
</ul>
<h3 id="最后：进入Linux用户空间"><a href="#最后：进入Linux用户空间" class="headerlink" title="最后：进入Linux用户空间"></a>最后：进入Linux用户空间</h3><ul>
<li><strong>比喻</strong>：你开始认真听讲，参与课堂活动。</li>
<li><strong>实际操作</strong>：当init程序启动完成后，计算机就进入了用户空间，这意味着用户可以开始使用计算机了，就像你开始参与课堂活动一样。用户可以打开各种应用程序，进行各种操作。</li>
</ul>
<h1 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h1><p>1、栈区是系统自动申请自动释放，且空间较小</p>
<p>2、堆区是需要手动申请，手动释放，空间较大</p>
<p>3、栈区常用来存放局部变量等</p>
<p>4、堆区常用来存放全局变量等</p>
<p>5、栈的空间是连续的，而堆不是</p>
<h3 id="1-栈区（Stack）"><a href="#1-栈区（Stack）" class="headerlink" title="1. 栈区（Stack）"></a>1. 栈区（Stack）</h3><ul>
<li><strong>比喻</strong>：想象你有一个书桌，书桌上有一个固定的区域用来放书本和文具。每次你写作业的时候，就会在这个区域放一些书本、笔记本和铅笔。写完作业后，你就会把这些东西收起来，这个区域又变得干净了。</li>
<li><strong>实际操作</strong>：<ul>
<li><strong>自动申请和释放</strong>：栈区是由系统自动管理的。当你在函数中定义局部变量（比如<code>int a = 5;</code>）时，系统会自动在栈区分配一小块空间来存储这个变量。当函数执行完毕后，系统会自动清理这块空间。</li>
<li><strong>空间较小</strong>：栈区的空间相对较小，通常只有几MB。</li>
</ul>
</li>
</ul>
<h3 id="2-堆区（Heap）"><a href="#2-堆区（Heap）" class="headerlink" title="2. 堆区（Heap）"></a>2. 堆区（Heap）</h3><ul>
<li><strong>比喻</strong>：想象你有一个大仓库，这个仓库可以用来放各种各样的东西，比如家具、玩具、书籍等。你需要的时候可以随时往里面放东西，用完之后也可以随时拿出来。</li>
<li><strong>实际操作</strong>：<ul>
<li><strong>手动申请和释放</strong>：堆区是由程序员手动管理的。当你需要一个较大的空间来存储数据（比如一个大的数组或者一个复杂的数据结构）时，你需要手动申请这块空间（比如用<code>malloc</code>函数）。用完之后，也需要手动释放这块空间（比如用<code>free</code>函数）。</li>
<li><strong>空间较大</strong>：堆区的空间相对较大，通常可以达到几百MB甚至更多。</li>
<li><strong>用途</strong>：堆区常用来存放动态分配的变量，比如全局变量、动态数组等。</li>
</ul>
</li>
</ul>
<h3 id="3-栈区常用来存放局部变量"><a href="#3-栈区常用来存放局部变量" class="headerlink" title="3. 栈区常用来存放局部变量"></a>3. 栈区常用来存放局部变量</h3><ul>
<li><strong>比喻</strong>：你在书桌上写作业，每次写作业都会用到一些书本和文具，这些就是局部变量。写完作业后，这些书本和文具就被收起来了。</li>
<li><strong>实际操作</strong>：在函数中定义的变量（局部变量）通常存放在栈区。这些变量在函数执行期间有效，函数执行完毕后，这些变量就会被自动清理。</li>
</ul>
<h3 id="4-堆区常用来存放全局变量等"><a href="#4-堆区常用来存放全局变量等" class="headerlink" title="4. 堆区常用来存放全局变量等"></a>4. 堆区常用来存放全局变量等</h3><ul>
<li><strong>比喻</strong>：你在仓库里放了一些家具和玩具，这些是你长期需要的东西，不会轻易拿出来。这些就是全局变量。</li>
<li><strong>实际操作</strong>：全局变量和动态分配的变量（比如用<code>malloc</code>分配的内存）通常存放在堆区。这些变量在程序的整个运行过程中都有效，直到你手动释放它们。</li>
</ul>
<h3 id="5-栈的空间是连续的，而堆不是"><a href="#5-栈的空间是连续的，而堆不是" class="headerlink" title="5. 栈的空间是连续的，而堆不是"></a>5. 栈的空间是连续的，而堆不是</h3><ul>
<li><strong>比喻</strong>：你的书桌是一个固定的区域，所有的东西都放在一起，空间是连续的。而仓库里的东西可以放在不同的地方，空间是不连续的。</li>
<li><strong>实际操作</strong>：<ul>
<li><strong>栈区</strong>：栈区的空间是连续的，系统会自动管理这块空间，确保每次分配和释放都是连续的。</li>
<li><strong>堆区</strong>：堆区的空间是不连续的，因为堆区是由程序员手动管理的，每次申请和释放的空间可能在不同的位置。</li>
</ul>
</li>
</ul>
<h1 id="什么是野指针，产后的原因是什么"><a href="#什么是野指针，产后的原因是什么" class="headerlink" title="什么是野指针，产后的原因是什么"></a>什么是野指针，产后的原因是什么</h1><p>1、野指针是指向位置是随机的且不正确的</p>
<p>2、产生原因  定义时未初始化，指向位置随机</p>
<p>或者在释放时没有指向null，从而指向垃圾内存</p>
<h3 id="1-什么是野指针？"><a href="#1-什么是野指针？" class="headerlink" title="1. 什么是野指针？"></a>1. 什么是野指针？</h3><p><strong>比喻</strong>：想象你手里拿着一张地图，但地图上的地址是乱写的，或者地图根本就没有地址，你按照这个地图去寻找某个地方，很可能就会迷失方向，甚至走到一个完全错误的地方。</p>
<p><strong>实际操作</strong>：</p>
<ul>
<li><strong>野指针</strong>：在编程中，指针是一个变量，它用来存储另一个变量的内存地址。如果一个指针指向了一个随机的、不正确的内存地址，或者指向了一个已经被释放的内存地址，这个指针就被称为“野指针”。</li>
<li><strong>野指针的危害</strong>：野指针可能会导致程序访问到错误的内存区域，从而引发程序崩溃、数据损坏等不可预测的问题。</li>
</ul>
<h3 id="2-产生原因"><a href="#2-产生原因" class="headerlink" title="2. 产生原因"></a>2. 产生原因</h3><h4 id="1-定义时未初始化"><a href="#1-定义时未初始化" class="headerlink" title="1. 定义时未初始化"></a>1. 定义时未初始化</h4><p><strong>比喻</strong>：你手里拿着一张地图，但地图上没有写地址，你不知道它指向哪里，所以你可能会走到一个完全错误的地方。</p>
<p><strong>实际操作</strong>：</p>
<ul>
<li><p>当你定义了一个指针变量，但没有给它一个具体的地址时，这个指针变量的值是随机的。比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr; <span class="comment">// 没有初始化，ptr的值是随机的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这个随机的值可能指向一个完全错误的内存地址，这就是野指针。</p>
</li>
</ul>
<h4 id="2-释放后未指向NULL"><a href="#2-释放后未指向NULL" class="headerlink" title="2. 释放后未指向NULL"></a>2. 释放后未指向NULL</h4><p><strong>比喻</strong>：你手里拿着一张地图，地图上写了一个地址，但这个地址的房子已经被拆掉了。你按照这个地图去寻找，可能会走到一个空地，或者一个完全不同的地方。</p>
<p><strong>实际操作</strong>：</p>
<ul>
<li><p>当你用<code>malloc</code>等函数分配了一块内存，并用一个指针变量指向它，然后释放了这块内存，但没有把指针变量设置为<code>NULL</code>，这个指针变量就会变成野指针。比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配内存</span></span><br><span class="line"><span class="built_in">free</span>(ptr); <span class="comment">// 释放内存</span></span><br><span class="line"><span class="comment">// 此时ptr仍然指向原来的内存地址，但这块内存已经被释放了</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果你继续使用<code>ptr</code>，它就会指向一个已经被释放的内存地址，这就是野指针。</p>
</li>
</ul>
<h2 id="如何避免野指针的问题"><a href="#如何避免野指针的问题" class="headerlink" title="如何避免野指针的问题"></a>如何避免野指针的问题</h2><h3 id="1-初始化指针"><a href="#1-初始化指针" class="headerlink" title="1. 初始化指针"></a>1. 初始化指针</h3><p><strong>建议</strong>：在定义指针时，始终初始化指针为<code>NULL</code>或指向一个有效的地址。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="literal">NULL</span>; <span class="comment">// 初始化为NULL</span></span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;value; <span class="comment">// 初始化为一个有效的地址</span></span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：初始化为<code>NULL</code>可以让你在后续使用指针时，通过检查是否为<code>NULL</code>来避免使用未初始化的指针。</p>
<h3 id="2-释放内存后将指针置为NULL"><a href="#2-释放内存后将指针置为NULL" class="headerlink" title="2. 释放内存后将指针置为NULL"></a>2. 释放内存后将指针置为<code>NULL</code></h3><p><strong>建议</strong>：在释放动态分配的内存后，立即将指针置为<code>NULL</code>。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用ptr</span></span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">ptr = <span class="literal">NULL</span>; <span class="comment">// 释放内存后将指针置为NULL</span></span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：这样可以避免指针继续指向已经被释放的内存，从而防止野指针的产生。</p>
<h3 id="3-检查指针是否为NULL"><a href="#3-检查指针是否为NULL" class="headerlink" title="3. 检查指针是否为NULL"></a>3. 检查指针是否为<code>NULL</code></h3><p><strong>建议</strong>：在使用指针之前，始终检查指针是否为<code>NULL</code>。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用ptr</span></span><br><span class="line">*ptr = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">ptr = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：通过检查指针是否为<code>NULL</code>，可以避免对未初始化或已经释放的指针进行操作。</p>
<h3 id="4-使用智能指针（C-）"><a href="#4-使用智能指针（C-）" class="headerlink" title="4. 使用智能指针（C++）"></a>4. 使用智能指针（C++）</h3><p><strong>建议</strong>：如果你使用的是C++，尽量使用智能指针（如<code>std::unique_ptr</code>或<code>std::shared_ptr</code>）来管理动态内存。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 使用ptr</span></span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：智能指针会自动管理内存的分配和释放，避免手动管理内存带来的风险。</p>
<h3 id="5-避免重复释放"><a href="#5-避免重复释放" class="headerlink" title="5. 避免重复释放"></a>5. 避免重复释放</h3><p><strong>建议</strong>：确保内存只被释放一次，避免重复释放。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">// 处理内存分配失败的情况</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用ptr</span></span><br><span class="line"><span class="built_in">free</span>(ptr);</span><br><span class="line">ptr = <span class="literal">NULL</span>; <span class="comment">// 释放内存后将指针置为NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免重复释放</span></span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：通过将指针置为<code>NULL</code>，可以避免重复释放的问题。</p>
<h3 id="6-使用工具检测野指针"><a href="#6-使用工具检测野指针" class="headerlink" title="6. 使用工具检测野指针"></a>6. 使用工具检测野指针</h3><p><strong>建议</strong>：使用内存检测工具（如<code>valgrind</code>）来检测野指针和内存泄漏问题。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind ./your_program</span><br></pre></td></tr></table></figure>

<p><strong>解释</strong>：<code>valgrind</code>等工具可以检测内存访问错误，帮助你发现野指针问题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p><strong>野指针</strong>：指向一个随机的、不正确的内存地址的指针。</p>
</li>
<li><p><strong>产生原因</strong>：</p>
<ol>
<li><strong>定义时未初始化</strong>：指针变量没有被赋予一个具体的地址，它的值是随机的。</li>
<li><strong>释放后未指向NULL</strong>：指针变量指向的内存被释放了，但指针变量没有被设置为<code>NULL</code>，它仍然指向原来的内存地址。</li>
</ol>
</li>
</ul>
<h1 id="dma有什么用"><a href="#dma有什么用" class="headerlink" title="dma有什么用"></a>dma有什么用</h1><p>主要是起一个搬运数据的作用，搬运通道可以时从外设到寄存器，外设到外设，寄存器到外设。</p>
<p>官方回答：DMA是在专门的硬件（ DMA）控制下，实现高速外设和主存储器之间自动成批交换数据尽量减少CPU干预的输入&#x2F;输出操作方式。主要作用就是减少CPU的负担。</p>
<h1 id="进程间通信的方法"><a href="#进程间通信的方法" class="headerlink" title="进程间通信的方法"></a>进程间通信的方法</h1><p>管道（有名管道和无名管道）</p>
<p>消息队列</p>
<p>共享内存</p>
<p>信号</p>
<p>信号量  </p>
<p>套接字</p>
<h1 id="程序中的内存分配方法"><a href="#程序中的内存分配方法" class="headerlink" title="程序中的内存分配方法"></a>程序中的内存分配方法</h1><p>连续分配，分段，分页，段页式</p>
<h1 id="定时器的作用和优势"><a href="#定时器的作用和优势" class="headerlink" title="定时器的作用和优势"></a>定时器的作用和优势</h1><p>作用：定时器，延时，PWM（输出比较），捕获输入（解码和时间测量），触发中断，单脉冲输出</p>
<p>优势：不需要cpu参与，精准</p>
<h1 id="已知单片机内置12位精度的ADC"><a href="#已知单片机内置12位精度的ADC" class="headerlink" title="已知单片机内置12位精度的ADC"></a>已知单片机内置12位精度的ADC</h1><p>单片机工作电压3.3V，ADC基准电压3V，请计算ADC采样的电压最小分辨率是多少？如果单片机ADC输入口电压为1V，则采样得到的值是多少？</p>
<p>只看基准电压即可</p>
<p>当ADC满量程4095时应该是输入的基准电压3V </p>
<p> 电压最小分辨率为3&#x2F;4095 V </p>
<p> 采样值为1&#x2F;3*4095 </p>
<h1 id="同步通信和异步通信有什么区别？全双工和半双工以及单工有什么区别？UART、SPI和I2C分别属于什么类型的通信方式？"><a href="#同步通信和异步通信有什么区别？全双工和半双工以及单工有什么区别？UART、SPI和I2C分别属于什么类型的通信方式？" class="headerlink" title="同步通信和异步通信有什么区别？全双工和半双工以及单工有什么区别？UART、SPI和I2C分别属于什么类型的通信方式？"></a>同步通信和异步通信有什么区别？全双工和半双工以及单工有什么区别？UART、SPI和I2C分别属于什么类型的通信方式？</h1><p>同步通信：需要时钟线，且双方的时钟频率要相同，在规定的时间内完成对数据的发送</p>
<p>异步通信：不需要时钟线，所以在传输的时候前后必需加上</p>
<p>全双工：两条通道任意时候都可以进行数据的接收和发送，通常四根线，如下图</p>
<p>半双工：两条通道可以进行数据的接收和发送，但是同一时间只能进行接收或者发送，通常是两根线</p>
<p>单工：只能单独一条通道进行数据单方向的传输（只发送或者只接受），通常只有一根线</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/1705922741622-ded4405c-7d26-4449-9e33-96e2d0e4f572.webp" alt="img"></p>
<p>UART：异步通信的全双工 </p>
<p>USART：比UART多一根时钟线，所以是同步通信的全双工</p>
<p>IIC：同步通信的半双工</p>
<p>SPI：同步通信的全双工</p>
<hr>
<h1 id="FreeRTOS-在智能语音台灯项目中的应用"><a href="#FreeRTOS-在智能语音台灯项目中的应用" class="headerlink" title="FreeRTOS 在智能语音台灯项目中的应用"></a><strong>FreeRTOS 在智能语音台灯项目中的应用</strong></h1><p>在智能语音台灯项目中，FreeRTOS 被广泛应用于多个关键环节，以优化任务调度、提高系统响应速度和稳定性。以下是 FreeRTOS 在项目中的具体应用：</p>
<h3 id="1-任务调度"><a href="#1-任务调度" class="headerlink" title="1. 任务调度"></a>1. <strong>任务调度</strong></h3><p>智能语音台灯项目包含多个功能模块，每个模块都可以作为一个任务运行在 FreeRTOS 上。通过 FreeRTOS 的任务调度功能，可以确保这些任务高效、有序地运行。例如：</p>
<ul>
<li><strong>语音控制任务</strong>：高优先级任务，负责实时响应用户的语音指令。</li>
<li><strong>疲劳检测任务</strong>：中高优先级任务，定期检测用户的面部姿态和疲劳程度。</li>
<li><strong>坐姿提醒任务</strong>：中优先级任务，通过超声波传感器检测用户的坐姿并提醒。</li>
<li><strong>环境监测任务</strong>：中优先级任务，定期读取光照传感器、温湿度传感器的数据。</li>
<li><strong>智能控光任务</strong>：低优先级任务，根据环境光照强度自动调节灯光亮度。</li>
<li><strong>数据记录任务</strong>：低优先级任务，负责记录用户的使用习惯和设备运行状态。</li>
</ul>
<p>通过 FreeRTOS 的任务调度器，可以根据任务的优先级动态分配 CPU 时间，确保高优先级任务能够及时响应，低优先级任务在系统空闲时运行。</p>
<h3 id="2-任务间通信"><a href="#2-任务间通信" class="headerlink" title="2. 任务间通信"></a>2. <strong>任务间通信</strong></h3><p>在多任务环境中，不同任务之间需要进行数据交换。FreeRTOS 提供了多种任务间通信机制，如队列、信号量、事件组等。在智能语音台灯项目中，这些机制被用于：</p>
<ul>
<li><strong>疲劳检测与语音提醒</strong>：疲劳检测任务检测到用户疲劳后，通过队列向语音控制任务发送消息，语音控制任务接收到消息后播放舒缓音乐并提醒用户休息。</li>
<li><strong>环境监测与智能控光</strong>：环境监测任务定期读取光照传感器数据，并通过队列将数据发送给智能控光任务，智能控光任务根据这些数据调整灯光亮度。</li>
<li><strong>坐姿提醒与语音提醒</strong>：坐姿提醒任务检测到用户坐姿不正确时，通过信号量通知语音控制任务，语音控制任务发出语音提示。</li>
</ul>
<h3 id="3-资源管理"><a href="#3-资源管理" class="headerlink" title="3. 资源管理"></a>3. <strong>资源管理</strong></h3><p>智能语音台灯项目中涉及多个硬件资源，如 GPIO 引脚、通信接口等。FreeRTOS 的互斥量（Mutex）可以用于保护这些共享资源，防止多个任务同时访问导致的冲突。例如：</p>
<ul>
<li><strong>GPIO 引脚</strong>：多个任务可能需要访问同一个 GPIO 引脚（如控制灯光开关的引脚），通过互斥量可以确保一次只有一个任务能够访问该引脚。</li>
<li><strong>通信接口</strong>：如 I2C 接口，多个任务可能需要通过 I2C 接口与传感器通信，互斥量可以防止通信冲突。</li>
</ul>
<h3 id="4-时间管理"><a href="#4-时间管理" class="headerlink" title="4. 时间管理"></a>4. <strong>时间管理</strong></h3><p>FreeRTOS 提供了时间管理功能，如延时、定时器等。在智能语音台灯项目中，这些功能被用于：</p>
<ul>
<li><strong>定时任务</strong>：环境监测任务可以使用 FreeRTOS 的定时器功能，每隔一定时间读取光照传感器的值，并根据读取结果调整灯光亮度。</li>
<li><strong>延时操作</strong>：语音控制任务在播放音乐或语音提示时，可能需要延时操作，FreeRTOS 的延时功能可以确保任务在指定的时间后继续执行。</li>
</ul>
<h3 id="5-内存管理"><a href="#5-内存管理" class="headerlink" title="5. 内存管理"></a>5. <strong>内存管理</strong></h3><p>FreeRTOS 提供了多种内存管理策略，可以根据项目的实际需求进行选择。在智能语音台灯项目中，可以使用静态内存分配策略，减少动态内存分配带来的碎片化和延迟。例如：</p>
<ul>
<li><strong>静态任务栈分配</strong>：为每个任务分配固定大小的栈空间，避免动态分配栈空间带来的开销。</li>
<li><strong>静态队列分配</strong>：为队列分配固定大小的内存，避免动态分配内存带来的开销。</li>
</ul>
<h3 id="6-系统稳定性与调试"><a href="#6-系统稳定性与调试" class="headerlink" title="6. 系统稳定性与调试"></a>6. <strong>系统稳定性与调试</strong></h3><p>FreeRTOS 提供了丰富的调试工具和功能，可以帮助开发人员监控任务的执行情况，识别瓶颈，优化系统性能。例如：</p>
<ul>
<li><strong>任务状态监控</strong>：通过 FreeRTOS 提供的调试工具，可以实时监控任务的运行状态、CPU 占用率等信息。</li>
<li><strong>上下文切换分析</strong>：使用 Tracealyzer 等工具，可以分析任务的上下文切换情况，优化任务调度。</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>在智能语音台灯项目中，FreeRTOS 被广泛应用于任务调度、任务间通信、资源管理、时间管理、内存管理以及系统调试等多个方面。通过 FreeRTOS 的这些功能，项目能够实现高效的任务管理、稳定的系统运行和良好的用户体验。</p>
<hr>
<h3 id="回答示例"><a href="#回答示例" class="headerlink" title="回答示例"></a><strong>回答示例</strong></h3><p>如果面试官问你：“FreeRTOS 在智能语音台灯项目中用在哪里了？”你可以这样回答：</p>
<p>“在智能语音台灯项目中，FreeRTOS 被用于多个关键环节，以优化任务调度、提高系统响应速度和稳定性。具体来说：</p>
<ol>
<li><strong>任务调度</strong>：FreeRTOS 的任务调度器确保了语音控制、疲劳检测、坐姿提醒、环境监测和智能控光等任务能够高效、有序地运行。</li>
<li><strong>任务间通信</strong>：通过队列和信号量，实现了疲劳检测与语音提醒、环境监测与智能控光、坐姿提醒与语音提醒等任务之间的数据交换。</li>
<li><strong>资源管理</strong>：使用互斥量保护了 GPIO 引脚和通信接口等共享资源，防止任务间的冲突。</li>
<li><strong>时间管理</strong>：利用 FreeRTOS 的定时器功能，实现了环境监测任务的定时执行和语音控制任务的延时操作。</li>
<li><strong>内存管理</strong>：采用静态内存分配策略，减少了动态内存分配带来的开销和碎片化。</li>
<li><strong>系统调试</strong>：通过 FreeRTOS 提供的调试工具，监控任务的执行情况，优化系统性能。</li>
</ol>
<h1 id="RTOS的调度机制"><a href="#RTOS的调度机制" class="headerlink" title="RTOS的调度机制"></a>RTOS的调度机制</h1><p>应用了FreeRTOS，实现了多任务并发。RTOS的核心调度机制是基于优先级的抢占式调度。每个任务根据其优先级被调度器动态分配CPU资源，高优先级任务可随时打断低优先级任务，确保关键任务实时响应。项目中，我合理分配了传感器采集、语音处理、自动调光等任务的优先级，并利用信号量与互斥锁保障数据同步与资源互斥，极大提升了系统的响应速度和稳定性。</p>
<h1 id="灯心智启”智能语音台灯项目中-优先级"><a href="#灯心智启”智能语音台灯项目中-优先级" class="headerlink" title="灯心智启”智能语音台灯项目中 优先级"></a>灯心智启”智能语音台灯项目中 优先级</h1><p>首先，我根据任务的实时性需求和重要程度进行分级。例如，语音交互和自动调光属于强实时任务，我将其优先级设置为最高，确保用户操作和环境变化能在毫秒级内响应。其次，传感器数据采集、摄像头检测等周期性任务设为中等优先级，保证数据流畅采集但不抢占关键任务资源。最后，APP&#x2F;小程序远程控制和数据上传等非实时任务则设置为较低优先级，利用系统空闲时间处理。</p>
<h1 id="stm32启动流程"><a href="#stm32启动流程" class="headerlink" title="stm32启动流程"></a>stm32启动流程</h1><p>STM32 启动流程严格遵循：上电&#x2F;复位 → 启动文件 → 堆栈初始化 → 数据段初始化 → 时钟配置 → C 库初始化 → 进入 main 函数。</p>
<p><strong>1. 复位与上电</strong><br>当 STM32 上电或复位后，处理器会将程序计数器（PC）设置为启动地址。</p>
<p><strong>2. 启动代码执行</strong><br>芯片首先跳转到存储在 <code>0x00000004</code> 地址的复位中断向量（Reset Handler）。这个地址里存放的就是启动函数的入口（通常是 startup_xx.s 汇编文件中的 Reset_Handler）。</p>
<p><strong>3. 堆栈初始化</strong><br>在复位中断处理函数（Reset_Handler）中，首先会初始化主堆栈指针（MSP），确保栈空间可用。</p>
<p><strong>4. 数据段和 BSS 段初始化</strong></p>
<ul>
<li>将 Flash 中的已初始化全局变量复制到 RAM（data 段初始化）。</li>
<li>清零未初始化的全局变量和静态变量（bss 段初始化）。</li>
</ul>
<p><strong>5. 系统时钟配置</strong><br>执行 <code>SystemInit()</code> 函数，完成系统时钟（HSE、PLL 等）和外设时钟的配置。</p>
<p><strong>6. 进入 main 函数</strong><br>所有初始化完成后，程序跳转到 <code>main()</code> 函数，开始用户应用程序。</p>
<p>首先，芯片上电或复位后，程序从复位向量（Reset Vector）开始执行，跳转到启动文件（startup.s）的复位处理函数。<br>接着，启动代码会完成堆栈指针初始化、系统时钟配置，然后将.data段的数据从Flash拷贝到SRAM，并清零.bss段，确保全局变量和静态变量的初始值正确。<br>随后，启动文件会调用C库的初始化函数（如__libc_init_array），为C语言环境做准备。<br>最后，所有初始化完成后，程序跳转到main函数，正式进入用户代码逻辑。</p>
<h1 id="Linux系统启动流程"><a href="#Linux系统启动流程" class="headerlink" title="Linux系统启动流程"></a>Linux系统启动流程</h1><p>首先，处理器上电后会执行ROM代码，检测启动引脚，选择启动介质，并加载第一阶段引导程序FSBL（First Stage Boot Loader）。</p>
<p>随后，初始化外部RAM控制器   FSBL负责初始化时钟和外部DDR内存，为后续大容量代码运行做准备，并将SSBL（Second Stage Boot Loader）加载到DDR中。</p>
<ul>
<li>FSBL 代码初始化时钟树、初始化外部RAM控制器，也就是DDR。最终FSBL将SSBL加载到DDR里面并运行SSBL代码。</li>
<li>DDR的全称其实是DDR SDRAM。所以在介绍DDR之前，得先了解什么是SDRAM。</li>
<li>SDRAM（同步动态随机存取内）可以看作一种特殊的DRAM（动态随机存取内存），我们平时说的计算机内存条就是一种DRAM。</li>
<li>SDRAM除了异步接口，还多了一个同步接口。同步接口需要数据发送方和接收方有一个统一的时钟信号，技术相对复杂，相应的传输速率和并发度都更高。</li>
</ul>
<p>第三步，SSBL（通常为u-boot）在DDR中运行，功能更全面，包括使能USB、网络、显示等外设，并灵活加载Linux内核，比如从Flash或网络中获取。第四步，u-boot将Linux内核加载到DDR并启动，内核会初始化各类硬件驱动，挂载根文件系统。</p>
<p>最后，内核启动用户空间的init进程，进一步初始化根文件系统和各类服务，系统进入多进程用户空间环境。</p>
<h1 id="linux内核启动后进入命令行流程"><a href="#linux内核启动后进入命令行流程" class="headerlink" title="linux内核启动后进入命令行流程"></a>linux内核启动后进入命令行流程</h1><p>首先，系统上电后，U-Boot等引导程序负责加载Linux内核和设备树到内存，并启动内核。内核启动后会进行硬件初始化，包括内存管理、CPU、外设驱动加载等。在这一过程中，我配置了设备树，确保各类外设能被正确识别和初始化，提升了系统兼容性和启动速度。</p>
<p>接下来，内核会挂载根文件系统（rootfs），这是命令行环境的基础。我针对项目需求，定制和优化了根文件系统内容，确保所需驱动和应用均能正常启动。</p>
<p>随后，内核会启动第一个用户空间进程，即init进程（通常为&#x2F;sbin&#x2F;init或systemd）。init进程根据配置文件（如inittab或systemd服务单元）依次启动各类系统服务和shell环境。最终，系统进入登录界面，用户即可访问命令行。</p>
<h1 id="stm32和嵌入式liunx的区别"><a href="#stm32和嵌入式liunx的区别" class="headerlink" title="stm32和嵌入式liunx的区别"></a>stm32和嵌入式liunx的区别</h1><p>分别在STM32和嵌入式Linux平台上开发过完整的应用。二者在代码层面并不完全互通。STM32多为裸机或RTOS环境，代码通常直接操作寄存器和外设，依赖于HAL库或底层驱动。而嵌入式Linux则基于操作系统，代码结构更偏向多进程、多线程，常用标准库和系统调用。</p>
<p>虽然两者都支持C，但如GPIO、串口、I2C等外设的操作接口和驱动方式差异较大，移植时需要针对平台进行适配。例如，在“灯心智启”项目中，我为STM32独立编写了底层驱动，而在Linux MQTT智能家居系统中，则需要通过设备树和内核驱动实现外设控制。</p>
<p>STM32通常运行裸机程序或RTOS，资源有限，主要通过直接操作寄存器和外设，适合对实时性和低功耗要求高的场景。例如在“灯心智启”项目中，STM32作为主控，负责传感器采集和实时控制，系统启动速度快，响应延迟低至毫秒级。</p>
<p>嵌入式Linux如IMX6ULL PRO平台，具备更强的处理能力和丰富的外设支持，能够运行多进程、多线程，支持QT图形界面、网络协议栈等复杂应用。在Linux MQTT智能家居系统项目中，我通过驱动开发和应用移植，实现了远程控制和多任务并发，</p>
<h1 id="can的负载率计算"><a href="#can的负载率计算" class="headerlink" title="can的负载率计算"></a>can的负载率计算</h1><p>CAN总线的负载率计算是进行系统性能评估的关键环节。以我在STM32平台集成多种传感器的数据采集和通信为例，CAN负载率的计算公式是：</p>
<p><strong>负载率 &#x3D; 实际传输的数据量 &#x2F; CAN总线最大传输能力 × 100%</strong></p>
<p>具体来说，需要统计单位时间内所有CAN帧的总位数（包括数据帧、控制帧等），然后除以CAN总线的理论带宽。例如，若CAN总线速率为500kbps，1秒内实际发送了20000帧，每帧128位，则负载率为：(20000 × 128) &#x2F; (500,000 × 1) ≈ 5.12%。通过准确计算负载率，我能有效预判系统瓶颈，保障通信实时性和稳定性</p>
<h1 id="IIC和CAN发送消息"><a href="#IIC和CAN发送消息" class="headerlink" title="IIC和CAN发送消息"></a>IIC和CAN发送消息</h1><p>IIC发送消息时，首先主设备发起起始信号，发送从设备地址并等待应答，随后按照协议顺序发送数据字节，每发送一个字节都需等待从设备应答，最后由主设备发送停止信号完成通信。在“灯心智启”项目中，我用STM32的IIC接口与多种传感器通信，优化了IIC驱动，传感器数据采集效率提升了约15%。</p>
<p>CAN发送消息则更适用于多节点高可靠通信。发送流程包括配置CAN控制器、设置报文标识符（ID）和数据、请求发送，CAN控制器自动完成仲裁和错误检测，确保数据可靠送达目标节点。在Linux MQTT智能家居系统项目中，我曾在IMX6ULL平台下调试过CAN驱动，确保多设备间数据同步，系统稳定性提升明显。</p>
<h1 id="IIC和CAN的仲裁"><a href="#IIC和CAN的仲裁" class="headerlink" title="IIC和CAN的仲裁"></a>IIC和CAN的仲裁</h1><p>IIC总线采用“线与”逻辑进行仲裁。当多个主机同时发起通信时，谁先在SDA线上发送低电平，谁就拥有总线控制权。若主机检测到自己发送高电平时总线上却为低电平，则自动放弃仲裁，保证通信不会冲突。在“灯心智启”STM32项目中，我通过合理规划IIC主机优先级，确保多传感器数据采集稳定，系统误码率降低了约10%。</p>
<p>CAN总线则采用基于报文ID的优先级仲裁。当多个节点同时发送数据时，ID越低优先级越高，节点实时监控总线状态，若检测到自己的ID位为高电平而总线上为低电平，则自动停止发送，等待下一轮仲裁。这个机制保证了高优先级数据实时可靠传输。在Linux智能家居系统中，我调试CAN驱动时，利用ID仲裁优化了多节点数据同步，系统响应延迟缩短了20%以上。</p>
<p>RTOS需要移植哪些东西</p>
<h1 id="spi和i2c计算"><a href="#spi和i2c计算" class="headerlink" title="spi和i2c计算"></a>spi和i2c计算</h1><p>I2C的速率计算主要基于其标准模式（100kbps）、快速模式（400kbps）等，实际带宽还需考虑起始位、地址位、应答位和停止位等开销。例如，传输8字节数据，需加上1字节地址和若干控制位，实际有效数据速率会低于标称速率。通过合理安排数据包结构，我在项目中将I2C数据传输效率提升约20%，满足了多传感器并行采集的需求。</p>
<p>SPI的速率计算更为直接，理论带宽为时钟频率×数据线数量（如全双工4线制）。例如，主频为8MHz时，1字节数据理论传输时间为1μs左右。SPI无地址和应答开销，效率更高。在项目中，采用SPI读取摄像头数据，实际带宽接近标称值，数据延迟降低约30%。</p>
<h1 id="spi，iic，can的地址管理区别"><a href="#spi，iic，can的地址管理区别" class="headerlink" title="spi，iic，can的地址管理区别"></a>spi，iic，can的地址管理区别</h1><p>SPI总线采用主从（一主多从）结构，不具备硬件层面的地址管理。主控通过片选信号（CS）直接选择具体的从设备，片选线数量决定可挂载的从设备数量。在“灯心智启”项目中，我通过STM32片选线扩展，实现了对多个传感器的高效管理。</p>
<p>IIC总线则采用7位或10位的从设备地址（多主多从），每个设备地址唯一，主机通过发送地址字节选择目标设备。IIC支持多主多从，扩展性强。在我的智能台灯项目中，通过合理分配IIC地址，实现了对光敏和温湿度传感器的统一管理，降低了硬件复杂度，整体布线减少约30%。</p>
<p>CAN总线采用全局唯一标识符（ID）进行节点识别，所有节点平等，消息以广播形式发送，接收方根据ID过滤信息。这种方式大大提升了系统的灵活性和容错性。我在智能家居系统开发中，利用CAN ID灵活分配，实现了多节点高效通信，系统扩展能力提升约40%。</p>
<h1 id="串口115200波特率是一秒传输几个字节数据"><a href="#串口115200波特率是一秒传输几个字节数据" class="headerlink" title="串口115200波特率是一秒传输几个字节数据"></a>串口115200波特率是一秒传输几个字节数据</h1><p>串口传输一个字节通常需要10位（1位起始位、8位数据位、1位停止位）。</p>
<p>​	每秒字节数&#x3D;115200&#x2F;10&#x3D;11520</p>
<h1 id="freeRTOS需要移植哪些东西"><a href="#freeRTOS需要移植哪些东西" class="headerlink" title="freeRTOS需要移植哪些东西"></a>freeRTOS需要移植哪些东西</h1><p>首先，需要适配处理器相关的端口文件（Porting Layer），包括任务切换的汇编代码和中断管理；其次，配置FreeRTOSConfig.h文件，定制系统时钟、任务优先级、堆栈大小等参数；第三，移植与硬件相关的启动文件及时钟节拍定时器（SysTick），确保系统节拍准确；最后，确保编译环境和链接脚本与目标芯片兼容。</p>
<p>首先，需要适配处理器相关的启动文件和端口层（Porting Layer），包括任务切换、上下文保存与恢复等核心代码。例如，在STM32 Cortex-M平台上，我优化了port.c和portmacro.h文件，保证任务切换高效可靠。</p>
<p>第二，必须实现与硬件平台相关的定时器中断，这为FreeRTOS提供系统时钟基础。在实际项目中，我通过配置SysTick定时器，实现了毫秒级任务调度，系统响应速度提升了约20%。</p>
<p>第三，内存管理模块的适配也非常关键。我根据项目实际需求选择和优化了heap_4.c内存管理方案，确保多任务运行时内存分配高效且无泄漏。</p>
<p>最后，还要根据应用场景适配外设驱动（如IIC、SPI、UART等）和中断服务函数，并完善任务优先级和同步互斥机制，提升整体系统稳定性和实时性。</p>
<ul>
<li>修改sys.h文件，让它支持OS。</li>
<li>修改usart文件，更改中断。在uC&#x2F;OS的时候，进入和退出中断需要添加OSIntEnter()和OSIntExit()两个函数，然后在FreeRTOS中并没有该机制，所以将这里的代码删除。</li>
<li>关于delay函数的修改，FreeRTOS中使用SysTick作为作为操作系统的心跳，所以需要将xPortSysTickHandler()添加，作为系统始终中断。</li>
<li>delay_init() 用于初始化SysTick，主要修改SysTick的重装载值，修改delay_ms和delay_us函数。</li>
<li>修改中断（SysTick中断、SVC中断、PendSV中断）。其中SysTick中断在delay.c文件中已经定义。</li>
</ul>
<h1 id="RTOS怎么实现任务调度的"><a href="#RTOS怎么实现任务调度的" class="headerlink" title="RTOS怎么实现任务调度的"></a>RTOS怎么实现任务调度的</h1><p>我深入应用了FreeRTOS任务调度机制，实现了多任务并发和高效资源管理。具体来说，RTOS通过以下方式实现任务调度：</p>
<p>首先，RTOS维护一个任务优先级队列，每个任务根据其优先级被动态管理。系统利用定时器中断（如SysTick）定期触发任务切换。每当中断发生时，RTOS会检查所有就绪任务，选择最高优先级的任务执行。</p>
<p>在我的项目中，我合理划分了各功能模块的任务优先级，例如自动调光、传感器采集和语音交互等，确保关键功能实时响应。通过配置FreeRTOS的抢占式调度，系统能在毫秒级内完成任务切换，整体响应速度提升约20%。</p>
<p>此外，RTOS还通过任务状态（就绪、运行、阻塞、挂起）管理任务生命周期，并利用互斥量和信号量实现任务间同步，避免资源冲突。</p>
<h1 id="RTOS中带ISR和不带ISR的函数区别"><a href="#RTOS中带ISR和不带ISR的函数区别" class="headerlink" title="RTOS中带ISR和不带ISR的函数区别"></a>RTOS中带ISR和不带ISR的函数区别</h1><p>在我的项目中，经常需要在FreeRTOS环境下处理任务与中断的数据交互。带ISR（如<code>xQueueSendFromISR</code>）和不带ISR（如<code>xQueueSend</code>）的函数核心区别在于：</p>
<p>带ISR（如 xQueueSendFromISR）专为中断服务函数（Interrupt Service Routine）设计，它们不涉及阻塞，通常会使用特殊的中断安全机制，比如临界区保护和任务切换标记，确保在中断上下文中安全、快速地操作RTOS对象。而不带ISR的函数（如 xQueueSend）只能在任务上下文中调用，支持阻塞和超时，系统会自动进行任务调度。.</p>
<ul>
<li><strong>调用环境不同</strong>：带ISR的函数只能在中断服务函数（ISR）内部调用，确保在中断上下文下操作RTOS资源时安全、快速；而不带ISR的函数仅能在任务中调用，支持阻塞和超时机制。</li>
<li><strong>系统行为不同</strong>：带ISR的函数不会阻塞，确保中断处理尽快完成，并通过特殊参数判断是否需要任务切换，保证系统实时性。而普通函数可以根据资源状态选择挂起或等待，系统会自动进行调度。</li>
</ul>
<p>我在实际项目中，合理区分并使用这两类API，既保证了数据的实时传递，也避免了死锁和优先级反转等问题。例如，在高频数据采集项目中，通过使用<code>xQueueSendFromISR</code>将采集数据从中断安全、无阻塞地传递到任务队列，</p>
<h1 id="解决RTC异常复位问题"><a href="#解决RTC异常复位问题" class="headerlink" title="解决RTC异常复位问题"></a>解决RTC异常复位问题</h1><p><strong>RTC（实时时钟）主要用于提供精准的时间基准，实现定时控制和数据记录等功能。例如，台灯的自动调光、疲劳监测和坐姿提醒等模块，都依赖RTC实现定时检测与事件触发。此外，RTC还能确保设备在断电或重启后依然保持准确的时间信息，保证用户体验和系统稳定性</strong></p>
<p><strong>我利用RTC实现了自动调光功能。具体做法是：首先，RTC模块为台灯提供了精准的时间信息，根据不同时间段（如早晨、傍晚、夜间）设定不同的亮度阈值。主控芯片定时读取RTC时间，并结合光敏传感器实时采集的环境光强度，通过算法判断是否需要调整灯光亮度。这样，台灯能够根据用户作息和环境变化，自动切换到最合适的照明状态。</strong></p>
<p>我曾遇到RTC（实时时钟）异常复位导致时间丢失的问题。面对这一挑战，我首先通过分析STM32的硬件手册，结合FreeRTOS环境，对电路和代码进行了系统排查，发现异常复位多因电源波动或初始化流程不完善引起。</p>
<p>在“灯心智启”智能语音台灯项目中，我曾遇到STM32 RTC模块因异常复位导致时间丢失的问题。为彻底解决这一挑战，我采取了软硬件结合的策略：</p>
<p>首先，我通过分析电路原理图和实际测试，发现主电源波动和初始化流程不完善是主要原因。针对硬件，我为RTC部分加装了纽扣电池，确保主电源断开时RTC依然能持续供电，保证时钟连续运行。</p>
<p>在软件层面，我优化了RTC初始化流程：启动时先检测备份寄存器内容，判断是否为异常复位；如果检测到异常，则从备份寄存器或外部接口恢复正确时间，避免时间重置。同时，增加了掉电检测机制，确保每次上电后RTC状态可靠。</p>
<p><strong>行动</strong><br>我首先定位问题，分析硬件电路和软件驱动，发现部分情况下RTC电源切换不及时，导致寄存器数据丢失。同时，系统初始化流程未对RTC状态做充分校验。<br>为此，我优化了硬件RTC电源管理，确保备用电池正常供电；在软件层面，增加了RTC寄存器的校验和自动修正机制，加入上电自检和时间回退保护。当检测到RTC异常时，系统自动恢复到最近一次有效时间，并通过日志记录异常，便于后续追踪。</p>
<p><strong>结果</strong><br>经过优化后，系统RTC异常复位问题大幅减少，时间丢失率降低至0.1%以内。项目顺利通过稳定性测试，客户对系统长期运行的可靠性给予高度评价。</p>
<h1 id="作为项目管理是怎么安排项目的"><a href="#作为项目管理是怎么安排项目的" class="headerlink" title="作为项目管理是怎么安排项目的"></a>作为项目管理是怎么安排项目的</h1><p>在某次嵌入式系统开发项目中，团队成员技术背景不一，项目任务涉及软硬件协同，时间紧、需求变更多。</p>
<p><strong>行动</strong>：首先，我与团队和客户一起明确里程碑和交付标准，将项目分解为若干阶段和具体可量化的任务。根据成员专长合理分工，通过每日站会跟踪进展，发现问题及时调整资源。同时引入看板工具，实现任务透明化管理，并设定每周回顾会议，确保风险早暴露、早处理。</p>
<p><strong>结果</strong>：最终，项目提前两周完成，产品一次性通过客户验收，Bug率降低了40%。团队成员的积极性和协作效率也显著提升。</p>
<p>在“灯心智启”智能语音台灯项目中，我独立承担了项目管理和全部开发工作。面对功能多、周期紧的挑战，我采用了模块化和阶段性推进的管理方式。</p>
<p>首先，我将项目拆分为硬件设计、嵌入式开发、AI模型训练和APP联调四大模块，明确每一阶段的目标和输出。针对每一模块，制定详细的时间表和里程碑，优先解决关键路径上的难题，比如主控芯片选型和多传感器数据融合。</p>
<h1 id="平时开发用什么语言"><a href="#平时开发用什么语言" class="headerlink" title="平时开发用什么语言"></a>平时开发用什么语言</h1><p>在“灯心智启”项目中，我使用C语言为STM32单片机编写底层驱动和主控逻辑，实现了多传感器数据采集、FreeRTOS多任务调度等核心功能。在“Linux MQTT智能家居系统”项目中，我则结合C++进行QT图形界面开发和多线程处理，</p>
<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>static 关键字主要用于控制变量和函数的作用域与生命周期 在“灯心智启”项目的嵌入式代码中，我会用 static 修饰局部变量，使其在函数多次调用时保持状态，从而提升模块的可靠性和数据一致性。同时，使用 static 修饰函数或全局变量，可以限定其只在当前文件内可见，避免命名冲突，增强代码的封装性和可维护性。</p>
<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>volatile，什么时候用</p>
<p>第一，修饰中断服务程序中会被主程序和中断同时访问的全局变量，防止编译器优化导致主程序无法及时感知变量的变化。<br>第二，用于多线程或多任务系统（如FreeRTOS）中，任务间共享的标志变量，确保每次读取的都是最新值。<br>第三，修饰与硬件寄存器相关的变量，如GPIO、外设状态寄存器等，防止编译器将其缓存到寄存器，保证对硬件的实时操作。</p>
<p>volatile 关键字主要用于修饰多线程或中断中会被异步修改的变量。例如，在“灯心智启”项目中，我使用STM32单片机进行多传感器数据采集和控制，涉及到中断服务程序（ISR）与主循环之间的数据通信。为了确保主循环每次都能读取到最新的传感器状态，我会将这类变量声明为volatile，防止编译器优化带来的缓存问题，确保数据实时性和系统稳定性。</p>
<p>通过规范使用volatile，有效避免了数据不同步导致的逻辑错误，提升了系统的可靠性。</p>
<p><strong>背景</strong>：在多任务或中断环境下，某些变量可能会被中断服务程序或外部硬件异步修改。如果不加<code>volatile</code>，编译器会优化代码，将变量缓存到寄存器，导致主程序无法察觉变量的实时变化。</p>
<p><strong>行动</strong>：针对这些易变变量，我都会加上<code>volatile</code>，确保每次访问都直接从内存读取，避免因编译器优化带来的数据不一致。例如，在FreeRTOS项目中，中断与主循环共享的标志位、状态寄存器等都会加<code>volatile</code>修饰。</p>
<p><strong>结果</strong>：通过规范使用<code>volatile</code>关键字，避免了难以发现的同步问题和死循环，系统稳定性提升20%以上。客户反馈项目可靠性明显增强。</p>
<h1 id="define"><a href="#define" class="headerlink" title="define"></a>define</h1><p><code>#define</code> 关键字经常被用于提高代码的可维护性和可读性。</p>
<p><strong>情境</strong>：在一个需要频繁修改硬件寄存器地址和参数的项目中，直接使用硬编码数值容易导致后期维护和调试困难。</p>
<p><strong>行动</strong>：我统一采用<code>#define</code>为常用的参数、寄存器地址和魔数定义宏。例如，将引脚号、缓冲区大小等用宏定义，便于代码复用和集中修改。对于条件编译和功能切换，也利用<code>#define</code>灵活控制代码片段的启用和关闭。</p>
<p><strong>结果</strong>：这种做法使代码结构更加清晰，后续功能扩展和Bug修复效率提升了50%以上，团队成员能够快速定位和修改关键参数，减少了人为错误。</p>
<h1 id="裸机进入main函数流程"><a href="#裸机进入main函数流程" class="headerlink" title="裸机进入main函数流程"></a>裸机进入main函数流程</h1><h1 id="IIC、SPI帧格式、一主多从"><a href="#IIC、SPI帧格式、一主多从" class="headerlink" title="IIC、SPI帧格式、一主多从"></a>IIC、SPI帧格式、一主多从</h1><p>IIC总线采用两根信号线（SCL、SDA），帧格式包括起始信号、从设备地址、读写位、数据段和停止信号，支持一主多从结构，主设备通过地址唯一识别多个从设备。在项目中，我通过合理分配地址，实现了光敏、温湿度等多个传感器的高效并行管理，数据采集效率提升约30%。</p>
<p>SPI总线则采用四根信号线（SCLK、MOSI、MISO、CS），帧格式为连续的数据流，通过片选信号（CS）区分不同从设备，同样支持一主多从。在驱动开发时，我优化了SPI通信协议，提升了外设响应速度，保证了系统的实时性和稳定性。</p>
<h1 id="线程通信方式"><a href="#线程通信方式" class="headerlink" title="线程通信方式"></a>线程通信方式</h1><p>我深入实践了多线程通信方式。项目采用IMX6ULL开发板和Linux系统，涉及多进程、多线程的并发控制。为实现线程间高效通信，我主要采用了互斥锁（mutex）、条件变量（condition variable）、信号量（semaphore）和消息队列（message queue）等方式。</p>
<p>具体来说，针对传感器数据采集和界面数据显示两个线程，我用互斥锁保证数据一致性，避免竞争条件；通过条件变量实现线程同步，确保数据显示及时准确。此外，在复杂的事件通知场景下，我还应用了信号量和消息队列，实现了线程间的高效异步通信。</p>
<ul>
<li><p><strong>共享内存</strong>：线程共享同一进程的内存空间，通过访问共享变量进行通信。需用互斥锁保护临界区。</p>
</li>
<li><p><strong>消息队列</strong>：线程间通过消息队列发送和接收消息，实现通信。</p>
</li>
<li><p><strong>信号量</strong>：用于线程同步，控制对共享资源的访问。</p>
</li>
<li><p><strong>事件</strong>：线程通过等待和触发事件进行同步。</p>
</li>
<li><p><strong>管道</strong>：线程间通过管道进行数据传输。</p>
<p><strong>情境</strong><br>在基于IMX6ULL开发板的Linux系统项目中，涉及多个线程并发采集传感器数据并同步到界面显示，要求高效的数据一致性与实时响应。</p>
<p><strong>行动</strong><br>我主要采用了互斥锁（mutex）保证多线程共享数据的安全，防止竞争条件；利用条件变量（condition variable）实现线程同步，确保数据处理和显示的时序准确；在事件通知和复杂交互场景下，还结合信号量（semaphore）与消息队列（message queue），实现了高效的异步通信和任务调度，显著提升线程间的协作效率。</p>
<p><strong>结果</strong><br>通过这些通信机制，系统多线程数据同步延迟降低至毫秒级，通信效率提升40%，整体运行更加稳定可靠。项目顺利通过验收，客户反馈系统响应速度和稳定性大幅提升。</p>
</li>
</ul>
<h1 id="怎么裁剪-u-boot启动"><a href="#怎么裁剪-u-boot启动" class="headerlink" title="怎么裁剪 u boot启动"></a>怎么裁剪 u boot启动</h1><p>在Linux MQTT智能家居系统项目中，我针对u-boot启动过程进行了精细的优化和裁剪，以提升系统启动速度和资源利用率。</p>
<p>具体来说，首先我分析了u-boot的启动流程，明确哪些功能模块是项目所需，哪些可以裁剪。例如，仅保留必要的启动命令和驱动，关闭如USB、网络、冗余文件系统等无关功能。通过修改<code>include/configs</code>下的配置头文件，注释或关闭不需要的宏定义，并精简启动命令行参数，减少无用初始化。</p>
<p>其次，我优化了环境变量设置，将启动脚本和参数直接嵌入到默认环境，避免二次加载；同时合并和简化设备树加载流程，减少等待和检测时间。</p>
<p>最后，在编译阶段，利用Makefile裁剪未用到的外设驱动和命令模块，使u-boot镜像体积缩小约30%，启动时间缩短近40%。整个裁剪过程严格测试，确保核心功能稳定可靠。</p>
<p>首先，内核裁剪是关键环节。结合我在Linux MQTT智能家居系统项目的经验，通过menuconfig等工具关闭未用的驱动模块、文件系统和功能特性，比如去除不需要的网络协议、外设驱动、调试功能等。经过裁剪，内核镜像体积可减少约35%，启动时间也相应缩短。</p>
<p>其次，根文件系统的精简同样重要。我会只保留实际运行所需的库、工具和应用，删除冗余的shell命令、开发工具和未用库文件。通过BusyBox集成常用命令，进一步减小文件系统体积，最高可减少50%以上的存储占用。</p>
<p>此外，应用层也可以优化。例如裁剪QT应用，删除未用控件和模块，优化图形界面布局；或在STM32等MCU端，精简固件代码和功能模块，提升运行效率。</p>
<h1 id="如何处理FreeRTOS中的任务优先级？如何避免优先级反转？"><a href="#如何处理FreeRTOS中的任务优先级？如何避免优先级反转？" class="headerlink" title="如何处理FreeRTOS中的任务优先级？如何避免优先级反转？"></a><strong>如何处理FreeRTOS中的任务优先级？如何避免优先级反转？</strong></h1><p>在“灯心智启”智能语音台灯项目中，我深入实践了FreeRTOS任务优先级的管理。针对多传感器数据采集和语音交互等并发场景，我根据任务的实时性需求合理分配优先级。例如，自动调光和疲劳监测等关键任务被设为较高优先级，后台数据处理和日志保存则分配较低优先级，从而保证系统核心功能的及时响应。</p>
<p>为避免优先级反转问题，我充分利用FreeRTOS的优先级继承机制。在涉及互斥量（Mutex）的任务同步场景中，确保高优先级任务被低优先级任务阻塞时，低优先级任务会临时提升优先级，直至释放资源，防止系统出现“高优先级饿死”的情况。通过这些措施，系统整体延迟降低了约25%，多任务协作更加流畅。</p>
<p>这些经验不仅提升了我对实时多任务系统的理解，也为我今后在贵公司开发高可靠性嵌入式产品提供了坚实的技术保障。我期待将这种精细化调度和系统优化能力带入贵团队，共同推动产品性能提升。</p>
<h1 id="FreeRTOS的调度算法是怎样的？如何实现时间片轮转？"><a href="#FreeRTOS的调度算法是怎样的？如何实现时间片轮转？" class="headerlink" title="FreeRTOS的调度算法是怎样的？如何实现时间片轮转？"></a><strong>FreeRTOS的调度算法是怎样的？如何实现时间片轮转？</strong></h1><p>在“灯心智启”智能语音台灯项目开发中，我深入研究并实际应用了FreeRTOS的调度算法。FreeRTOS采用基于优先级的抢占式调度机制，即始终运行当前就绪队列中最高优先级的任务。当有更高优先级任务进入就绪态时，调度器会立即切换，保证关键任务的实时响应。</p>
<p>针对项目中多任务并发的需求，我通过配置FreeRTOS的时间片轮转功能（即使能启用configUSE_TIME_SLICING），让同一优先级的多个任务能按时间片公平轮转。这样，自动调光、语音交互等同优先级任务能够高效协作，避免单一任务独占CPU，系统整体响应效率提升约30%。</p>
<p>通过合理利用FreeRTOS的调度策略和时间片机制，我确保了台灯多功能模块的稳定运行和良好用户体验。这一调度优化经验，也让我具备了为贵公司嵌入式系统设计高效任务管理方案的能力，助力产品实现更高的实时性和稳定性。</p>
<h2 id="如何调试FreeRTOS应用？有哪些常用的调试技巧"><a href="#如何调试FreeRTOS应用？有哪些常用的调试技巧" class="headerlink" title="如何调试FreeRTOS应用？有哪些常用的调试技巧"></a><strong>如何调试FreeRTOS应用？有哪些常用的调试技巧</strong></h2><p>在“灯心智启”智能语音台灯项目开发中，我独立完成了基于FreeRTOS的主控程序，积累了丰富的调试经验。面对多任务并发和实时性要求高的场景，我采用了多种调试技巧来保障系统稳定。</p>
<p>首先，我充分利用Keil的断点和单步调试功能，结合FreeRTOS内核感知插件，实时监控任务切换、堆栈使用和任务状态。这帮助我快速定位到一次任务堆栈溢出的问题，通过优化任务栈分配，系统崩溃率下降了约40%。其次，我在关键路径加入串口日志输出，实时打印任务切换、队列和信号量状态，便于追踪异常。对于死锁或优先级反转等问题，我会利用FreeRTOS自带的trace宏，分析任务间的同步关系。</p>
<p>此外，我还习惯用Watch窗口监控全局变量，结合硬件LED指示灯进行简单故障定位。这些调试手段，大大提升了开发效率和系统稳定性。</p>
<p>我相信，这些扎实的FreeRTOS调试经验和系统化的方法论，能够帮助贵公司快速定位和解决嵌入式项目中的复杂问题，提升产品可靠性和开发效率。</p>
<h1 id="什么是交叉编译"><a href="#什么是交叉编译" class="headerlink" title="什么是交叉编译"></a>什么是交叉编译</h1><p>交叉编译是在一个平台上编译出另一个平台上运行的程序的过程。</p>
<h2 id="不同平台之间的交叉编译需要以下步骤：w"><a href="#不同平台之间的交叉编译需要以下步骤：w" class="headerlink" title="不同平台之间的交叉编译需要以下步骤：w"></a>不同平台之间的交叉编译需要以下步骤：w</h2><ol>
<li><p><strong>准备交叉编译工具链</strong></p>
<ul>
<li>选择适合目标平台的交叉编译工具链，如GNU工具链（<code>arm-linux-gnueabihf-gcc</code>）、Linaro工具链等。</li>
<li>可以通过包管理器安装（如<code>sudo apt install gcc-arm-linux-gnueabihf</code>），或者从官网下载并解压。</li>
</ul>
</li>
<li><p><strong>配置编译环境</strong></p>
<ul>
<li><p>设置环境变量，指定交叉编译工具链的路径和目标平台的系统根目录（Sysroot）。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=/path/to/toolchain/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="built_in">export</span> CC=arm-linux-gnueabihf-gcc</span><br><span class="line"><span class="built_in">export</span> SYSROOT=/path/to/sysroot</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>编写和配置代码</strong></p>
<ul>
<li>确保代码兼容目标平台的架构和操作系统。</li>
<li>如果使用CMake，可以通过工具链文件指定交叉编译选项。</li>
</ul>
</li>
<li><p><strong>编译代码</strong></p>
<ul>
<li><p>使用交叉编译工具链编译代码，例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gnueabihf-gcc -o hello_arm hello.c --sysroot=<span class="variable">$SYSROOT</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>部署和测试</strong></p>
<ul>
<li>将生成的可执行文件或库部署到目标平台进行测试</li>
</ul>
</li>
</ol>
<h1 id="static-1"><a href="#static-1" class="headerlink" title="static"></a>static</h1><h2 id="static关键词的作用？"><a href="#static关键词的作用？" class="headerlink" title="static关键词的作用？"></a><strong>static关键词的作用？</strong></h2><ol>
<li><strong>限定变量作用域</strong>：在函数内声明 static 变量时，变量只在该函数内可见，但生命周期贯穿整个程序运行。例如，在我独立开发 STM32 主控芯片源程序时，使用 static 修饰的局部变量可以实现自动调光等功能的数据持久化，避免数据在每次函数调用时被重置，提升了系统的稳定性。</li>
<li><strong>限制外部访问</strong>：在文件级别声明 static 变量或函数时，该变量或函数只能在当前源文件中访问，防止命名冲突。在 Linux MQTT 智能家居项目中，我通过 static 修饰驱动模块内部的私有函数，增强了代码的模块化和安全性，使驱动程序更易于维护和扩展。</li>
<li><strong>节省资源，提高效率</strong>：static 变量存储在静态存储区，初始化只进行一次，有效减少了内存分配和释放的开销。在 FreeRTOS 多任务环境下，这种做法使得任务间数据管理更加高效，系统运行更流畅。</li>
</ol>
<p>在“灯心智启”项目的嵌入式代码中，我会用 static 修饰局部变量，使其在函数多次调用时保持状态，从而提升模块的可靠性和数据一致性。同时，使用 static 修饰函数或全局变量，可以限定其只在当前文件内可见，避免命名冲突，增强代码的封装性和可维护性。</p>
<h2 id="为什么-static变量只初始化一次？"><a href="#为什么-static变量只初始化一次？" class="headerlink" title="为什么 static变量只初始化一次？"></a><strong>为什么 static变量只初始化一次？</strong></h2><p>static 变量只初始化一次的原因，源于其存储方式和生命周期。以我在 STM32 智能语音台灯和 Linux 智能家居项目中的实际开发为例：</p>
<p>在 C 语言中，static 变量被分配在静态存储区，程序启动时分配内存，并在整个程序生命周期内保持其值。与普通局部变量每次进入函数都会重新分配和初始化不同，static 变量只在程序首次执行到其定义处时初始化一次。之后无论函数被调用多少次，static 变量都不会再次初始化，而是保留上次的值。</p>
<p>在我独立开发的智能台灯项目中，利用 static 变量保存传感器历史状态，实现了对用户坐姿和环境亮度的持续监测。这样不仅节省了内存分配的系统开销，还保证了数据的连续性，程序稳定性提升约20%。同样，在 Linux 智能家居驱动开发中，static 变量的单次初始化特性，使得驱动状态管理更可靠，减少了重复初始化带来的资源浪费。</p>
<p>这种机制非常适合嵌入式和实时系统，有效提升了资源利用率和系统响应速度。未来，我希望把这种高效的内存管理和代码规范带到贵公司的嵌入式开发中，助力产品性能持续优化。</p>
<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><h2 id="什么是常量指针？"><a href="#什么是常量指针？" class="headerlink" title="什么是常量指针？"></a><strong>什么是常量指针？</strong></h2><p>常量指针是指“指针本身的值不能改变”，即指针一旦指向某个地址后，不能再指向其他地址，但可以通过该指针修改所指向地址的内容。在 C 语言中，常量指针的声明方式为 <code>int *const p</code>。</p>
<p>结合我的项目经验，比如在 STM32 智能台灯开发中，为了确保关键控制变量的指针不会被意外修改，我会用常量指针来保证指针的稳定性，避免因指针误操作导致系统异常。这种做法在硬件寄存器操作、驱动开发等场景尤为重要，能提升代码的健壮性和安全性。</p>
<h1 id="什么是指针常量？"><a href="#什么是指针常量？" class="headerlink" title="什么是指针常量？"></a>什么是指针常量？</h1><p>指针常量是指“指针所指向的数据内容不能被修改”，但指针本身的值（即指向的地址）是可以改变的。在 C 语言中，声明方式通常为 <code>const int *p</code>，表示通过 p 不能修改所指向的内容，但可以让 p 指向其他地址。</p>
<p>在我主导的 STM32 智能语音台灯和 Linux 智能家居项目开发过程中，指针常量被广泛用于保护关键数据不被意外修改。例如，在操作传感器数据或硬件寄存器时，为了防止误操作导致系统异常，我会使用指针常量来限定数据的只读属性，提升系统的安全性和健壮性。</p>
<h1 id="typedef和define有什么区别？"><a href="#typedef和define有什么区别？" class="headerlink" title="typedef和define有什么区别？"></a>typedef和define有什么区别？</h1><p>typedef 是用来为已有的数据类型起别名，由编译器在编译阶段处理，能够提升代码的可读性和可维护性。例如在 STM32 智能台灯项目中，我常用 typedef 定义结构体别名，便于团队协作和后期维护。</p>
<p>#define 是预处理指令，在编译前进行简单的文本替换，常用于定义常量或宏。它不具备类型检查，容易因宏替换带来隐患。在 Linux 智能家居驱动开发中，我会用 #define 定义寄存器地址等常量，提升代码清晰度。</p>
<h1 id="定义常量谁更好？-define还是-const？"><a href="#定义常量谁更好？-define还是-const？" class="headerlink" title="定义常量谁更好？# define还是 const？"></a><strong>定义常量谁更好？# define还是 const？</strong></h1><p>在实际项目开发中，我更推荐使用 <code>const</code> 来定义常量，而不是 <code>#define</code>。<code>const</code> 由编译器进行类型检查，能够明确指定常量的数据类型，提升代码的安全性和可读性。例如，在 STM32 智能语音台灯和 Linux 智能家居系统开发过程中，我大量采用 <code>const</code> 定义关键参数和配置信息，有效防止了因类型不匹配导致的编译错误和运行时隐患。</p>
<p>相比之下，<code>#define</code> 只是简单的文本替换，不具备类型检查，容易引发调试困难和潜在 bug。在我的项目实践中，通过将 <code>#define</code> 替换为 <code>const</code>，团队在代码审查和测试阶段发现的相关问题数量下降了约15%。</p>
<h1 id="全局变量和局部变量的区别是什么"><a href="#全局变量和局部变量的区别是什么" class="headerlink" title="全局变量和局部变量的区别是什么?"></a><strong>全局变量和局部变量的区别是什么?</strong></h1><p><strong>全局变量</strong>和<strong>局部变量</strong>的最大区别在于作用域和生命周期。全局变量定义在函数外部，整个程序都可以访问，生命周期贯穿整个程序运行过程。而局部变量只在其所在的函数或代码块内有效，生命周期仅限于该函数或代码块执行期间。</p>
<p>在实际项目中，比如我在 STM32 智能语音台灯和 Linux 智能家居系统开发时，会优先使用局部变量来避免全局变量带来的命名冲突和内存占用问题。只有在驱动开发等需要多个模块共享数据时，才会合理使用全局变量，并通过加锁等手段保证线程安全。通过这种变量管理方式，项目代码的可维护性提升了约20%，也有效减少了调试过程中的隐性 bug</p>
<h1 id="局部变量能否和全局变量重名？"><a href="#局部变量能否和全局变量重名？" class="headerlink" title="局部变量能否和全局变量重名？"></a><strong>局部变量能否和全局变量重名？</strong></h1><ul>
<li>局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量，对于有些编译器而言，在同一个函数内可以定义多个同名的局部变量，比如在两个循环体内都定义一个同名的局部变量，而那个局部变量的作用域就在那个循环体内</li>
</ul>
<p>全局变量不建议直接定义在可被多个 .c 文件包含的头文件中。原因在于，如果在头文件中直接定义全局变量，每个包含该头文件的 .c 文件都会生成一份同名变量，导致链接错误，增加调试难度。</p>
<p>局部变量可以和全局变量重名，但在同一作用域内，局部变量会覆盖全局变量。实际开发中，我在STM32智能语音台灯项目中就遇到过类似情况。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> status = <span class="number">0</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">checkStatus</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> status = <span class="number">1</span>; <span class="comment">// 局部变量，覆盖全局变量</span></span><br><span class="line">    <span class="comment">// 此处使用的status是局部变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，函数<code>checkStatus</code>里的<code>status</code>变量会屏蔽全局的<code>status</code>，只在函数内部生效。这种做法虽然语法允许，但容易引发混淆和维护风险。因此，我在实际项目中严格遵循良好的命名规范，尽量避免局部和全局变量重名。这样做让团队在代码审查和维护阶段，变量命名冲突相关的问题减少了30%以上。</p>
<p>在我负责的 STM32 智能语音台灯和 Linux 智能家居系统开发过程中，我始终遵循“在头文件中用 extern 声明全局变量，在一个 .c 文件中定义”的规范。这样既保证了变量的唯一性，又方便了多模块间的数据共享。实际应用中，这一规范让团队在大型项目集成时链接错误率下降了约25%，显著提升了开发效率。</p>
<h1 id="C语言常用字符串"><a href="#C语言常用字符串" class="headerlink" title="C语言常用字符串"></a>C语言常用字符串</h1><p>在C语言项目开发中，常用的字符串操作函数主要包括：</p>
<ul>
<li><code>strcpy</code>：字符串拷贝</li>
<li><code>strncpy</code>：限定长度的字符串拷贝</li>
<li><code>strcat</code>：字符串拼接</li>
<li><code>strncat</code>：限定长度的字符串拼接</li>
<li><code>strcmp</code>：字符串比较</li>
<li><code>strncmp</code>：限定长度的字符串比较</li>
<li><code>strlen</code>：获取字符串长度</li>
<li><code>strchr</code>：查找字符首次出现的位置</li>
<li><code>strstr</code>：查找子串首次出现的位置</li>
<li><code>sprintf</code>&#x2F;<code>snprintf</code>：格式化字符串输出</li>
</ul>
<h1 id="ARM-硬件基础-内部架构"><a href="#ARM-硬件基础-内部架构" class="headerlink" title="ARM -硬件基础&#x2F;内部架构"></a>ARM -硬件基础&#x2F;内部架构</h1><h2 id="NAND-FLASH-和NOR-FLASH异同？"><a href="#NAND-FLASH-和NOR-FLASH异同？" class="headerlink" title="NAND FLASH 和NOR FLASH异同？"></a>NAND FLASH 和NOR FLASH异同？</h2><p><strong>相同点</strong>：</p>
<ul>
<li>都属于非易失性存储器，断电后数据不丢失。</li>
<li>都广泛应用于嵌入式系统中，作为代码或数据存储介质。</li>
</ul>
<p><strong>不同点</strong>：</p>
<ul>
<li><strong>结构与原理</strong>：NOR FLASH支持随机读取，适合直接执行（XIP），常用于存储启动代码；NAND FLASH以页为单位操作，顺序读写速度快，容量大，性价比高。</li>
<li><strong>速度与容量</strong>：NOR FLASH读写速度较慢，容量一般较小；NAND FLASH写入和擦除速度快，容量通常大于1GB，适合大数据存储。</li>
<li><strong>应用场景</strong>：NOR FLASH常用于固件、引导程序存储；NAND FLASH多用于大容量数据如文件系统、存储卡等。</li>
<li><strong>可靠性</strong>：NOR FLASH支持更高次数的擦写，数据可靠性高；NAND FLASH需配合错误检测与纠正（ECC）机制。</li>
</ul>
<h2 id="CPU、MPU、MCU、SOC、SOPC-联系与差别？"><a href="#CPU、MPU、MCU、SOC、SOPC-联系与差别？" class="headerlink" title="CPU、MPU、MCU、SOC、SOPC 联系与差别？"></a>CPU、MPU、MCU、SOC、SOPC 联系与差别？</h2><p>在我的嵌入式项目实践中，常常需要根据系统需求选择合适的芯片架构。以下是对CPU、MPU、MCU、SoC、SOPC的联系与差别的总结：</p>
<ul>
<li><strong>CPU（中央处理器）</strong>：是计算机或嵌入式系统的核心运算单元，负责指令的运算和控制。</li>
<li><strong>MPU（微处理器）</strong>：通常指只包含CPU核心的芯片，需要外接存储和外设，适合高性能、灵活扩展的应用，如我在Linux智能家居系统中用到的i.MX6ULL开发板核心就是MPU。</li>
<li><strong>MCU（单片机）</strong>：<strong>微控制器</strong>集成了CPU、存储器（Flash&#x2F;RAM）和多种外设于一体，适合资源受限、低功耗场景。例如STM32单片机在我的AI语音台灯项目中实现了高集成度和低成本。</li>
<li><strong>SoC（系统级芯片）</strong>：在一块芯片上集成了CPU、存储、外设、通信接口等完整系统功能，广泛应用于智能硬件和移动设备。SoC能显著提升系统集成度和可靠性，降低整体功耗。（将就认为是MCU集成化与MPU强处理力各优点二合一）</li>
<li><strong>SOPC（可编程片上系统）</strong>：基于FPGA平台，用户可自定义CPU、外设等硬件资源，适合对灵活性和定制化要求极高的场合。</li>
</ul>
<h2 id="什么是交叉编译？"><a href="#什么是交叉编译？" class="headerlink" title="什么是交叉编译？"></a>什么是交叉编译？</h2><p>交叉编译是指在一种平台（如PC的x86架构）上，使用专门的交叉编译工具链，为另一种硬件平台（如ARM架构的嵌入式设备）生成可执行文件的过程。它是嵌入式开发的核心环节，尤其在我的Linux智能家居系统和STM32单片机项目中应用广泛。</p>
<ul>
<li>在一种计算机环境中运行的编译程序，能编译出在另外一种环境下运行的代码，我们就称这种编译器支持交叉编译。这个编译过程就叫交叉编译。简单地说，就是在一个平台上生成另一个平台上的可执行代码。</li>
<li>这里需要注意的是所谓平台，实际上包含两个概念：体系结构（Architecture）、操作系统（OperatingSystem）。同一个体系结构可以运行不同的操作系统；同样，同一个操作系统也可以在不同的体系结构上运行。举例来说，我们常说的x86 Linux平台实际上是Intel x86体系结构和Linux for x86操作系统的统称；而x86 WinNT平台实际上是Intel x86体系结构和Windows NT for x86操作系统的简称。</li>
</ul>
<h2 id="为什么需要交叉编译？"><a href="#为什么需要交叉编译？" class="headerlink" title="为什么需要交叉编译？"></a>为什么需要交叉编译？</h2><ul>
<li>有时是因为目的平台上不允许或不能够安装我们所需要的编译器，而我们又需要这个编译器的某些特征；有时是因为目的平台上的资源贫乏，无法运行我们所需要编译器；有时又是因为目的平台还没有建立，连操作系统都没有，根本谈不上运行什么编译器。</li>
</ul>
<h2 id="ROM和RAM的区别及类型"><a href="#ROM和RAM的区别及类型" class="headerlink" title="ROM和RAM的区别及类型"></a>ROM和RAM的区别及类型</h2><p>ROM（只读存储器）和RAM（随机存取存储器）是嵌入式系统中两类基本存储器件，二者在我的STM32和IMX6ULL项目开发中均有实际应用。</p>
<p>ROM主要用于永久性存储程序代码和固件，断电后数据依然保存。常见类型包括Mask ROM、EPROM、EEPROM和Flash，其中Flash ROM在STM32单片机和IMX6ULL开发板中广泛作为主程序存储介质。比如在我的智能语音台灯项目中，主控芯片的固件就是烧录在Flash ROM中，保障了系统的稳定运行。</p>
<p>RAM则用于临时存储运行时数据，断电后数据丢失。其类型主要有SRAM和DRAM，SRAM常用于嵌入式芯片内部高速缓存，DRAM则多见于高性能设备。以Linux智能家居系统为例，IMX6ULL板载的RAM为系统运行和多任务处理提供了充足的缓存空间</p>
<h2 id="关于RAM中，DRAM和SRAM对比"><a href="#关于RAM中，DRAM和SRAM对比" class="headerlink" title="关于RAM中，DRAM和SRAM对比"></a><strong>关于RAM中，DRAM和SRAM对比</strong></h2><p>DRAM和SRAM作为RAM的两种主要类型，各有特点和应用场景。</p>
<p>SRAM（静态随机存取存储器）速度快、功耗低、结构简单，适合用作CPU缓存和MCU片内高速缓存。例如在STM32单片机项目中，SRAM被用于存储中间变量和实时数据，显著提升了数据处理速度，使系统响应时间缩短约20%。</p>
<p>DRAM（动态随机存取存储器）存储密度高、成本低、容量大，但需要周期性刷新，访问速度略慢，适合大容量数据存储。在Linux智能家居系统项目中，IMX6ULL开发板采用DRAM作为主存，为多任务和复杂应用提供了充足的空间，保证了系统的稳定运行和多线程处理能力。</p>
<p>首先，单片机上电后，硬件电路会完成上电复位，确保系统处于初始状态。接着，芯片内部的启动引导程序（Bootloader）会初始化时钟系统、堆栈指针，并将中断向量表重定位到RAM或Flash的指定地址。随后，启动代码会将全局变量和静态变量从ROM拷贝到RAM，并对未初始化的数据区进行清零。</p>
<p>在此基础上，系统会依次初始化外设和关键模块，如时钟、GPIO、串口等。以我的台灯项目为例，我对光敏、温湿度等传感器进行了初始化，确保各模块协同启动。最后，主程序进入主循环或操作系统调度，开始执行核心应用逻辑。</p>
<h1 id="ARM中断与异常"><a href="#ARM中断与异常" class="headerlink" title="ARM中断与异常"></a>ARM中断与异常</h1><h2 id="异常和中断"><a href="#异常和中断" class="headerlink" title="异常和中断"></a>异常和中断</h2><p>中断是指外部或内部事件触发CPU暂停当前任务，转而执行相应的中断服务程序。例如在台灯项目中，光敏和超声波传感器的数据采集都采用了中断方式，极大提升了实时性和系统响应速度，系统整体响应延迟降低了约30%。</p>
<p>异常则通常指程序运行中出现的非法操作或特殊情况，如非法指令、访问越界等，系统会自动进入异常处理流程，保障软件和硬件的安全。</p>
<p><strong>中断和异常的区别：</strong></p>
<ul>
<li>产生源不相同，异常是由CPU产生的，而中断是由硬件设备产生的。</li>
<li>中断是异步的，这意味着中断可能随时到来:而异常是CPU产生的，所以，它是时钟同步的。</li>
<li>当处理中断时，处于中断上下文中:处理异常时，处于进程上下文中。</li>
</ul>
<h2 id="中断和DMA的区别"><a href="#中断和DMA的区别" class="headerlink" title="中断和DMA的区别"></a>中断和DMA的区别</h2><p>中断是指当外部或内部事件发生时，CPU会暂停当前任务，转而执行中断服务程序，处理完后再返回原任务。例如我在传感器数据采集时，采用中断方式实现数据的实时响应，保证了系统的高效性和可靠性。</p>
<p>而DMA（直接存储器访问）是一种无需CPU直接参与的数据传输方式，能够让外设和内存之间实现高速数据搬运。这样CPU可以专注于其他任务，显著提升系统吞吐率。在我的项目中，利用DMA进行大批量数据传输时，CPU占用率降低了近40%，系统整体运行效率有明显提升。</p>
<h2 id="中断响应执行流程"><a href="#中断响应执行流程" class="headerlink" title="中断响应执行流程"></a>中断响应执行流程</h2><p>首先，CPU接收到中断信号后，会立即保存当前的上下文环境（如寄存器内容和程序计数器），以便中断处理完成后能够恢复原有程序。随后，CPU跳转到中断服务程序执行上半部，完成关键的、对时效性要求高的处理，比如传感器数据的初步采集和标志位设置。接着，通过FreeRTOS将耗时的操作安排到中断下半部（如数据进一步处理或消息队列投递），这样不会长时间占用中断资源。最后，系统恢复原有上下文，CPU返回中断前的位置，继续执行主程序。</p>
<h2 id="中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？"><a href="#中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？" class="headerlink" title="中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？"></a>中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？</h2><ul>
<li><p>中断是CPU处于被动状态下来接受设备的信号，而轮询是CPU主动去查询该设备是否有请求。</p>
</li>
<li><p>凡事都是两面性，所以，看效率不能简单的说那个效率高。如果是请求设备是一个频繁请求cpu的设备，或者有大量数据请求的网络设备，那么轮询的效率是比中断高。如果是一般设备，并且该设备请求 cpu的频率比较低，则用中断效率要高一些。主要是看请求频率。</p>
</li>
<li><p>当外设请求频率较低或需要实时响应时，中断方式更高效，因为它能让CPU专注于主任务，只有事件发生才响应，避免了资源浪费。例如在台灯项目中，人体检测和姿态提醒等功能，我采用了中断，系统CPU占用率降低了约30%，响应时间也更快。</p>
</li>
<li><p>但对于高频率或大量数据传输的场景，比如网络通信或者高速ADC采集，轮询反而能减少频繁的上下文切换，整体吞吐率更高。在Linux MQTT智能家居系统中，部分驱动我就采用了高效的轮询机制，保证了数据实时性。</p>
</li>
<li><p>我们正好现在在做一个硬件通讯的性能优化工作，经过测试，中断触发的方式延时还是很可观的，大约在15微秒，而我们不注册中断函数而改用死循环不停判断中断寄存器，中断发生后1微秒就能知道。性能有了巨大提升，代价就是有一个cpu核心一直保持100%占用率，不过我们的设备就干这一件事，而且对功耗不敏感。所以方案都是根据实际需要权衡的，也不是哪个一定好。</p>
</li>
</ul>
<h2 id="当一个异常出现以后，ARM微处理器会执行哪几步操作？"><a href="#当一个异常出现以后，ARM微处理器会执行哪几步操作？" class="headerlink" title="当一个异常出现以后，ARM微处理器会执行哪几步操作？"></a>当一个异常出现以后，ARM微处理器会执行哪几步操作？</h2><p>首先，ARM处理器会立即保存当前的程序计数器（PC）和程序状态寄存器（CPSR），确保异常返回时能恢复原有执行状态。接着，处理器会切换到对应的异常模式（如IRQ、FIQ、SVC等），并自动屏蔽相应的中断，防止嵌套异常影响系统稳定性。随后，处理器跳转到异常向量表指定的入口地址，执行异常服务程序，进行相应的异常处理。最后，异常处理结束后，通过专门的异常返回指令（如SUBS PC, LR, #4），恢复原先的上下文，继续主程序运行。</p>
<h2 id="STM32是大端还是小端？"><a href="#STM32是大端还是小端？" class="headerlink" title="STM32是大端还是小端？"></a>STM32是大端还是小端？</h2><p>STM32采用的是ARM Cortex-M系列内核，默认情况下属于小端模式（Little Endian），即低字节存储在低地址，高字节存储在高地址。这种小端模式在数据通信和多字节数据处理时具有较高的兼容性，也便于与主流PC及网络协议的数据交互。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.linqiutianovo.xyz">LinQiuTian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.linqiutianovo.xyz/2025/05/05/test/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/">https://www.linqiutianovo.xyz/2025/05/05/test/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.linqiutianovo.xyz" target="_blank">林秋天的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/">面试知识</a></div><div class="post-share"><div class="social-share" data-image="/img/data-structure-cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/09/06/test/%E8%BD%A6%E8%BD%BDc%E7%9F%A5%E8%AF%86/" title="车载C知识"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/data-structure-cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">车载C知识</div></div><div class="info-2"><div class="info-item-1">c记录一些自己不会的...</div></div></div></a><a class="pagination-related" href="/2025/05/29/test/c%E5%92%8Cc++/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/" title=""><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-cover3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2"></div></div><div class="info-2"><div class="info-item-1">编码规范 </div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/08/07/KfPnTIM8WvotugL.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">LinQiuTian</div><div class="author-info-description">林秋天的博客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">62</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/linqiutian"><i></i><span>🛴客官点一点...</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/linqiutian" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/412581566@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><center>主域名：<br><a href="https://www.linqiutianovo.xyz"><b><font color="#5ea6e5">https://www.linqiutianovo.xyz/</font></b></a>&nbsp;|&nbsp;<a href="https://www.linqiutianovo.xyz/"><b><font color="#5ea6e5">https://www.linqiutianovo.xyz</font></b></a><br>备用域名：<br><a href="https://www.linqiutianovo.xyz"><b><font color="#5ea6e5">https://www.linqiutianovo.xyz</font></b></a><br><a href="https://www.linqiutianovo.xyz"><b><font color="#5ea6e5">aa.fomal.cc</font></b></a><br><a href="https://www.linqiutianovo.xyz/"><b><font color="#5ea6e5">https://www.linqiutianovo.xyz/</font></b></a><br><a href="mailto:412581566@fqq.com">📬：<b><font color="#a591e0">412581566@fqq.com</font></b></a></center></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-C-%E9%A2%98%E7%9B%AE"><span class="toc-text">C&#x2F;C++ 题目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE1"><span class="toc-text">题目1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE2"><span class="toc-text">题目2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE3"><span class="toc-text">题目3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE4"><span class="toc-text">题目4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE5"><span class="toc-text">题目5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE6"><span class="toc-text">题目6</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Uboot-%E5%BC%95%E5%AF%BC%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E7%9A%84%E5%A4%A7%E6%A6%82%E9%A1%BA%E5%BA%8F%E6%98%AF%EF%BC%9F"><span class="toc-text">Uboot 引导嵌入式Linux操作系统启动的大概顺序是？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%EF%BC%9AROM-Code%EF%BC%88%E8%8A%AF%E7%89%87%E5%8E%82%E5%95%86%E5%86%85%E7%BD%AE%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%89"><span class="toc-text">第一阶段：ROM Code（芯片厂商内置的代码）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%EF%BC%9AFSBL%EF%BC%88First-Stage-Boot-Loader%EF%BC%89"><span class="toc-text">第二阶段：FSBL（First Stage Boot Loader）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%8A%A0%E8%BD%BDLinux%E7%B3%BB%E7%BB%9F"><span class="toc-text">第三阶段：加载Linux系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%EF%BC%9ALinux%E5%86%85%E6%A0%B8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">第四阶段：Linux内核初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%EF%BC%9A%E8%BF%9B%E5%85%A5Linux%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4"><span class="toc-text">最后：进入Linux用户空间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">堆和栈的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%88%E5%8C%BA%EF%BC%88Stack%EF%BC%89"><span class="toc-text">1. 栈区（Stack）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A0%86%E5%8C%BA%EF%BC%88Heap%EF%BC%89"><span class="toc-text">2. 堆区（Heap）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A0%88%E5%8C%BA%E5%B8%B8%E7%94%A8%E6%9D%A5%E5%AD%98%E6%94%BE%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text">3. 栈区常用来存放局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A0%86%E5%8C%BA%E5%B8%B8%E7%94%A8%E6%9D%A5%E5%AD%98%E6%94%BE%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%AD%89"><span class="toc-text">4. 堆区常用来存放全局变量等</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%A0%88%E7%9A%84%E7%A9%BA%E9%97%B4%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%EF%BC%8C%E8%80%8C%E5%A0%86%E4%B8%8D%E6%98%AF"><span class="toc-text">5. 栈的空间是连续的，而堆不是</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8E%E6%8C%87%E9%92%88%EF%BC%8C%E4%BA%A7%E5%90%8E%E7%9A%84%E5%8E%9F%E5%9B%A0%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">什么是野指针，产后的原因是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%87%8E%E6%8C%87%E9%92%88%EF%BC%9F"><span class="toc-text">1. 什么是野指针？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0"><span class="toc-text">2. 产生原因</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89%E6%97%B6%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">1. 定义时未初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%87%8A%E6%94%BE%E5%90%8E%E6%9C%AA%E6%8C%87%E5%90%91NULL"><span class="toc-text">2. 释放后未指向NULL</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E9%87%8E%E6%8C%87%E9%92%88%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">如何避免野指针的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%8C%87%E9%92%88"><span class="toc-text">1. 初始化指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E5%90%8E%E5%B0%86%E6%8C%87%E9%92%88%E7%BD%AE%E4%B8%BANULL"><span class="toc-text">2. 释放内存后将指针置为NULL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A3%80%E6%9F%A5%E6%8C%87%E9%92%88%E6%98%AF%E5%90%A6%E4%B8%BANULL"><span class="toc-text">3. 检查指针是否为NULL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%88C-%EF%BC%89"><span class="toc-text">4. 使用智能指针（C++）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E9%87%8A%E6%94%BE"><span class="toc-text">5. 避免重复释放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E6%A3%80%E6%B5%8B%E9%87%8E%E6%8C%87%E9%92%88"><span class="toc-text">6. 使用工具检测野指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dma%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-text">dma有什么用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">进程间通信的方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E6%B3%95"><span class="toc-text">程序中的内存分配方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E4%BC%98%E5%8A%BF"><span class="toc-text">定时器的作用和优势</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%B2%E7%9F%A5%E5%8D%95%E7%89%87%E6%9C%BA%E5%86%85%E7%BD%AE12%E4%BD%8D%E7%B2%BE%E5%BA%A6%E7%9A%84ADC"><span class="toc-text">已知单片机内置12位精度的ADC</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1%E5%92%8C%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%85%A8%E5%8F%8C%E5%B7%A5%E5%92%8C%E5%8D%8A%E5%8F%8C%E5%B7%A5%E4%BB%A5%E5%8F%8A%E5%8D%95%E5%B7%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9FUART%E3%80%81SPI%E5%92%8CI2C%E5%88%86%E5%88%AB%E5%B1%9E%E4%BA%8E%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">同步通信和异步通信有什么区别？全双工和半双工以及单工有什么区别？UART、SPI和I2C分别属于什么类型的通信方式？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FreeRTOS-%E5%9C%A8%E6%99%BA%E8%83%BD%E8%AF%AD%E9%9F%B3%E5%8F%B0%E7%81%AF%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">FreeRTOS 在智能语音台灯项目中的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-text">1. 任务调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%BB%E5%8A%A1%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">2. 任务间通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-text">3. 资源管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-text">4. 时间管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">5. 内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%B3%BB%E7%BB%9F%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%B8%8E%E8%B0%83%E8%AF%95"><span class="toc-text">6. 系统稳定性与调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E7%AD%94%E7%A4%BA%E4%BE%8B"><span class="toc-text">回答示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RTOS%E7%9A%84%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6"><span class="toc-text">RTOS的调度机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%81%AF%E5%BF%83%E6%99%BA%E5%90%AF%E2%80%9D%E6%99%BA%E8%83%BD%E8%AF%AD%E9%9F%B3%E5%8F%B0%E7%81%AF%E9%A1%B9%E7%9B%AE%E4%B8%AD-%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">灯心智启”智能语音台灯项目中 优先级</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#stm32%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">stm32启动流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">Linux系统启动流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#linux%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E5%90%8E%E8%BF%9B%E5%85%A5%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">linux内核启动后进入命令行流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#stm32%E5%92%8C%E5%B5%8C%E5%85%A5%E5%BC%8Fliunx%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">stm32和嵌入式liunx的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#can%E7%9A%84%E8%B4%9F%E8%BD%BD%E7%8E%87%E8%AE%A1%E7%AE%97"><span class="toc-text">can的负载率计算</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IIC%E5%92%8CCAN%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="toc-text">IIC和CAN发送消息</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IIC%E5%92%8CCAN%E7%9A%84%E4%BB%B2%E8%A3%81"><span class="toc-text">IIC和CAN的仲裁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#spi%E5%92%8Ci2c%E8%AE%A1%E7%AE%97"><span class="toc-text">spi和i2c计算</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#spi%EF%BC%8Ciic%EF%BC%8Ccan%E7%9A%84%E5%9C%B0%E5%9D%80%E7%AE%A1%E7%90%86%E5%8C%BA%E5%88%AB"><span class="toc-text">spi，iic，can的地址管理区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3115200%E6%B3%A2%E7%89%B9%E7%8E%87%E6%98%AF%E4%B8%80%E7%A7%92%E4%BC%A0%E8%BE%93%E5%87%A0%E4%B8%AA%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE"><span class="toc-text">串口115200波特率是一秒传输几个字节数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#freeRTOS%E9%9C%80%E8%A6%81%E7%A7%BB%E6%A4%8D%E5%93%AA%E4%BA%9B%E4%B8%9C%E8%A5%BF"><span class="toc-text">freeRTOS需要移植哪些东西</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RTOS%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9A%84"><span class="toc-text">RTOS怎么实现任务调度的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RTOS%E4%B8%AD%E5%B8%A6ISR%E5%92%8C%E4%B8%8D%E5%B8%A6ISR%E7%9A%84%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB"><span class="toc-text">RTOS中带ISR和不带ISR的函数区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3RTC%E5%BC%82%E5%B8%B8%E5%A4%8D%E4%BD%8D%E9%97%AE%E9%A2%98"><span class="toc-text">解决RTC异常复位问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%89%E6%8E%92%E9%A1%B9%E7%9B%AE%E7%9A%84"><span class="toc-text">作为项目管理是怎么安排项目的</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B3%E6%97%B6%E5%BC%80%E5%8F%91%E7%94%A8%E4%BB%80%E4%B9%88%E8%AF%AD%E8%A8%80"><span class="toc-text">平时开发用什么语言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#static"><span class="toc-text">static</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#volatile"><span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#define"><span class="toc-text">define</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A3%B8%E6%9C%BA%E8%BF%9B%E5%85%A5main%E5%87%BD%E6%95%B0%E6%B5%81%E7%A8%8B"><span class="toc-text">裸机进入main函数流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IIC%E3%80%81SPI%E5%B8%A7%E6%A0%BC%E5%BC%8F%E3%80%81%E4%B8%80%E4%B8%BB%E5%A4%9A%E4%BB%8E"><span class="toc-text">IIC、SPI帧格式、一主多从</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-text">线程通信方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E8%A3%81%E5%89%AA-u-boot%E5%90%AF%E5%8A%A8"><span class="toc-text">怎么裁剪 u boot启动</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86FreeRTOS%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC%EF%BC%9F"><span class="toc-text">如何处理FreeRTOS中的任务优先级？如何避免优先级反转？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FreeRTOS%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC%EF%BC%9F"><span class="toc-text">FreeRTOS的调度算法是怎样的？如何实现时间片轮转？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95FreeRTOS%E5%BA%94%E7%94%A8%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7"><span class="toc-text">如何调试FreeRTOS应用？有哪些常用的调试技巧</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91"><span class="toc-text">什么是交叉编译</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E9%9C%80%E8%A6%81%E4%BB%A5%E4%B8%8B%E6%AD%A5%E9%AA%A4%EF%BC%9Aw"><span class="toc-text">不同平台之间的交叉编译需要以下步骤：w</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#static-1"><span class="toc-text">static</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E8%AF%8D%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-text">static关键词的作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-static%E5%8F%98%E9%87%8F%E5%8F%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E6%AC%A1%EF%BC%9F"><span class="toc-text">为什么 static变量只初始化一次？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#const"><span class="toc-text">const</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%EF%BC%9F"><span class="toc-text">什么是常量指针？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%EF%BC%9F"><span class="toc-text">什么是指针常量？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#typedef%E5%92%8Cdefine%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">typedef和define有什么区别？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F%E8%B0%81%E6%9B%B4%E5%A5%BD%EF%BC%9F-define%E8%BF%98%E6%98%AF-const%EF%BC%9F"><span class="toc-text">定义常量谁更好？# define还是 const？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">全局变量和局部变量的区别是什么?</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%83%BD%E5%90%A6%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E9%87%8D%E5%90%8D%EF%BC%9F"><span class="toc-text">局部变量能否和全局变量重名？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">C语言常用字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ARM-%E7%A1%AC%E4%BB%B6%E5%9F%BA%E7%A1%80-%E5%86%85%E9%83%A8%E6%9E%B6%E6%9E%84"><span class="toc-text">ARM -硬件基础&#x2F;内部架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NAND-FLASH-%E5%92%8CNOR-FLASH%E5%BC%82%E5%90%8C%EF%BC%9F"><span class="toc-text">NAND FLASH 和NOR FLASH异同？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E3%80%81MPU%E3%80%81MCU%E3%80%81SOC%E3%80%81SOPC-%E8%81%94%E7%B3%BB%E4%B8%8E%E5%B7%AE%E5%88%AB%EF%BC%9F"><span class="toc-text">CPU、MPU、MCU、SOC、SOPC 联系与差别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%EF%BC%9F"><span class="toc-text">什么是交叉编译？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%EF%BC%9F"><span class="toc-text">为什么需要交叉编译？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ROM%E5%92%8CRAM%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%B1%BB%E5%9E%8B"><span class="toc-text">ROM和RAM的区别及类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ERAM%E4%B8%AD%EF%BC%8CDRAM%E5%92%8CSRAM%E5%AF%B9%E6%AF%94"><span class="toc-text">关于RAM中，DRAM和SRAM对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ARM%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8"><span class="toc-text">ARM中断与异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD"><span class="toc-text">异常和中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8CDMA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">中断和DMA的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%93%8D%E5%BA%94%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">中断响应执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%92%8C%E8%BD%AE%E8%AF%A2%E5%93%AA%E4%B8%AA%E6%95%88%E7%8E%87%E9%AB%98%EF%BC%9F%E6%80%8E%E6%A0%B7%E5%86%B3%E5%AE%9A%E6%98%AF%E9%87%87%E7%94%A8%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F%E8%BF%98%E6%98%AF%E9%87%87%E7%94%A8%E8%BD%AE%E8%AF%A2%E6%96%B9%E5%BC%8F%E5%8E%BB%E5%AE%9E%E7%8E%B0%E9%A9%B1%E5%8A%A8%EF%BC%9F"><span class="toc-text">中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E4%B8%80%E4%B8%AA%E5%BC%82%E5%B8%B8%E5%87%BA%E7%8E%B0%E4%BB%A5%E5%90%8E%EF%BC%8CARM%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%93%AA%E5%87%A0%E6%AD%A5%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-text">当一个异常出现以后，ARM微处理器会执行哪几步操作？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STM32%E6%98%AF%E5%A4%A7%E7%AB%AF%E8%BF%98%E6%98%AF%E5%B0%8F%E7%AB%AF%EF%BC%9F"><span class="toc-text">STM32是大端还是小端？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/25/test/RS485%E5%92%8Cmodbus/" title="无标题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2025/06/25/test/RS485%E5%92%8Cmodbus/" title="无标题">无标题</a><time datetime="2025-06-25T12:16:30.341Z" title="发表于 2025-06-25 20:16:30">2025-06-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/16/test/BSP%E5%A4%A7%E4%BD%9C%E4%B8%9A/" title="无标题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2025/06/16/test/BSP%E5%A4%A7%E4%BD%9C%E4%B8%9A/" title="无标题">无标题</a><time datetime="2025-06-16T10:54:43.120Z" title="发表于 2025-06-16 18:54:43">2025-06-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/02/test/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="无标题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2025/06/02/test/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="无标题">无标题</a><time datetime="2025-06-02T07:05:56.500Z" title="发表于 2025-06-02 15:05:56">2025-06-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/01/test/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95/" title="嵌入式软件调试"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/data-structure-cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="嵌入式软件调试"/></a><div class="content"><a class="title" href="/2025/06/01/test/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95/" title="嵌入式软件调试">嵌入式软件调试</a><time datetime="2025-06-01T11:50:16.000Z" title="发表于 2025-06-01 19:50:16">2025-06-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/" title="Ƕ��ʽ����������ȫָ�� - �����۵�ʵ��"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/covers/embedded-debug-cover.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ƕ��ʽ����������ȫָ�� - �����۵�ʵ��"/></a><div class="content"><a class="title" href="/2025/06/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E8%B0%83%E8%AF%95%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/" title="Ƕ��ʽ����������ȫָ�� - �����۵�ʵ��">Ƕ��ʽ����������ȫָ�� - �����۵�ʵ��</a><time datetime="2025-06-01T11:50:16.000Z" title="发表于 2025-06-01 19:50:16">2025-06-01</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2024 - 2025 By LinQiuTian</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.4.0-b1"></script><script src="/js/main.js?v=5.4.0-b1"></script><script src="/js/tw_cn.js?v=5.4.0-b1"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"></div><div class="aplayer" data-id="12551163241" data-server="netease" data-type="playlist" data-fixed="true" data-theme="#3F51B5" data-preload="none" data-autoplay="false"></div>[object Object]<script defer src="/js/universe-optimized.js"></script><script defer src="/js/performance-optimized.js"></script><script defer src="/js/structured-data.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/fireworks.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search articles..." type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.4.0-b1"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = '637b20351e874329896d0920eb741c8e';
  var gaud_map_key = '4a866722dcf666eb29a2326ae458eaf1';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'true';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路托管于Vercel" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://dashboard.4everland.org/" style="margin-inline:5px" data-title="本站采用多线部署，备用线路托管于4EVERLAND" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-4EVERLAND-22DDDD?style=flat&amp;logo=IPFS" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>