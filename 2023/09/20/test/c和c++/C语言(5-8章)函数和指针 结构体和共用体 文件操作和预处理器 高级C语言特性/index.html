<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C语言第5-8章内容 | 林秋天的博客</title><meta name="author" content="LinQiuTian"><meta name="copyright" content="LinQiuTian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#F8F5F0"><meta name="description" content="第五章 函数和指针一、C语言中函数的定义和调用在C语言中，函数是一组可重复使用的代码，用于执行特定任务。函数的优势在于它可以随需求调用，减少代码的冗余性，并增强代码的可读性。函数的基本组成包括：返回（函数）类型 ， 函数名 ， 参数列表和函数体。  返回类型 ： 函数可以返回一个值。返回类型是函数返回值的数据类型。如果函数不反悔任何值，则其返回值为void。 函数名：这是表示函数的唯一名称，函数名">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言第5-8章内容">
<meta property="og:url" content="https://www.linqiutianovo.xyz/2023/09/20/test/c%E5%92%8Cc++/C%E8%AF%AD%E8%A8%80(5-8%E7%AB%A0)%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%B1%E7%94%A8%E4%BD%93%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%20%E9%AB%98%E7%BA%A7C%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/index.html">
<meta property="og:site_name" content="林秋天的博客">
<meta property="og:description" content="第五章 函数和指针一、C语言中函数的定义和调用在C语言中，函数是一组可重复使用的代码，用于执行特定任务。函数的优势在于它可以随需求调用，减少代码的冗余性，并增强代码的可读性。函数的基本组成包括：返回（函数）类型 ， 函数名 ， 参数列表和函数体。  返回类型 ： 函数可以返回一个值。返回类型是函数返回值的数据类型。如果函数不反悔任何值，则其返回值为void。 函数名：这是表示函数的唯一名称，函数名">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-09-19T16:00:00.000Z">
<meta property="article:modified_time" content="2025-05-30T10:06:17.657Z">
<meta property="article:author" content="LinQiuTian">
<meta property="article:tag" content="C语言">
<meta property="article:tag" content="函数">
<meta property="article:tag" content="指针">
<meta property="article:tag" content="结构体">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "C语言第5-8章内容",
  "url": "https://www.linqiutianovo.xyz/2023/09/20/test/c%E5%92%8Cc++/C%E8%AF%AD%E8%A8%80(5-8%E7%AB%A0)%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%B1%E7%94%A8%E4%BD%93%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%20%E9%AB%98%E7%BA%A7C%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/",
  "image": "https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg",
  "datePublished": "2023-09-19T16:00:00.000Z",
  "dateModified": "2025-05-30T10:06:17.657Z",
  "author": [
    {
      "@type": "Person",
      "name": "LinQiuTian",
      "url": "https://www.linqiutianovo.xyz/"
    }
  ]
}</script><link rel="shortcut icon" href="https://www.fomal.cc/favicon.ico"><link rel="canonical" href="https://www.linqiutianovo.xyz/2023/09/20/test/c%E5%92%8Cc++/C%E8%AF%AD%E8%A8%80(5-8%E7%AB%A0)%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%B1%E7%94%A8%E4%BD%93%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%20%E9%AB%98%E7%BA%A7C%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.4.0-b1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#F8F5F0')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 18
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C语言第5-8章内容',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/url(https:/s2.loli.net/2024/08/07/EBzp91lhZCgXDI6.png));"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/08/07/KfPnTIM8WvotugL.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa-heart"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">林秋天的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">C语言第5-8章内容</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa-heart"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">C语言第5-8章内容</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-09-19T16:00:00.000Z" title="发表于 2023-09-20 00:00:00">2023-09-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-30T10:06:17.657Z" title="更新于 2025-05-30 18:06:17">2025-05-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/">C语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">20.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>72分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-05-30 18:06:17&quot;}" hidden></div><h1 id="第五章-函数和指针"><a href="#第五章-函数和指针" class="headerlink" title="第五章 函数和指针"></a><strong>第五章 函数和指针</strong></h1><h2 id="一、C语言中函数的定义和调用"><a href="#一、C语言中函数的定义和调用" class="headerlink" title="一、C语言中函数的定义和调用"></a>一、C语言中函数的定义和调用</h2><p>在C语言中，函数是一组可重复使用的代码，用于执行特定任务。函数的优势在于它可以随需求调用，减少代码的冗余性，并增强代码的可读性。<br>函数的基本组成包括：<strong>返回（函数）类型</strong> ， <strong>函数名</strong> ， <strong>参数列表和函数体</strong>。</p>
<ul>
<li><strong>返回类型</strong> ： 函数可以返回一个值。返回类型是函数返回值的数据类型。如果函数不反悔任何值，则其返回值为void。</li>
<li><strong>函数名</strong>：这是表示函数的唯一名称，函数名和参数列表一起构成了函数的签名。、</li>
<li><strong>参数列表</strong>：参数是传递给函数的值。参数列表包括参数的类型、类型、参数的数量，参数是可选的，也就是说，函数可以不包含参数</li>
<li><strong>函数体</strong>：函数体包含了定义函数行为的一组语句。</li>
</ul>
<h3 id="1-1-函数的定义"><a href="#1-1-函数的定义" class="headerlink" title="1.1 函数的定义"></a>1.1 函数的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  返回类型是 int ，函数名为add 参数列表是两个int类型的参数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1 , <span class="type">int</span> num2)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">int</span> sum = num1 + num;</span><br><span class="line">     <span class="keyword">return</span> sum;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>一旦我们定义了函数，就可以在其他地方调用它。要调用函数，我们只需要编写函数名和在括号中传递适当的参数。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = add(<span class="number">5</span> , <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;两数之和等于 %d\n&quot;</span>,result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，add(5, 10)是函数调用，5和10是传递给add函数的参数，add函数返回15，我们将这个返回值赋值给result变量，然后打印出来。</p>
<h2 id="二、C语言中函数参数的传递"><a href="#二、C语言中函数参数的传递" class="headerlink" title="二、C语言中函数参数的传递"></a>二、C语言中函数参数的传递</h2><p>C语言中函数参数传递基本上有两种方式：值传递和引用传递。</p>
<ul>
<li><strong>值传递</strong>：在值传递方式中，被调函数的<strong>形式参数</strong>作为被调用函数的局部变量处理，即在栈中开辟了内存空间，以存放主调函数传递过来的实参值，这个空间值只在函数调用的过程中有效，也就是说，值传递的方式，函数接收的是参数的副本，函数内部对参数的任何改变，都不会影响到实际参数的值</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">     x = <span class="number">20</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Inside change() x=%d\n&quot;</span>, x);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">     change(x);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Outside change() x=%d\n&quot;</span>, x);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，即使在change函数中修改了x的值，但在main函数中打印x时，其值还是原来的值10，这就是值传递。</p>
<ul>
<li><strong>引用传递（Pass by Reference）</strong>： 在引用传递方式中，被调函数的形式参数虽然也作为局部变量在堆栈中开辟了内存空间，但是这次存放的是主调函数放进来实参的变量地址。被调函数对形参的任何操作都被处理成间接寻址，即对实参操作。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> *x)</span> &#123;</span><br><span class="line">     *x = <span class="number">20</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Inside change() x=%d\n&quot;</span>, *x);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">     change(&amp;x);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Outside change() x=%d\n&quot;</span>, x);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们传递了x的地址给change函数，然后在change函数中修改了x的值。在main函数中，我们看到x的值已经被修改为20，这就是引用传递。</p>
<ul>
<li><strong>形式参数</strong> : 形式参数也成为形参，是函数定义时声明的参数。形参只在函数定义时有意义，在函数内部形参作为局部变量使用。</li>
<li><strong>实际参数</strong>：实际参数也成为实参，实在函数调用时实际传给函数的参数。实参可以是常量、变量或者是表达式，无论实参是任何形式的量，在进行函数调用时，他们都必须有确定的值，以便把这些值传给形参。</li>
</ul>
<p>实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void myFunction(int x) &#123;    // 这里的int x就是形式参数</span><br><span class="line">     printf(&quot;%d&quot;, x);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> int main() &#123;</span><br><span class="line">     int y = 10;</span><br><span class="line">     myFunction(y);   // 这里的y就是实际参数</span><br><span class="line">     return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，myFunction的定义中int x就是形式参数，当我们在main函数中调用myFunction(y)时，y就是实际参数。<br>函数在被调用时，实际参数的值会被复制给形式参数。如果形式参数在函数体内发生改变，并不会影响实际参数的值。但如果你使用了指针作为形式参数，那么你可以在函数体内改变实际参数的值，这是因为你传递的是实际参数的地址，而不是实际参数的值。</p>
<h2 id="三、C语言中函数的返回值"><a href="#三、C语言中函数的返回值" class="headerlink" title="三、C语言中函数的返回值"></a>三、C语言中函数的返回值</h2><p>C语言中的函数可以返回一个值给调用他的函数或者是主程序。返回值可以是任何基本类型，也可以是街头提或者枚举类型。当然，函数也可以设定为不返回任何值，这种类型的函数被声明为”void”<br>函数的返回值</p>
<h2 id="四、C语言中全局变量和局部变量"><a href="#四、C语言中全局变量和局部变量" class="headerlink" title="四、C语言中全局变量和局部变量"></a>四、C语言中全局变量和局部变量</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><ul>
<li><strong>定义</strong>：全局变量是在函数之外定义的变量，它在程序的任何地方都可以访问（除了在它定义之前）。</li>
<li><strong>作用范围</strong>：全局变量在整个程序中都是可见的，从它被定义开始，直到程序结束。</li>
<li><strong>生命周期</strong>：全局变量的生命周期是整个程序运行期间，它们在程序开始时分配内存，在程序结束时释放。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int globalVar = 10; // 定义一个全局变量</span><br><span class="line"></span><br><span class="line">void func() &#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, globalVar); // 可以访问全局变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><ul>
<li><p><strong>定义</strong>：局部变量是在函数内部定义的变量，它只在定义它的函数内部可见。</p>
</li>
<li><p><strong>作用范围</strong>：局部变量只在定义它的函数内部有效，函数外部无法访问。</p>
</li>
<li><p><strong>生命周期</strong>：局部变量的生命周期仅限于函数执行期间，当函数执行完毕后，局部变量的内存会被释放。</p>
</li>
<li><p><strong>例子</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">20</span>; <span class="comment">// 定义一个局部变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, localVar); <span class="comment">// 可以访问局部变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// int localVar = 20; // 错误：无法访问func函数内的局部变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="五、C语言中指针的概念和使用"><a href="#五、C语言中指针的概念和使用" class="headerlink" title="五、C语言中指针的概念和使用"></a>五、C语言中指针的概念和使用</h2><h3 id="6-1-指针中的一些基础概念知识"><a href="#6-1-指针中的一些基础概念知识" class="headerlink" title="6.1 指针中的一些基础概念知识"></a>6.1 指针中的一些基础概念知识</h3><h4 id="6-1-1-指针的作用"><a href="#6-1-1-指针的作用" class="headerlink" title="6.1.1 指针的作用"></a>6.1.1 指针的作用</h4><ul>
<li><strong>使程序简洁、高效</strong>：指针可以直接访问内存，提高性能，减少内存使用。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;a; <span class="comment">// ptr是指向a的指针，它存储着a的内存地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *ptr); <span class="comment">// 输出a的值，即10</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>表示复杂数据结构</strong>：指针是实现链表、树等复杂数据结构的关键。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">head</span> =</span> <span class="literal">NULL</span>; <span class="comment">// 链表的头指针，开始时为空</span></span><br><span class="line"><span class="comment">// 可以继续添加节点到链表中</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>动态内存分配</strong>：运行时需要动态分配或释放内存时，必须使用指针。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配一个int大小的内存，并让ptr指向它</span></span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    *ptr = <span class="number">20</span>; <span class="comment">// 通过指针修改内存中的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *ptr); <span class="comment">// 输出20</span></span><br><span class="line">    <span class="built_in">free</span>(ptr); <span class="comment">// 使用完后释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>返回多个函数值</strong>：通过传递指针给函数，函数可以修改并返回多个结果。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">10</span>;</span><br><span class="line">    swap(&amp;x, &amp;y);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x: %d, y: %d\n&quot;</span>, x, y); <span class="comment">// 输出x: 10, y: 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-1-2-指针、内存、地址的概念"><a href="#6-1-2-指针、内存、地址的概念" class="headerlink" title="6.1.2 指针、内存、地址的概念"></a>6.1.2 指针、内存、地址的概念</h4><ul>
<li><strong>内存</strong>：内存是计算机存储空间中，每个变量都占用的一定内存空间。</li>
<li><strong>地址</strong>：内存中每个字节都拥有唯一的地址，这个地址是内存空间的标识符</li>
<li><strong>指针</strong>：指针是一个特殊的变量，他存储了内存的地址，通过这个地址，我们可以直接访问内存中的数据</li>
</ul>
<p>指针就是链接内存和地址的桥梁，通过指针我们可以直接的操作内存中的数据，这是C语言中非常重要和强大的特性<br>其关系如图所示，其实指针也只是一个变量，这个变量存储的类型有一点点特殊，存储的是我们其他变量的地址。我们只需要知道一个变量是由地址和数据组成，而我们的指针变量所能做的就是存储你这个普通变量的地址并能进行操作。<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/8368890/1694678675709-6891934b-7d53-4e48-a6b8-ab0498a6ba13.png#averageHue=%23f3f3f3&clientId=ufdda5353-03bf-4&from=paste&id=u1b89d7e7&originHeight=865&originWidth=1710&originalType=url&ratio=1.5&rotation=0&showTitle=false&size=89081&status=done&style=none&taskId=u93bf1897-7638-4b49-aec6-dc61622deef&title=" alt="img"></p>
<h3 id="6-2-指针的概念"><a href="#6-2-指针的概念" class="headerlink" title="6.2 指针的概念"></a>6.2 指针的概念</h3><p>在C语言中，指针就是一个变量，<strong>其值为另一个变量的内存地址</strong>，也就是它指向该地址的变量。指针允许以直接和间接的方式通过引用内存地址来访问和操作内存中存储数据。</p>
<h4 id="6-2-1-指针变量说明"><a href="#6-2-1-指针变量说明" class="headerlink" title="6.2.1 指针变量说明"></a>6.2.1 指针变量说明</h4><p>指针变量的一般形式如下：<br>type * v &#x3D; NULL;<br>在这里，</p>
<ul>
<li>type：表示指针变量所指向的变量的数据类型。它可以是任何的数据类型，例如 int, char, double, float 等。</li>
<li>*：表示这是一个指针变量。</li>
<li>v：是指针变量的名称。</li>
</ul>
<h3 id="6-3-指针的使用"><a href="#6-3-指针的使用" class="headerlink" title="6.3 指针的使用"></a>6.3 指针的使用</h3><p>在C语言中要使用指针，我们首先需要声明一个指针，然后可以通过地址操作符（&amp;）来获取变量的地址并将其存储在指针中，然后通过解引用操作符(*)来获取存储该地址中的值<br>以下是指针的基本步骤：</p>
<h4 id="6-3-1-指针使用的基本步骤"><a href="#6-3-1-指针使用的基本步骤" class="headerlink" title="6.3.1 指针使用的基本步骤"></a>6.3.1 指针使用的基本步骤</h4><hr>
<p><strong>步骤如下</strong>：</p>
<ul>
<li>声明指针</li>
<li>为指针分配地址</li>
<li>使用访问变量值</li>
<li>修改指针指向的变量的值</li>
</ul>
<p><strong>声明指针</strong>：在C语言中，使用星号（*）来声明一个指针。<br>int * p;<br><strong>为指针分配地址</strong>：我们可以使用“&amp;”来获取一个变量的地址，然后将该地址分配给指针。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> * p;</span><br><span class="line">p = &amp;i;    <span class="comment">//存地址</span></span><br></pre></td></tr></table></figure>

<p><strong>使用指针访问变量值</strong>：使用星号(<em>)前缀可以访问变量的值。这称为*<em>解引用</em></em><br>printf(“%d”,*p); &#x2F;&#x2F;去数据<br><strong>修改指针指向的变量的值</strong>：你也可以使用指针来修改它所指向的变量的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> * p;</span><br><span class="line">p = &amp;i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p);</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> * p = &amp;a;</span><br><span class="line"></span><br><span class="line">    *p = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印地址： p = %p a = %p&quot;</span> , p , &amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印数据： p = %d a = %d&quot;</span> , *p, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="六、C语言中指针运算"><a href="#六、C语言中指针运算" class="headerlink" title="六、C语言中指针运算"></a>六、C语言中指针运算</h2><p>指针的运算就是以指针变量中所存放的值（地址量）作为运算量而进行运算。指针运算的知识就是地址的计算。<br>指针运算的种类是有限制的，只能进行<strong>算术运算</strong>、<strong>关系运算</strong>，以及我们前面所讲过的赋值，这里称为赋值运算。<br>如下表：</p>
<h3 id="6-1-算术运算"><a href="#6-1-算术运算" class="headerlink" title="6.1 算术运算"></a>6.1 算术运算</h3><p>不同类型的两个指针实行加减是无意义的：<br>px+n 表示实际内存单元的地址量是:(px)+sizeof(px的类型)*n;<br>px+n 表示实际内存单元的地址量是:(px)-sizeof(px的类型)*n;<br><strong>指针算术运算：</strong></p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>用法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>p + n</td>
<td>指针p向前（向高地址）移动n个同类型元素的位置</td>
</tr>
<tr>
<td>-</td>
<td>p - n</td>
<td>指针p向后（向低地址）移动n个同类型元素的位置</td>
</tr>
<tr>
<td>-</td>
<td>p - q</td>
<td>计算两个指针p和q之间相差多少个同类型元素的位置</td>
</tr>
</tbody></table>
<p><strong>指针的自增与自减运算：</strong></p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>用法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>++</td>
<td>p 或 p</td>
<td>指针p向前（向高地址）移动一个同类型元素的位置</td>
</tr>
<tr>
<td>–</td>
<td>–p 或 p–</td>
<td>指针p向后（向低地址）移动一个同类型元素的位置</td>
</tr>
</tbody></table>
<p><strong>注意</strong>：这些运算符直接改变指针本身的值。具体来说，p或–p首先改变指针的值，然后返回新的指针值；p或p–先返回原始的指针值，然后改变指针的值。<br><strong>例程</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> * p = arr;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">    <span class="comment">//打印地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印地址: p = %p , arr = %p \n &quot;</span> , &amp;p , arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印数据: p = %d\n&quot;</span>,*p);</span><br><span class="line">    <span class="comment">/*加法运算*/</span></span><br><span class="line">    p = p + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****************加法计算******************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印地址: p = %p , arr = %p \n&quot;</span> , &amp;p , arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印数据: p = %d\n&quot;</span>,*p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*减法运算*/</span></span><br><span class="line">    p = p - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****************加法计算******************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印地址: p = %p , arr = %p \n&quot;</span> , &amp;p , arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印数据: p = %d\n&quot;</span>,*p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*指针差*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****************指针差******************\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> * p_3 = &amp;arr[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> * p_4 = &amp;arr[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> i = p_3 - p_4;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;指针差%d\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*自增运算*/</span></span><br><span class="line">    p++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****************加法计算******************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印地址: p = %p , arr = %p \n&quot;</span> , &amp;p , arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印数据: p = %d\n&quot;</span>,*p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*减法运算*/</span></span><br><span class="line">    j</span><br><span class="line">        p--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;****************加法计算******************\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印地址: p = %p , arr = %p \n&quot;</span> , &amp;p , arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印数据: p = %d\n&quot;</span>,*p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2关系运算"><a href="#6-2关系运算" class="headerlink" title="6.2关系运算"></a>6.2关系运算</h3><p>关于指针的关系运算，需要注意以下几个问题</p>
<ol>
<li>指针关系运算应当在同类型和同数据区域的指针间进行。具有不同数据类型的指针之间的关系运算没有意义，指向不同数据区域（例如，一个指针指向堆，另一个指向栈）的两个指针之间，关系运算也没有意义。</li>
<li>指针与整数之间的关系运算没有意义，不能进行大于、小于等判断，但是可以与0进行等于或不等于的比较，用于判断指针是否为空。这是因为在C语言中，NULL指针通常被定义为0。</li>
</ol>
<p><strong>指针关系运算</strong></p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>用法</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;</td>
<td>p &#x3D;&#x3D; q</td>
<td>如果指针p和q指向同一位置则返回真</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>p !&#x3D; q</td>
<td>如果指针p和q指向不同位置则返回真</td>
</tr>
<tr>
<td>&lt;</td>
<td>p &lt; q</td>
<td>如果指针p位于q之前则返回真</td>
</tr>
<tr>
<td>&gt;</td>
<td>p &gt; q</td>
<td>如果指针p位于q之后则返回真</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>p &lt;&#x3D; q</td>
<td>如果指针p位于q之前或与q同位置则返回真</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>p &gt;&#x3D; q</td>
<td>如果指针p位于q之后或与q同位置则返回真</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;</span><br><span class="line">    <span class="type">int</span> * p_1 = arr;</span><br><span class="line">    <span class="type">int</span> * p_2 = arr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印数据:p_1 = %d , p_2 = %d , arr = %d\n&quot;</span> , *p_1 , *p_2 ,* arr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打印地址:p_1 = %p , p_2 = %p , arr = %p\n&quot;</span> , p_1 , p_2 , arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*大于小于判断*/</span></span><br><span class="line">    p_1 = p_1 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p_2 &gt; p_1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打印数据:p_1 = %d , p_2 = %d , arr = %d\n&quot;</span> , *p_1 , *p_2 ,* arr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打印地址:p_1 = %p , p_2 = %p , arr = %p\n&quot;</span> , p_1 , p_2 , arr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p_2 &gt; p_1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//p_1 = p_1 - 1;</span></span><br><span class="line">    <span class="comment">//p_2 = p_2 + 1;</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p_2 &lt; p_1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打印数据:p_1 = %d , p_2 = %d , arr = %d\n&quot;</span> , *p_1 , *p_2 ,* arr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打印地址:p_1 = %p , p_2 = %p , arr = %p\n&quot;</span> , p_1 , p_2 , arr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p_2 &gt; p_1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、C语言中指针和数组的关系"><a href="#七、C语言中指针和数组的关系" class="headerlink" title="七、C语言中指针和数组的关系"></a>七、C语言中指针和数组的关系</h2><p>在 C 语言中，指针和数组有着紧密的联系。理解这种联系有助于我们更好地理解如何在 C 程序中使用数组和指针。</p>
<h4 id="7-1-数组名作为指针"><a href="#7-1-数组名作为指针" class="headerlink" title="7.1 数组名作为指针"></a>7.1 <strong>数组名作为指针</strong></h4><p>在 C 语言中，数组名是一个常量指针，它指向数组的第一个元素。例如，如果你有一个数组 int arr[5]，那么 arr 就是指向 arr[0] 的指针。你可以通过对数组名进行解引用操作来获取第一个元素的值，例如 *arr 就是 arr[0] 的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *arr);  <span class="comment">// 输出: 1</span></span><br></pre></td></tr></table></figure>

<h4 id="7-2-使用指针访问数组元素"><a href="#7-2-使用指针访问数组元素" class="headerlink" title="7.2 使用指针访问数组元素:"></a>7.2 <strong>使用指针访问数组元素</strong>:</h4><p>你可以使用指针来访问和操作数组的元素。你可以通过对指针进行增减操作来移动指针，并使用解引用操作符来访问指针当前指向的元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = arr;  <span class="comment">// p 指向数组的第一个元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *p);  <span class="comment">// 输出当前元素的值</span></span><br><span class="line">    p++;  <span class="comment">// 指针向前移动</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-3-数组作为函数参数"><a href="#7-3-数组作为函数参数" class="headerlink" title="7.3 数组作为函数参数"></a>7.3 <strong>数组作为函数参数</strong></h4><p>当数组作为函数参数时，它会被自动地转化为指向数组第一个元素的指针。这意味着函数内部不能直接获取到数组的长度，因为指针不保存数组的长度信息。为了在函数内部处理数组，你通常需要将数组的长度作为另一个参数传入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printArr</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> size)</span>·-</span><br><span class="line">    <span class="title function_">for</span> <span class="params">(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    printArr(arr, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总的来说，理解指针和数组的关系有助于我们编写更高效、更灵活的 C 代码。</p>
<h2 id="八、C语言中指针当函数参数和返回值"><a href="#八、C语言中指针当函数参数和返回值" class="headerlink" title="八、C语言中指针当函数参数和返回值"></a>八、C语言中指针当函数参数和返回值</h2><p>在 C 语言中，我们可以使用指针作为函数的参数，也可以使用指针作为函数的返回值。这种使用指针的方式可以使我们的代码更加灵活，特别是在处理数组，字符串，动态内存分配等问题时。</p>
<ol>
<li><strong>指针作为函数参数</strong>: 通过将指针作为函数参数，我们可以实现在函数内部修改外部变量的值。此外，当我们需要在函数中处理数组，字符串等数据结构时，也通常会使用指针作为参数。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>* p)</span> &#123;    <span class="comment">//引用传递</span></span><br><span class="line">    (*p)++;  <span class="comment">// increment the value of variable pointed by p</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before: %d\n&quot;</span>, a);</span><br><span class="line">    add(&amp;a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After: %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，add函数接收一个整数指针作为参数，然后增加该指针所指向的变量的值。</p>
<ol>
<li><strong>指针作为函数返回值</strong>: 如果函数需要返回数组，字符串，或者其他的复杂数据类型，那么通常会使用指针作为函数的返回值。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="title function_">getArr</span><span class="params">()</span> &#123;     <span class="comment">//指针函数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>* arr = getArr();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中，getArr函数返回一个指向整型数组的指针。<br>注意事项：函数返回的指针必须指向静态数据或者动态分配的内存，不能返回指向栈上数据的指针，因为当函数执行完毕后，局部变量（存储在栈上）的生命周期就结束了，其内存区域可能会被其他的数据覆盖。<br>以上，就是在 C 语言中使用指针作为函数参数和返回值的基本用法。</p>
<h2 id="九、C语言中指针函数和函数指针"><a href="#九、C语言中指针函数和函数指针" class="headerlink" title="九、C语言中指针函数和函数指针"></a>九、C语言中指针函数和函数指针</h2><p>在 C 语言中，指针函数和函数指针是两个不同的概念，它们的含义和用法如下：</p>
<ol>
<li>**指针函数 (Pointer Function)**：指针函数其实就是返回指针的函数。在这种情况下，函数的返回类型是一个指针类型。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">getString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span>* str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">    str = getString();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，getString是一个返回char类型指针的函数，也被称为指针函数。</p>
<ol>
<li>**函数指针 (Function Pointer)**：函数指针是一个指针，它指向了一个函数。这样我们就可以像使用普通函数一样来使用这个指针。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void hello() &#123;</span><br><span class="line">    printf(&quot;Hello, World!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    void (*funcPtr)();  // declare a function pointer</span><br><span class="line">    funcPtr = hello;  // assign hello function to funcPtr</span><br><span class="line">    funcPtr();  // call the function via the function pointer</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，funcPtr就是一个函数指针，它被用来指向hello函数。然后通过funcPtr()来调用hello函数。<br>这两者虽然名字类似，但其实是两个完全不同的概念。指针函数是一种特殊类型的函数，它的返回值是一个指针。函数指针则是指向函数的指针，它可以被用来调用所指向的函数。</p>
<h2 id="十、C语言中命令行参数函数"><a href="#十、C语言中命令行参数函数" class="headerlink" title="十、C语言中命令行参数函数"></a>十、C语言中命令行参数函数</h2><p>在 C 语言中，我们可以通过命令行为程序提供参数，这些参数会在 main 函数中以特定的形式被处理。一个处理命令行参数的 main 函数的形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的两个参数分别是：</p>
<ol>
<li>argc (参数的数量)：这是一个整型，代表命令行参数的数量。当没有任何参数时，argc 的值为 1，因为程序的名称本身也被视作一个参数。</li>
<li>argv (参数的值)：这是一个指向字符串的指针数组，其中包含了每个参数的具体值。argv[0] 是程序的名称，argv[1] 是第一个参数，以此类推。</li>
</ol>
<p>比如，你有一个程序叫做 program，你通过命令行以这种方式运行它：.&#x2F;program arg1 arg2。在这种情况下，argc 的值为 3，argv[0] 是 .&#x2F;program，argv[1] 是 arg1，argv[2] 是 arg2。<br>这是一个简单的处理命令行参数的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;程序名称: %s\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;参数 %d: %s\n&quot;</span>, i, argv[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有提供参数.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序会打印出它自己的名称以及所有的命令行参数。如果没有提供任何参数，它将输出 “没有提供参数.”。<br><strong>应用场景</strong>：<br>命令行参数在许多情况下都非常有用。这是因为它们提供了一种灵活的方式，让你可以在启动程序时向其提供一些信息。这意味着你可以控制程序的行为，而无需修改和重新编译代码。<br>以下是一些具体的使用场景：</p>
<ol>
<li><strong>配置选项</strong>：你可以使用命令行参数来控制程序的行为。例如，许多命令行工具都有诸如 -v 或 –verbose 的参数，这些参数可以控制程序显示更多的输出信息。</li>
<li><strong>输入和输出文件</strong>：你可以使用命令行参数来指定输入和&#x2F;或输出文件的路径。例如，编译器就需要一个源代码文件作为输入，并将生成的机器代码写入到另一个文件中。</li>
<li><strong>参数化测试</strong>：如果你正在编写一个需要进行大量测试的程序，那么命令行参数可能会派上用场。你可以编写一个脚本来运行你的程序，每次使用不同的参数，这样就可以自动化测试过程。</li>
<li><strong>环境设置</strong>：例如，你可能需要指定一些环境特定的设置，比如数据库的地址、密码等。</li>
</ol>
<p>总的来说，命令行参数提供了一种灵活的方式来影响程序的行为，而无需每次都去改变和重新编译代码。</p>
<h1 id="第六章-结构体和共用体"><a href="#第六章-结构体和共用体" class="headerlink" title="第六章 结构体和共用体"></a><strong>第六章 结构体和共用体</strong></h1><p><strong>目标</strong></p>
<ul>
<li>1、C语言中结构体和概念和使用</li>
<li>2、C语言中结构体数组和指针</li>
<li>3、C语言中结构体字节对齐和位域</li>
<li>4、C语言中共用体的概念和使用</li>
<li>5、C语言中枚举的概念和使用</li>
<li>6、C语言中的类型定义和typedef</li>
</ul>
<h2 id="一、C语言中结构体和概念和使用"><a href="#一、C语言中结构体和概念和使用" class="headerlink" title="一、C语言中结构体和概念和使用"></a>一、C语言中结构体和概念和使用</h2><h3 id="1-1-结构体的概念和基本定义"><a href="#1-1-结构体的概念和基本定义" class="headerlink" title="1.1 结构体的概念和基本定义"></a>1.1 结构体的概念和基本定义</h3><h4 id="1-1-1-什么是结构体，它的用途和场景"><a href="#1-1-1-什么是结构体，它的用途和场景" class="headerlink" title="1.1.1 什么是结构体，它的用途和场景"></a>1.1.1 什么是结构体，它的用途和场景</h4><p>结构体（Structure）是C语言中一种复合数据类型，它允许开发者将不同类型的数据项组织在一起。结构体中的每个数据项被称为“成员”，这些成员可以具有不同的数据类型，包括基本类型（如int，char，float等）和其他复合类型（包括其他结构体或数组）。结构体提供了一种方法，让开发者能够将相关数据项集中在一起并分配给一个变量。<br>结构体在以下场景中特别有用：</p>
<ol>
<li>表示复杂的数据对象：例如，如果要表示一个学生，可以创建一个包含姓名、年龄、成绩等成员的结构体。</li>
<li>将一组相关的变量组织在一起：如果有一组数据项属于同一实体或概念，那么将它们放在一个结构体中是有意义的。例如，一个结构体可以代表一个日期，其中包含年份、月份和日期这三个成员。</li>
<li>作为函数的参数或返回类型：在复杂的程序中，可能需要通过函数传递或返回多个数据。在这种情况下，将这些数据封装在一个结构体中会更有效，而且代码更易于阅读和理解。</li>
<li>实现更复杂的数据结构：在数据结构和算法中，结构体是实现链表、树、图等高级数据结构的基础。</li>
</ol>
<p>因此，结构体是C语言中一个非常重要的概念，掌握了结构体，就意味着你已经进入了C语言的一个更高级的阶段。</p>
<h4 id="1-1-2-结构体的基本语法"><a href="#1-1-2-结构体的基本语法" class="headerlink" title="1.1.2 结构体的基本语法"></a>1.1.2 结构体的基本语法</h4><p>结构体的基本语法在C语言中如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct_name</span> &#123;</span></span><br><span class="line">    data_type member1;</span><br><span class="line">    data_type member2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>struct 是一个关键字，表示这是一个结构体类型的定义。</li>
<li>struct_name 是你为这个结构体类型取的名字，这个名字在后面声明结构体变量时会用到。</li>
<li>data_type 是成员的数据类型，它可以是任何有效的C语言数据类型，包括基本数据类型（如int，float，char等）和其他复合类型（如数组，指针，甚至其他的结构体类型）。</li>
<li>member1，member2 等是成员的名字，你可以根据实际需要定义任意多个成员。</li>
</ul>
<p>例如，如果你想定义一个表示“学生”的结构体类型，你可以这么写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个结构体类型名字叫做 “Student”，它有三个成员：一个是长度为50的字符数组 “name”，用来存储学生的名字；一个是整型 “age”，用来存储学生的年龄；一个是浮点型 “grade”，用来存储学生的成绩。<br>这只是定义了一个结构体类型，如果你想要创建一个具体的学生，你需要声明一个结构体变量，就像这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">lile</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就创建了一个 “Student” 类型的变量 “tzp”，你可以通过 “.” 操作符来访问它的成员，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(lile.name, <span class="string">&quot;lile&quot;</span>);</span><br><span class="line">lile.age = <span class="number">20</span>;</span><br><span class="line">lile.grade = <span class="number">90.5</span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-结构体变量的声明和访问"><a href="#1-2-结构体变量的声明和访问" class="headerlink" title="1.2 结构体变量的声明和访问"></a>1.2 结构体变量的声明和访问</h3><h4 id="1-2-1-如何声明结构体变量"><a href="#1-2-1-如何声明结构体变量" class="headerlink" title="1.2.1 如何声明结构体变量"></a>1.2.1 如何声明结构体变量</h4><p>声明结构体变量的方式和声明其他类型的变量类似。首先要写出结构体类型，然后跟上你要声明的变量名。如下面的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student1</span>;</span>  <span class="comment">// 声明了一个类型为struct Student的变量student1</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>此外，你也可以在定义结构体的同时声明变量，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125; student1, student2;  <span class="comment">// 在定义struct Student类型的同时，声明了两个此类型的变量student1和student2</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-如何访问结构体成员"><a href="#1-2-2-如何访问结构体成员" class="headerlink" title="1.2.2 如何访问结构体成员"></a>1.2.2 如何访问结构体成员</h4><p>访问结构体变量的成员可以使用.运算符。首先写出结构体变量的名字，然后写上.，最后写上你要访问的成员的名字。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125; student1, student2;  <span class="comment">// 在定义struct Student类型的同时，声明了两个此类型的变量student1和student2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">strcpy</span>(student1.name, <span class="string">&quot;lican&quot;</span>);  <span class="comment">// 设置student1的名字为&quot;John Doe&quot;</span></span><br><span class="line">     student1.age = <span class="number">20</span>;  <span class="comment">// 设置student1的年龄为20</span></span><br><span class="line">     student1.grade = <span class="number">90.5</span>;  <span class="comment">// 设置student1的成绩为90.5</span></span><br><span class="line"></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student3</span>;</span></span><br><span class="line">     <span class="built_in">strcpy</span>(student3.name, <span class="string">&quot;lile&quot;</span>);  <span class="comment">// 设置student1的名字为&quot;John Doe&quot;</span></span><br><span class="line">     student3.age = <span class="number">20</span>;  <span class="comment">// 设置student1的年龄为20</span></span><br><span class="line">     student3.grade = <span class="number">90.5</span>;  <span class="comment">// 设置student1的成绩为90.5</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>当我们使用指向结构体的指针时，可以使用 -&gt; 运算符来访问结构体的成员。下面是一个使用 -&gt; 运算符访问结构体成员的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">     <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">     <span class="type">int</span> age;</span><br><span class="line">     <span class="type">float</span> grade;</span><br><span class="line"> &#125;student1;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">strcpy</span>(student1.name, <span class="string">&quot;lican&quot;</span>);  <span class="comment">// 设置student1的名字为&quot;John Doe&quot;</span></span><br><span class="line">     student1.age = <span class="number">20</span>;  <span class="comment">// 设置student1的年龄为20</span></span><br><span class="line">     student1.grade = <span class="number">90.5</span>;  <span class="comment">// 设置student1的成绩为90.5</span></span><br><span class="line"></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student3</span>;</span></span><br><span class="line">     <span class="built_in">strcpy</span>(student3.name, <span class="string">&quot;lile&quot;</span>);  <span class="comment">// 设置student1的名字为&quot;John Doe&quot;</span></span><br><span class="line">     student3.age = <span class="number">20</span>;  <span class="comment">// 设置student1的年龄为20</span></span><br><span class="line">     student3.grade = <span class="number">90.5</span>;  <span class="comment">// 设置student1的成绩为90.5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">p</span> =</span> &amp;student1;  <span class="comment">// p是一个指向student1的指针</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用-&gt;运算符访问student1的成员</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p-&gt;name);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;age);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, p-&gt;grade);</span><br><span class="line"></span><br><span class="line">     p = <span class="literal">NULL</span>;</span><br><span class="line">     p = &amp;student3;  <span class="comment">// p是一个指向student1的指针</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用-&gt;运算符访问student3的成员</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p-&gt;name);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;age);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, p-&gt;grade);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，p 是一个指向 student1 的指针，p-&gt;name 就是访问 p 指向的结构体的 name 成员，p-&gt;age 和 p-&gt;grade 同理。所以，-&gt; 运算符是用于通过结构体指针访问结构体成员的。</p>
<h4 id="1-2-3-如何初始化结构体变量"><a href="#1-2-3-如何初始化结构体变量" class="headerlink" title="1.2.3 如何初始化结构体变量"></a>1.2.3 如何初始化结构体变量</h4><p>初始化结构体变量可以在声明的同时进行。写出结构体类型和变量名，然后在等号右边用花括号包裹起来的值列表来初始化所有的成员。值的顺序应该和成员在结构体定义中的顺序一致。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student1</span> =</span> &#123;<span class="string">&quot;tan&quot;</span>, <span class="number">20</span>, <span class="number">90.5</span>&#125;;  <span class="comment">// 初始化student1的所有成员</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，”tan”初始化了name成员，20初始化了age成员，90.5初始化了grade成员。<br>也可以使用指定初始化器的方式来初始化结构体变量，这种方式可以不按照成员顺序进行，而是根据成员的名字来指定值。例如：<br><strong>struct Student student1 &#x3D; {.name &#x3D; “John Doe”, .age &#x3D; 20, .grade &#x3D; 90.5}; &#x2F;&#x2F; 使用指定初始化器初始化student1的所有成员</strong></p>
<h3 id="1-3-结构体和函数的关系"><a href="#1-3-结构体和函数的关系" class="headerlink" title="1.3 结构体和函数的关系"></a>1.3 结构体和函数的关系</h3><h4 id="1-3-1-如何将结构体作为函数参数"><a href="#1-3-1-如何将结构体作为函数参数" class="headerlink" title="1.3.1 如何将结构体作为函数参数"></a>1.3.1 如何将结构体作为函数参数</h4><p>我们可以将结构体作为函数的参数。在这种情况下，函数会接收结构体的一个<strong>副本</strong>，修改这个副本并不会影响原来的结构体。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_student</span><span class="params">(                                                )</span>    <span class="comment">//参数列表为结构体</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, s.grade);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">john</span> =</span> &#123;<span class="string">&quot;John Doe&quot;</span>, <span class="number">20</span>, <span class="number">90.5</span>&#125;;</span><br><span class="line">print_student(john);  <span class="comment">// 将john作为参数传递给print_student函数</span></span><br></pre></td></tr></table></figure>

<p>如果要在函数内部修改原来的结构体，需要传递一个指向结构体的指针，然后在函数内部通过这个指针来访问和修改结构体。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">birthday</span><span class="params">(<span class="keyword">struct</span> Student *s)</span> &#123;</span><br><span class="line">    s-&gt;age++;  <span class="comment">// 通过指针访问并修改结构体的成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">birthday(&amp;john);  <span class="comment">// 将指向john的指针作为参数传递给birthday函数</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-在函数中返回结构体"><a href="#1-3-2-在函数中返回结构体" class="headerlink" title="1.3.2 在函数中返回结构体"></a>1.3.2 在函数中返回结构体</h4><p>函数也可以返回一个结构体。 在这种情况下，函数会返回一个结构体的副本。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student <span class="title function_">make_student</span><span class="params">(<span class="type">char</span> *name, <span class="type">int</span> age, <span class="type">float</span> grade)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s</span>;</span></span><br><span class="line">    <span class="built_in">strcpy</span>(s.name, name);</span><br><span class="line">    s.age = age;</span><br><span class="line">    s.grade = grade;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">john</span> =</span> make_student(<span class="string">&quot;peng&quot;</span>, <span class="number">20</span>, <span class="number">90.5</span>);  <span class="comment">// 使用make_student函数的返回值来初始化john</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，返回一个结构体会涉及到拷贝整个结构体，如果结构体很大，这可能会比较低效。在这种情况下，一种可能的解决方案是返回一个指向结构体的指针。但需要注意的是，不能返回指向局部变量的指针，因为当函数返回后，局部变量就不存在了。你可以返回一个指向动态分配的内存的指针，这个内存可以在函数返回后继续存在。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct Student *make_student(char *name, int age, float grade) &#123;</span><br><span class="line">    struct Student *s = malloc(sizeof(struct Student));</span><br><span class="line">    if (s != NULL) &#123;</span><br><span class="line">        strcpy(s-&gt;name, name);</span><br><span class="line">        s-&gt;age = age;</span><br><span class="line">        s-&gt;grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Student *john = make_student(&quot;John Doe&quot;, 20, 90.5);  // john是一个指向动态分配的结构体的指针</span><br></pre></td></tr></table></figure>

<p>在这个例子中，make_student 函数使用 malloc 函数动态分配了一块内存，并返回了指向这块内存的指针。使用完这块内存后，你需要使用 free 函数来释放它，防止内存泄漏。</p>
<h2 id="二、C语言中结构体数组和指针"><a href="#二、C语言中结构体数组和指针" class="headerlink" title="二、C语言中结构体数组和指针"></a>二、C语言中结构体数组和指针</h2><h3 id="2-1-结构体数组的定义和使用"><a href="#2-1-结构体数组的定义和使用" class="headerlink" title="2.1 结构体数组的定义和使用"></a>2.1 结构体数组的定义和使用</h3><h4 id="2-1-1-如何定义和初始化结构体数组"><a href="#2-1-1-如何定义和初始化结构体数组" class="headerlink" title="2.1.1 如何定义和初始化结构体数组"></a>2.1.1 如何定义和初始化结构体数组</h4><p>定义和初始化结构体数组的语法与普通数组非常类似。我们首先定义结构体类型，然后声明该类型的数组，并在声明时初始化数组。<br>以下是一个示例，我们定义了一个名为Student的结构体，并声明了该类型的数组students：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并初始化一个结构体数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">students</span>[3] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">20</span>, <span class="number">85.6</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">22</span>, <span class="number">90.8</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">19</span>, <span class="number">88.5</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-2-如何访问结构体数组的元素"><a href="#2-1-2-如何访问结构体数组的元素" class="headerlink" title="2.1.2 如何访问结构体数组的元素"></a>2.1.2 如何访问结构体数组的元素</h4><p>访问结构体数组的元素非常直观，我们可以通过索引来访问数组的元素，然后使用.运算符来访问结构体的成员。<br>以下是一个示例，我们访问students数组的元素并打印相关信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印第一个学生的姓名</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, students[<span class="number">0</span>].name);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印第二个学生的年龄</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Age: %d\n&quot;</span>, students[<span class="number">1</span>].age);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印第三个学生的成绩</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Grade: %.2f\n&quot;</span>, students[<span class="number">2</span>].grade);</span><br></pre></td></tr></table></figure>

<p>在这个示例中，students[0]、students[1]、students[2]分别表示数组students中的第一个、第二个和第三个元素，这些元素都是Student类型的结构体。我们使用.运算符来访问这些结构体的成员。</p>
<h3 id="2-2-的定义和使用"><a href="#2-2-的定义和使用" class="headerlink" title="2.2 &lt;结构体指针&gt;的定义和使用"></a>2.2 &lt;结构体指针&gt;的定义和使用</h3><h4 id="2-2-1-如何定义结构体指针"><a href="#2-2-1-如何定义结构体指针" class="headerlink" title="2.2.1 如何定义结构体指针"></a>2.2.1 如何定义结构体指针</h4><p>定义一个指向结构体的指针与定义普通指针类似。首先我们需要指定指针的类型，即指针指向的结构体的类型，然后指定指针的名称。例如，我们可以这样定义一个指向 struct Student 类型的指针 p：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> grade;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student1</span> =</span> &#123;<span class="string">&quot;John Doe&quot;</span>, <span class="number">20</span>, <span class="number">90.5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">p</span>;</span>  <span class="comment">// 定义一个指向struct Student类型的指针p</span></span><br><span class="line"></span><br><span class="line">p = &amp;student1;  <span class="comment">// 将p指向student1</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中，我们首先定义了一个 struct Student 类型的变量 student1，然后定义了一个指向 struct Student 类型的指针 p，最后将 p 指向 student1。</p>
<h4 id="2-2-2-如何访问指向结构体的指针成员"><a href="#2-2-2-如何访问指向结构体的指针成员" class="headerlink" title="2.2.2 如何访问指向结构体的指针成员"></a>2.2.2 如何访问指向结构体的指针成员</h4><p>我们可以通过结构体指针来访问结构体的成员，这时我们需要使用 <strong>-&gt;</strong> 运算符。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, p-&gt;name);  <span class="comment">// 使用-&gt;运算符访问p指向的结构体的name成员</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, p-&gt;age);  <span class="comment">// 使用-&gt;运算符访问p指向的结构体的age成员</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, p-&gt;grade);  <span class="comment">// 使用-&gt;运算符访问p指向的结构体的grade成员</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，p 是一个指向 student1 的指针，p-&gt;name 就是访问 p 指向的结构体的 name 成员，p-&gt;age 和 p-&gt;grade 同理。所以，-&gt; 运算符是用于通过结构体指针访问结构体成员的。</p>
<h2 id="三、C语言中结构体字节对齐和位域"><a href="#三、C语言中结构体字节对齐和位域" class="headerlink" title="三、C语言中结构体字节对齐和位域"></a>三、C语言中结构体字节对齐和位域</h2><h3 id="3-1-结构体的字节对齐"><a href="#3-1-结构体的字节对齐" class="headerlink" title="3.1 结构体的字节对齐"></a>3.1 结构体的字节对齐</h3><p>字节对齐（Data Alignment）是计算机硬件为了提高内存读写效率所采取的一种措施。在C语言中，结构体的成员可能不会严格按照代码中的顺序在内存中排列，而会进行字节对齐。</p>
<h4 id="3-1-1-结构体的字节对齐"><a href="#3-1-1-结构体的字节对齐" class="headerlink" title="3.1.1 结构体的字节对齐"></a>3.1.1 结构体的字节对齐</h4><p>结构体的字节对齐是指编译器在分配内存时，会保证每个成员的存储地址相对于结构体起始地址的偏移量是该成员类型大小的整数倍。例如，如果一个成员的类型为 int，则其偏移量必须是 sizeof(int) 的整数倍。</p>
<h4 id="3-1-2-结构体的字节对齐规则"><a href="#3-1-2-结构体的字节对齐规则" class="headerlink" title="3.1.2 结构体的字节对齐规则"></a>3.1.2 结构体的字节对齐规则</h4><ul>
<li>结构体的每个成员根据其类型的自然对齐要求，从起始位置按该类型的整数倍位置开始存放。</li>
<li>结构体本身，按照所有成员中最大自然对齐值的整数倍来对齐。</li>
<li>在成员对齐时，如果成员大小小于对齐值，按照成员大小对齐。如果成员大小大于对齐值，按照对齐值对齐。</li>
</ul>
<h4 id="3-1-3-如何设置字节对齐"><a href="#3-1-3-如何设置字节对齐" class="headerlink" title="3.1.3 如何设置字节对齐"></a>3.1.3 如何设置字节对齐</h4><p>在C语言中，可以通过编译指令 #pragma pack(n) 来设置字节对齐的规则。n 表示最大对齐字节数，必须是2的非负整数次幂，并且小于或等于平台最大支持的对齐字节数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(2) <span class="comment">// 设定字节对齐规则为2字节对齐</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyData</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack() <span class="comment">// 恢复编译器默认的对齐规则</span></span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，使用 #pragma pack(2) 设定了2字节对齐，MyData 结构体的 c 成员和 i 成员之间可能就会有1个字节的填充。然后使用 #pragma pack() 恢复了编译器默认的对齐规则。</p>
<p>结构体对齐的规则通常包括以下几点：</p>
<ol>
<li>基本对齐原则：结构体中的每个成员按照其自身类型的大小进行对齐。例如， int 类型通常按照 4 字节对齐， double 类型通常按照 8 字节对齐。</li>
<li>填充字节：为了满足对齐要求，可能会在成员之间插入填充字节。例如，如果一个  char 类型（1 字节）后面紧跟着一个  int 类型（4 字节），那么可能会在  char 后面填充 3 个字节，以使  int 从 4 字节的边界开始存储。</li>
<li>结构体大小：结构体的总大小是其最大成员大小的整数倍。如果结构体的最后一个成员后面还需要填充字节以满足这个规则，也会进行填充。</li>
<li>嵌套结构体：如果结构体中包含嵌套的结构体，嵌套结构体也会按照上述规则进行对齐，并且整个结构体的对齐要考虑嵌套结构体的对齐情况。</li>
<li>编译器特定规则：不同的编译器可能对结构体的对齐有一些细微的差别，或者提供特定的编译选项来控制对齐方式。</li>
</ol>
<p>下面是一个示例来说明结构体对齐：</p>
<p>#include &lt;stdio.h&gt;</p>
<p>struct S1 {</p>
<p>​    char c;</p>
<p>​    int i;</p>
<p>};</p>
<p>struct S2 {</p>
<p>​    int i;</p>
<p>​    char c;</p>
<p>};</p>
<p>int main() {</p>
<p>​    printf(“Size of S1: %zu\n”, sizeof(struct S1));</p>
<p>​    printf(“Size of S2: %zu\n”, sizeof(struct S2));</p>
<p>​    return 0;</p>
<p>}</p>
<p>在常见的编译器中， struct S1 的大小可能是 8 字节，因为  char 后面会填充 3 个字节以满足  int 的 4 字节对齐要求。而  struct S2 的大小通常也是 8 字节，因为结构体的总大小要为 4 的整数倍，所以在最后可能会填充 3 个字节。</p>
<h3 id="3-2-结构体的位域"><a href="#3-2-结构体的位域" class="headerlink" title="3.2 结构体的位域"></a>3.2 结构体的位域</h3><h4 id="3-2-1-什么是位域，他的作用"><a href="#3-2-1-什么是位域，他的作用" class="headerlink" title="3.2.1 什么是位域，他的作用"></a>3.2.1 什么是位域，他的作用</h4><p>位域（Bit-field）是C语言中的一种特殊类型，它允许程序员对一个整型变量的位进行操作，从而节省内存空间。位域通常用于处理底层硬件或者协议中的数据，例如，一些硬件的寄存器可能只有几个位有实际意义，或者网络协议中的一些字段可能只有几位。</p>
<h4 id="3-2-2-如何定义和使用位域"><a href="#3-2-2-如何定义和使用位域" class="headerlink" title="3.2.2 如何定义和使用位域"></a>3.2.2 如何定义和使用位域</h4><p>位域的定义在语法上类似于普通的结构体成员定义，但是需要在类型名和成员名之间加上一个冒号和一个数字，表示该成员的位数。<br>例如，下面的代码定义了一个包含两个位域成员的结构体 BitField：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BitField</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a : <span class="number">3</span>;  <span class="comment">// a是一个3位的无符号整型位域</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b : <span class="number">4</span>;  <span class="comment">// b是一个4位的无符号整型位域</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用位域的方式和普通的结构体成员类似，都是使用 . 运算符。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BitField</span> <span class="title">bf</span>;</span></span><br><span class="line">bf.a = <span class="number">5</span>;  <span class="comment">// 设置a为5</span></span><br><span class="line">bf.b = <span class="number">10</span>;  <span class="comment">// 设置b为10</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，位域的值不能超过它的位数所能表示的最大值。例如，在上面的代码中，a 最大只能表示到 2^3-1 &#x3D; 7，如果尝试设置一个更大的值，那么只有最低的3位会被保留，高位的值会被丢弃。</p>
<h4 id="3-2-3-位于在结构体中的内存分布"><a href="#3-2-3-位于在结构体中的内存分布" class="headerlink" title="3.2.3 位于在结构体中的内存分布"></a>3.2.3 位于在结构体中的内存分布</h4><p>位域在内存中的布局取决于具体的编译器和平台。大部分情况下，同一类型的连续位域会被打包在一起。如果一组连续的位域的总位数超过了它们的类型的大小，那么编译器可能会将它们分配到两个或更多的字（word）中。如果位域之间有一个非位域成员，或者两个位域成员的类型不同，那么它们也可能被分配到不同的字中。<br>例如，下面的代码定义了一个包含三个位域成员的结构体 BitField2：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BitField2</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a : <span class="number">3</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b : <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> c : <span class="number">6</span>;  <span class="comment">// c可能无法和a、b打包在一起，因为a、b、c的总位数超过了unsigned int的大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，a、b 和 c 可能无法全部打包在一个 unsigned int 中，因为它们的总位数（3+4+6 &#x3D; 13）超过了 unsigned int 的大小（通常为8或16）。这时，c 可能会被分配到另一个 unsigned int 中。但是具体的内存布局取决于编译器和平台，可以通过编译器的文档或者实验来确定。</p>
<h2 id="四、C语言中共用体的概念和使用-union"><a href="#四、C语言中共用体的概念和使用-union" class="headerlink" title="四、C语言中共用体的概念和使用(union)"></a>四、C语言中共用体的概念和使用(union)</h2><h3 id="4-1-共用体的概念"><a href="#4-1-共用体的概念" class="headerlink" title="4.1 共用体的概念"></a>4.1 共用体的概念</h3><p>共用体（union）是C语言中的一种复合数据类型，类似于结构体。它允许在相同的内存位置存储不同的数据类型。也就是说，共用体的所有成员共享同一块内存空间，它的大小由最大的成员决定。因此，共用体可以被看作是一个可以存储多种数据类型的变量。<br>共用体的主要用途是节省内存，特别是当我们有一些组件会以多种方式使用的时候。但请注意，同一时间只能使用共用体的一个成员，因为所有成员都共享同一块内存。</p>
<h3 id="4-2-共用体的基本语法"><a href="#4-2-共用体的基本语法" class="headerlink" title="4.2 共用体的基本语法"></a>4.2 共用体的基本语法</h3><p>共用体的定义与结构体类似，使用关键字 union。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">union Data &#123;</span><br><span class="line">   int i;</span><br><span class="line">   float f;</span><br><span class="line">   char str[20];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了一个名为 Data 的共用体，它有三个成员：一个 int，一个 float 和一个 char 数组。共用体 Data 的大小等于其最大成员的大小，即 char str[20] 的大小。</p>
<h3 id="4-3-如何使用共用体"><a href="#4-3-如何使用共用体" class="headerlink" title="4.3 如何使用共用体"></a>4.3 如何使用共用体</h3><p>共用体的使用方法和结构体相似。我们可以定义一个共用体类型的变量，然后通过 . 运算符来访问它的成员。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">union Data data;</span><br><span class="line"></span><br><span class="line">data.i = 10;</span><br><span class="line">printf( &quot;%d\n&quot;, data.i);</span><br><span class="line"></span><br><span class="line">data.f = 220.5;</span><br><span class="line">printf( &quot;%f\n&quot;, data.f);</span><br><span class="line"></span><br><span class="line">strcpy( data.str, &quot;C Programming&quot;);</span><br><span class="line">printf( &quot;%s\n&quot;, data.str);</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，首先定义了一个 Data 类型的变量 data，然后依次将其 int 成员 i，float 成员 f 和 char 数组成员 str 赋值并打印。注意在赋值新的成员之后，之前的成员的值就不再保留了。<br>总结来说，共用体在C语言中是一个非常有用的工具，它可以帮助我们在不同情况下复用内存，但使用时需要注意其成员之间的覆盖关系。</p>
<h2 id="五、C语言中枚举的概念和使用-enum"><a href="#五、C语言中枚举的概念和使用-enum" class="headerlink" title="五、C语言中枚举的概念和使用(enum)"></a>五、C语言中枚举的概念和使用(enum)</h2><h3 id="5-1-枚举的概念"><a href="#5-1-枚举的概念" class="headerlink" title="5.1 枚举的概念"></a>5.1 枚举的概念</h3><p>枚举（enum）是C语言中的一种数据类型，它由程序员定义一组整数常量，并给这组常量赋予一个名字。枚举类型的变量只能被赋予枚举中的某个值，这样可以使程序更加清晰和易于理解。<br>枚举类型通常被用在需要一组固定值的场景，例如一周的七天、一个月的十二个月、棋盘的颜色（黑色和白色）、交通信号灯的颜色（红、黄、绿）等等。</p>
<h3 id="5-2-枚举的基本语法"><a href="#5-2-枚举的基本语法" class="headerlink" title="5.2 枚举的基本语法"></a>5.2 枚举的基本语法</h3><p>枚举的定义使用关键字 enum。例如，下面的代码定义了一个名为 Day 的枚举类型，它包含一周的七天：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span> &#123;</span></span><br><span class="line">    SUNDAY,</span><br><span class="line">    MONDAY,</span><br><span class="line">    TUESDAY,</span><br><span class="line">    WEDNESDAY,</span><br><span class="line">    THURSDAY,</span><br><span class="line">    FRIDAY,</span><br><span class="line">    SATURDAY</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，SUNDAY、MONDAY 等被称为枚举常量，它们默认对应的整数值从0开始，逐个加1。也就是说，SUNDAY 对应0，MONDAY 对应1，以此类推。你也可以显式地为它们赋予其他的整数值。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span> &#123;</span></span><br><span class="line">    SUNDAY = <span class="number">1</span>,</span><br><span class="line">    MONDAY,</span><br><span class="line">    TUESDAY,</span><br><span class="line">    WEDNESDAY,</span><br><span class="line">    THURSDAY,</span><br><span class="line">    FRIDAY,</span><br><span class="line">    SATURDAY</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，SUNDAY 被显式赋值为1，那么 MONDAY 对应的值就是2，TUESDAY 对应的值就是3，以此类推。</p>
<h3 id="5-3-如何使用枚举"><a href="#5-3-如何使用枚举" class="headerlink" title="5.3 如何使用枚举"></a>5.3 如何使用枚举</h3><p>定义了枚举类型后，你就可以声明该类型的变量，并将枚举常量赋给它。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span> <span class="title">day</span>;</span></span><br><span class="line">day = MONDAY;</span><br></pre></td></tr></table></figure>

<p>你也可以直接使用枚举常量，因为它们本质上就是整数。例如，你可以在 printf 函数中打印它们：<br><strong>printf(“%d\n”, MONDAY); &#x2F;&#x2F; 打印1</strong><br>或者在 switch 语句中使用它们：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(day) &#123;</span><br><span class="line">    <span class="keyword">case</span> MONDAY:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Today is Monday.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> TUESDAY:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Today is Tuesday.\n&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 其他情况</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结来说，枚举是一种非常有用的工具，它可以帮助我们创建一组命名的整数常量，使程序更加清晰和易于理解。</p>
<h2 id="六、C语言中的类型定义和typedef"><a href="#六、C语言中的类型定义和typedef" class="headerlink" title="六、C语言中的类型定义和typedef"></a>六、C语言中的类型定义和typedef</h2><h3 id="6-1-类型定义的概念"><a href="#6-1-类型定义的概念" class="headerlink" title="6.1 类型定义的概念"></a>6.1 类型定义的概念</h3><p>在 C 语言中，typedef 是一个关键字，它用于为复杂的数据类型定义新的名称，以方便在程序中使用。这通常被用来简化复杂的类型声明，或者为某种特定的类型定义更具可读性的名称。</p>
<h3 id="6-2-typedef-的基本语法"><a href="#6-2-typedef-的基本语法" class="headerlink" title="6.2 typedef 的基本语法"></a>6.2 typedef 的基本语法</h3><p>作用：给变量更换名字</p>
<p>typedef 的基本语法是这样的：<br><strong>typedef existing_type new_type_name;</strong><br>在这个语句中，existing_type 是一个已经存在的类型，可以是内置的类型（如 int, float 等），也可以是用户定义的类型（如结构体，联合体等）。new_type_name 是你想要定义的新类型的名称。<br>例如，你可以为 unsigned int 类型定义一个新的名称 uint：<br><strong>typedef unsigned int uint;</strong><br>之后，你就可以在程序中使用 uint 来代替 unsigned int 类型：<br><strong>uint a &#x3D; 10;</strong></p>
<h3 id="6-3-typedef-在结构体和联合体中的使用"><a href="#6-3-typedef-在结构体和联合体中的使用" class="headerlink" title="6.3 typedef 在结构体和联合体中的使用"></a>6.3 typedef 在结构体和联合体中的使用</h3><p>typedef 在结构体和联合体中的使用非常常见。例如，你可以为结构体定义一个新的类型名称，这样在声明结构体变量时就不用再写 struct 关键字了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; Point;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在你可以直接使用 Point 来声明变量</span></span><br><span class="line">Point p1, p2;</span><br></pre></td></tr></table></figure>

<p>这种方式在定义复杂的类型，如指向结构体的指针或者结构体数组时，会让代码更加清晰易读。<br>总结来说，typedef 是一个非常有用的工具，它可以帮助我们简化复杂的类型声明，提高代码的可读性。</p>
<h1 id="第七章-文件操作和预处理器"><a href="#第七章-文件操作和预处理器" class="headerlink" title="第七章 文件操作和预处理器"></a><strong>第七章 文件操作和预处理器</strong></h1><p>@[toc]<strong>目标</strong></p>
<ul>
<li>1、C语言的文件操作</li>
<li>2、C语言中的文件读写函数</li>
<li>3、C语言中的文件定位函数</li>
<li>4、C语言中的文件实战</li>
<li>5、C语言中的预处理器指令</li>
<li>6、C语言中的模块化编程</li>
<li>7、C语言中的宏函数和内联函数</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../../images/1695088035509-427cdd79-45a7-4cd9-a9ec-410a1da1c686.jpeg" alt="img"></p>
<h2 id="一、C语言的文件操作"><a href="#一、C语言的文件操作" class="headerlink" title="一、C语言的文件操作"></a>一、C语言的文件操作</h2><h3 id="1-1-文件操作的基本概念"><a href="#1-1-文件操作的基本概念" class="headerlink" title="1.1 文件操作的基本概念"></a>1.1 文件操作的基本概念</h3><p>在C语言中，文件是一种存储在存储设备上（如硬盘、光盘等）的数据集合。文件是数据的重要载体，是操作系统中对数据管理的一种抽象方式。文件不仅可以存储程序代码，还可以存储各种类型的数据，如文字、图片、音频、视频等。C语言提供了一系列的文件操作函数，可以帮助我们实现对文件的读取、写入、修改等操作。</p>
<h3 id="1-2-文件的打开和关闭"><a href="#1-2-文件的打开和关闭" class="headerlink" title="1.2 文件的打开和关闭"></a>1.2 文件的打开和关闭</h3><p>在C语言中，我们使用fopen函数来打开一个文件，fopen函数需要两个参数：一个是文件路径，另一个是文件模式。文件模式决定了我们可以进行哪些操作，例如，我们可以选择只读模式（”r”）、只写模式（”w”）、读写模式（”rw”）等。<br>在操作完文件后，我们需要使用fclose函数来关闭文件，以释放操作系统分配给该文件的资源。这是一个良好的编程习惯，可以防止资源泄漏，提高程序的稳定性和运行效率。</p>
<h3 id="1-3-文件模式"><a href="#1-3-文件模式" class="headerlink" title="1.3 文件模式"></a>1.3 文件模式</h3><p>文件模式用于决定如何操作文件。以下是C语言中常用的文件模式：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.nlark.com/yuque/0/2023/png/8368890/1695052366873-08a7b38d-ee80-40ae-b43d-7c9d514b3511.png#averageHue=%23f1f1f1&clientId=u6674c2ea-3afd-4&from=paste&height=591&id=uc15feaa9&originHeight=886&originWidth=1691&originalType=binary&ratio=1.5&rotation=0&showTitle=false&size=570163&status=done&style=none&taskId=u99c57e77-6df2-4fef-ad4c-b50a6b548e9&title=&width=1127.3333333333333" alt="img"></p>
<ul>
<li>“r”：只读模式。这种模式下，程序只能读取文件，不能写入。如果文件不存在，fopen函数会返回NULL。</li>
<li>“w”：只写模式。这种模式下，程序只能写入文件，不能读取。如果文件不存在，fopen函数会创建一个新文件。如果文件已存在，它的内容将被清空，即被覆盖。</li>
<li>“a”：追加模式。这种模式下，程序只能在文件的末尾写入数据。如果文件不存在，fopen函数会创建一个新文件。</li>
<li><strong>“r+”：读写模式。这种模式下，程序既能读取文件，也能写入文件。文件必须存在，否则fopen函数会返回NULL。</strong></li>
<li><strong>“w+”：读写模式。这种模式下，程序既能读取文件，也能写入文件。如果文件不存在，fopen函数会创建一个新文件。如果文件已存在，它的内容将被清空，即被覆盖。</strong></li>
<li><strong>“a+”：读写模式。这种模式下，程序既能读取文件，也能在文件的末尾写入数据。如果文件不存在，fopen函数会创建一个新文件。</strong></li>
</ul>
<p>在这些模式中，我们可以添加一个”b”来打开一个二进制文件，如”rb”、”wb”、”ab”、”r+b”、”w+b”、”a+b”。在二进制模式下，文件将按照二进制形式进行读取或写入，这对于处理图像、音频、视频等非文本文件非常有用。</p>
<h2 id="二、C语言中的文件读写函数"><a href="#二、C语言中的文件读写函数" class="headerlink" title="二、C语言中的文件读写函数"></a>二、C语言中的文件读写函数</h2><h3 id="2-1-读写函数的基本概念"><a href="#2-1-读写函数的基本概念" class="headerlink" title="2.1 读写函数的基本概念"></a>2.1 读写函数的基本概念</h3><p>在C语言中，我们可以使用特定的函数来从文件中读取数据或者向文件中写入数据。这些函数主要分为三类：</p>
<ol>
<li><strong>字符读写函数</strong>：这类函数用于读取或写入单个字符，例如 fgetc 和 fputc。</li>
<li><strong>行读写函数</strong>：这类函数用于读取或写入一行字符串，例如 fgets 和 fputs。</li>
<li><strong>格式化读写函数</strong>：这类函数用于读取或写入特定格式的数据，例如 fscanf 和 fprintf。</li>
</ol>
<p>所有这些函数都需要一个文件指针作为参数，这个文件指针指向要读取或写入的文件。接下来，我们将详细介绍这些函数的使用方法。</p>
<h4 id="2-2-使用-fgetc-和-fputc-进行字符读写"><a href="#2-2-使用-fgetc-和-fputc-进行字符读写" class="headerlink" title="2.2 使用 fgetc 和 fputc 进行字符读写"></a>2.2 使用 fgetc 和 fputc 进行字符读写</h4><p>fgetc 和 fputc 是C语言中最基本的文件读写函数，它们分别用于从文件中读取单个字符和向文件中写入单个字符。</p>
<h5 id="fgetc-函数"><a href="#fgetc-函数" class="headerlink" title="fgetc 函数"></a>fgetc 函数</h5><ul>
<li><strong>头文件</strong>：stdio.h</li>
<li><strong>函数原型</strong>：int fgetc(FILE *stream);</li>
<li><strong>函数功能</strong>：从参数stream所指的文件中读取一个字符。</li>
<li><strong>返回值</strong>：读取成功返回字符的ASCII值，读到文件结束或发生错误返回EOF。</li>
</ul>
<h5 id="fputc-函数"><a href="#fputc-函数" class="headerlink" title="fputc 函数"></a>fputc 函数</h5><ul>
<li><strong>头文件</strong>：stdio.h</li>
<li><strong>函数原型</strong>：int fputc(int c, FILE *stream);</li>
<li><strong>函数功能</strong>：将参数c指定的字符写入参数stream所指的文件中。</li>
<li><strong>返回值</strong>：写入成功返回写入的字符，发生错误返回EOF。</li>
</ul>
<h5 id="示例程序："><a href="#示例程序：" class="headerlink" title="示例程序："></a>示例程序：</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     FILE *fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);  <span class="comment">//读写模式</span></span><br><span class="line">     <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Open file failed!\n&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用fputc向文件中写入字符</span></span><br><span class="line">     <span class="type">char</span> c;</span><br><span class="line">     <span class="keyword">for</span> (c = <span class="string">&#x27;A&#x27;</span>; c &lt;= <span class="string">&#x27;Z&#x27;</span>; c++) &#123;</span><br><span class="line">         fputc(c, fp);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 将文件指针重新定位到文件开头</span></span><br><span class="line">     rewind(fp);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用fgetc从文件中读取字符</span></span><br><span class="line">     <span class="keyword">while</span> ((c = fgetc(fp)) != EOF) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, c);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 关闭文件</span></span><br><span class="line">     fclose(fp);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>此程序首先向文件test.txt中写入了从’A’到’Z’的所有大写字母，然后将文件指针重新定位到文件开头，接着用fgetc从文件中读取并打印出所有字符。</p>
<ol>
<li><p>编写一个程序，使用fgetc和fputc复制一个文件的内容到另一个文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *sourceFile, *destinationFile;  <span class="comment">// 定义两个文件指针</span></span><br><span class="line">    <span class="type">char</span> ch;                            <span class="comment">// 用于存储读取的字符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开源文件，以只读模式（&quot;r&quot;）</span></span><br><span class="line">    sourceFile = fopen(<span class="string">&quot;source.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sourceFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开源文件。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 文件打开失败，退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建或打开目标文件，以写入模式（&quot;w&quot;）</span></span><br><span class="line">    destinationFile = fopen(<span class="string">&quot;destination.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (destinationFile == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法创建或打开目标文件。\n&quot;</span>);</span><br><span class="line">        fclose(sourceFile);  <span class="comment">// 关闭源文件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 文件打开失败，退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐个字符读取并写入</span></span><br><span class="line">    <span class="keyword">while</span> ((ch = fgetc(sourceFile)) != EOF) &#123;  <span class="comment">// EOF是文件结束标志</span></span><br><span class="line">        fputc(ch, destinationFile);  <span class="comment">// 将读取的字符写入目标文件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(sourceFile);</span><br><span class="line">    fclose(destinationFile);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;文件复制完成。\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>编写一个程序，使用fgetc读取一个文本文件，并统计其中的字符数量。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="2-3-使用-fgets-和-fputs-进行行读写"><a href="#2-3-使用-fgets-和-fputs-进行行读写" class="headerlink" title="2.3 使用 fgets 和 fputs 进行行读写"></a>2.3 使用 fgets 和 fputs 进行行读写</h3><p>fgets 和 fputs 是C语言中用于处理字符串的文件读写函数，它们分别用于从文件中读取一行字符串和向文件中写入一行字符串。</p>
<h5 id="fgets-函数"><a href="#fgets-函数" class="headerlink" title="fgets 函数"></a>fgets 函数</h5><ul>
<li><strong>头文件</strong>：stdio.h</li>
<li><strong>函数原型</strong>：char <em>fgets(char</em> str, int n, FILE *stream);</li>
<li><strong>函数功能</strong>：从参数stream所指的文件中读取一行字符串（包括’\n’）到str所指的字符数组，最多读取n-1个字符（最后一个字符会被自动赋值为’\0’）。</li>
</ul>
<h5 id="fgets-函数参数解释"><a href="#fgets-函数参数解释" class="headerlink" title="fgets 函数参数解释"></a>fgets 函数参数解释</h5><ul>
<li><strong>str</strong>：这是指向一个字符数组的指针，该数组将存储从文件中读取的字符串。</li>
<li><strong>n</strong>：这是要读取的最大字符数，包括空字符’\0’。换句话说，str指向的字符数组的大小应至少为n。</li>
<li><strong>stream</strong>：这是一个指向FILE类型的指针，它指定了要从中读取字符的文件。</li>
<li><strong>返回值</strong>：读取成功返回str，读到文件结束或发生错误返回NULL。</li>
</ul>
<h5 id="fputs-函数"><a href="#fputs-函数" class="headerlink" title="fputs 函数"></a>fputs 函数</h5><ul>
<li><strong>头文件</strong>：stdio.h</li>
<li><strong>函数原型</strong>：int fputs(const char <em>str, FILE</em> stream);</li>
<li><strong>函数功能</strong>：将参数str所指的字符串写入参数stream所指的文件中。</li>
</ul>
<h5 id="fputs-函数参数解释"><a href="#fputs-函数参数解释" class="headerlink" title="fputs 函数参数解释"></a>fputs 函数参数解释</h5><ul>
<li><strong>str</strong>：这是一个指针，指向要写入文件的字符串。字符串应以空字符’\0’结尾。</li>
<li><strong>stream</strong>：这是一个指向FILE类型的指针，它指定了要写入字符串的文件。</li>
<li><strong>返回值</strong>：写入成功返回非负值，发生错误返回EOF。</li>
</ul>
<h5 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     FILE *fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;文件打开失败\n&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用fputs向文件中写入字符串</span></span><br><span class="line">     <span class="type">char</span> str[] = <span class="string">&quot;Hello, World!\n&quot;</span>;</span><br><span class="line">     <span class="built_in">fputs</span>(str, fp);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 将文件指针重新定位到文件开头</span></span><br><span class="line">     rewind(fp);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用fgets从文件中读取字符串</span></span><br><span class="line">     <span class="type">char</span> buffer[<span class="number">50</span>];</span><br><span class="line">     <span class="keyword">while</span> (fgets(buffer, <span class="number">50</span>, fp) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 关闭文件</span></span><br><span class="line">     fclose(fp);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-使用-fscanf-和-fprintf-进行格式化读写"><a href="#2-4-使用-fscanf-和-fprintf-进行格式化读写" class="headerlink" title="2.4 使用 fscanf 和 fprintf 进行格式化读写"></a>2.4 使用 fscanf 和 fprintf 进行格式化读写</h4><p>fscanf 和 fprintf 是C语言中用于格式化文件读写的函数，它们可以分别从文件中读取和向文件中写入各种类型的数据，包括字符、数字和字符串。</p>
<h5 id="fscanf-函数"><a href="#fscanf-函数" class="headerlink" title="fscanf 函数"></a>fscanf 函数</h5><ul>
<li><p><strong>头文件</strong>：stdio.h</p>
</li>
<li><p><strong>函数原型</strong>：int fscanf(FILE <em>stream, const char</em> format, …);</p>
</li>
<li><p><strong>函数功能</strong>：从参数stream所指的文件中按照参数format所指定的格式读取数据。</p>
</li>
<li><p>参数解析： </p>
</li>
<li><p><strong>stream</strong>：这是一个指向FILE类型的指针，它指定了要从中读取数据的文件。</p>
</li>
<li><p><strong>format</strong>：这是一个格式字符串，它包含一个或多个用于指定要读取的数据类型的格式说明符。</p>
</li>
<li><p>**…**：这是变长参数列表，每一个参数都应该是一个指向变量的指针，这些变量将被用于存储从文件中读取的数据。</p>
</li>
<li><p><strong>返回值</strong>：成功读取的项数，或者在读取失败或读到文件末尾时返回EOF。</p>
</li>
</ul>
<h5 id="fprintf-函数"><a href="#fprintf-函数" class="headerlink" title="fprintf 函数"></a>fprintf 函数</h5><ul>
<li><p><strong>头文件</strong>：stdio.h</p>
</li>
<li><p><strong>函数原型</strong>：int fprintf(FILE <em>stream, const char</em> format, …);</p>
</li>
<li><p><strong>函数功能</strong>：将参数format所指定的格式的数据写入参数stream所指的文件。</p>
</li>
<li><p>参数解析： </p>
</li>
<li><p><strong>stream</strong>：这是一个指向FILE类型的指针，它指定了要写入数据的文件。</p>
</li>
<li><p><strong>format</strong>：这是一个格式字符串，它包含一个或多个用于指定要写入的数据类型的格式说明符。</p>
</li>
<li><p>**…**：这是变长参数列表，每一个参数都应该是一个变量，这些变量的值将被写入文件。</p>
</li>
<li><p><strong>返回值</strong>：成功写入的项数，或者在写入失败时返回负值。</p>
</li>
</ul>
<h5 id="示例程序-1"><a href="#示例程序-1" class="headerlink" title="示例程序"></a>示例程序</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line"> &#123;</span><br><span class="line">     FILE * fp = fopen(<span class="string">&quot;hello.txt&quot;</span> , <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;文件打开失败!!!&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用fprintf向文件写入数据</span></span><br><span class="line">     <span class="type">int</span> age = <span class="number">30</span>;</span><br><span class="line">     <span class="type">float</span> height = <span class="number">180.5</span>;</span><br><span class="line">     <span class="built_in">fprintf</span>(fp , <span class="string">&quot;年龄 :%d\n身高 :%.2f\n&quot;</span>, age , height);    <span class="comment">//格式化输入字符到文件中</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//将文件重新定义到文件开头</span></span><br><span class="line">     rewind(fp);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用fscanf 从文件中读取格式化的数据</span></span><br><span class="line">     <span class="type">int</span> read_age = <span class="number">0</span>;</span><br><span class="line">     <span class="type">float</span> read_height = <span class="number">0</span>;</span><br><span class="line">     <span class="built_in">fscanf</span>(fp , <span class="string">&quot;年龄 :%d\n身高 :%f\n&quot;</span>, &amp;read_age , &amp;read_height);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;年龄 :%d\n身高 :%.2f\n&quot;</span>, read_age , read_height);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     fclose(fp);  <span class="comment">//关闭文件</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>*<strong>fprintf和fscanf格式和文件内部格式一定要相同，不要自己写，ctrl c v*</strong></p>
<h2 id="三、C语言中的文件定位函数"><a href="#三、C语言中的文件定位函数" class="headerlink" title="三、C语言中的文件定位函数"></a>三、C语言中的文件定位函数</h2><h3 id="3-1-文件定位函数的基本概念"><a href="#3-1-文件定位函数的基本概念" class="headerlink" title="3.1 文件定位函数的基本概念"></a>3.1 文件定位函数的基本概念</h3><p>文件定位函数用于操作文件指针，改变文件指针的当前位置。它们使得我们可以在文件中随机地访问数据，而不仅仅是按顺序读取或写入数据。这在处理大文件或需要随机访问的应用中尤其有用。<br>C语言中的文件定位函数主要包括以下几种：</p>
<ol>
<li>fseek 函数：移动文件指针到指定位置</li>
<li>ftell 函数：获取当前文件指针的位置</li>
<li>rewind 函数：将文件指针重置到文件的开头</li>
</ol>
<p>文件指针是一个指示当前正在读取或写入的文件位置的指针。每个文件在被打开时都会有一个文件指针与之关联，这个指针最初总是指向文件的开头。当我们读取或写入数据时，文件指针会随之移动，以指示下一个将要操作的位置。</p>
<h3 id="3-2-使用-fseek-进行文件定位"><a href="#3-2-使用-fseek-进行文件定位" class="headerlink" title="3.2 使用 fseek 进行文件定位"></a>3.2 使用 fseek 进行文件定位</h3><ul>
<li><p><strong>头文件</strong>：#include &lt;stdio.h&gt;</p>
</li>
<li><p><strong>函数原型</strong>：int fseek(FILE *stream, long offset, int whence);</p>
</li>
<li><p><strong>函数名称</strong>：fseek</p>
</li>
<li><p><strong>函数参数</strong>： </p>
</li>
<li><p>FILE *stream: 需要进行定位的文件指针。</p>
</li>
<li><p>long offset: 需要移动的字节数，从 whence 指定的位置算起。</p>
</li>
<li><p>int whence: 偏移的起始位置，可以有三个值： </p>
</li>
<li><p><strong>SEEK_SET: 文件开头</strong></p>
</li>
<li><p><strong>SEEK_CUR: 当前位置</strong></p>
</li>
<li><p><strong>SEEK_END: 文件结尾</strong></p>
</li>
<li><p><strong>函数返回值</strong>：如果成功，返回0。如果发生错误，返回非0值。</p>
</li>
<li><p><strong>示例程序</strong>：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     FILE *fp;</span><br><span class="line"></span><br><span class="line">     fp = fopen(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">     <span class="built_in">fputs</span>(<span class="string">&quot;This is a test&quot;</span>, fp);</span><br><span class="line"></span><br><span class="line">     fseek(fp, <span class="number">7</span>, SEEK_SET);</span><br><span class="line">     <span class="built_in">fputs</span>(<span class="string">&quot; Hello World!&quot;</span>, fp);</span><br><span class="line">     fclose(fp);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>以上程序会创建一个新文件 file.txt，并在其中写入 “This is a test”。然后，程序将文件指针移动到文件的第7个字节（即 ‘a’ 后面的空格），并接着写入 “ Hello World!”。所以，最后的文件内容将是 “This is Hello World!”。</p>
<ul>
<li><p>练习： </p>
</li>
<li><p>创建一个文件，并写入一些文本。</p>
</li>
<li><p>使用 fseek 函数将文件指针移动到文件中的某个位置。</p>
</li>
<li><p>在该位置写入一些文本。</p>
</li>
<li><p>关闭文件，并查看最后的文件内容。</p>
</li>
</ul>
<h3 id="3-3-使用-ftell-获取当前位置"><a href="#3-3-使用-ftell-获取当前位置" class="headerlink" title="3.3 使用 ftell 获取当前位置"></a>3.3 使用 ftell 获取当前位置</h3><p>ftell 是一个标准库函数，它返回参数指定的文件流的当前文件位置指示器的位置。该函数是非常有用的，尤其是当你需要在文件中进行随机访问时。<br><strong>头文件</strong>：需要包含头文件 #include &lt;stdio.h&gt;<br><strong>函数原型</strong>：long ftell(FILE *stream);<br><strong>函数名</strong>：ftell<br><strong>函数参数</strong>：FILE *stream，指向FILE对象的指针，该FILE对象指定了一个输入流。<br><strong>函数返回值</strong>：如果成功，该函数返回当前文件位置指示器的位置，否则返回-1并设置全局变量 errno。<br><strong>示例程序</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     FILE *fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Open file failed!\n&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 移动文件位置指示器到文件中间</span></span><br><span class="line">     fseek(fp, <span class="number">5</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 获取当前文件位置</span></span><br><span class="line">     <span class="type">long</span> pos = ftell(fp);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Current file position: %ld\n&quot;</span>, pos);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 关闭文件</span></span><br><span class="line">     fclose(fp);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们首先打开一个文件，并使用 fseek 函数将文件位置指示器移到文件的中间。然后，我们使用 ftell 函数获取当前的文件位置，并打印出来。最后，我们关闭文件。<br><strong>练习</strong>：尝试修改示例程序，让文件位置指示器移动到文件的不同位置，然后使用 ftell 函数获取并打印当前的文件位置。</p>
<h3 id="3-4-使用-回到文件首部"><a href="#3-4-使用-回到文件首部" class="headerlink" title="3.4 使用	 回到文件首部"></a>3.4 使用	 回到文件首部</h3><p>rewind 是一个标准库函数，它将文件位置指示器移回参数指定的文件流的开始位置，同时清除和流有关的错误和结束文件状态。<br><strong>头文件</strong>：需要包含头文件 #include &lt;stdio.h&gt;<br><strong>函数原型</strong>：void rewind(FILE *stream);<br><strong>函数名</strong>：rewind<br><strong>函数参数</strong>：FILE *stream，指向FILE对象的指针，该FILE对象指定了一个输入流。<br><strong>函数返回值</strong>：无。<br><strong>示例程序</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     FILE *fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Open file failed!\n&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 写入一些数据到文件</span></span><br><span class="line">     <span class="built_in">fputs</span>(<span class="string">&quot;Hello, world!&quot;</span>, fp);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 使用rewind将文件位置指示器重置到文件开始</span></span><br><span class="line">     rewind(fp);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 读取并打印文件中的数据</span></span><br><span class="line">     <span class="type">char</span> buffer[<span class="number">50</span>];</span><br><span class="line">     fgets(buffer, <span class="number">50</span>, fp);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 关闭文件</span></span><br><span class="line">     fclose(fp);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们首先打开一个文件并写入一些数据。然后我们使用 rewind 函数将文件位置指示器重置到文件的开始。接着，我们读取并打印出文件中的数据。最后，我们关闭文件。<br><strong>练习</strong>：尝试修改示例程序，使用 fseek 函数将文件位置指示器移动到文件的不同位置，然后使用 rewind 函数重置文件位置指示器，并使用 fgets 函数读取并打印出文件中的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Open file failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入一些数据到文件</span></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;Hello, world!\nThis is a test file.\n&quot;</span>, fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用rewind将文件位置指示器重置到文件开始</span></span><br><span class="line">    rewind(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取并打印文件中的数据</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">50</span>];</span><br><span class="line">    fgets(buffer, <span class="number">50</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First read: %s&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用fseek将文件位置指示器移动到文件的特定位置</span></span><br><span class="line">    <span class="comment">// 移动到文件开头后50个字节的位置</span></span><br><span class="line">    fseek(fp, <span class="number">50</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次读取并打印文件中的数据</span></span><br><span class="line">    fgets(buffer, <span class="number">50</span>, fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nSecond read: %s&quot;</span>, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="四、C语言中的文件实战"><a href="#四、C语言中的文件实战" class="headerlink" title="四、C语言中的文件实战"></a>四、C语言中的文件实战</h2><h3 id="4-1-实战项目介绍"><a href="#4-1-实战项目介绍" class="headerlink" title="4.1 实战项目介绍"></a>4.1 实战项目介绍</h3><h3 id="4-2-代码实现"><a href="#4-2-代码实现" class="headerlink" title="4.2 代码实现"></a>4.2 代码实现</h3><h3 id="4-3-代码测试和问题解决"><a href="#4-3-代码测试和问题解决" class="headerlink" title="4.3 代码测试和问题解决"></a>4.3 代码测试和问题解决</h3><h2 id="五、C语言中的预处理器指令"><a href="#五、C语言中的预处理器指令" class="headerlink" title="五、C语言中的预处理器指令"></a>五、C语言中的预处理器指令</h2><p>C 语言的预处理器指令是在编译器开始编译程序代码之前由预处理器执行的一些指令。以下是一些常见的预处理器指令：</p>
<ol>
<li>#include - 用于包含头文件。例如： #include &lt;stdio.h&gt;</li>
</ol>
<p><strong>include</strong><br>include &lt;&gt; : 调用系统库内的.h文件<br>include “” : 调用本地文件的.h文件， 如果没有则查找系统库内的文件</p>
<ol>
<li>#define - 用于定义宏。例如： #define PI 3.14159</li>
</ol>
<p>define 宏定义 ： 无脑替换<br>定义常量<br>定义函数</p>
<ol>
<li>#undef - 用于取消已定义的宏。例如： #undef PI</li>
<li>#if, #elif, #else, #endif - 用于条件编译。例如：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(WIN32)</span></span><br><span class="line"><span class="comment">// Windows 平台的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(LINUX)</span></span><br><span class="line"><span class="comment">// Linux 平台的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// 其他平台的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li>#ifdef 和 #ifndef - 用于检查宏是否已定义或未定义。例如：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="comment">// 调试模式下的代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>注意，预处理器指令不是C语言的一部分，它们是由C预处理器处理的，而不是C编译器。预处理器指令通常不遵循C语言的语法规则，而是遵循自己的规则集。</p>
<h2 id="六、C语言中的模块化编程"><a href="#六、C语言中的模块化编程" class="headerlink" title="六、C语言中的模块化编程"></a>六、C语言中的模块化编程</h2><h2 id="七、C语言中的宏函数和内联函数"><a href="#七、C语言中的宏函数和内联函数" class="headerlink" title="七、C语言中的宏函数和内联函数"></a>七、C语言中的宏函数和内联函数</h2><p>在C语言中，宏是由预处理器（preprocessor）处理的一种机制，可以用来为代码创建别名或者执行简单的代码生成任务。宏可以分为对象宏和函数宏两种。</p>
<h3 id="1-对象宏（Object-Macros）"><a href="#1-对象宏（Object-Macros）" class="headerlink" title="1. 对象宏（Object Macros）"></a>1. 对象宏（Object Macros）</h3><p>对象宏用于为某个值或表达式定义一个名字。它们通常是这样定义的：<br>#define PI 3.14159<br>在这里，PI 是一个宏，它被定义为3.14159。</p>
<h3 id="2-函数宏（Function-Macros）"><a href="#2-函数宏（Function-Macros）" class="headerlink" title="2. 函数宏（Function Macros）"></a>2. 函数宏（Function Macros）</h3><p>函数宏类似于函数，但它们是在预处理阶段展开的，而不是在运行时被调用。函数宏是这样定义的：<br>#define SQUARE(x) ((x) * (x))<br>在这里，SQUARE是一个宏，它接受一个参数x，并返回x的平方。注意，参数被括在括号里，以避免由于运算符优先级引起的问题。</p>
<h3 id="3-宏函数的使用注意事项："><a href="#3-宏函数的使用注意事项：" class="headerlink" title="3. 宏函数的使用注意事项："></a>3. 宏函数的使用注意事项：</h3><ol>
<li><strong>括号的使用</strong>：为了避免优先级的问题，参数和整个宏都应该用括号括起来。</li>
<li><strong>副作用</strong>：由于宏是在预处理阶段展开的，所以如果宏的参数有副作用（例如，它是一个具有副作用的表达式），那么这个副作用可能会发生多次。</li>
<li><strong>代码膨胀</strong>：使用宏可以导致代码膨胀，因为宏每次被调用时都会被其定义所替换。</li>
<li><strong>调试困难</strong>：使用宏可以使代码更难调试，因为编译器在编译代码之前会先展开宏，这使得源代码和编译器看到的代码之间存在差异。</li>
</ol>
<h3 id="4-一个例子："><a href="#4-一个例子：" class="headerlink" title="4. 一个例子："></a>4. 一个例子：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">double</span> radius = <span class="number">2.0</span>;</span><br><span class="line">     <span class="type">double</span> area = PI * SQUARE(radius);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Area: %f\n&quot;</span>, area);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了两个宏：PI 和 SQUARE，并使用它们来计算一个圆的面积。</p>
<p>内联函数是一种特殊类型的函数，它的目的是为了减少函数调用的开销。当你将一个函数声明为内联时，编译器会尝试将该函数的代码嵌入到每一个调用点，就像宏一样。但是与宏不同，内联函数仍然是一个真正的函数，这意味着它遵循常规的类型检查和作用域规则。</p>
<h3 id="声明内联函数"><a href="#声明内联函数" class="headerlink" title="声明内联函数"></a>声明内联函数</h3><p>要声明一个内联函数，你可以使用 inline 关键字，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="特点和注意事项"><a href="#特点和注意事项" class="headerlink" title="特点和注意事项"></a>特点和注意事项</h3><ol>
<li><strong>类型检查</strong>：内联函数与普通函数一样，进行类型检查，而宏不进行类型检查。</li>
<li><strong>编译器决定</strong>：即使你将一个函数声明为内联，编译器也可能决定不内联它，特别是如果函数体很大或者很复杂。</li>
<li><strong>代码膨胀</strong>：与宏一样，内联函数也可能导致代码膨胀，因为它们的代码可以被插入到多个调用点。</li>
<li><strong>调用开销减少</strong>：通过内联一个函数，你可以减少函数调用的开销，这可能会使你的程序运行得更快，但是这也可能增加你的程序的大小。</li>
<li><strong>多重定义</strong>：在多个源文件中包含相同的内联函数定义是允许的，但所有的定义必须是完全相同的。</li>
</ol>
<h3 id="内联函数的例子："><a href="#内联函数的例子：" class="headerlink" title="内联函数的例子："></a>内联函数的例子：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> x * x;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Square of %d is %d\n&quot;</span>, a, square(a));</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了一个内联函数 square，用于计算一个数的平方，并在 main 函数中调用它。注意，我们使用 inline 关键字来指示编译器我们想要将这个函数作为内联函数。</p>
<h1 id="第八章-高级C语言特性"><a href="#第八章-高级C语言特性" class="headerlink" title="第八章 高级C语言特性"></a><strong>第八章 高级C语言特性</strong></h1><p>@[toc]<strong>目标</strong></p>
<ul>
<li>1、C语言中的动态内存分配</li>
<li>2、C语言中的可变参数函数</li>
<li>3、C语言中的递归函数</li>
</ul>
<h2 id="一、C语言中的动态内存分配"><a href="#一、C语言中的动态内存分配" class="headerlink" title="一、C语言中的动态内存分配"></a>一、C语言中的动态内存分配</h2><h3 id="1-内存管理"><a href="#1-内存管理" class="headerlink" title="1. 内存管理"></a>1. 内存管理</h3><p>内存的使用是程序设计中需要考虑的重要因素，尤其是在嵌入式系统中，对于内存资源是有限的。<br>在C语言中，内存通常分为以下几个区域：</p>
<ul>
<li><p><strong>代码区（Text Segment）</strong>：该区域存放程序的代码（可执行指令），它是只读的，以防止程序在运行时自我修改。</p>
</li>
<li><p><strong>数据区</strong>：又可以细分为以下几部分： </p>
</li>
<li><p><strong>全局变量与静态变量区</strong>：此区域用于存放全局变量和静态变量。这些变量的内存是在程序启动时分配的，并在程序结束时释放。</p>
</li>
<li><p><strong>常量区</strong>：存放如字符串常量的区域。</p>
</li>
<li><p><strong>堆区（Heap）</strong>：堆是用于动态内存分配的区域，使用malloc，calloc或realloc函数分配内存，并使用free函数释放内存。动态内存分配提供了灵活性，但也增加了内存泄漏和其他问题的可能性。</p>
</li>
<li><p><strong>栈区（Stack）</strong>：栈用于存放局部变量和函数调用的信息。它是系统自管理的，每当进入一个函数时，就会为该函数分配一块新的栈空间，函数返回时，该块栈空间被释放。虽然栈的使用很高效，但空间有限 ，在Linux中只有8m 8192。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../../images/1695190187057-9ac6f647-031b-4c12-98ce-852571ada6cf.jpeg" alt="img"><br><strong>示例与解释</strong><br>例如，当我们定义如下结构体时：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果学生的姓名超过我们所定义的空间，可能会发生内存溢出的问题。因此，在这种情况下使用动态内存分配更合理，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以动态分配内存来存储姓名，这样可以避免内存溢出的问题。在分配内存时，我们可以根据实际需要来分配内存空间，而不是预先分配固定大小的空间。<br>下面这段程序示例了不同类型的内存分配：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//  申请空间</span></span><br><span class="line"><span class="comment">//  void * 类型   泛指针   -&gt;  可以转换成其他类型的</span></span><br><span class="line"><span class="comment">// extern void *malloc (size_t __size)</span></span><br><span class="line"><span class="comment">//  size_t __size   要申请空间的大小</span></span><br><span class="line"><span class="comment">//  malloc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放空间</span></span><br><span class="line"><span class="comment">//  extern void free (void *__ptr) </span></span><br><span class="line"><span class="comment">//  free(__ptr)</span></span><br><span class="line"><span class="comment">//  __ptr   要释放的空间</span></span><br><span class="line"><span class="comment">// 强制类型转换 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zzh</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> * name;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125;zzh;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//申请空间</span></span><br><span class="line">    zzh * zzh1 = (zzh *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(zzh));</span><br><span class="line">    <span class="comment">//  zzh * zzh1   创建结构体指针</span></span><br><span class="line">    <span class="comment">//  (zzh *)malloc(sizeof(zzh));</span></span><br><span class="line">    <span class="comment">//      (zzh *)         类型转换</span></span><br><span class="line">    <span class="comment">//      malloc          申请空间的函数</span></span><br><span class="line">    <span class="comment">//      sizeof(zzh)     申请空间的大小</span></span><br><span class="line">    <span class="comment">//判断空间创建是否成功</span></span><br><span class="line">    <span class="comment">//      指针指向问题  :  指针只能指向同类型的变量地址</span></span><br><span class="line">    <span class="keyword">if</span> (zzh1 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zzh1-&gt;id = <span class="number">666</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span> , zzh1-&gt;id);</span><br><span class="line">    zzh1-&gt;name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span> , zzh1-&gt;name);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放空间</span></span><br><span class="line">    <span class="built_in">free</span>(zzh1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个名为stu的结构体，包含一个字符指针和一个整数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line">        <span class="type">char</span> *name;</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配内存以存储一个stu结构体实例</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">s</span> =</span> (<span class="keyword">struct</span> stu*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> stu));</span><br><span class="line">    <span class="comment">// 检查内存分配是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为结构体中的name字段动态分配内存，可以容纳50个字符</span></span><br><span class="line">    s-&gt;name = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">50</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">    <span class="comment">// 检查内存分配是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;name == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">free</span>(s); <span class="comment">// 在退出前释放之前分配的内存</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置结构体中的id和name字段</span></span><br><span class="line">    s-&gt;id = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">snprintf</span>(s-&gt;name, <span class="number">50</span>, <span class="string">&quot;Student Name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印结构体中的id和name字段</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ID: %d, Name: %s\n&quot;</span>, s-&gt;id, s-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="built_in">free</span>(s-&gt;name);</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 程序成功结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此程序中，我们创建了一个stu结构体并动态分配了内存来存储结构体及其name字段。在程序结束时，我们释放了分配的内存，避免了内存泄漏。</p>
<h3 id="2、动态内存的申请和释放"><a href="#2、动态内存的申请和释放" class="headerlink" title="2、动态内存的申请和释放"></a>2、动态内存的申请和释放</h3><p>malloc 和 free 是 C 语言中用于动态内存分配和释放的两个主要函数。下面我们将详细介绍这两个函数的用法和一些相关注意事项：</p>
<h4 id="1-malloc"><a href="#1-malloc" class="headerlink" title="1. malloc"></a>1. malloc</h4><p><strong>功能</strong>：malloc ，用于在堆上分配一块指定大小的内存。<br><strong>原型</strong>：<br>void* malloc(size_t size);<br><strong>参数</strong>：</p>
<ul>
<li>size：要分配的内存大小，以字节为单位。</li>
</ul>
<p><strong>返回值</strong>：</p>
<ul>
<li>如果分配成功，则返回指向分配的内存块的指针。</li>
<li>如果分配失败，则返回 NULL。</li>
</ul>
<p><strong>例子</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 分配一块足够存放一个整数的内存</span></span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed\n&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">*ptr = <span class="number">42</span>; <span class="comment">// 初始化分配的内存</span></span><br></pre></td></tr></table></figure>

<h4 id="2-free"><a href="#2-free" class="headerlink" title="2. free"></a>2. free</h4><p><strong>功能</strong>：释放由 malloc（或 calloc, realloc）分配的内存块。<br><strong>原型</strong>：<br>void free(void* ptr);<br><strong>参数</strong>：</p>
<ul>
<li>ptr：指向要释放的内存块的指针。</li>
</ul>
<p><strong>返回值</strong>：无<br><strong>例子</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = (<span class="type">int</span>*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed\n&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line">*ptr = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">free</span>(ptr); <span class="comment">// 释放分配的内存</span></span><br><span class="line">ptr = <span class="literal">NULL</span>; <span class="comment">// 为了避免悬挂指针，将 ptr 设置为 NULL</span></span><br></pre></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol>
<li><strong>内存泄漏</strong>：如果你分配了内存但未释放它，就会发生内存泄漏。为了避免内存泄漏，你应该确保每次调用 malloc 后，最终都调用 free 来释放内存。</li>
<li><strong>悬挂指针</strong>：在释放内存后，应将指针设置为 NULL 以避免产生悬挂指针（指针仍然指向已释放的内存区域）。</li>
<li><strong>双重释放</strong>：避免对同一内存块进行多次释放，因为这将导致未定义的行为。</li>
<li><strong>内存初始化</strong>：malloc 分配的内存块不会被初始化，它可能包含垃圾数据。在使用前，你应该自己初始化这块内存。</li>
</ol>
<p>通过适当使用 malloc 和 free，你可以更灵活地管理程序中的内存，但也要注意避免相关的内存管理问题。</p>
<h3 id="3、堆和栈的区别"><a href="#3、堆和栈的区别" class="headerlink" title="3、堆和栈的区别"></a>3、堆和栈的区别</h3><p>堆（Heap）和栈（Stack）是两种不同的内存分配机制，它们在程序中扮演不同的角色。以下是它们之间的一些主要区别：<br><strong>堆 ：</strong> 程序员手动申请 ， 手动释放<br><strong>栈 ：</strong> 系统自动申请，自动释放 (局部变量）</p>
<h4 id="1-内存管理-1"><a href="#1-内存管理-1" class="headerlink" title="1. 内存管理"></a>1. <strong>内存管理</strong></h4><ul>
<li><p><strong>堆（Heap）</strong></p>
</li>
<li><p>堆是一个由操作系统管理的内存区域，主要用于<strong>动态内存分配</strong>。在C语言中，你可以使用malloc(), calloc(), realloc()等函数来在堆上分配内存，<strong>并使用free()来释放内存。</strong></p>
</li>
<li><p>堆内存的分配和释放由程序员控制，容易产生内存泄漏（memory leaks）和悬挂指针（dangling pointers）等问题，如果不妥善管理。</p>
</li>
<li><p><strong>栈（Stack）</strong></p>
</li>
<li><p>栈是一个由编译器自动管理的内存区域，用于存储局部变量、函数参数和返回地址等。</p>
</li>
<li><p>栈内存的分配和释放是自动的，由编译器在函数调用和返回时进行。</p>
</li>
</ul>
<h4 id="2-内存分配速度"><a href="#2-内存分配速度" class="headerlink" title="2. 内存分配速度"></a>2. <strong>内存分配速度</strong></h4><ul>
<li><p><strong>堆（Heap）</strong></p>
</li>
<li><p>动态内存分配和释放通常比栈上的分配和释放要慢，因为它涉及到更复杂的内存管理算法和可能的系统调用。</p>
</li>
<li><p><strong>栈（Stack）</strong></p>
</li>
<li><p>栈上的内存分配和释放速度非常快，因为它仅涉及到栈指针的移动。</p>
</li>
</ul>
<h4 id="3-内存大小"><a href="#3-内存大小" class="headerlink" title="3. 内存大小"></a>3. <strong>内存大小</strong></h4><ul>
<li><p><strong>堆（Heap）</strong></p>
</li>
<li><p>堆通常有很大的空间，可以用于存储大量数据。</p>
</li>
<li><p>在堆上分配大量内存可能会导致内存碎片化（memory fragmentation）。</p>
</li>
<li><p><strong>栈（Stack）</strong></p>
</li>
<li><p>栈的大小通常比堆小，因此适合存储小量的数据。</p>
</li>
<li><p>超出栈的大小限制（例如递归调用深度太深）可能会导致栈溢出（stack overflow）。</p>
</li>
</ul>
<h4 id="4-生命周期"><a href="#4-生命周期" class="headerlink" title="4. 生命周期"></a>4. <strong>生命周期</strong></h4><ul>
<li><p><strong>堆（Heap）</strong></p>
</li>
<li><p>分配在堆上的内存的生命周期由程序员控制，可以跨越多个函数调用。</p>
</li>
<li><p><strong>栈（Stack）</strong></p>
</li>
<li><p>栈上的内存有限制的生命周期，通常与它们所在的函数调用的生命周期相同。</p>
</li>
</ul>
<h4 id="5-可见性"><a href="#5-可见性" class="headerlink" title="5. 可见性"></a>5. <strong>可见性</strong></h4><ul>
<li><p><strong>堆（Heap）</strong></p>
</li>
<li><p>堆上分配的内存可以被程序中的任何函数访问，只要你有指向该内存的有效指针。</p>
</li>
<li><p><strong>栈（Stack）</strong></p>
</li>
<li><p>栈上的内存（如局部变量）仅在其声明的函数内部可见。</p>
</li>
</ul>
<p>希望这有助于你理解堆和栈的区别！如果你有任何其他问题或需要更多的解释，请随时问。</p>
<h2 id="二、C语言中的可变参数函数"><a href="#二、C语言中的可变参数函数" class="headerlink" title="二、C语言中的可变参数函数"></a>二、C语言中的可变参数函数</h2><p>在C语言中，可变参数函数是一种可以接受可变数量的参数的函数。要创建可变参数函数，您需要包含头文件 &lt;stdarg.h&gt;，然后使用一组宏来访问这些参数。下面是一个简单的步骤和示例说明如何创建和使用可变参数函数：</p>
<h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><ol>
<li><strong>包含头文件</strong>：&lt;stdarg.h&gt;是包含可变参数宏的头文件，您需要在程序中包含它。 #include &lt;stdarg.h&gt;</li>
<li><strong>定义函数</strong>：在函数定义中，至少应有一个已命名的参数，后跟省略号（…），表示函数可以接收可变数量的参数。 void my_function(int num, …);</li>
<li><strong>声明va_list</strong>：在函数内部，使用va_list类型的变量来存储可变参数的列表。</li>
<li><strong>初始化va_list</strong>：使用va_start宏初始化va_list变量。</li>
<li><strong>访问可变参数</strong>：使用va_arg宏来访问可变参数列表中的每个参数。</li>
<li><strong>清理va_list</strong>：使用va_end宏来清理va_list变量。</li>
</ol>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_function</span><span class="params">(<span class="type">int</span> num, ...)</span> &#123;</span><br><span class="line">     va_list args;</span><br><span class="line">     va_start(args, num);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">         <span class="type">int</span> value = va_arg(args, <span class="type">int</span>);</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;Argument %d: %d\n&quot;</span>, i+<span class="number">1</span>, value);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     va_end(args);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     my_function(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，my_function是一个可变参数函数，它接受一个整数参数num，表示将传递多少个可变参数，然后是实际的可变参数。它使用va_list和相关的宏来访问和处理这些参数。</p>
<h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Argument 1: 1</span><br><span class="line">Argument 2: 2</span><br><span class="line">Argument 3: 3</span><br></pre></td></tr></table></figure>

<p>这是创建和使用可变参数函数的基本方式。您可以根据需要修改和扩展这个示例，以适应更复杂的情况和不同类型的参数。</p>
<h2 id="三、C语言中的递归函数"><a href="#三、C语言中的递归函数" class="headerlink" title="三、C语言中的递归函数"></a>三、C语言中的递归函数</h2><p>在C语言中，递归是一个函数直接或间接地调用自身的过程。递归函数是解决分治问题的有力工具，但是必须有一个明确的基本情况或停止条件，以避免无限递归。下面是一个递归函数的基本结构和一个简单的示例（计算阶乘）：</p>
<h3 id="递归函数的基本结构："><a href="#递归函数的基本结构：" class="headerlink" title="递归函数的基本结构："></a>递归函数的基本结构：</h3><ol>
<li><strong>基本情况</strong>：这是递归结束的条件，避免无限递归。</li>
<li><strong>递归步骤</strong>：这是一个或多个递归调用，通过逐步减小问题的规模来解决原始问题。</li>
</ol>
<h3 id="示例：计算阶乘"><a href="#示例：计算阶乘" class="headerlink" title="示例：计算阶乘"></a>示例：计算阶乘</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">factorial</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">     <span class="comment">// 基本情况</span></span><br><span class="line">     <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 递归步骤</span></span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">int</span> number = <span class="number">5</span>;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;The factorial of %d is: %d\n&quot;</span>, number, factorial(number));</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ● 基本情况：当n等于0时，函数返回1，因为0的阶乘定义为1。</span></span><br><span class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ● 递归步骤：否则，函数调用自身，参数为n-1，并将返回值与n相乘。</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> num * fun(num - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  压栈</span></span><br><span class="line"><span class="comment">//  fun -&gt;   num = 5</span></span><br><span class="line"><span class="comment">//      fun -&gt; num = 4</span></span><br><span class="line"><span class="comment">//          fun -&gt; num = 3</span></span><br><span class="line"><span class="comment">//              fun -&gt; num = 2</span></span><br><span class="line"><span class="comment">//                  fun -&gt; num = 1</span></span><br><span class="line"><span class="comment">//                      fun -&gt; num = 0  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  出栈</span></span><br><span class="line"><span class="comment">//                      fun -&gt; num = 1  fun(num - 1) -&gt;1    num * 1;    1</span></span><br><span class="line"><span class="comment">//                  fun -&gt; num = 2  fun(num - 1) -&gt;1    num * 1;        2</span></span><br><span class="line"><span class="comment">//               fun -&gt; num = 3  fun(num - 1) -&gt;1    num * 1;           6</span></span><br><span class="line"><span class="comment">//            fun -&gt; num = 4  fun(num - 1) -&gt;1    num * 1;              24</span></span><br><span class="line"><span class="comment">//          fun -&gt; num = 5  fun(num - 1) -&gt;1    num * 1;                120</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d 的阶乘是%d\n&quot;</span> , num , fun(num));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//   压栈</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li><strong>基本情况</strong>：当n等于0时，函数返回1，因为0的阶乘定义为1。</li>
<li><strong>递归步骤</strong>：否则，函数调用自身，参数为n-1，并将返回值与n相乘。</li>
</ul>
<p>递归函数的调用栈会增长到它达到基本情况并开始返回。在上述示例中，调用栈将如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">factorial(<span class="number">5</span>)</span><br><span class="line">   → factorial(<span class="number">4</span>)</span><br><span class="line">     → factorial(<span class="number">3</span>)</span><br><span class="line">       → factorial(<span class="number">2</span>)</span><br><span class="line">         → factorial(<span class="number">1</span>)</span><br><span class="line">           → factorial(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>然后它开始返回并计算结果。<br>注意，<strong>递归函数要小心设计，以避免无限递归和栈溢出，还应注意可能的高时间和空间复杂度。</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.linqiutianovo.xyz">LinQiuTian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.linqiutianovo.xyz/2023/09/20/test/c%E5%92%8Cc++/C%E8%AF%AD%E8%A8%80(5-8%E7%AB%A0)%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%B1%E7%94%A8%E4%BD%93%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%20%E9%AB%98%E7%BA%A7C%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/">https://www.linqiutianovo.xyz/2023/09/20/test/c%E5%92%8Cc++/C%E8%AF%AD%E8%A8%80(5-8%E7%AB%A0)%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88%20%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%B1%E7%94%A8%E4%BD%93%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%20%E9%AB%98%E7%BA%A7C%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.linqiutianovo.xyz" target="_blank">林秋天的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C%E8%AF%AD%E8%A8%80/">C语言</a><a class="post-meta__tags" href="/tags/%E5%87%BD%E6%95%B0/">函数</a><a class="post-meta__tags" href="/tags/%E6%8C%87%E9%92%88/">指针</a><a class="post-meta__tags" href="/tags/%E7%BB%93%E6%9E%84%E4%BD%93/">结构体</a></div><div class="post-share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/08/06/test/%E5%8D%9A%E5%AE%A2/2024-08-06-%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/" title="第一篇文章"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-cover2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">第一篇文章</div></div><div class="info-2"><div class="info-item-1">测试测试</div></div></div></a><a class="pagination-related" href="/2023/09/20/test/c%E5%92%8Cc++/C%E8%AF%AD%E8%A8%80(1-4%E7%AB%A0)/" title="C语言第1-4章内容"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-cover3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">C语言第1-4章内容</div></div><div class="info-2"><div class="info-item-1">第一章 计算机内部结构1.1 计算机内部结构（存储器、CPU、输入输出设备）1.2 C语言的起源和发展1.3 C语言的特点和优缺点1.4 C语言的应用领域1.5 C语言中的八进制、十进制、十六进制数和计算机二进制1.6 C语言的第一个hello world程序  一、计算机内部结构1.1 冯·诺伊曼架构1.1.1 冯·诺伊曼 基本信息：约翰·冯·诺伊曼，1903-1957，匈牙利裔美国数学家和理论物理学家。重要贡献：开创了存储程序的计算机设计概念，即冯·诺伊曼架构。 冯诺伊曼架构 定义：冯·诺伊曼模型，也称冯·诺伊曼架构，是现代计算机的基础，分为输入设备，输出设备，存储器，处理器和总线五部分。输入设备：让用户向计算机输入数据，如键盘，鼠标等。输出设备：让计算机将处理过的数据展示给用户，如显示器，打印机等。存储器：用于存储数据和指令，在冯·诺伊曼模型中，数据和指令存储在同一内存中。  硬盘 ： 外部存储设备 内存 ： 存储程序运行数据 缓存 ：...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2023/09/20/test/c%E5%92%8Cc++/C%E8%AF%AD%E8%A8%80(1-4%E7%AB%A0)/" title="C语言第1-4章内容"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/default-cover3.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2023-09-20</div><div class="info-item-2">C语言第1-4章内容</div></div><div class="info-2"><div class="info-item-1">第一章 计算机内部结构1.1 计算机内部结构（存储器、CPU、输入输出设备）1.2 C语言的起源和发展1.3 C语言的特点和优缺点1.4 C语言的应用领域1.5 C语言中的八进制、十进制、十六进制数和计算机二进制1.6 C语言的第一个hello world程序  一、计算机内部结构1.1 冯·诺伊曼架构1.1.1 冯·诺伊曼 基本信息：约翰·冯·诺伊曼，1903-1957，匈牙利裔美国数学家和理论物理学家。重要贡献：开创了存储程序的计算机设计概念，即冯·诺伊曼架构。 冯诺伊曼架构 定义：冯·诺伊曼模型，也称冯·诺伊曼架构，是现代计算机的基础，分为输入设备，输出设备，存储器，处理器和总线五部分。输入设备：让用户向计算机输入数据，如键盘，鼠标等。输出设备：让计算机将处理过的数据展示给用户，如显示器，打印机等。存储器：用于存储数据和指令，在冯·诺伊曼模型中，数据和指令存储在同一内存中。  硬盘 ： 外部存储设备 内存 ： 存储程序运行数据 缓存 ：...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/08/07/KfPnTIM8WvotugL.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">LinQiuTian</div><div class="author-info-description">林秋天的博客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">28</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">38</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">17</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/linqiutian"><i></i><span>🛴客官点一点...</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/linqiutian" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/412581566@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><center>主域名：<br><a href="https://www.linqiutianovo.xyz"><b><font color="#5ea6e5">https://www.linqiutianovo.xyz/</font></b></a>&nbsp;|&nbsp;<a href="https://www.linqiutianovo.xyz/"><b><font color="#5ea6e5">https://www.linqiutianovo.xyz</font></b></a><br>备用域名：<br><a href="https://www.linqiutianovo.xyz"><b><font color="#5ea6e5">https://www.linqiutianovo.xyz</font></b></a><br><a href="https://www.linqiutianovo.xyz"><b><font color="#5ea6e5">aa.fomal.cc</font></b></a><br><a href="https://www.linqiutianovo.xyz/"><b><font color="#5ea6e5">https://www.linqiutianovo.xyz/</font></b></a><br><a href="mailto:412581566@fqq.com">📬：<b><font color="#a591e0">412581566@fqq.com</font></b></a></center></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%87%BD%E6%95%B0%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-text">第五章 函数和指针</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8"><span class="toc-text">一、C语言中函数的定义和调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1.1 函数的定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-text">二、C语言中函数参数的传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">三、C语言中函数的返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text">四、C语言中全局变量和局部变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text">局部变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%8C%87%E9%92%88%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">五、C语言中指针的概念和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%8C%87%E9%92%88%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E7%9F%A5%E8%AF%86"><span class="toc-text">6.1 指针中的一些基础概念知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">6.1.1 指针的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-%E6%8C%87%E9%92%88%E3%80%81%E5%86%85%E5%AD%98%E3%80%81%E5%9C%B0%E5%9D%80%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">6.1.2 指针、内存、地址的概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%8C%87%E9%92%88%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">6.2 指针的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E8%AF%B4%E6%98%8E"><span class="toc-text">6.2.1 指针变量说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">6.3 指针的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-1-%E6%8C%87%E9%92%88%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="toc-text">6.3.1 指针使用的基本步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%8C%87%E9%92%88%E8%BF%90%E7%AE%97"><span class="toc-text">六、C语言中指针运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="toc-text">6.1 算术运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97"><span class="toc-text">6.2关系运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">七、C语言中指针和数组的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E6%95%B0%E7%BB%84%E5%90%8D%E4%BD%9C%E4%B8%BA%E6%8C%87%E9%92%88"><span class="toc-text">7.1 数组名作为指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-text">7.2 使用指针访问数组元素:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-text">7.3 数组作为函数参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%8C%87%E9%92%88%E5%BD%93%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">八、C语言中指针当函数参数和返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-text">九、C语言中指针函数和函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0"><span class="toc-text">十、C语言中命令行参数函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%85%B1%E7%94%A8%E4%BD%93"><span class="toc-text">第六章 结构体和共用体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">一、C语言中结构体和概念和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89"><span class="toc-text">1.1 结构体的概念和基本定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%8C%E5%AE%83%E7%9A%84%E7%94%A8%E9%80%94%E5%92%8C%E5%9C%BA%E6%99%AF"><span class="toc-text">1.1.1 什么是结构体，它的用途和场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">1.1.2 结构体的基本语法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E8%AE%BF%E9%97%AE"><span class="toc-text">1.2 结构体变量的声明和访问</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E5%A6%82%E4%BD%95%E5%A3%B0%E6%98%8E%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F"><span class="toc-text">1.2.1 如何声明结构体变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98"><span class="toc-text">1.2.2 如何访问结构体成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E5%A6%82%E4%BD%95%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F"><span class="toc-text">1.2.3 如何初始化结构体变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">1.3 结构体和函数的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E5%A6%82%E4%BD%95%E5%B0%86%E7%BB%93%E6%9E%84%E4%BD%93%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-text">1.3.1 如何将结构体作为函数参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E5%9C%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">1.3.2 在函数中返回结构体</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-text">二、C语言中结构体数组和指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">2.1 结构体数组的定义和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84"><span class="toc-text">2.1.1 如何定义和初始化结构体数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">2.1.2 如何访问结构体数组的元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">2.2 &lt;结构体指针&gt;的定义和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88"><span class="toc-text">2.2.1 如何定义结构体指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E6%8C%87%E5%90%91%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%8C%87%E9%92%88%E6%88%90%E5%91%98"><span class="toc-text">2.2.2 如何访问指向结构体的指针成员</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%92%8C%E4%BD%8D%E5%9F%9F"><span class="toc-text">三、C语言中结构体字节对齐和位域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90"><span class="toc-text">3.1 结构体的字节对齐</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90"><span class="toc-text">3.1.1 结构体的字节对齐</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99"><span class="toc-text">3.1.2 结构体的字节对齐规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90"><span class="toc-text">3.1.3 如何设置字节对齐</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E4%BD%8D%E5%9F%9F"><span class="toc-text">3.2 结构体的位域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%8D%E5%9F%9F%EF%BC%8C%E4%BB%96%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">3.2.1 什么是位域，他的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8%E4%BD%8D%E5%9F%9F"><span class="toc-text">3.2.2 如何定义和使用位域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E4%BD%8D%E4%BA%8E%E5%9C%A8%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83"><span class="toc-text">3.2.3 位于在结构体中的内存分布</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%85%B1%E7%94%A8%E4%BD%93%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%BF%E7%94%A8-union"><span class="toc-text">四、C语言中共用体的概念和使用(union)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%85%B1%E7%94%A8%E4%BD%93%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">4.1 共用体的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%85%B1%E7%94%A8%E4%BD%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">4.2 共用体的基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%85%B1%E7%94%A8%E4%BD%93"><span class="toc-text">4.3 如何使用共用体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%BF%E7%94%A8-enum"><span class="toc-text">五、C语言中枚举的概念和使用(enum)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">5.1 枚举的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%9E%9A%E4%B8%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">5.2 枚举的基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE"><span class="toc-text">5.3 如何使用枚举</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E5%92%8Ctypedef"><span class="toc-text">六、C语言中的类型定义和typedef</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">6.1 类型定义的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-typedef-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text">6.2 typedef 的基本语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-typedef-%E5%9C%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%81%94%E5%90%88%E4%BD%93%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">6.3 typedef 在结构体和联合体中的使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-text">第七章 文件操作和预处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-text">一、C语言的文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1.1 文件操作的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD"><span class="toc-text">1.2 文件的打开和关闭</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%96%87%E4%BB%B6%E6%A8%A1%E5%BC%8F"><span class="toc-text">1.3 文件模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0"><span class="toc-text">二、C语言中的文件读写函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">2.1 读写函数的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E4%BD%BF%E7%94%A8-fgetc-%E5%92%8C-fputc-%E8%BF%9B%E8%A1%8C%E5%AD%97%E7%AC%A6%E8%AF%BB%E5%86%99"><span class="toc-text">2.2 使用 fgetc 和 fputc 进行字符读写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#fgetc-%E5%87%BD%E6%95%B0"><span class="toc-text">fgetc 函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fputc-%E5%87%BD%E6%95%B0"><span class="toc-text">fputc 函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F%EF%BC%9A"><span class="toc-text">示例程序：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%BD%BF%E7%94%A8-fgets-%E5%92%8C-fputs-%E8%BF%9B%E8%A1%8C%E8%A1%8C%E8%AF%BB%E5%86%99"><span class="toc-text">2.3 使用 fgets 和 fputs 进行行读写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#fgets-%E5%87%BD%E6%95%B0"><span class="toc-text">fgets 函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fgets-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A"><span class="toc-text">fgets 函数参数解释</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fputs-%E5%87%BD%E6%95%B0"><span class="toc-text">fputs 函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fputs-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A"><span class="toc-text">fputs 函数参数解释</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="toc-text">示例程序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E4%BD%BF%E7%94%A8-fscanf-%E5%92%8C-fprintf-%E8%BF%9B%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%AF%BB%E5%86%99"><span class="toc-text">2.4 使用 fscanf 和 fprintf 进行格式化读写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#fscanf-%E5%87%BD%E6%95%B0"><span class="toc-text">fscanf 函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#fprintf-%E5%87%BD%E6%95%B0"><span class="toc-text">fprintf 函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F-1"><span class="toc-text">示例程序</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D%E5%87%BD%E6%95%B0"><span class="toc-text">三、C语言中的文件定位函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">3.1 文件定位函数的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%BD%BF%E7%94%A8-fseek-%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D"><span class="toc-text">3.2 使用 fseek 进行文件定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%BD%BF%E7%94%A8-ftell-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E4%BD%8D%E7%BD%AE"><span class="toc-text">3.3 使用 ftell 获取当前位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E4%BD%BF%E7%94%A8-%E5%9B%9E%E5%88%B0%E6%96%87%E4%BB%B6%E9%A6%96%E9%83%A8"><span class="toc-text">3.4 使用	 回到文件首部</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E5%AE%9E%E6%88%98"><span class="toc-text">四、C语言中的文件实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D"><span class="toc-text">4.1 实战项目介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.2 代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95%E5%92%8C%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-text">4.3 代码测试和问题解决</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-text">五、C语言中的预处理器指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E7%BC%96%E7%A8%8B"><span class="toc-text">六、C语言中的模块化编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%AE%8F%E5%87%BD%E6%95%B0%E5%92%8C%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-text">七、C语言中的宏函数和内联函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%B9%E8%B1%A1%E5%AE%8F%EF%BC%88Object-Macros%EF%BC%89"><span class="toc-text">1. 对象宏（Object Macros）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E5%AE%8F%EF%BC%88Function-Macros%EF%BC%89"><span class="toc-text">2. 函数宏（Function Macros）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AE%8F%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-text">3. 宏函数的使用注意事项：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="toc-text">4. 一个例子：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-text">声明内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">特点和注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="toc-text">内联函数的例子：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E9%AB%98%E7%BA%A7C%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7"><span class="toc-text">第八章 高级C语言特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">一、C语言中的动态内存分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">1. 内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%9A%84%E7%94%B3%E8%AF%B7%E5%92%8C%E9%87%8A%E6%94%BE"><span class="toc-text">2、动态内存的申请和释放</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-malloc"><span class="toc-text">1. malloc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-free"><span class="toc-text">2. free</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3、堆和栈的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-1"><span class="toc-text">1. 内存管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E9%80%9F%E5%BA%A6"><span class="toc-text">2. 内存分配速度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E5%A4%A7%E5%B0%8F"><span class="toc-text">3. 内存大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">4. 生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-text">5. 可见性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0"><span class="toc-text">二、C语言中的可变参数函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-text">步骤：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%EF%BC%9A"><span class="toc-text">输出：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0"><span class="toc-text">三、C语言中的递归函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-text">递归函数的基本结构：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%AE%A1%E7%AE%97%E9%98%B6%E4%B9%98"><span class="toc-text">示例：计算阶乘</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2024 - 2025 By LinQiuTian</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.4.0-b1"></script><script src="/js/main.js?v=5.4.0-b1"></script><script src="/js/tw_cn.js?v=5.4.0-b1"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"></div><div class="aplayer" data-id="12551163241" data-server="netease" data-type="playlist"  data-fixed="true" data-theme="#3F51B5"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/fireworks.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search articles..." type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.4.0-b1"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = '637b20351e874329896d0920eb741c8e';
  var gaud_map_key = '4a866722dcf666eb29a2326ae458eaf1';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'true';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路托管于Vercel" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://dashboard.4everland.org/" style="margin-inline:5px" data-title="本站采用多线部署，备用线路托管于4EVERLAND" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-4EVERLAND-22DDDD?style=flat&amp;logo=IPFS" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>