<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>车载C知识 | 林秋天的博客</title><meta name="author" content="LinQiuTian"><meta name="copyright" content="LinQiuTian"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#F8F5F0"><meta name="description" content="c记录一些自己不会的 和理解不够深的   存储方式：  C风格字符串通过字符数组（char[]）表示，以&#39;\0&#39;（空字符）结尾。 C++中使用std::string类来表示字符串，更加抽象和方便。   动态内存管理：  C风格字符串需要手动进行内存分配和释放，使用如malloc()或new来分配内存，并使用free()或delete释放内存。 C++的std::string类自动管">
<meta property="og:type" content="article">
<meta property="og:title" content="车载C知识">
<meta property="og:url" content="https://www.linqiutianovo.xyz/2024/09/06/test/%E8%BD%A6%E8%BD%BDc%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="林秋天的博客">
<meta property="og:description" content="c记录一些自己不会的 和理解不够深的   存储方式：  C风格字符串通过字符数组（char[]）表示，以&#39;\0&#39;（空字符）结尾。 C++中使用std::string类来表示字符串，更加抽象和方便。   动态内存管理：  C风格字符串需要手动进行内存分配和释放，使用如malloc()或new来分配内存，并使用free()或delete释放内存。 C++的std::string类自动管">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.linqiutianovo.xyz/img/data-structure-cover.jpg">
<meta property="article:published_time" content="2024-09-06T11:50:16.000Z">
<meta property="article:modified_time" content="2025-05-30T06:01:31.941Z">
<meta property="article:author" content="LinQiuTian">
<meta property="article:tag" content="车载C知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.linqiutianovo.xyz/img/data-structure-cover.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "车载C知识",
  "url": "https://www.linqiutianovo.xyz/2024/09/06/test/%E8%BD%A6%E8%BD%BDc%E7%9F%A5%E8%AF%86/",
  "image": "https://www.linqiutianovo.xyz/img/data-structure-cover.jpg",
  "datePublished": "2024-09-06T11:50:16.000Z",
  "dateModified": "2025-05-30T06:01:31.941Z",
  "author": [
    {
      "@type": "Person",
      "name": "LinQiuTian",
      "url": "https://www.linqiutianovo.xyz/"
    }
  ]
}</script><link rel="shortcut icon" href="https://www.fomal.cc/favicon.ico"><link rel="canonical" href="https://www.linqiutianovo.xyz/2024/09/06/test/%E8%BD%A6%E8%BD%BDc%E7%9F%A5%E8%AF%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.4.0-b1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.7.2/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#F8F5F0')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 18
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '车载C知识',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/url(https:/s2.loli.net/2024/08/07/EBzp91lhZCgXDI6.png));"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/08/07/KfPnTIM8WvotugL.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa-heart"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/data-structure-cover.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">林秋天的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">车载C知识</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa-heart"></i><span> 留言板</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">车载C知识</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-06T11:50:16.000Z" title="发表于 2024-09-06 19:50:16">2024-09-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-30T06:01:31.941Z" title="更新于 2025-05-30 14:01:31">2025-05-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%BD%A6%E8%BD%BDc%E7%9F%A5%E8%AF%86/">车载c知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">11.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>37分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-05-30 14:01:31&quot;}" hidden></div><p>c<br>记录一些自己不会的 和理解不够深的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250513220710273.png" alt="image-20250513220710273"></p>
<ol>
<li><p><strong>存储方式</strong>：</p>
<ul>
<li>C风格字符串通过字符数组（<code>char[]</code>）表示，以<code>&#39;\0&#39;</code>（空字符）结尾。</li>
<li>C++中使用<code>std::string</code>类来表示字符串，更加抽象和方便。</li>
</ul>
</li>
<li><p><strong>动态内存管理</strong>：</p>
<ul>
<li>C风格字符串需要手动进行内存分配和释放，使用如<code>malloc()</code>或<code>new</code>来分配内存，并使用<code>free()</code>或<code>delete</code>释放内存。</li>
<li>C++的<code>std::string</code>类自动管理内存，通过构造函数和析构函数自动处理内存，无需手动分配或释放内存。</li>
</ul>
</li>
<li><p><strong>字符串操作</strong>：</p>
<ul>
<li>C风格字符串的操作需要使用一系列的字符串处理函数（如<code>strcpy()</code>、<code>strcat()</code>、<code>strlen()</code>等），这些函数需要将字符串指针作为参数。</li>
<li>C++的<code>std::string</code>类提供了丰富的成员函数，如<code>append()</code>、<code>length()</code>、<code>find()</code>等，可以直接操作字符串对象，更加方便和易用。</li>
</ul>
</li>
<li><p><strong>安全性</strong>：</p>
<ul>
<li><p>C风格字符串没有提供越界检查，需要开发人员自行保证字符串的正确性。</p>
<ul>
<li>C++的<code>std::string</code>类具有越界检查功能，可以避免缓冲区溢出等安全问题。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250513220823443.png" alt="image-20250513220823443"></p>
</li>
</ul>
<p>连接字符串常用</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250513220915980.png" alt="image-20250513220915980"></p>
<h3 id="向量的概念和优势"><a href="#向量的概念和优势" class="headerlink" title="向量的概念和优势"></a>向量的概念和优势</h3><ol>
<li><strong>动态数组容器</strong>：<ul>
<li>向量是C++标准库提供的一种动态数组容器，使用前需要包含头文件<code>&lt;vector&gt;</code>。</li>
</ul>
</li>
<li><strong>线性存储</strong>：<ul>
<li>向量是一种线性容器，可以存储同一类型的元素。</li>
</ul>
</li>
<li><strong>顺序存储</strong>：<ul>
<li>向量中的元素按照它们在向量中的顺序进行存储。</li>
</ul>
</li>
<li><strong>随机访问</strong>：<ul>
<li>向量支持随机访问，可以通过索引访问向量中的元素。</li>
</ul>
</li>
<li><strong>动态调整大小</strong>：<ul>
<li>向量的大小可以动态调整，可以根据需要动态添加或删除元素。</li>
</ul>
</li>
<li><strong>优势</strong>：<ul>
<li>向量具有动态大小、随机访问、内存管理简单、较好的可扩展性等优势。</li>
</ul>
</li>
</ol>
<h3 id="向量的创建和初始化"><a href="#向量的创建和初始化" class="headerlink" title="向量的创建和初始化"></a>向量的创建和初始化</h3><ol>
<li><p><strong>创建空向量</strong>：</p>
<ul>
<li>使用<code>std::vector&lt;int&gt; myVector;</code>创建一个空的整型向量。</li>
</ul>
</li>
<li><p><strong>初始化向量</strong>：</p>
<ul>
<li>可以通过初始化列表、使用迭代器、使用默认值等方式初始化向量。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250513221111990.png" alt="image-20250513221111990"></p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250513221125703.png" alt="image-20250513221125703"></p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250513221153145.png" alt="image-20250513221153145"></p>
<h1 id="指针的声明和初始化"><a href="#指针的声明和初始化" class="headerlink" title="指针的声明和初始化"></a>指针的声明和初始化</h1><ol>
<li><p><strong>声明与初始化语法</strong>：</p>
<ul>
<li><p>语法格式为：<code>&lt;数据类型&gt;* &lt;指针名称&gt; = &lt;空指针或已存在变量地址&gt;;</code></p>
</li>
<li><p>示例：声明一个指向整数的指针并初始化为空指针。  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>内存分配</strong>：</p>
<ul>
<li><p>在使用指针之前，确保为指针分配了合适的内存空间或者将其初始化为有效的内存地址。</p>
</li>
<li><p>示例：使用动态内存分配为指针分配内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>释放内存</strong>：</p>
<ul>
<li><p>使用动态分配的内存后，要记得使用<code>delete</code>运算符释放该内存，以避免内存泄漏。</p>
</li>
<li><p>示例：释放之前分配的内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> ptr;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<p>当然，这里有一个使用<code>new</code>和<code>delete</code>运算符进行动态内存分配和释放的实际例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 动态分配一个整数的内存</span></span><br><span class="line">    <span class="type">int</span>* dynamicInt = <span class="keyword">new</span> <span class="type">int</span>; <span class="comment">// 分配内存并初始化为0（对于基本数据类型）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给动态分配的内存赋值</span></span><br><span class="line">    *dynamicInt = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出动态分配内存中的值</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value of dynamicInt is: &quot;</span> &lt;&lt; *dynamicInt &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用完动态分配的内存后，释放它</span></span><br><span class="line">    <span class="keyword">delete</span> dynamicInt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放后，尝试访问dynamicInt将会导致未定义行为</span></span><br><span class="line">    <span class="comment">// *dynamicInt = 100; // 这行代码如果被执行，将会导致错误</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Memory has been freed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ol>
<li>使用<code>new int</code>为一个整数动态分配了内存，并将返回的指针赋值给<code>dynamicInt</code>。</li>
<li>通过解引用指针<code>*dynamicInt</code>给这块内存赋值为42。</li>
<li>输出这块内存中的值。</li>
<li>使用<code>delete dynamicInt</code>释放了之前分配的内存。</li>
<li>释放内存后，<code>dynamicInt</code>指针不再指向有效的内存区域，如果再次访问它将会导致未定义行为，可能是程序崩溃或其他不可预知的结果。</li>
</ol>
<p>请注意，对于数组，应该使用<code>delete[]</code>来释放内存：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* dynamicIntArray = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]; <span class="comment">// 动态分配一个整数数组的内存</span></span><br><span class="line"><span class="comment">// ... 使用数组</span></span><br><span class="line"><span class="keyword">delete</span>[] dynamicIntArray; <span class="comment">// 释放数组内存</span></span><br></pre></td></tr></table></figure>

<p>正确地管理内存是非常重要的，因为它可以防止内存泄漏和其他内存相关的问题。在现代C++中，通常推荐使用智能指针（如<code>std::unique_ptr</code>和<code>std::shared_ptr</code>），因为它们可以自动管理内存，从而减少内存泄漏的风险。</p>
<p>是的，<code>std::unique_ptr</code>和<code>std::shared_ptr</code>是C++11及以后版本中引入的智能指针，它们可以帮助自动管理内存，减少内存泄漏的风险。使用这些智能指针，通常不需要（也不应该）手动调用<code>delete</code>来释放内存。智能指针会在适当的时候自动释放它们所管理的资源。</p>
<h3 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h3><p><code>std::unique_ptr</code>代表独占所有权的智能指针，意味着同一时间只能有一个<code>std::unique_ptr</code>指向特定资源。当<code>std::unique_ptr</code>被销毁时（例如，当它离开作用域或被重新赋值时），它会自动释放所管理的资源。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionUsingUniquePtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 当ptr离开作用域时，它所管理的内存将自动被释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">functionUsingUniquePtr</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，当<code>ptr</code>离开<code>functionUsingUniquePtr</code>函数的作用域时，它所管理的内存会自动被释放。</p>
<h3 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h3><p><code>std::shared_ptr</code>代表共享所有权的智能指针，允许多个<code>std::shared_ptr</code>实例共同拥有同一资源。资源的释放是在最后一个拥有该资源的<code>std::shared_ptr</code>被销毁或被赋值为其他资源时自动进行的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">createSharedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">createSharedPtr</span>();</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1; <span class="comment">// 现在ptr1和ptr2共享同一个资源</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; *ptr1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ptr1和ptr2离开作用域时，它们所管理的内存不会被释放，因为引用计数不为0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>ptr1</code>和<code>ptr2</code>共享同一个资源。当<code>main</code>函数结束时，这两个智能指针都会被销毁，因为它们的引用计数都变为0，所以它们管理的内存会被自动释放。</p>
<p>总的来说，使用<code>std::unique_ptr</code>和<code>std::shared_ptr</code>可以大大简化内存管理，减少内存泄漏和其他内存管理错误的风险。然而，智能指针也有其开销，因此在性能敏感的应用中，需要权衡使用智能指针的便利性和性能开销。</p>
<h3 id="指针的简单使用"><a href="#指针的简单使用" class="headerlink" title="指针的简单使用"></a>指针的简单使用</h3><ol>
<li><p><strong>变量地址获取</strong>：</p>
<ul>
<li><p>使用<code>&amp;</code>运算符可以获取变量的地址，并将其赋值给指针。</p>
</li>
<li><p>示例：获取变量的地址并赋值给指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr = &amp;var;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>解引用</strong>：</p>
<ul>
<li><p>使用<code>*</code>运算符可以解引用指针，即访问指针所指向的变量的值。</p>
</li>
<li><p>示例：通过指针访问变量的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; *ptr;  <span class="comment">// 输出：10</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>动态内存分配</strong>：</p>
<ul>
<li><p>使用<code>new</code>运算符可以动态分配内存，返回指向该内存的指针。</p>
</li>
<li><p>示例：动态分配内存并初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>数组操作</strong>：</p>
<ul>
<li><p>指针可以用于数组的访问和操作。</p>
</li>
<li><p>示例：使用指针遍历数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptr = arr;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; *(ptr + i) &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出：1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>函数参数传递</strong>：</p>
<ul>
<li><p>指针可以被用来在函数之间传递参数，使得函数可以直接修改指向对象的值。</p>
</li>
<li><p>示例：通过指针修改变量的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> *ptr)</span> </span>&#123;</span><br><span class="line">    *ptr = <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">modify</span>(&amp;var);</span><br><span class="line">    std::cout &lt;&lt; var;  <span class="comment">// 输出：30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h1 id="C-容器与智能指针"><a href="#C-容器与智能指针" class="headerlink" title="C++容器与智能指针"></a>C++容器与智能指针</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250514182018774.png" alt="image-20250514182018774"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250514182052165.png" alt="image-20250514182052165"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250514182157447.png" alt="image-20250514182157447"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250514182150823.png" alt="image-20250514182150823"></p>
<h3 id="数组（固定大小的连续存储空间）"><a href="#数组（固定大小的连续存储空间）" class="headerlink" title="数组（固定大小的连续存储空间）"></a>数组（固定大小的连续存储空间）</h3><ul>
<li><strong>声明和定义</strong>：<ul>
<li>使用声明符号<code>[]</code>来声明数组，并指定数组的大小。</li>
<li>数组的大小必须是常量表达式，可以在编译时确定。</li>
<li>数组的元素类型可以是任意的基本类型（如整数、浮点数、字符等），也可以是自定义的类型。</li>
</ul>
</li>
<li><strong>数组元素的访问</strong>：<ul>
<li>数组元素通过索引访问，索引从0开始，到数组大小减1结束。</li>
<li>使用方括号<code>[]</code>运算符和元素的索引来访问数组元素。</li>
</ul>
</li>
<li><strong>数组的初始化</strong>：<ul>
<li>可以在声明数组时同时进行初始化，或者在后续的操作中对数组元素进行赋值。</li>
<li>使用花括号<code>&#123;&#125;</code>来提供初始值。可以使用花括号列表初始化整个数组，或者使用索引逐个初始化数组元素。</li>
</ul>
</li>
<li><strong>数组的遍历</strong>：<ul>
<li>可以使用循环结构（如<code>for</code>循环）来遍历数组，以访问和处理数组中的每个元素。</li>
</ul>
</li>
</ul>
<h3 id="向量（Vector，动态数组，可变大小的连续存储空间）"><a href="#向量（Vector，动态数组，可变大小的连续存储空间）" class="headerlink" title="向量（Vector，动态数组，可变大小的连续存储空间）"></a>向量（Vector，动态数组，可变大小的连续存储空间）</h3><ul>
<li><strong>声明和定义向量</strong>：<ul>
<li>使用<code>std::vector</code>类模板来声明和定义向量。</li>
<li>指定向量中元素的类型作为模板参数。</li>
</ul>
</li>
<li><strong>向量的操作</strong>：<ul>
<li>向量提供了一系列成员函数和操作符来进行元素的插入、删除、访问和修改等操作。</li>
<li>通过成员函数和操作符，可以获取向量的大小、清空向量、判断向量是否为空等。</li>
</ul>
</li>
<li><strong>向量的遍历</strong>：<ul>
<li>可以使用循环结构（如<code>for</code>循环）来遍历向量，以访问和处理向量中的每个元素。</li>
</ul>
</li>
</ul>
<h3 id="列表（List，双向链表结构）"><a href="#列表（List，双向链表结构）" class="headerlink" title="列表（List，双向链表结构）"></a>列表（List，双向链表结构）</h3><ul>
<li><strong>声明和定义列表</strong>：<ul>
<li>使用<code>std::list</code>类模板来声明和定义列表。</li>
<li>指定列表中元素的类型作为模板参数。</li>
</ul>
</li>
<li><strong>列表的操作</strong>：<ul>
<li>列表提供了一系列成员函数来进行元素的插入、删除、访问和修改等操作。</li>
<li>通过成员函数，可以获取列表的大小、清空列表、判断列表是否为空等。</li>
</ul>
</li>
<li><strong>列表的遍历</strong>：<ul>
<li>可以使用迭代器或循环结构（如<code>for</code>循环）来遍历列表，以访问和处理列表中的每个元素。</li>
</ul>
</li>
</ul>
<p>这些容器各有特点和适用场景，选择哪种容器取决于具体的应用需求。例如，如果需要频繁地在容器中间插入或删除元素，列表可能是更好的选择；如果需要快速随机访问元素，向量或数组可能更合适。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250514182631401.png" alt="image-20250514182631401"></p>
<h3 id="映射（Map）容器概述"><a href="#映射（Map）容器概述" class="headerlink" title="映射（Map）容器概述"></a>映射（Map）容器概述</h3><ul>
<li><strong>定义</strong>：映射（Map）是一种键值对的容器，用于存储和管理键值对（key-value）数据。</li>
<li><strong>特点</strong>：映射是C++标准库中的一种容器，提供了方便的操作和管理键值对数据的方法。</li>
<li><strong>键的唯一性</strong>：映射类似于字典的概念，其中键是唯一的，可以用于快速查找和访问对应的值。</li>
<li><strong>头文件</strong>：映射类定义在<code>&lt;map&gt;</code>头文件中，需要引入该头文件才能使用映射。</li>
</ul>
<h3 id="声明和定义映射"><a href="#声明和定义映射" class="headerlink" title="声明和定义映射"></a>声明和定义映射</h3><ul>
<li><strong>使用<code>std::map</code>类模板</strong>：使用<code>std::map</code>类模板来声明和定义映射。</li>
<li><strong>模板参数</strong>：指定键和值的类型作为模板参数。</li>
</ul>
<h3 id="映射的操作"><a href="#映射的操作" class="headerlink" title="映射的操作"></a>映射的操作</h3><ul>
<li><strong>成员函数和操作符</strong>：映射提供了一系列成员函数和操作符来进行键值对的插入、删除、查找和访问等操作。</li>
<li><strong>获取映射大小</strong>：通过成员函数，可以获取映射的大小。</li>
<li><strong>清空映射</strong>：可以清空映射，即删除映射中的所有键值对。</li>
<li><strong>判断映射是否为空</strong>：可以判断映射是否为空。</li>
</ul>
<h3 id="映射的遍历"><a href="#映射的遍历" class="headerlink" title="映射的遍历"></a>映射的遍历</h3><ul>
<li><strong>迭代器或循环结构</strong>：可以使用迭代器或循环结构（如<code>for</code>循环）来遍历映射，以访问和处理映射中的每个键值对。</li>
</ul>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><ul>
<li><p><strong>声明映射</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; studentGrades; <span class="comment">// 声明一个字符串到整数的映射</span></span><br><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; phoneBook; <span class="comment">// 声明一个整数到字符串的映射</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>插入键值对</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">studentGrades[<span class="string">&quot;Alice&quot;</span>] = <span class="number">90</span>; <span class="comment">// 插入一个键值对</span></span><br><span class="line">studentGrades[<span class="string">&quot;Bob&quot;</span>] = <span class="number">85</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>访问键值对</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; studentGrades[<span class="string">&quot;Alice&quot;</span>] &lt;&lt; std::endl; <span class="comment">// 访问键对应的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>遍历映射</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (std::map&lt;std::string, <span class="type">int</span>&gt;::iterator it = studentGrades.<span class="built_in">begin</span>(); it != studentGrades.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl; <span class="comment">// 输出键值对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="常见容器的分类"><a href="#常见容器的分类" class="headerlink" title="常见容器的分类"></a>常见容器的分类</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250514183545638.png" alt="image-20250514183545638"></p>
<h4 id="1-顺序容器（Sequence-Container）"><a href="#1-顺序容器（Sequence-Container）" class="headerlink" title="1. 顺序容器（Sequence Container）"></a>1. 顺序容器（Sequence Container）</h4><ul>
<li><strong>存储方式</strong>：顺序容器按照元素的插入顺序来存储元素，元素在容器中的位置由插入顺序决定。</li>
<li><strong>访问方式</strong>：可以使用迭代器（iterator）或下标运算符来访问容器中的元素。</li>
<li><strong>示例容器</strong>：包括向量（vector）、双向链表（list）、双端队列（deque）等。</li>
</ul>
<h4 id="2-有序容器（Ordered-Container）"><a href="#2-有序容器（Ordered-Container）" class="headerlink" title="2. 有序容器（Ordered Container）"></a>2. 有序容器（Ordered Container）</h4><ul>
<li><strong>存储方式</strong>：有序容器按照一定的排序准则对元素进行排序，并在插入时维持元素的有序性。</li>
<li><strong>访问方式</strong>：可以使用迭代器或下标运算符来访问容器中的元素（元素的顺序是根据排序准则来决定的）。</li>
<li><strong>示例容器</strong>：包括集合（set）、映射（map）、多重集合（multiset）、多重映射（multimap）等。</li>
</ul>
<h3 id="其他区别"><a href="#其他区别" class="headerlink" title="其他区别"></a>其他区别</h3><ul>
<li><strong>适用场景</strong>：<ul>
<li>顺序容器适用于需要保留元素插入顺序的场景。</li>
<li>有序容器适用于需要根据排序准则进行存储和访问的场景。</li>
</ul>
</li>
<li><strong>插入和删除操作</strong>：<ul>
<li>顺序容器的插入和删除操作可能会导致元素在内存中的重新分配和移动。</li>
<li>有序容器则需要保持元素的有序性，因此插入和删除操作可能更复杂。</li>
</ul>
</li>
<li><strong>查找操作</strong>：<ul>
<li>顺序容器的查找操作通常需要遍历整个容器，时间复杂度为O(n)。</li>
<li>有序容器可以利用内部的排序结构进行快速的查找，时间复杂度为O(log n)。</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>顺序容器</strong>：适用于需要保留元素插入顺序的场景，如向量、列表、双端队列。</li>
<li><strong>有序容器</strong>：适用于需要根据排序准则进行存储和访问的场景，如集合、映射、多重集合、多重映射。</li>
<li><strong>性能差异</strong>：顺序容器的查找操作通常较慢，而有序容器可以利用排序结构进行快速查找。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250514183612141.png" alt="image-20250514183612141"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250514183634954.png" alt="image-20250514183634954"></p>
<h3 id="遍历容器元素"><a href="#遍历容器元素" class="headerlink" title="遍历容器元素"></a>遍历容器元素</h3><h4 id="使用迭代器遍历容器元素"><a href="#使用迭代器遍历容器元素" class="headerlink" title="使用迭代器遍历容器元素"></a>使用迭代器遍历容器元素</h4><ul>
<li><strong>迭代器</strong>：是一种能够遍历容器元素的对象，类似于指针。</li>
<li><strong>获取迭代器</strong>：容器类通常提供<code>begin()</code>和<code>end()</code>成员函数来获取迭代器的起始和结束位置。</li>
<li><strong>遍历方法</strong>：可以使用循环结构（如<code>while</code>或<code>for</code>循环）和迭代器逐个访问容器元素。</li>
</ul>
<h4 id="使用范围-for循环遍历容器元素"><a href="#使用范围-for循环遍历容器元素" class="headerlink" title="使用范围-for循环遍历容器元素"></a>使用范围-for循环遍历容器元素</h4><ul>
<li><strong>范围-for循环</strong>：是C++11引入的语法，可以简化容器元素的遍历。</li>
<li><strong>自动类型推断</strong>：使用<code>auto</code>关键字来推断迭代器的类型，并使用范围-for循环对容器进行遍历。</li>
</ul>
<h3 id="容器的遍历和常用操作"><a href="#容器的遍历和常用操作" class="headerlink" title="容器的遍历和常用操作"></a>容器的遍历和常用操作</h3><h4 id="插入和删除元素"><a href="#插入和删除元素" class="headerlink" title="插入和删除元素"></a>插入和删除元素</h4><ul>
<li><strong>插入元素</strong>：<ul>
<li>顺序容器中使用<code>push_back()</code>或<code>push_front()</code>函数，分别在容器尾部和头部插入元素。</li>
<li>有序容器中使用<code>insert()</code>函数，在容器指定位置插入元素。</li>
</ul>
</li>
<li><strong>删除元素</strong>：<ul>
<li>顺序容器中使用<code>pop_back()</code>或<code>pop_front()</code>函数，分别删除在容器尾部和头部的元素。</li>
<li>使用<code>erase()</code>函数，删除有序容器和映射中指定位置或者指定键的元素。</li>
</ul>
</li>
</ul>
<h4 id="查找和替换元素"><a href="#查找和替换元素" class="headerlink" title="查找和替换元素"></a>查找和替换元素</h4><ul>
<li><strong>查找元素</strong>：<ul>
<li>有序容器和映射中，使用<code>find()</code>函数在容器中查找指定元素，并返回该元素的迭代器。</li>
<li>有序容器和映射中，使用<code>count()</code>函数计算容器中指定元素的个数。</li>
</ul>
</li>
<li><strong>替换元素</strong>：<ul>
<li>可以使用迭代器来直接修改容器中的元素。</li>
<li>使用下标运算符[]直接修改容器中的元素。</li>
</ul>
</li>
</ul>
<h4 id="容器大小和容量的操作"><a href="#容器大小和容量的操作" class="headerlink" title="容器大小和容量的操作"></a>容器大小和容量的操作</h4><ul>
<li><strong>容器大小</strong>：<ul>
<li>使用容器的成员函数<code>size()</code>函数获取容器中的元素个数。</li>
<li>使用容器的成员函数<code>empty()</code>函数检查容器是否为空，容器中没有元素则返回true，否则返回false。</li>
</ul>
</li>
<li><strong>容器容量</strong>：<ul>
<li>使用容器的成员函数<code>capacity()</code>，获取容器重新分配内容之前可以容纳的元素个数。</li>
<li>使用容器的成员函数<code>reserve()</code>，为容器设置预留的容量，可以避免频繁的重新分配内存。</li>
</ul>
</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>这些操作涵盖了C++容器的基本使用，包括遍历、插入、删除、查找、替换以及获取容器的大小和容量等。通过这些操作，可以有效地管理和操作容器中的数据。使用迭代器和范围-for循环可以方便地遍历容器，而各种成员函数则提供了对容器元素的增删改查等操作。理解这些基本概念和操作对于在C++中有效地使用容器至关重要。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250518220951020.png" alt="image-20250518220951020"></p>
<h3 id="公有成员"><a href="#公有成员" class="headerlink" title="公有成员"></a>公有成员</h3><ul>
<li><strong>定义</strong>：通过公有访问修饰符<code>public</code>修饰的成员变量或成员函数。</li>
<li><strong>访问权限</strong>：<ul>
<li><strong>公有成员变量</strong>：可以被类的对象和类外部代码直接访问和修改。</li>
<li><strong>公有成员函数</strong>：可以被类的对象和类外部代码调用。</li>
</ul>
</li>
</ul>
<h3 id="保护成员"><a href="#保护成员" class="headerlink" title="保护成员"></a>保护成员</h3><ul>
<li><strong>定义</strong>：通过保护访问修饰符<code>protected</code>修饰的成员变量或成员函数。</li>
<li><strong>访问权限</strong>：<ul>
<li><strong>保护成员变量</strong>：只能被类的派生类访问和修改。</li>
<li><strong>保护成员函数</strong>：只能被类的派生类调用。</li>
</ul>
</li>
</ul>
<h3 id="私有成员"><a href="#私有成员" class="headerlink" title="私有成员"></a>私有成员</h3><ul>
<li><strong>定义</strong>：通过私有访问修饰符<code>private</code>修饰的成员变量或成员函数。</li>
<li><strong>访问权限</strong>：<ul>
<li><strong>私有成员变量</strong>：只能被类的成员函数访问和修改。</li>
<li><strong>私有成员函数</strong>：只能被类的其他成员函数调用。</li>
</ul>
</li>
</ul>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>公有成员</strong>：具有最宽松的访问权限，可以被类的对象和类外部代码访问。</li>
<li><strong>保护成员</strong>：具有中等的访问权限，只能被类的派生类访问。</li>
<li><strong>私有成员</strong>：具有最严格的访问权限，只能被类的成员函数访问。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250518220805025.png" alt="image-20250518220805025"></p>
<h3 id="函数覆盖的概念和使用"><a href="#函数覆盖的概念和使用" class="headerlink" title="函数覆盖的概念和使用"></a>函数覆盖的概念和使用</h3><ul>
<li><strong>函数覆盖</strong>：派生类重写（覆盖）基类中的虚函数，以实现特定行为。这是实现运行时多态性的一种机制。</li>
<li><strong>使用关键字</strong>：<ul>
<li>在基类中声明虚函数时，使用关键字<code>virtual</code>来标识。</li>
<li>在派生类中重写（覆盖）基类中的虚函数。</li>
</ul>
</li>
</ul>
<h3 id="使用override和final关键字"><a href="#使用override和final关键字" class="headerlink" title="使用override和final关键字"></a>使用override和final关键字</h3><ul>
<li><strong>override关键字</strong>：<ul>
<li>在C++中，<code>override</code>和<code>final</code>是两个关键字，用于对虚函数进行重写和类进行继承的修饰。</li>
<li><code>override</code>关键字帮助我们确保正确地进行函数重写。</li>
<li><code>final</code>关键字防止派生和重写。</li>
<li><strong>用法</strong>：<ul>
<li><code>override</code>关键字可用于派生类中对基类虚函数的重写，以确保正确地进行函数覆盖。</li>
<li>在派生类中使用<code>override</code>关键字标识对基类中虚函数的重写，可以帮助我们在编译时捕获一些常见的错误，如函数签名不匹配的情况。</li>
<li>如果派生类中的函数声明使用<code>override</code>关键字，但实际上并没有重写基类中的虚函数，编译器将会发出错误提示。</li>
</ul>
</li>
</ul>
</li>
<li><strong>final关键字</strong>：<ul>
<li><code>final</code>关键字用于修饰类、虚函数或成员函数，表示它们是最终版本，禁止进一步的派生或重写。</li>
<li><strong>用法</strong>：<ul>
<li>在类声明中使用<code>final</code>关键字修饰类，表示该类是最终类，不能再被继承。</li>
<li>在虚函数声明中使用<code>final</code>关键字修饰虚函数，表示该虚函数不能再被派生类重写。</li>
<li>在成员函数声明中使用<code>final</code>关键字修饰成员函数，表示该成员函数不能在派生类中被重写。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>总结来说，<code>override</code>和<code>final</code>关键字在C++中用于确保类的继承和函数的重写符合预期，避免错误和歧义。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250514183659851.png" alt="image-20250514183659851"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250514183713078.png" alt="image-20250514183713078"></p>
<h1 id="C-常用总结"><a href="#C-常用总结" class="headerlink" title="C++常用总结"></a>C++常用总结</h1><p>​																																																																									</p>
<ol>
<li><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a><strong>文件操作</strong></h1><ul>
<li>文件操作通常涉及创建、读取、写入和删除文件。在C++中，可以使用标准库中的<code>&lt;fstream&gt;</code>头文件提供的类，如<code>std::ifstream</code>（输入文件流）、<code>std::ofstream</code>（输出文件流）和<code>std::fstream</code>（输入输出文件流）来进行文件操作。</li>
</ul>
</li>
</ol>
<p>​	文件指针的操作</p>
<p>在C++中，文件指针用于定位和控制文件中的读写位置。以下是文件指针操作的主要方法：</p>
<h4 id="获取文件指针的位置"><a href="#获取文件指针的位置" class="headerlink" title="获取文件指针的位置"></a>获取文件指针的位置</h4><ul>
<li>**<code>tellg()</code>**：用于获取输入文件流的当前读取位置。</li>
<li>**<code>tellp()</code>**：用于获取输出文件流的当前写入位置。</li>
</ul>
<h4 id="设置文件指针的位置"><a href="#设置文件指针的位置" class="headerlink" title="设置文件指针的位置"></a>设置文件指针的位置</h4><ul>
<li>**<code>seekg(pos)</code>**：将输入文件流的读取位置设置为相对于文件开头的<code>pos</code>位置。</li>
<li>**<code>seekp(pos)</code>**：将输出文件流的写入位置设置为相对于文件开头的<code>pos</code>位置。</li>
<li>**<code>seekg(offset, dir)</code> 和 <code>seekp(offset, dir)</code>**：在当前位置的基础上相对于<code>offset</code>进行偏移，<code>dir</code>可以是以下常量之一：<ul>
<li>**<code>std::ios::beg</code>**：相对于文件开头进行偏移。</li>
<li>**<code>std::ios::cur</code>**：相对于当前位置进行偏移。</li>
<li>**<code>std::ios::end</code>**：相对于文件末尾进行偏移。</li>
</ul>
</li>
</ul>
<h4 id="检查文件指针的有效性"><a href="#检查文件指针的有效性" class="headerlink" title="检查文件指针的有效性"></a>检查文件指针的有效性</h4><ul>
<li>**<code>good()</code>**：成员函数检查文件指针是否有效。如果文件指针有效，则返回<code>true</code>；否则返回<code>false</code>。</li>
</ul>
<ol>
<li><h1 id="空指针的处理"><a href="#空指针的处理" class="headerlink" title="空指针的处理"></a><strong>空指针的处理</strong></h1><ul>
<li>空指针是指没有指向任何对象的指针。在C++中，空指针通常用<code>nullptr</code>表示。处理空指针时，需要检查指针是否为空，避免解引用空指针，这会导致程序崩溃。可以使用条件语句来检查指针是否为<code>nullptr</code>。</li>
</ul>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250514221542740.png" alt="image-20250514221542740"></p>
<h3 id="空指针的判断和使用"><a href="#空指针的判断和使用" class="headerlink" title="空指针的判断和使用"></a>空指针的判断和使用</h3><ul>
<li><p><strong>判断空指针</strong>：</p>
<ul>
<li><p>使用条件判断语句将目标指针与<code>nullptr</code>进行比较。如果指针为空（即没有指向任何对象），则条件为真；否则为假。</p>
</li>
<li><p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 指针为空的处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>空指针的特性</strong>：</p>
<ul>
<li>空指针没有有效的内存地址，访问空指针指向的对象是不安全的，可能导致程序崩溃或未定义行为。</li>
<li>将<code>nullptr</code>赋值给指针，可以将指针显式地设置为空指针。</li>
</ul>
</li>
</ul>
<h3 id="避免空指针的错误"><a href="#避免空指针的错误" class="headerlink" title="避免空指针的错误"></a>避免空指针的错误</h3><ul>
<li><p><strong>检查动态分配的内存</strong>：</p>
<ul>
<li><p>在动态分配内存后，应该检查分配的指针是否为空，以确保内存分配成功。如果分配失败，指针将为<code>nullptr</code>。</p>
</li>
<li><p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 内存分配失败的处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>使用指针前检查</strong>：</p>
<ul>
<li><p>在使用指针之前，始终检查指针是否为空，并尽量避免访问空指针。</p>
</li>
<li><p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 安全地使用指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>空指针是C++编程中常见的问题，处理不当可能导致程序崩溃或未定义行为。以下是一些关键点：</p>
<ol>
<li><p><strong>判断空指针</strong>：使用条件判断语句将指针与<code>nullptr</code>比较，确保指针不为空后再使用。</p>
</li>
<li><p><strong>显式设置空指针</strong>：将<code>nullptr</code>赋值给指针，显式地将指针设置为空。</p>
</li>
<li><p><strong>检查动态内存分配</strong>：在动态分配内存后，检查指针是否为空，确保内存分配成功。</p>
</li>
<li><p><strong>使用前检查指针</strong>：在每次使用指针之前，检查指针是否为空，避免访问空指针。</p>
</li>
<li><h1 id="常用版本特性"><a href="#常用版本特性" class="headerlink" title="常用版本特性"></a><strong>常用版本特性</strong></h1><ul>
<li>这可能指的是C++语言的不同版本中引入的新特性。例如，C++11引入了自动类型推断（<code>auto</code>）、范围<code>for</code>循环、智能指针等。了解不同版本的新特性可以帮助开发者编写更现代、更高效的代码。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250514221601991.png" alt="image-20250514221601991"></p>
<h3 id="C-11-的特性和改进"><a href="#C-11-的特性和改进" class="headerlink" title="C++11 的特性和改进"></a>C++11 的特性和改进</h3><ol>
<li><strong>自动类型推导</strong>：<ul>
<li>引入了关键字 <code>auto</code>，可以根据初始化表达式的类型自动推导变量的类型。这简化了代码编写，特别是在处理复杂类型时。</li>
</ul>
</li>
<li><strong>统一的初始化语法</strong>：<ul>
<li>引入了初始化列表语法 <code>&#123;&#125;</code>，可以用于初始化数组、容器、结构体等各种类型的对象。这种语法提供了一种统一且直观的方式来初始化对象。</li>
</ul>
</li>
<li><strong>范围-based for 循环</strong>：<ul>
<li>引入了新的循环语法 <code>for (element : sequence)</code>，用于遍历容器、数组等序列中的元素。这种循环语法使代码更加简洁和易读。</li>
</ul>
</li>
<li><strong>空指针常量</strong>：<ul>
<li>引入了关键字 <code>nullptr</code>，用于表示空指针。它可以用来替代旧的表示空指针的 <code>NULL</code> 或者 <code>0</code>，提供了更强的类型安全。</li>
</ul>
</li>
<li><strong>强类型枚举</strong>：<ul>
<li>引入了新的枚举语法，允许为枚举类型指定底层类型，并提供了更强的类型检查。这使得枚举类型更加安全和灵活。</li>
</ul>
</li>
<li><strong>Lambda 表达式</strong>：<ul>
<li>引入了匿名函数的概念，允许在代码中定义小型的匿名函数。Lambda 表达式可以捕获外部变量，并可以作为函数对象使用，这在编写回调函数和处理事件时非常有用。</li>
</ul>
</li>
<li><strong>智能指针</strong>：<ul>
<li>引入了三种智能指针类型：<code>std::unique_ptr</code>、<code>std::shared_ptr</code> 和 <code>std::weak_ptr</code>。这些智能指针类型简化了动态内存管理，自动管理内存的分配和释放，减少了内存泄漏的风险。</li>
</ul>
</li>
<li><strong>并发编程支持</strong>：<ul>
<li>引入了线程库、互斥量、条件变量等多线程和并发编程的支持。这些特性使得C++能够更好地支持并发编程，方便开发者编写并发程序。</li>
</ul>
</li>
</ol>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>C++11标准引入了大量新特性和改进，这些特性不仅提高了代码的可读性和安全性，还简化了代码编写和内存管理。通过使用这些新特性，开发者可以编写更简洁、更安全、更高效的代码，充分利用C++语言的强大功能。同时，这些特性也使得C++语言在现代软件开发中更具竞争力，适用于各种应用场景。</p>
</li>
<li><h1 id="常见的编码技巧和最佳实践"><a href="#常见的编码技巧和最佳实践" class="headerlink" title="常见的编码技巧和最佳实践"></a><strong>常见的编码技巧和最佳实践</strong></h1><ul>
<li>编码技巧和最佳实践包括代码的组织结构、命名约定、内存管理、错误处理等。例如，使用有意义的变量名、避免魔法数字、编写可重用的代码、进行异常处理等。这些实践有助于提高代码的可读性、可维护性和性能。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250514221828341.png" alt="image-20250514221828341"></p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250514221850561.png" alt="image-20250514221850561"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250514221906985.png" alt="image-20250514221906985"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250514221943742.png" alt="image-20250514221943742"></p>
<ol>
<li><h1 id="一些友善的建议"><a href="#一些友善的建议" class="headerlink" title="一些友善的建议"></a><strong>一些友善的建议</strong></h1><ul>
<li>这可能包括编程时的一些软技能建议，如团队合作、代码审查、持续学习等。友善的建议有助于提高开发者的工作效率和团队的整体表现。</li>
</ul>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250514222009032.png" alt="image-20250514222009032"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250514222021860.png" alt="image-20250514222021860"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250514222048606.png" alt="image-20250514222048606"></p>
<h1 id="车载事业部C-代码规范培训"><a href="#车载事业部C-代码规范培训" class="headerlink" title="车载事业部C++代码规范培训"></a>车载事业部C++代码规范培训</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250514222156466.png" alt="image-20250514222156466"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250515212602980.png" alt="image-20250515212602980"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250515215400176.png" alt="image-20250515215400176"></p>
<h2 id="1-预处理宏"><a href="#1-预处理宏" class="headerlink" title="1. 预处理宏"></a>1. 预处理宏</h2><p>主要目的是<strong>避免宏带来的问题</strong>，给出了一些规范和建议：</p>
<ul>
<li>不要在 .h 文件中定义宏。<ul>
<li>避免头文件被多处引用时意外影响其它代码。</li>
</ul>
</li>
<li>在马上要使用时才进行 #define，使用后要立即 #undef。<ul>
<li>这样可以减少宏对其它代码的影响，做到用完即丢。</li>
</ul>
</li>
<li>不要只是对已经存在的宏使用 #undef，选择一个不会冲突的名称。<ul>
<li>避免冲突和潜在的命名污染。</li>
</ul>
</li>
<li>不要试图使用展开后会导致 C++ 构造不稳定的宏，否则至少要附上文档说明其行为。<ul>
<li>指的是有些宏展开后可能对 C++ 构造（如类、函数等）产生不可预期影响，因此要谨慎使用并注明。</li>
</ul>
</li>
<li>不要用 ## 处理函数、类和变量的名字。<ul>
<li>这是宏拼接符，容易导致名字混淆，可读性和可维护性差。</li>
</ul>
</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>这些规范旨在<strong>减少预处理宏带来的副作用</strong>，提高代码的可维护性和安全性。</p>
<hr>
<h2 id="2-整型变量的定义"><a href="#2-整型变量的定义" class="headerlink" title="2. 整型变量的定义"></a>2. 整型变量的定义</h2><p>主要讲述<strong>整型变量的选择</strong>，以及推荐用法：</p>
<ul>
<li><p><strong>优先用 C++ 内建类型 int。</strong></p>
</li>
<li><p>需要不同大小时建议用 <code>&lt;stdint.h&gt;</code> 里的精确整型 如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int16_t  int32_t  int32_t</span><br></pre></td></tr></table></figure>



<ul>
<li>这样可以明确表达变量的位数，提升代码可移植性和准确性。</li>
</ul>
</li>
<li><p>如果变量可能超过 int 能表示的范围，比如大于 2^31（2GiB），就应该直接用 64 位变量 int64_t。</p>
<ul>
<li>这样可以避免溢出和数据错误。</li>
</ul>
</li>
<li><p>即使值不会超过 int 表示的范围，在计算过程中也可能溢出。</p>
<ul>
<li>所以宁可用大类型，不要“拿不准时用更大的类型”。</li>
</ul>
</li>
</ul>
<h3 id="介绍："><a href="#介绍：" class="headerlink" title="&lt;stdint.h&gt; 介绍："></a><code>&lt;stdint.h&gt;</code> 介绍：</h3><ul>
<li>里面定义了 <code>int16_t</code>、<code>uint32_t</code>、<code>int64_t</code> 等精确大小的整型。</li>
<li>如果需要保证整型大小，可以用这些类型代替 <code>short</code>、<code>unsigned long long</code> 等。</li>
</ul>
<hr>
<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><ul>
<li><strong>宏的使用要谨慎，避免污染、冲突、难以维护。</strong><ul>
<li><strong>整型变量建议用精确类型，防止溢出和类型不确定的问题，提升代码的健壮性和可移植性</strong></li>
</ul>
</li>
</ul>
<h1 id="DTS"><a href="#DTS" class="headerlink" title="DTS"></a>DTS</h1><h3 id="一、什么是DTS"><a href="#一、什么是DTS" class="headerlink" title="一、什么是DTS"></a>一、什么是DTS</h3><p>DTS是一种描述硬件设备信息的文件格式，主要用于Linux内核中。它以文本的形式描述硬件设备的属性、连接关系等信息，然后通过设备树编译器（DTC）将其编译成设备树二进制文件（.dtb），供内核在启动时加载和解析，从而实现对硬件设备的识别和初始化。</p>
<h3 id="二、需要了解DTS的情况"><a href="#二、需要了解DTS的情况" class="headerlink" title="二、需要了解DTS的情况"></a>二、需要了解DTS的情况</h3><ol>
<li><strong>使用Linux内核的嵌入式开发</strong><ul>
<li>如果你开发的嵌入式系统使用Linux内核，那么了解DTS是非常重要的。因为Linux内核从3.5版本开始，对于许多嵌入式平台（如ARM、RISC-V等）都推荐使用设备树来描述硬件。例如，在开发基于ARM架构的嵌入式设备时，你需要通过DTS文件来告诉内核硬件设备的详细信息，如GPIO引脚的用途、外设的地址范围、时钟配置等。只有这样，内核才能正确地初始化和驱动硬件设备。</li>
<li>例如，对于一个带有多功能GPIO引脚的嵌入式开发板，你可能需要在DTS文件中指定某个GPIO引脚用于I2C通信，而另一个引脚用于普通数字输入输出。如果DTS文件配置错误，可能会导致硬件设备无法正常工作。</li>
</ul>
</li>
<li><strong>硬件平台的移植和定制开发</strong><ul>
<li>当你需要将Linux内核移植到一个新的硬件平台或者对现有硬件平台进行定制开发时，DTS文件的编写和修改是必不可少的。因为不同的硬件平台有不同的硬件架构和设备配置，你需要通过DTS文件来适配这些差异。比如，当你将一个Linux内核版本从一个开发板移植到另一个具有不同外设的开发板时，就需要修改DTS文件，以确保内核能够正确识别和管理新开发板上的硬件设备。</li>
</ul>
</li>
<li><strong>驱动开发</strong><ul>
<li>对于嵌入式系统中的驱动开发，DTS文件提供了硬件设备的接口信息。驱动开发者可以通过DTS文件获取硬件设备的寄存器地址、中断号等关键信息，从而编写出能够正确与硬件设备交互的驱动程序。例如，开发一个SPI设备的驱动时，驱动代码需要从DTS文件中获取SPI控制器的设备树节点信息，包括SPI设备的片选号、时钟速率等参数，才能实现对SPI设备的有效控制。</li>
</ul>
</li>
</ol>
<h3 id="三、不需要了解DTS的情况"><a href="#三、不需要了解DTS的情况" class="headerlink" title="三、不需要了解DTS的情况"></a>三、不需要了解DTS的情况</h3><ol>
<li><strong>使用非Linux内核的嵌入式开发</strong><ul>
<li>如果你的嵌入式系统使用的是其他操作系统（如RTOS，即实时操作系统，像FreeRTOS、μC&#x2F;OS-II等）或者无操作系统，那么DTS文件通常不会被用到。因为这些系统通常采用不同的方式来管理硬件设备，例如通过直接在代码中硬编码硬件设备的地址和配置信息，而不是依赖于像DTS这样的设备树描述机制。</li>
</ul>
</li>
<li><strong>使用封装良好的开发平台和硬件抽象层</strong><ul>
<li>在一些嵌入式开发平台中，硬件厂商可能已经提供了高度封装的硬件抽象层（HAL）或者中间件，这些抽象层直接隐藏了硬件设备的具体细节，包括DTS文件的使用。在这种情况下，开发者可以直接调用抽象层提供的接口函数来操作硬件设备，而无需关心DTS文件。例如，一些基于STM32微控制器的开发平台，通过STM32 HAL库封装了硬件操作，开发者可以直接使用库函数来控制GPIO、定时器等外设，而无需编写DTS文件。</li>
</ul>
</li>
</ol>
<h1 id="QNX共享内存"><a href="#QNX共享内存" class="headerlink" title="QNX共享内存"></a>QNX共享内存</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250521153325554.png" alt="image-20250521153325554"></p>
<h3 id="一、什么是QNX共享内存"><a href="#一、什么是QNX共享内存" class="headerlink" title="一、什么是QNX共享内存"></a>一、什么是QNX共享内存</h3><p>QNX是一个基于微内核的实时操作系统，其设计目标是提供高效的进程间通信（IPC）和资源管理机制。共享内存是QNX中一种重要的进程间通信方式，允许多个进程共享同一块物理内存区域，从而实现高效的数据交换和通信。</p>
<p>在QNX中，共享内存的使用通常涉及以下几个关键概念：</p>
<ol>
<li><strong>共享内存段（Shared Memory Segment）</strong>：这是共享内存的基本单位，由一个或多个进程创建和访问。</li>
<li><strong>内存映射（Memory Mapping）</strong>：通过内存映射机制，将共享内存段映射到进程的地址空间中，使得进程可以像访问普通内存一样访问共享内存。</li>
<li><strong>同步机制（Synchronization）</strong>：由于多个进程可能同时访问共享内存，因此需要使用同步机制（如信号量、互斥锁等）来避免数据竞争和不一致性问题。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250521153608341.png" alt="image-20250521153608341"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250521153633809.png" alt="image-20250521153633809"></p>
<h3 id="QNX共享内存的优缺点"><a href="#QNX共享内存的优缺点" class="headerlink" title="QNX共享内存的优缺点"></a>QNX共享内存的优缺点</h3><ol>
<li><strong>优点</strong><ul>
<li><strong>高效性</strong>：共享内存是一种非常高效的进程间通信方式，因为它避免了数据的多次复制和传输。多个进程可以直接访问同一块物理内存，从而大大提高了数据交换的效率。</li>
<li><strong>灵活性</strong>：QNX的共享内存机制提供了灵活的控制方式，可以通过多种系统调用和库函数来创建、管理和访问共享内存。同时，还可以结合同步机制来实现复杂的并发控制。</li>
<li><strong>实时性</strong>：在实时系统中，共享内存可以快速地传递数据，满足实时性要求。例如，在高精度的工业控制系统中，共享内存可以用于实时传递传感器数据和控制指令。</li>
</ul>
</li>
<li><strong>缺点</strong><ul>
<li><strong>同步复杂性</strong>：由于多个进程可能同时访问共享内存，因此需要使用同步机制来避免数据竞争和不一致性问题。同步机制的使用增加了编程的复杂性，需要开发者仔细设计和实现。</li>
<li><strong>安全性问题</strong>：共享内存的访问权限需要严格控制，否则可能会导致安全问题。例如，如果一个恶意进程访问了共享内存，可能会篡改数据或导致系统崩溃。因此，在使用共享内存时，需要确保只有授权的进程才能访问共享内存。</li>
<li><strong>内存管理复杂性</strong>：共享内存的生命周期管理需要特别注意。如果某个进程意外崩溃或退出，可能会导致共享内存无法被正确释放，从而造成内存泄漏。因此，需要在程序设计中仔细处理共享内存的创建、使用和销毁过程。</li>
</ul>
</li>
</ol>
<h3 id="是否需要了解QNX共享内存"><a href="#是否需要了解QNX共享内存" class="headerlink" title="是否需要了解QNX共享内存"></a>是否需要了解QNX共享内存</h3><p>是否需要了解QNX共享内存，取决于你的开发需求和目标平台：</p>
<ol>
<li><strong>需要了解的情况</strong><ul>
<li>如果你正在开发基于QNX操作系统的嵌入式系统，尤其是涉及到多进程协作、实时数据交换或资源管理的场景，那么了解QNX共享内存是非常重要的。掌握共享内存的使用方法可以帮助你设计出高效、可靠的系统架构，提高系统的性能和实时性。</li>
<li>例如，在开发一个实时监控系统时，多个进程需要实时交换图像数据和传感器数据。通过使用QNX共享内存，可以快速地传递这些数据，同时结合同步机制确保数据的一致性和完整性。</li>
</ul>
</li>
<li><strong>不需要了解的情况</strong><ul>
<li>如果你的嵌入式系统不使用QNX操作系统，或者你的开发场景中不需要使用共享内存机制（例如，系统中只有一个进程，或者数据交换量非常小），那么了解QNX共享内存可能不是必要的。</li>
<li>另外，如果你使用的是封装良好的开发框架或中间件，这些框架可能已经隐藏了共享内存的实现细节，你只需要调用相关的接口函数即可实现进程间通信，而无需深入了解共享内存的底层机制。</li>
</ul>
</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250521154241355.png" alt="image-20250521154241355"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250521154302419.png" alt="image-20250521154302419"></p>
<p>一个使用共享内存（Shared Memory）和互斥锁（Mutex）在QNX操作系统中进行进程间通信（IPC）的示例。下面我将详细解释这个示例的代码和运行结果。</p>
<h3 id="示例代码解释"><a href="#示例代码解释" class="headerlink" title="示例代码解释"></a>示例代码解释</h3><h4 id="shmemcreator-c"><a href="#shmemcreator-c" class="headerlink" title="shmemcreator.c"></a><code>shmemcreator.c</code></h4><p>这个程序创建共享内存和一个信号量，并在共享内存中写入一些文本。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shmemcreator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *programname = <span class="string">&quot;shmemcreator&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">shmem_t</span> *ptr;</span><br><span class="line">    <span class="type">pthread_mutexattr_t</span> myattr;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> myshmmutex;</span><br><span class="line"></span><br><span class="line">    pthread_mutexattr_init(&amp;myattr);</span><br><span class="line">    pthread_mutexattr_setpshared(&amp;myattr, PTHREAD_PROCESS_SHARED);</span><br><span class="line">    pthread_mutex_init(&amp;ptr-&gt;myshmemmutex, &amp;myattr);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;ptr-&gt;myshmemmutex);</span><br><span class="line">    <span class="built_in">strcpy</span>(ptr-&gt;text, <span class="string">&quot;Text by shmemcreator.c&quot;</span>); <span class="comment">/* write to the shared memory */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Shared memory created and semaphore initialized to 0.\n&quot;</span>,</span><br><span class="line">            programname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Wrote text &#x27;%s&#x27; to shared memory.\n&quot;</span>,</span><br><span class="line">            programname, ptr-&gt;text);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Sleeping for 20 seconds. While this program is sleeping\n&quot;</span>,</span><br><span class="line">            programname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: run &#x27;example_shmem_user&#x27;\n&quot;</span>, programname, programname);</span><br><span class="line">    sleep(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Woke up. Now unlocking the mutex.\n&quot;</span>, programname);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;ptr-&gt;myshmemmutex);</span><br><span class="line"></span><br><span class="line">    close(fd); <span class="comment">// Closing the file descriptor</span></span><br><span class="line">    munmap(ptr, <span class="keyword">sizeof</span>(<span class="type">shmem_t</span>)); <span class="comment">// removing the mapping</span></span><br><span class="line">    shm_unlink(<span class="string">&quot;/myshmemobject&quot;</span>); <span class="comment">// Delete the shared memory object</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="shmemuser-c"><a href="#shmemuser-c" class="headerlink" title="shmemuser.c"></a><code>shmemuser.c</code></h4><p>这个程序打开共享内存对象，等待信号量，访问共享内存并读取其中的内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;shmemcreator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *programname = <span class="string">&quot;shmemuser&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">shmem_t</span> *ptr;</span><br><span class="line"></span><br><span class="line">    fd = shm_open(<span class="string">&quot;/myshmemobject&quot;</span>, O_RDWR, S_IRWXU);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: error opening the shared memory object: %s\n&quot;</span>,</span><br><span class="line">                programname, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ptr = mmap(<span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">shmem_t</span>),</span><br><span class="line">               PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Waiting on the mutex. Run &#x27;pidin&#x27;. I should be MUTEX_blocked.\n&quot;</span>,</span><br><span class="line">            programname);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;ptr-&gt;myshmemmutex);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Got the mutex, now accessing shared memory\n&quot;</span>, programname);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s: Shared memory contains &#x27;%s&#x27;\n&quot;</span>, programname, ptr-&gt;text);</span><br><span class="line"></span><br><span class="line">    pthread_mutex_unlock(&amp;ptr-&gt;myshmemmutex);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    munmap(ptr, <span class="keyword">sizeof</span>(<span class="type">shmem_t</span>));</span><br><span class="line">    <span class="keyword">return</span> (EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># ./shmemcreator</span><br><span class="line">shmemcreator: Shared memory created and semaphore initialized to <span class="number">0.</span></span><br><span class="line">shmemcreator: Wrote text <span class="string">&#x27;Text by shmemcreator.c&#x27;</span> to shared memory</span><br><span class="line">shmemcreator: Sleeping <span class="keyword">for</span> <span class="number">20</span> seconds. While this program is sleeping</span><br><span class="line">shmemcreator: run <span class="string">&#x27;example_shmem_user&#x27;</span></span><br><span class="line"></span><br><span class="line"># ./shmemuser</span><br><span class="line">shmemuser: Waiting on the mutex. Run <span class="string">&#x27;pidin&#x27;</span>. I should be MUTEX_blocked.</span><br><span class="line">shmemuser: Got the mutex, now accessing shared memory</span><br><span class="line">shmemuser: The shared memory contains <span class="string">&#x27;Text by shmemcreator.c&#x27;</span></span><br></pre></td></tr></table></figure>



<h4 id="运行结果解释"><a href="#运行结果解释" class="headerlink" title="运行结果解释"></a>运行结果解释</h4><p><strong><code>shmemcreator</code> 程序</strong>：</p>
<ul>
<li>创建共享内存和信号量，初始化为0。</li>
<li>写入文本 <code>&quot;Text by shmemcreator.c&quot;</code> 到共享内存。</li>
<li>打印共享内存创建和信号量初始化的信息。</li>
<li>打印写入共享内存的文本。</li>
<li>打印程序将要休眠20秒的信息。</li>
<li>休眠20秒。</li>
<li>解锁信号量。</li>
<li>关闭文件描述符，解除映射，删除共享内存对象。</li>
</ul>
<p><strong><code>shmemuser</code> 程序</strong>：</p>
<ul>
<li>打开共享内存对象。</li>
<li>将共享内存对象映射到进程地址空间。</li>
<li>等待信号量（此时会被阻塞，因为 <code>shmemcreator</code> 程序已经锁定了信号量）。</li>
<li>获取信号量后，访问共享内存并读取其中的内容。</li>
<li>打印读取到的共享内存内容。</li>
<li>解锁信号量。</li>
<li>关闭文件描述符，解除映射。</li>
</ul>
<p>运行 <code>shmemcreator</code> 程序后，它会创建共享内存，写入文本，然后休眠20秒。在此过程中，运行 <code>shmemuser</code> 程序，它会等待信号量，因为 <code>shmemcreator</code> 程序已经锁定了信号量。20秒后，<code>shmemcreator</code> 程序解锁信号量，<code>shmemuser</code> 程序获取信号量，访问共享内存并读取其中的内容。</p>
<p>这个示例展示了如何在QNX操作系统中使用共享内存和互斥锁进行进程间通信。<code>shmemcreator</code> 程序创建共享内存并写入数据，然后休眠一段时间。<code>shmemuser</code> 程序等待信号量，获取信号量后访问共享内存并读取数据。通过这种方式，可以实现多个进程之间的高效数据交换。</p>
<h2 id="通俗解释QNX程序"><a href="#通俗解释QNX程序" class="headerlink" title="通俗解释QNX程序"></a>通俗解释QNX程序</h2><p>想象你和朋友们在做一个团队项目，需要共享一些信息。为了避免混乱，你们决定用一个特别的“共享笔记本”来记录信息。这个笔记本就像电脑里的“共享内存”，大家都能看和写。</p>
<ol>
<li><strong>创建共享笔记本</strong>：<ul>
<li>你（<code>shmemcreator</code>程序）首先创建了这个共享笔记本，并写下了第一条信息：“Text by shmemcreator.c”。</li>
<li>然后你锁上了笔记本（使用互斥锁），这样其他人就不能同时写入，避免信息混乱。</li>
<li>你告诉其他人，你要休息20秒（程序休眠20秒），在这期间他们可以开始读取笔记本。</li>
</ul>
</li>
<li><strong>读取共享笔记本</strong>：<ul>
<li>你的朋友（<code>shmemuser</code>程序）看到你锁上了笔记本，就等着（等待互斥锁）。</li>
<li>20秒后，你回来解锁了笔记本，告诉你的朋友可以看了。</li>
<li>你的朋友打开笔记本，看到了你写的信息：“Text by shmemcreator.c”，然后他把这条信息告诉了团队里的其他人。</li>
</ul>
</li>
<li><strong>结束工作</strong>：<ul>
<li>你和你的朋友都完成了工作，你把笔记本收起来，这样其他人就不能再次访问它了。</li>
</ul>
</li>
</ol>
<p><strong>运行结果</strong>：</p>
<ul>
<li>你先创建了共享内存，写入了信息，然后休息了20秒。</li>
<li>在这期间，你的朋友尝试读取共享内存，但因为你锁定了它，所以他必须等待。</li>
<li>20秒后，你解锁了共享内存，你的朋友读取了里面的信息，并告诉了团队其他人。</li>
</ul>
<p>20秒等待主要是为了演示和测试的目的：</p>
<ol>
<li><p><strong>演示互斥锁的效果</strong>：<code>shmemcreator</code>程序通过锁定互斥锁来确保在它休眠的20秒内，<code>shmemuser</code>程序能够体验到等待互斥锁释放的过程。这展示了互斥锁的同步机制，即一个程序在访问共享资源时如何等待另一个程序释放锁。(你有足够的时间完成所有与笔记本相关的操作)</p>
</li>
<li><p><strong>测试共享内存的访问</strong>：通过在写入数据后休眠，<code>shmemcreator</code>程序确保了<code>shmemuser</code>程序在其休眠期间运行并尝试读取共享内存。这样可以测试<code>shmemuser</code>程序是否能够正确地等待互斥锁，以及在互斥锁释放后是否能够成功读取共享内存中的数据。(其他人不会在你完成之前干扰笔记本中的内容。)</p>
</li>
<li><p><strong>模拟实际应用场景</strong>：在实际应用中，可能存在一个程序需要在完成数据写入后，让另一个程序来处理这些数据的情况。通过休眠20秒，<code>shmemcreator</code>程序模拟了这种场景，即在一个程序完成数据处理后，另一个程序开始处理这些数据。(当你解锁笔记本时，其他人可以安全地访问最新的、完整的信息。)</p>
</li>
<li><p><strong>为什么你的朋友不能自己打开笔记本？</strong></p>
<ul>
<li>因为你在笔记本上加了一把锁（这就像是电脑里的互斥锁）。这把锁是为了防止大家同时写入笔记本，造成信息混乱。所以，只有你（或者有钥匙的人）能打开这个锁，其他人必须等待。</li>
</ul>
</li>
<li><p><strong>为什么一定要等20秒后才能打开给他看？</strong></p>
<ul>
<li>你告诉团队，你要休息20秒。在这期间，你的朋友不能打开笔记本，因为笔记本被锁住了。这20秒就像是你处理一些事情的时间，比如写一些重要的信息到笔记本里。</li>
</ul>
</li>
<li><p><strong>如果我打开了，不就是两个人一起看了吗？</strong></p>
<ul>
<li>当你20秒后回来，你打开了笔记本的锁，这时候你的朋友就可以看了。但是，即使他看了，也只有一个人能同时写入笔记本，因为每次只能有一个人拿着钥匙（解锁）。这样，其他人就不会同时写入，造成混乱。</li>
</ul>
</li>
</ol>
<h1 id="C语言编码规范"><a href="#C语言编码规范" class="headerlink" title="C语言编码规范"></a>C语言编码规范</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250521164427381.png" alt="image-20250521164427381"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250521164537900.png" alt="image-20250521164537900"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250521164502982.png" alt="image-20250521164502982"></p>
<h3 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h3><ol>
<li><strong>组成</strong>：<ul>
<li>只能包含字母、数字和下划线。</li>
<li>不能以数字开头。</li>
<li>下划线不能出现在开头或结尾。</li>
</ul>
</li>
<li><strong>目的</strong>：<ul>
<li>让代码更易读。</li>
<li>避免混淆，例如 <code>variable_name</code> 和 <code>variable___name</code>。</li>
</ul>
</li>
<li><strong>命名原则</strong>：<ul>
<li>使用完整的英文描述。</li>
<li>遵循“最小长度 &amp; 最大信息”原则，谨慎使用缩写。</li>
</ul>
</li>
<li><strong>说明</strong>：<ul>
<li>如果缩写，需在代码中统一使用。例如，<code>num</code> 代表 <code>number</code>，则全程使用 <code>num</code>。</li>
</ul>
</li>
</ol>
<p>这样命名标识符可以让代码更清晰、更一致。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250521164739687.png" alt="image-20250521164739687"></p>
<p><strong>规则</strong>：</p>
<ul>
<li>文件名必须全部小写。</li>
<li>单词之间用下划线分隔。</li>
<li>文件后缀只能是 <code>.h</code> 或 <code>.c</code>。</li>
</ul>
<p><strong>正确示例</strong>：</p>
<ul>
<li><code>bw_media_scan_service.c</code></li>
<li><code>bw_media_scan_service.h</code></li>
</ul>
<p><strong>错误示例</strong>：</p>
<ul>
<li><code>MediaScanner.inc</code> （文件名不对）</li>
<li><code>mediascanner.cc</code> （文件名和后缀都不对）</li>
<li><code>Media_Scanner.hpp</code> （文件名和后缀都不对）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250521165229163.png" alt="image-20250521165229163"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250521165317163.png" alt="image-20250521165317163"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250521165423756.png" alt="image-20250521165423756"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250521165442890.png" alt="image-20250521165442890"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250521165606544.png" alt="image-20250521165606544"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250521171346648.png" alt="image-20250521171346648"></p>
<h1 id="智能汽车技术培训-操作系统基础"><a href="#智能汽车技术培训-操作系统基础" class="headerlink" title="智能汽车技术培训-操作系统基础"></a>智能汽车技术培训-操作系统基础</h1><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250521171816673.png" alt="image-20250521171816673"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/./../../images/image-20250521171850212.png" alt="image-20250521171850212"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.linqiutianovo.xyz">LinQiuTian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.linqiutianovo.xyz/2024/09/06/test/%E8%BD%A6%E8%BD%BDc%E7%9F%A5%E8%AF%86/">https://www.linqiutianovo.xyz/2024/09/06/test/%E8%BD%A6%E8%BD%BDc%E7%9F%A5%E8%AF%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.linqiutianovo.xyz" target="_blank">林秋天的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BD%A6%E8%BD%BDC%E7%9F%A5%E8%AF%86/">车载C知识</a></div><div class="post-share"><div class="social-share" data-image="/img/data-structure-cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/08/07/test/shell%E8%AF%AD%E6%B3%95%E5%A4%8D%E4%B9%A0/" title="shell语法复习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/shell-script-cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">shell语法复习</div></div><div class="info-2"><div class="info-item-1">以下是完善后的 Markdown 文件内容，标题已添加超链接：  Linux硬件开发常用Shell指令笔记一、系统信息查看 查看系统信息 1uname -a   解释：显示系统内核版本、主机名、硬件架构等详细信息。 用途：确认系统环境是否符合开发要求。   查看CPU信息 1cat /proc/cpuinfo   解释：显示CPU的详细信息，包括型号、核心数、主频等。 用途：确认CPU性能是否满足需求。   查看内存信息 1cat /proc/meminfo   解释：显示系统的内存信息，包括总内存、可用内存等。 用途：评估内存是否足够支持程序运行。   查看系统负载 1uptime   解释：显示系统当前的负载情况，包括平均负载值。 用途：监控系统运行状态，判断是否需要优化。     二、硬件设备检测 查看设备文件 1ls...</div></div></div></a><a class="pagination-related" href="/2025/05/05/test/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86/" title="面试知识"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/data-structure-cover.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">面试知识</div></div><div class="info-2"><div class="info-item-1">C&#x2F;C++ 题目一个保险柜，密码是由 NOMONEY 组成的 7 位数字。每个字母对应的数字隐藏在下面的 10 进制加法算式中，相同的字母对应相同的数字，不同的字母对应不同的数字，数字范围 0-9，并且已知密码中没有 4。请解码密码。 1234	G I V E+ 	M O R E	  M O N E Y   M &#x3D; 1（因两四位数相加得五位数，最高位必为1）  G &#x3D; 9（9 + 1 &#x3D; 10，产生进位，满足五位数）  O &#x3D; 0（千位相加：9 + 1 + 0 &#x3D; 10，进位后万位为1）  E &#x3D; 8（个位：6 + 6 &#x3D; 12 → Y &#x3D; 2，进位1）  Y &#x3D; 6（由E &#x3D; 8推导）  V &#x3D; 5，R &#x3D; 2（十位：7 + 5 + 进位1 &#x3D; 13 → 进位1，E &#x3D; 6）    I &#x3D; 3（百位：8 + 进位1 &#x3D; 9 → N &#x3D; 9，但需调整后最终得出N &#x3D; 2）  N &#x3D;...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2024/08/07/KfPnTIM8WvotugL.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">LinQiuTian</div><div class="author-info-description">林秋天的博客</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">37</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/linqiutian"><i></i><span>🛴客官点一点...</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/linqiutian" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/412581566@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><center>主域名：<br><a href="https://www.linqiutianovo.xyz"><b><font color="#5ea6e5">https://www.linqiutianovo.xyz/</font></b></a>&nbsp;|&nbsp;<a href="https://www.linqiutianovo.xyz/"><b><font color="#5ea6e5">https://www.linqiutianovo.xyz</font></b></a><br>备用域名：<br><a href="https://www.linqiutianovo.xyz"><b><font color="#5ea6e5">https://www.linqiutianovo.xyz</font></b></a><br><a href="https://www.linqiutianovo.xyz"><b><font color="#5ea6e5">aa.fomal.cc</font></b></a><br><a href="https://www.linqiutianovo.xyz/"><b><font color="#5ea6e5">https://www.linqiutianovo.xyz/</font></b></a><br><a href="mailto:412581566@fqq.com">📬：<b><font color="#a591e0">412581566@fqq.com</font></b></a></center></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BC%98%E5%8A%BF"><span class="toc-text">向量的概念和优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">向量的创建和初始化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">指针的声明和初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#std-unique-ptr"><span class="toc-text">std::unique_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-shared-ptr"><span class="toc-text">std::shared_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-text">指针的简单使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%AE%B9%E5%99%A8%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">C++容器与智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%EF%BC%88%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E7%9A%84%E8%BF%9E%E7%BB%AD%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%EF%BC%89"><span class="toc-text">数组（固定大小的连续存储空间）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F%EF%BC%88Vector%EF%BC%8C%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%8C%E5%8F%AF%E5%8F%98%E5%A4%A7%E5%B0%8F%E7%9A%84%E8%BF%9E%E7%BB%AD%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%EF%BC%89"><span class="toc-text">向量（Vector，动态数组，可变大小的连续存储空间）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%EF%BC%88List%EF%BC%8C%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%EF%BC%89"><span class="toc-text">列表（List，双向链表结构）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%EF%BC%88Map%EF%BC%89%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-text">映射（Map）容器概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%92%8C%E5%AE%9A%E4%B9%89%E6%98%A0%E5%B0%84"><span class="toc-text">声明和定义映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">映射的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">映射的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">示例代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">常见容器的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%EF%BC%88Sequence-Container%EF%BC%89"><span class="toc-text">1. 顺序容器（Sequence Container）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9C%89%E5%BA%8F%E5%AE%B9%E5%99%A8%EF%BC%88Ordered-Container%EF%BC%89"><span class="toc-text">2. 有序容器（Ordered Container）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%8C%BA%E5%88%AB"><span class="toc-text">其他区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0"><span class="toc-text">遍历容器元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%81%8D%E5%8E%86%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0"><span class="toc-text">使用迭代器遍历容器元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4-for%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0"><span class="toc-text">使用范围-for循环遍历容器元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">容器的遍历和常用操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text">插入和删除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2%E5%85%83%E7%B4%A0"><span class="toc-text">查找和替换元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%A4%A7%E5%B0%8F%E5%92%8C%E5%AE%B9%E9%87%8F%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">容器大小和容量的操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E6%9C%89%E6%88%90%E5%91%98"><span class="toc-text">公有成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%88%90%E5%91%98"><span class="toc-text">保护成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98"><span class="toc-text">私有成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%A6%86%E7%9B%96%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">函数覆盖的概念和使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8override%E5%92%8Cfinal%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">使用override和final关键字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93"><span class="toc-text">C++常用总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-text">文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-text">获取文件指针的位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-text">设置文件指针的位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E6%96%87%E4%BB%B6%E6%8C%87%E9%92%88%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7"><span class="toc-text">检查文件指针的有效性</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">空指针的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E7%9A%84%E5%88%A4%E6%96%AD%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-text">空指针的判断和使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E7%A9%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-text">避免空指针的错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="toc-text">常用版本特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-11-%E7%9A%84%E7%89%B9%E6%80%A7%E5%92%8C%E6%94%B9%E8%BF%9B"><span class="toc-text">C++11 的特性和改进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-text">常见的编码技巧和最佳实践</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%8F%8B%E5%96%84%E7%9A%84%E5%BB%BA%E8%AE%AE"><span class="toc-text">一些友善的建议</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%A6%E8%BD%BD%E4%BA%8B%E4%B8%9A%E9%83%A8C-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E5%9F%B9%E8%AE%AD"><span class="toc-text">车载事业部C++代码规范培训</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%A2%84%E5%A4%84%E7%90%86%E5%AE%8F"><span class="toc-text">1. 预处理宏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%95%B4%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">2. 整型变量的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%EF%BC%9A"><span class="toc-text">&lt;stdint.h&gt; 介绍：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DTS"><span class="toc-text">DTS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFDTS"><span class="toc-text">一、什么是DTS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3DTS%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">二、需要了解DTS的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%B8%8D%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3DTS%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">三、不需要了解DTS的情况</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QNX%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-text">QNX共享内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFQNX%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-text">一、什么是QNX共享内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#QNX%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">QNX共享内存的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3QNX%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-text">是否需要了解QNX共享内存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-text">例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A"><span class="toc-text">示例代码解释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#shmemcreator-c"><span class="toc-text">shmemcreator.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shmemuser-c"><span class="toc-text">shmemuser.c</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E8%A7%A3%E9%87%8A"><span class="toc-text">运行结果解释</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E4%BF%97%E8%A7%A3%E9%87%8AQNX%E7%A8%8B%E5%BA%8F"><span class="toc-text">通俗解释QNX程序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83"><span class="toc-text">C语言编码规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-text">标识符命名规则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%B1%BD%E8%BD%A6%E6%8A%80%E6%9C%AF%E5%9F%B9%E8%AE%AD-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80"><span class="toc-text">智能汽车技术培训-操作系统基础</span></a></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2024 - 2025 By LinQiuTian</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.4.0-b1"></script><script src="/js/main.js?v=5.4.0-b1"></script><script src="/js/tw_cn.js?v=5.4.0-b1"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@19.1.3/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"></div><div class="aplayer" data-id="12551163241" data-server="netease" data-type="playlist"  data-fixed="true" data-theme="#3F51B5"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/dist/fireworks.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.4/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search articles..." type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.4.0-b1"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = '637b20351e874329896d0920eb741c8e';
  var gaud_map_key = '4a866722dcf666eb29a2326ae458eaf1';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'true';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路托管于Vercel" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://dashboard.4everland.org/" style="margin-inline:5px" data-title="本站采用多线部署，备用线路托管于4EVERLAND" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-4EVERLAND-22DDDD?style=flat&amp;logo=IPFS" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '2');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>